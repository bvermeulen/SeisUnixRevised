head	1.2;
access;
symbols;
locks
	john:1.2; strict;
comment	@c @;


1.2
date	97.10.23.15.17.59;	author john;	state Exp;
branches;
next	1.1;

1.1
date	97.01.28.19.25.22;	author john;	state Exp;
branches;
next	;


desc
@cwell
@


1.2
log
@broke declaration in two, to prevent error on older SUN fortran compilers.
Thanks to Ekkehart Tessmer
@
text
@c--------------------------------------------------------------------


      INTEGER     PARIN,       SHTOUT,     INTERF,
     :            RAYOUT,      RAYLST,
     :            colsin,      rwell,
     :            src,         swell,      stderr

      PARAMETER ( stderr = 0,
     :            PARIN  = 10,
     :            INTERF = 12,
     :            SHTOUT = 13,
     :            RAYOUT = 15,
     :            RAYLST = 16,
     :            colsin = 17,
     :            rwell  = 18,
     :            swell  = 20,
     :            src    = 19)


      INTEGER    MAXINT,       MAXSPL,         MXSPM1,
     :           MAXN,         MAXNP1,         MAXNP3,
     :           MAXREF,       MAXEVT,         maxrec,
     :           maxsrc

      PARAMETER ( MAXINT = 20,
     :            MAXSPL = 51,
     :            MAXN   = 40,
     :            MAXREF = 20,
     :            MAXEVT = 20,
     :            maxrec = 300,
     :            maxsrc = 100)


      PARAMETER ( MAXNP1 = MAXN + 1,
     :            MAXNP3 = MAXN + 3,
     :            MXSPM1 = MAXSPL - 1)


      real       rw0(mxspm1),                 rw1(mxspm1),
     :           rw2(mxspm1),                 rw3(mxspm1),
     :           sw0(mxspm1),                 sw1(mxspm1),
     :           sw2(mxspm1),                 sw3(mxspm1)

c     max #times in a branch within a layer
      integer    maxt
      parameter( maxt = 500)
      real       t(maxt),     zend(maxt),  trec(maxrec),
     :           phase(maxt),              phsrec(maxrec),
     :           amp(maxt),   work(maxt),  amprec(maxrec),
     :           tc(maxn)
      real       c(maxt),     dd(maxt),    e(maxt),
     :           b(maxt),     cv(0:maxt),
     :           d0(maxt),    d1(maxt)

      REAL        XINT(0:MAXINT,MAXSPL),     ZINT(0:MAXINT,MAXSPL),
     :            A0(0:MAXINT,MXSPM1),       A1(0:MAXINT,MXSPM1),
     :            A2(0:MAXINT,MXSPM1),       A3(0:MAXINT,MXSPM1),
     :            SIGN(0:MAXN)

      INTEGER     NPTS(0:MAXINT),   NINT,      NORDER(MAXN)

      COMMON /A/   XINT,          ZINT,
     :             A0,            A1,        A2,          A3,
     :             SIGN,
     :             NPTS,          NINT,      NORDER



      REAL       DZ(MAXN),       DDZ(MAXN),
     :           D(MAXNP1),      DELTAX(MAXNP1),   DELTAZ(MAXNP1),
     :           V(MAXNP1)

      INTEGER    N

      COMMON /B/   DZ,           DDZ,
     :             D,            DELTAX,        DELTAZ,
     :             V,            N



      REAL       X(0:MAXNP3),       VEL(0:MAXINT+1),   VREF(MAXREF),
     :           xrec(maxrec),      zrec(maxrec),
     :           z(0:maxnp3),
     :           xrwell(0:maxspl),   zrwell(0:maxspl),
     :           xswell(0:maxspl),   zswell(0:maxspl),
     :           xcross(0:maxint),  zcross(0:maxint),
     :           xold(0:maxnp1),    zold(0:maxnp1),
     :           xs(maxsrc),        zs(maxsrc),
     :           AMPTMP,     xstart, 
     :           BETA,       BETAI,       BETAF
      REAL       DELTAB, 
     :           GEOINC,    inplan,
     :           PI,  
     :           XEND,        XLAST,
     :           ZS1,       ZSINC,
     :           r1,      drec,     s1,    dsrc,    deltag,
     :           rayden,  fourpi,   db,    bold,    xw,
     :           zw,      xwprev,   zwprev, dw,
     :           ttmp,    phstmp,   
     :           sinthc,  dxbig,    dxsmll,  dx,
     :           thetac,  danold,   sinthr,  dangle,
     :           t1,      x1,       z1,      hdamp,
     :           x0,      t2,       t3,      dt2,   signdx


      integer    icolor(maxint)

      integer    slayer(maxsrc),  rlayer(maxrec), nrlayr(maxint),
     :           firstr(maxint),  lastr(maxint),  rlprev


      INTEGER    I,         IEVENT,     IERR,
     :           J,         K,          NCHARC,      NDUMMY,
     :           NEVENT,    NMULTS,
     :           IPEN,      nrec,       nrwell,     nswell,
     :           nsrc,      irecd,      lref,       nnew,
     :           np1,       nt,         icross,     iint,
     :           iintp1,    icp1,       intlay,     ilprev,
     :           icold,     icaus1,     icaus2,     nseg,
     :           idummy,    nrec1,      nrecn,      irfrct,
     :           newsly


      character event*30,   evtype(maxevt)*1


      integer  irefl(maxevt,0:maxref),  nrefls(maxevt)
   


      CHARACTER   MODEL*20,    OUTNAM*20,     OUTFIL*20,
     :            geomfl*20,
     :            YORN*1,      colors*20,   wellr*20,   pltype*5,
     :            source*20,   jobtyp*3,    mode*3,     wells*20,
     :            rorh*1



      LOGICAL     fail,       caustc,       
     :            pltmod,     pltgeo,       pltsrc,   unform,
     :            pltsw,      pltrw,        rdsrc,
     :            pltray,     begplt,       qtplot,   list,
     :            shtrec,     qtplt2,       qtplt3,        
     :            downhl,     genral,       rdgeom,
     :            dumml,      valid,      
     :            tinfo,      left,         right,
     :            lefthw,     righthw,
     :            up,         down,     
     :            spfail,     inside,       
     :            newbrn,     turnup,       turndn,   
     :            outt,       outa,         outp,
     :            search,     samebr,       restart,
     :            rwopn,      swopn,        allray,
     :            next,       first

      PARAMETER ( PI = 3.141592653589)
      PARAMETER ( FOURPI = 4.*PI)

c     parameter(pixpi = 60.,
c    :          xscrn = 10.,
c    :          zscrn = 8.)


c**************************************************************


c     Reading from the file PARAM.
      OPEN(UNIT=PARIN,FILE='param1',STATUS ='old',ERR=5)
      GO TO 10
5     WRITE(stderr,'(1x,A)') 'Can''t open file param.'
      STOP
10    REWIND PARIN

c     READ(PARIN,'(A)') YORN
c     IF(YORN.EQ.'y') THEN
c        allray = .true.
c     else
         allray = .false.
c     end if

c     read x and z dimensions of any plots
c     read(parin,*) xdim,zdim

      READ(PARIN,'(A)') MODEL
      OPEN(UNIT=INTERF,FILE=MODEL,STATUS='old',ERR=15)
      GO TO 20
15    WRITE(stderr,'(A)') 'Can''t open file :',MODEL
      STOP
20    REWIND INTERF

      READ(PARIN,*) NINT
      IF(NINT.GT.MAXINT) THEN
         WRITE(stderr,'(A)') 'MAIN : too many interfaces'
         STOP
      END IF

c     Reading the points defining each interface.
c     A large and negative z value defines the end of an interface.
      DO 30 I = 0,  NINT
         J = 1
25       READ(INTERF,*) XINT(I,J),ZINT(I,J)
         IF(ZINT(I,J).LT.-9999.) THEN
            NPTS(I) = J - 1
            IF(NPTS(I).LT.2) THEN
               WRITE(stderr,'(A,I2)')
     :        'MAIN : not enough points defining interface ',I
               STOP
            END IF
         ELSE
            J = J + 1
            IF(J.GT.MAXSPL) THEN
               WRITE(stderr,'(A,I2)')
     :        'MAIN : too many points in interface ',I
               STOP
            END IF
            GO TO 25
         END IF
30       CONTINUE


      xstart = xint(0,1)
      xend   = xint(0,npts(0))     
c-----------------------------------------------------------
c
      READ(PARIN,'(A)') colors
      OPEN(UNIT=colsin,FILE=colors,STATUS='old',ERR=32)
      GO TO 35
32    WRITE(stderr,'(A)') 'Can''t open file :',colors
      STOP
35    REWIND colsin
      do 40 i = 1, 6
         read(colsin,*,end=48) icolor(i)
40       continue
      go to 50
48    WRITE(stderr,*) 'Not enough colors'
      stop

50    continue


c------------------------------------------------------------
c     Calculating the cubic spline coefficients of each interface.
      CALL CUSPLN(NINT,XINT,ZINT,NPTS,A0,A1,A2,A3,spfail)
      if(spfail) then
         write(stderr,'(1x,a)')
     :   'MAIN: Failed to fit spline through interfaces.'
         stop
      end if

c     Read first plot descriptor 
      READ(PARIN,'(A)') pltype
      begplt = .false.
      call setvar(pltype,pltmod,dumml,qtplot,begplt,
     :'m','M','m','M','q','Q')
      if(qtplot) go to 100

c     Read filename containing receiver well description
      read(parin,'(a)',end=100) wellr

c     Read second plot descriptor 
      READ(PARIN,'(A)',end=100) pltype
      call setvar(pltype,pltrw,pltgeo,qtplt2,begplt,
     :'w','W','g','G','q','Q')
      if(pltrw) rwopn = .true.
      if(pltgeo) rwopn = .true.
      if(pltgeo) rdgeom = .true.
      if(qtplt2) go to 100

c     Read shooting mode  
      READ(PARIN,'(A)',end=100) mode
      call setvar(mode,downhl,dumml,genral,dumml,
     :'d','D',' ',' ','g','G')
      if(downhl) swopn = .true.

c     Read filename containing source well description
      read(parin,'(a)',end=100) wells

c     Read source file    
      READ(PARIN,'(A)',end=100) source

c     Read third plot descriptor 
      READ(PARIN,'(A)',end=100) pltype
      call setvar(pltype,pltsw,pltsrc,qtplt3,begplt,
     :'w','W','s','S','q','Q')
      if(pltsw) swopn = .true.
      if(pltsrc) rdsrc = .true.
      if(qtplt3) go to 100

c     Read job descriptor 
      READ(PARIN,'(A)',end=100) jobtyp
      call setvar(jobtyp,list,pltray,shtrec,dumml,
     :'l','L','r','R','t','T')
      if(list)   rdgeom = .true.
      if(shtrec) rdgeom = .true.
      if(pltray) rdgeom = .true.
      if(list)   rdsrc  = .true.
      if(shtrec) rdsrc  = .true.
      if(pltray) rdsrc  = .true.
      if(pltray) rwopn  = .true.
      if(pltray) begplt = .true.
      if(rdgeom) rwopn  = .true.


100   continue

      if(rwopn) then
         open(unit=rwell,file=wellr,status='old',ERR=160)
         GO TO 165
160      WRITE(stderr,'(A)') 'Can''t open well file :',wellr
         stop
165      rewind rwell
c        Read the x,z coordinates of the well 
c        track the number of points defining the well
         nrwell = 0
         zrwell(0) = 0.
         read(rwell,*,end=180) xrwell(0)
170      if(zrwell(nrwell).gt.-9999.) then
            nrwell = nrwell + 1
            if(nrwell.gt.maxspl) then
               write(stderr,'(1x,a,i2)')
     :         'MAIN: Too many points defining the well - max is:',
     :          maxspl
                stop
            end if
            read(rwell,*,end=180) xrwell(nrwell),zrwell(nrwell)
            go to 170
         end if

180      if(nrwell.lt.2) then
            write(stderr,'(1x,a)') 
     :      'Not enough points defining receiver well in file :', 
     :       wellr
            stop
         end if
         if(xrwell(0).le.xstart.or.xrwell(0).gt.xend) then
c          well outside model
           write(stderr,'(1x,a)') 'MAIN: receiver well outside model.'
           stop
         end if

c        calculate z-coordinate of well at surface
         j = 1
185      if(xrwell(0).gt.xint(0,j)) then
            j = j + 1
            go to 185
         end if
         j = j - 1
         zrwell(0) = a0(0,j) + a1(0,j) * xrwell(0)
     :                       + a2(0,j) * xrwell(0)**2
     :                       + a3(0,j) * xrwell(0)**3

c        fit cubic spline to receiver well
         call cusplw(zrwell,xrwell,nrwell,rw0,rw1,rw2,rw3,spfail,
     :               c,dd,e,b,cv)
         if(spfail) then
            write(stderr,'(1x,a)')
     :      'MAIN: Failed to fit spline through receiver well.'
            stop
         end if

         if(rdgeom) then
            read(rwell,*) r1
            read(rwell,*) nrec, drec
            if(nrec.gt.maxrec) then
               write(stderr,'(1x,a,i3)') 
     :         'MAIN: too many receivers in the well - max is: ',
     :         maxrec
               stop
            end if
c           Calculate x-z coordinates of receivers in well
            call xzsrc(r1,nrec,drec,zrwell,nrwell,rw0,rw1,
     :      rw2,rw3,xrec,zrec,fail)
            if(fail) then
               write(stderr,'(1x,a)')
     :         'MAIN: Failed to find receiver coordinates in well.'
                stop
            end if
            rlprev = 0
            do 190 i = 1,  nrec
               call layer(xrec(i),zrec(i),rlayer(i),inside)
               if(.not.inside) then
                  write(stderr,'(1x,a)')
     :            'MAIN: Receiver outside model.'
                  stop
               end if
               if(rlayer(i).eq.rlprev) then
c                 receiver in same layer
                  nrlayr(rlayer(i)) = nrlayr(rlayer(i)) + 1
                  lastr(rlayer(i)) = i
               else
c                 new layer
                  nrlayr(rlayer(i)) = 1
                  firstr(rlayer(i)) = i
                  lastr(rlayer(i)) = i
                  rlprev = rlayer(i)
               end if
190            continue

c           find where receiver well cuts interfaces
            call xzwint(xrwell,zrwell,nrwell,rw0,rw1,rw2,rw3,
     :      xint,a0,a1,a2,a3,maxint,maxspl,mxspm1,nint,
     :      xcross,zcross,fail,stderr)
            if(fail) then
               write(stderr,'(1x,a,1x,a)')
     :         'MAIN: Failed to find well-interface intersections.',
     :         'Well must cross all interfaces in model.'
                stop
            end if

         end if

      end if


      if(swopn) then
        
         open(unit=swell,file=wells,status='old',ERR=200)
         GO TO 202
200      WRITE(stderr,'(A)') 'Can''t open well file :',wells
         stop

202      rewind swell
c        Read the x,z coordinates of the source well 
c        track the number of points defining the well
         nswell = 0
         zswell(0) = 0.
         read(swell,*,end=210) xswell(0)
205      if(zswell(nswell).gt.-99999.) then
            nswell = nswell + 1
            read(swell,*,end=210) xswell(nswell),zswell(nswell)
            go to 205
         end if
210      continue

         if(nswell.lt.2) then
            write(stderr,'(1x,a)') 
     :      'Not enough points defining source well in file :', 
     :       wells
            stop
         end if

         if(xswell(0).le.xstart.or.xswell(0).gt.xend) then
c          well outside model
           write(stderr,'(1x,a)') 'MAIN: source well outside model.'
           stop
         end if

c        find z-coordinate of source well at surface
         j = 1
215      if(xswell(0).gt.xint(0,j)) then
            j = j + 1
            go to 215
         end if
         j = j - 1
         zswell(0) = a0(0,j) + a1(0,j) * xswell(0)
     :                       + a2(0,j) * xswell(0)**2
     :                       + a3(0,j) * xswell(0)**3

c        fit cubic spline to source well
         call cusplw(zswell,xswell,nswell,sw0,sw1,sw2,sw3,spfail,
     :               c,dd,e,b,cv)
         if(spfail) then
            write(stderr,'(1x,a)')
     :      'MAIN: Failed to fit spline through source well.'
            stop
         end if
         
         if(rdsrc) then
            read(swell,*) s1
            read(swell,*) nsrc, dsrc
c           Calculate x-z coordinates of sources in source well
            call xzsrc(s1,nsrc,dsrc,zswell,nswell,sw0,sw1,
     :      sw2,sw3,xs,zs,fail)
            if(fail) then
               write(stderr,'(1x,a)')
     :         'MAIN: Failed to find source coordinates in well.'
                stop
            end if
            do 225 i = 1,  nsrc
               call layer(xs(i),zs(i),slayer(i),inside)
               if(.not.inside) then
                  write(stderr,'(1x,a)')
     :            'MAIN: Source outside model.'
                   stop
               end if
225            continue
         end if

      end if

      if(genral) then

         open(unit=src,file=source,status='old',ERR=235)
         GO TO 240
235      WRITE(stderr,'(A)') 'Can''t open sources file :',source
         stop
240      rewind src

         nsrc = 1
245      read(src,*,end=248) xs(nsrc),zs(nsrc)
         nsrc = nsrc + 1
         go to 245
248      nsrc = nsrc - 1

c        calculate which layer each source belongs in
         do 250 i = 1,  nsrc
            call layer(xs(i),zs(i),slayer(i),inside)
            if(.not.inside) then
               write(stderr,'(1x,a)')
     :         'MAIN: Source outside model.'
               stop
            end if
250         continue


      end if
        

      if(begplt) then
c        Plotting

         call ploti

c?       call scale(xor,zor,uppix,rwopn,zrwell,nrwell,xdim,zdim,
c?   :   xint,zint,npts,nint,xscrn,zscrn,pixpi,maxint,maxspl)

         if(pltmod) then
            ipen = icolor(6)
c           call pen(ipen)
c           CALL PLOTIN(xor,zor,uppix,ipen,icolor)
            CALL PLOTIN(ipen)
         end if

         if(qtplot) then
            call plote
            stop
         end if

         if(pltrw) then
            ipen = icolor(3)
c           call pen(ipen)
c           call plotwl(xor,zor,uppix,zrwell,nrwell,rw0,
            call plotwl(zrwell,nrwell,rw0,rw1,rw2,rw3,ipen)
         end if
         if(pltgeo) then
            ipen = icolor(1)
c           call pen(ipen)
c?          call pltsym(xrec,zrec,nrec,xor,zor,uppix,ipen)
            call pltsym(xrec,zrec,nrec,2.*drec,ipen)
         end if
         if(qtplt2) then
            call plote
            stop
         end if

         if(pltsw) then
            ipen =  icolor(3)
c           call pen(icolor(3))
c           call pen(ipen)
            call plotwl(zswell,nswell,sw0,sw1,sw2,sw3,ipen)
         end if
         if(pltsrc) then
            ipen = icolor(2)
c           call pen(ipen)
            call pltsym(xs,zs,nsrc,2.*drec,ipen)
         end if
         if(qtplt3) then
            call plote
            stop
         end if


         if(.not.pltray) call plote
      
      end if


      if(pltray.or.list) then
c        proceed
      else if(shtrec) then
c        proceed
      else
c        nothing else to do
         stop
      end if

      if(list)   tinfo = .true.
      if(shtrec) tinfo = .true.

c     Read the remainder of param1

c     Read the name to be given the output files, if there are to be any.
      READ(PARIN,'(A)',end=500) OUTNAM

      if(list.or.shtrec) then
c        Count the number of characters in the name, up to first blank.
         J = 1
300      IF(OUTNAM(J:J).EQ.' ') THEN
         ELSE
            J = J + 1
            GO TO 300
         END IF
         NCHARC = J - 1
      end if

      IF(list) THEN
         OUTFIL = OUTNAM(1:NCHARC)//'data'
         OPEN(UNIT=RAYOUT,FILE=OUTFIL,ERR=320)
         GO TO 325
320      WRITE(stderr,'(1x,A)')'Can''t open ray data file.'
         STOP
325      REWIND RAYOUT

         OUTFIL = OUTNAM(1:NCHARC)//'listing'
         OPEN(UNIT=RAYLST,FILE=OUTFIL,ERR=330)
         GO TO 335 
330      WRITE(stderr,'(A)') 'Can''t open ray listing file.'
         STOP
335      REWIND RAYLST
      end if


c     Want to generate a shot record ?
      unform = .true.
      IF(shtrec) THEN
         OUTFIL = OUTNAM(1:NCHARC)//'shot'
         if(unform) then
            OPEN(UNIT=SHTOUT,FORM='UNFORMATTED',FILE=OUTFIL,
     :      ERR=370)
            GO TO 375
         else
            OPEN(UNIT=SHTOUT,FILE=OUTFIL,ERR=370)
            GO TO 375
         end if
370      WRITE(stderr,'(1x,A)') 'Error creating output trace file.'
         STOP
375      REWIND SHTOUT
      END IF

      READ(PARIN,*) BETAI,BETAF

      IF(BETAI.GT.BETAF) THEN
         WRITE(stderr,'(1x,A)') 'MAIN : must have betaf > betai'
         STOP
      END IF

c     read search angles and ray density
      READ(PARIN,*) DELTAB,deltag,rayden
      IF(DELTAB.LE.0.) THEN
         WRITE(stderr,'(1x,A)') 'MAIN : deltab must be positive'
         STOP
      END IF
      IF(DELTAg.LE.0.) THEN
         WRITE(stderr,'(1x,A)') 'MAIN : deltag must be positive'
         STOP
      END IF
      IF(rayden.LE.0.) THEN
         WRITE(stderr,'(1x,A)') 'MAIN : ray density must be positive'
         STOP
      END IF

c     read layer velocities
      READ(PARIN,*,end=400) (VEL(I),I=1,NINT+1)
      go to 405
400   write(stderr,'(1x,a)')
     :'Not enough velocities - need one more than #interfaces.'
      if(begplt) call plote
      stop
405   continue


c     Now read in events
      nevent = 0
c     want direct wave?
      read(parin,'(a)') yorn 
      if(yorn.eq.'y') then
         nevent = 1
         evtype(nevent) = 'd'
      end if

c     want all primaries?
      read(parin,'(a)',end=500) yorn
      if(yorn.eq.'y') then
c        calculate primary reflections
         do 410 k = 1, nint
            nevent = nevent + 1
            evtype(nevent) = 'r'
            nrefls(nevent) = 1
            irefl(nevent,1) = k
410         continue
      end if

c     want all head waves?
      read(parin,'(a)',end=500) yorn
      if(yorn.eq.'y') then
c        calculate head waves
         do 415 k = 1, nint
            nevent = nevent + 1
            evtype(nevent) = 'h'
            nrefls(nevent) = 1
            irefl(nevent,1) = k
415         continue
      end if

c     now come the extra events
420   read(parin,'(a,a)',end=425) rorh,event
      if(rorh.eq.'H') rorh = 'h'
      if(rorh.eq.'R') rorh = 'r'
      nevent = nevent + 1
      if(rorh.eq.'r'.or.rorh.eq.'h') then
         call setref(event,irefl,nrefls(nevent),nevent,
     :   valid,maxevt,maxref,nint)
         if(nrefls(nevent).eq.0) then
c           not an event - probably a blank line
            nevent = nevent - 1
         else if(.not.valid) then
            nevent = nevent - 1
            write(stderr,'(1x,a)')
     :      'Invalid extra event specification'
         else
            evtype(nevent) = rorh
         end if
      else
         nevent = nevent - 1
         write(stderr,'(1x,a)')
     :   'Extra event must begin with r or h'
      end if
      go to 420
425   continue

      go to 505
500   write(stderr,'(1x,a)')
     :'MAIN: param1 not filled-out.'
      stop
505   continue


      if(list) then

         write(raylst,'(/,20x,a/)')
     :   'XWELL Listing File'
         write(raylst,'(/2x,a)') 'Velocities:'
         do 605 i = 1,  nint + 1
            write(raylst,'(2x,a,i2,1x,f8.1)')
     :      'layer ',i,vel(i)
605         continue

         if(downhl) then
            write(raylst,'(/2x,a,f8.2,a,f8.2)')
     :      'Top of receiver well is at coordinates ',xrwell(0),',',
     :      zrwell(0)
         end if
         if(downhl) then
            write(raylst,'(2x,a,f8.2,a,f8.2/)')
     :      'Top of source well is at coordinates ',xswell(0),',',
     :      zswell(0)
         end if
         WRITE(RAYLST,'(/,2X,A,I4)') 'Number of shots = ',nsrc
         WRITE(RAYLST,'(2X,A,I4)') 'Number of events per shot = ',
     :   NEVENT

         write(raylst,'(/2x,a,11x,a,9x,a)')'shot',
     :   'x-z coordinates',
     :   'layer number'
         do 350 k = 1,  nsrc
            write(raylst,'(2x,i3,10x,f8.2,2x,f8.2,12x,i2)')
     :      k,xs(k),zs(k),slayer(k)
350         continue

         write(raylst,'(/2x,a,7x,a,9x,a)')'receiver',
     :   'x-z coordinates',
     :   'layer number'
         do 355 k = 1,  nrec
            write(raylst,'(2x,i3,10x,f8.2,2x,f8.2,12x,i2)')
     :      k,xrec(k),zrec(k),rlayer(k)
355         continue

      end if




c     VEL(0) identifies reflections from the surface of the
c     earth ( reflection coefficient is then set to -1 ).
      VEL(0) = 0.

ccc   Main loop over shots 
c-------------------------

      do 2000 irecd = 1,  nsrc

      x(0) = xs(irecd)
      z(0) = zs(irecd)

      call srcpos(xs(irecd),zs(irecd),
     :zrwell,xrwell(0),rw0,rw1,rw2,rw3,left,right)



ccc   Do for each event
c----------------------

      DO 1000 IEVENT = 1,  NEVENT

      IF(list) THEN
         WRITE(RAYLST,'(3(/),2X,A,I4,6X,A,I4/)')
     :   'Shot ',irecd,'event ',IEVENT
      END IF

      if(evtype(ievent).eq.'d') then
         if(list) write(raylst,'(2x,a/)')'This is a direct wave.'
         lref = 0
      else
         if(evtype(ievent).eq.'r') then
            if(list) write(raylst,'(2x,a/)')'This is a reflection.'
         else
            if(list) write(raylst,'(2x,a/)')'This is a head wave.'
            x(0) = xs(irecd)
            z(0) = zs(irecd)
         end if
         call order(irefl,nrefls(ievent),slayer(irecd),ievent,
     :           vel,norder,v,sign,vref,n,
     :           valid,list,raylst,stderr,maxevt,maxref,
     :           nint,lref,evtype(ievent),sinthc)
         if(.not.valid) go to 1000
      end if



c     Initialize
      nnew = 0
      np1 = n + 1
      beta = betai
      db = deltab
      nt = 0
      turnup = .false.
      turndn = .false.
      newbrn = .false.
      search = .false.
      samebr = .false.
      restart = .true.
      

      if(evtype(ievent).eq.'h') then

c     Head Wave
c     After critical ray is found, source point runs
c     along refractor shooting rays at critical angle.
c     dxbig is step size along refractor while searching for 
c     a well intersection. dxmall is used in vicinity of well.

      dxbig = drec
      dxsmll = dxbig/10.
      dx = dxbig

c     Search for critical intersection point
c     First find where incident angle passes through critical
      thetac = asin(abs(sinthc))
      danold = 0.
      sinthr = 0.
      next = .false.
      fail = .false.

650   if(beta.le.betaf) then

         CALL SHOOT(X,z,BETA,PI,drec,nnew,xstart,xend,
     :   lref,sinthr)

cpaul    if(allray) CALL RAYplt(X,Z,nnew-1,ipen)

c        check to see if ray reached target refractor..
         if(nnew.le.lref) next = .true.

         if(left.and.sinthr.le.0.) next = .true.
         if(right.and.sinthr.gt.0.)next = .true.

         if(next) then
            next = .false.
            beta = beta + deltab
            if(allray) CALL RAYplt(X,Z,lref-1,ipen)
            go to 650
         end if

c        difference between angle ray makes with normal at
c        refractor and critical angle (thetac)
         dangle = 180. * (asin(abs(sinthr)) - thetac)/pi

         if(dangle.ne.0.) then
            if(danold/dangle.ge.0.) then
               if(allray) CALL RAYplt(X,Z,lref-1,ipen)
               danold = dangle
               beta = beta + deltab
               go to 650
            end if
         end if

c        ...passed though critical
c        Converge on critical ray...

         if(dangle.eq.0.) then
c           at critical
         else 
c           danold/dangle < 0., ie sign change
c           if(pltray) then
c              ipen = icolor(5)
c              CALL RAYplt(X,Z,nnew-1,ipen)
c           end if
c           now use bisection to zero in on critical ray
            call bisect(beta,deltab,thetac,sinthr,pi,
     :      xstart,xend,drec,lref,x,z)
         end if

ccc      Found Critical Ray

         if(pltray) then
            ipen = icolor(5)
            CALL RAYplt(X,Z,lref-1,ipen)
c           CALL RAYplt(X,Z,nnew-1,ipen)
         end if

         if(list) then
            write(raylst,'(2x,a/)')'Source segment of raypath:'
            call xzout(x,z,lref,raylst)
            write(raylst,'(/2x,a/)')'Receiver segments follow...'
         end if
      else

c        couldn't find critical intersection
         go to 1000

      end if




ccc   Calculate traveltime between source and refractor
      call ttime(n,d,v,t1,lref-1)
c     save coordinates of intersection with refractor
      x1 = x(lref)
      z1 = z(lref)

      first = .true.

c     calculate amplitude (transmission effects) down
c     to refractor
      call RAYDAT(zw,VREF,irefl,ievent,amptmp,phstmp,
     :maxevt,maxref,rw1,rw2,rw3,zrwell,
     :nrwell,lref-1,icp1,norder,tc,.true.)

c     constant used in head wave amplitude calculations...
      hdamp = v(lref) * sinthc / 
     :        ( 2. * pi * (1.-sinthc*sinthc) )

c     multiply by transmission effects between source and refractor
      do 660 i = 1,  lref - 1
         hdamp = hdamp * tc(i)
660      continue
      

      if(left) then
c        source to left of well, move to right along interface
         signdx = 1.
      else
c        source to right of well, move to left along interface
         signdx = -1.
      end if

ccc   NOTE
c     Caustics in head wave field not supported (ie a phase shifted
c     head wave wavelet is NOT used---CSHOT2 does not have this 
c     capability at present.  The caustic rays are calculated here
c     but a normal head wave wavelet will be placed on wiggle trace.)
      caustc = .false.
ccc


c     Next, move along interface shooting rays at critical angle.

c     Interface number of refractor (refractor number is the last
c     interface in the specification - there may be many reflections
c     before ray reaches the refractor)...
      irfrct = irefl(ievent,nrefls(ievent))

c     calculate point on refractor for source of receiver portion
c     of head wave ray, also calculate takeoff angle relative to vertical
      call hwsrc(x(lref),sinthc,irfrct,dx,x(0),z(0),lref,
     :up,down,beta,signdx,pi,newsly,xstart,xend,fail,
     :xcross,lefthw,righthw)

      if(fail) go to 1000

c     receiver portion of ray is viewed as a direct ray, the source
c     of which lies on the refractor
c     set some parameters for this direct ray...
      ir1tmp = irefl(ievent,1)
      call setdir(lefthw,up,down,bold,beta,sign,
     :x(0),z(0),newsly,nint,xcross,zcross,pi,n,np1,
     :norder,v,vel,irefl,maxevt,ievent,'h')


c     Now start shooting rays from source points on the refractor
c     Check that source is within limits of model

1750  if(x(0).gt.xstart.and.x(0).lt.xend) then

         fail = .false.

         if(restart) then

c           shoot a ray from this point on interface
            CALL SHOOT(X,z,BETA,PI,drec,nnew,xstart,xend,0,sinthr)

c           check for intersection with receiver well...
            call xzwell(x,z,xcross,zcross,0,norder,n,nnew,nint,fail,
     :               icross,iint,iintp1,newsly,lefthw,righthw,
     :               zrwell,nrwell,rw0,rw1,rw2,rw3,xw,zw,deltax,
     :               deltaz,d,icp1)

            if(.not.fail) then
c              Found a ray that hits the well.
c              Backspace to previous source location and
c              approach well more carefully...
               x0 = x(0) - dxbig 
               dx = dxsmll
c              begin search for next ray
               search = .true. 
               restart = .false.
               x(icp1) = xw
               z(icp1) = zw
               if(pltray) then
c                 plot first ray a different color
c                 ipen = icolor(7)
c                 call pen(ipen)
                  CALL RAYplt(X,Z,icross,ipen)
               end if
            else
c              continue to search for well
               if(allray) then
                  ipen = icolor(4)
c                 call pen(ipen)
                  CALL RAYplt(X,Z,nnew-1,ipen)
               end if
               x0 = x(0) 
               dx = dxbig
            end if

c           move to next source location on refractor
            call hwsrc(x0,sinthc,irfrct,dx,x(0),z(0),lref,
     :      up,down,beta,signdx,pi,newsly,xstart,xend,fail,
     :      xcross,lefthw,righthw)

            go to 1750

         end if


         if(search) then

c           Search for the first ray on branch
c           shoot a ray from this source location
            CALL SHOOT(X,z,BETA,PI,drec,nnew,xstart,xend,0,sinthr)

c           check for well intersection
            call xzwell(x,z,xcross,zcross,0,norder,n,nnew,nint,fail,
     :                 icross,iint,iintp1,newsly,lefthw,righthw,
     :                 zrwell,nrwell,rw0,rw1,rw2,rw3,xw,zw,deltax,
     :                 deltaz,d,icp1)

            if(.not.fail) then
c              found first ray on branch
               nt = 0
               search = .false.
               samebr = .true.
               intlay = max(iint,iintp1)
               ilprev = intlay
               x(icp1) = xw
               z(icp1) = zw
               xwprev = xw
               zwprev = zw
               if(pltray) then
                  ipen = icolor(5)
c                 call pen(ipen)
                  CALL RAYplt(X,Z,icross,ipen)
               end if
               if(first.and.tinfo) then
c                 calculate traveltime along refractor for first ray
                  call tinteg(x1,z1,irfrct,
     :            vel(irfrct+1),x(0),z(0),t2,
     :            xint,a0,a1,a2,a3,maxint,maxspl,mxspm1)
                  first = .false.
                  xold(0) = x(0)
                  zold(0) = z(0)
               end if
            else
               if(allray) then
                  ipen = icolor(4)
c                 call pen(ipen)
                  CALL RAYplt(X,Z,nnew-1,ipen)
               end if
            end if

c           move to next source position
            x0 = x(0)
            dx = dxsmll
            call hwsrc(x0,sinthc,irfrct,dx,x(0),z(0),lref,
     :      up,down,beta,signdx,pi,newsly,xstart,xend,fail,
     :      xcross,lefthw,righthw)

            go to 1750

         end if



         if(samebr) then

c           look for next ray on this branch
c           shoot a ray from this source location
            CALL SHOOT(X,z,BETA,PI,drec,nnew,xstart,xend,
     :      0,sinthr)

c           check for well intersection
            call xzwell(x,z,xcross,zcross,0,norder,n,nnew,nint,fail,
     :                 icross,iint,iintp1,newsly,lefthw,righthw,
     :                 zrwell,nrwell,rw0,rw1,rw2,rw3,xw,zw,deltax,
     :                 deltaz,d,icp1)

            if(.not.fail) then
               x(icp1) = xw
               z(icp1) = zw
               intlay = max(iint,iintp1)
               if(intlay.eq.ilprev) then
                  newbrn = .false.
                  ilprev = intlay
               else
c                 write(*,*)'New Branch',intlay,ilprev
c                 read(*,'(a)')yorn
                  newbrn = .true.
               end if

               dw = sqrt( (xw-xwprev)**2 + (zw-zwprev)**2 )
   
               if(tinfo) then
c                 integrate traveltime along refractor from previous
c                 ray to current ray
                  call tinteg(xold(0),zold(0),irfrct,
     :            vel(irfrct+1),x(0),z(0),dt2,
     :            xint,a0,a1,a2,a3,maxint,maxspl,mxspm1)
                  t2 = t2 + dt2
                  xold(0) = x(0)
                  zold(0) = z(0)
               end if

               if(.not.newbrn) then
                  if(tinfo) then
                     call ttime(n,d,v,t3,icross)
c                    this is the total traveltime...
                     ttmp = t1 + t2 + t3
                  end if
                  if(shtrec) then
c                    compute amplitude factors on receiver segment of ray
                     call RAYDAT(zw,VREF,irefl,ievent,amptmp,phstmp,
     :               maxevt,maxref,rw1,rw2,rw3,zrwell,
     :               nrwell,icross,icp1,norder,tc,.true.)

                     amptmp = hdamp / (xs(irecd)-xw)**2
c                    apply receiver segment transmission factors
                     do 1650 i = 1,  icross
                        amptmp = amptmp * tc(i)
1650                    continue
                     if(nt.eq.maxt) then
                        write(stderr,'(1x,a)')'Too many rays in layer'
                        go to 990 
                     end if
                     nt = nt + 1
                     t(nt) = ttmp
                     amp(nt) = amptmp 
                     phase(nt) = 0.
                     zend(nt) = zw
                  end if
                  IF(list) THEN
c                    write(rayout,*)n+2,ttmp
c                    call xzout(x,z,icross+1,rayout)
                     call xzout(x,z,icross+1,raylst)
                     WRITE(raylst,'(3X,A,F10.6/)') 't = ',ttmp
                  END IF
               end if

c              now calculate dx from change in end points of ray
c              don't let dx get too big though
               if(dw.gt.0.)dx = dx * drec / (dw*rayden)
               dx = min(dx,dxbig)

               xwprev = xw
               zwprev = zw
               if(pltray) then
                  ipen = icolor(5)
                  CALL RAYplt(X,Z,icross,ipen)
               end if
            else
c              couldn't find well intersection
c              read(*,'(a)')yorn
               newbrn = .true.
               samebr = .false.
               restart = .true.
               dx = dxbig
               if(allray) then
                  ipen = icolor(4)
                  CALL RAYplt(X,Z,nnew-1,ipen)
               end if
            end if

            x0 = x(0)
            call hwsrc(x0,sinthc,irfrct,dx,x(0),z(0),lref,
     :      up,down,beta,signdx,pi,newsly,xstart,xend,fail,
     :      xcross,lefthw,righthw)

         end if


         if(newbrn) then

c           Ouput data from previous branch

            if(nt.ge.2.and.nrlayr(ilprev).gt.0) then
               call linint(zend,t,amp,phase,work,nt,
     :         d0,d1,spfail,firstr(ilprev),lastr(ilprev),
     :         nrlayr(ilprev),zrec,nrec,trec,
     :         amprec,phsrec,nrec1,nrecn,turnup,turndn)

               if(shtrec) then
c                 if(outt) then
c                    call output(nrec1,nrecn,
c    :               zrec,nrec,trec,zend,t,
c    :               nt,nrlayr(ilprev),rayout,irecd,ievent)
c                 else if(outa) then
c                    call output(nrec1,nrecn,
c    :               zrec,nrec,amprec,zend,amp,
c    :               nt,nrlayr(ilprev),rayout,irecd,ievent)
c                 else if(outp) then
c                    call output(nrec1,nrecn,
c    :               zrec,nrec,phsrec,zend,phase,
c    :               nt,nrlayr(ilprev),rayout,irecd,ievent)
c                 end if

                  call wrtsht(nrec1,nrecn,zrec,nrec,
     :            trec,amprec,phsrec,caustc,
     :            nrlayr,shtout,irecd,ievent,unform,.true.)
               end if

            end if
            nt = 0
            newbrn = .false.
            turnup = .false.
            turndn = .false.
            ilprev = intlay
      
         end if

         go to 1750

      end if
            

990   continue
      irefl(ievent,1) = ir1tmp

ccc   END OF HEAD WAVE IF
      end if


      if(evtype(ievent).eq.'h') go to 1000



c------
c     Begin searching for a ray that intersects the well


750   if(beta.le.betaf) then

         fail = .false.
         if(evtype(ievent).eq.'d') then
c           for a direct wave, the order of intersections may
c           change with takeoff angle...
            call setdir(left,up,down,bold,beta,sign,
     :      xs(irecd),zs(irecd),slayer(irecd),nint,
     :      xcross,zcross,pi,n,np1,
     :      norder,v,vel,irefl,maxevt,ievent,'d')
         end if


         if(restart) then

c           shoot a ray at takeoff angle beta
            CALL SHOOT(X,z,BETA,PI,drec,nnew,xstart,xend,
     :      lref,sinthr)

            call xzwell(x,z,xcross,zcross,lref,norder,n,nnew,nint,fail,
     :                    icross,iint,iintp1,slayer(irecd),left,right,
     :                    zrwell,nrwell,rw0,rw1,rw2,rw3,xw,zw,deltax,
     :                    deltaz,d,icp1)

            if(.not.fail) then
c              Found a ray that hits the well.
c              Backspace to previous takeoff angle and
c              approach well more carefully...
               if(evtype(ievent).eq.'d') then
                  beta = bold - deltab + deltag
               else
                  beta = beta - deltab + deltag
               end if
c              begin search for next ray
               search = .true. 
               restart = .false.
               db = deltag
               x(icp1) = xw
               z(icp1) = zw
               if(pltray) then
c                 plot first ray a different color
c                 ipen = icolor(7)
                  ipen = icolor(5)
                  CALL RAYplt(X,Z,icross,ipen)
               end if
            else
               if(allray) then
                  ipen = icolor(4)
                  CALL RAYplt(X,Z,nnew-1,ipen)
               end if
               if(evtype(ievent).eq.'d') beta = bold
               beta = beta + deltab
            end if

            go to 750

         end if


         if(search) then

c           Search for the first ray on branch
c           shoot a ray at takeoff angle beta
            CALL SHOOT(X,z,BETA,PI,drec,nnew,xstart,xend,
     :      lref,sinthr)

            call xzwell(x,z,xcross,zcross,lref,norder,n,nnew,nint,fail,
     :                 icross,iint,iintp1,slayer(irecd),left,right,
     :                 zrwell,nrwell,rw0,rw1,rw2,rw3,xw,zw,deltax,
     :                 deltaz,d,icp1)

            if(.not.fail) then
c              found first ray on branch
               nt = 0
               search = .false.
               samebr = .true.
               intlay = max(iint,iintp1)
               ilprev = intlay
               x(icp1) = xw
               z(icp1) = zw
               xwprev = xw
               zwprev = zw
               icold = icp1
               icaus1 = 1
               do 600 i = 0, icp1
                  xold(i) = x(i)
                  zold(i) = z(i)
600               continue
               if(pltray) then
                  ipen = icolor(5)
                  CALL RAYplt(X,Z,icross,ipen)
               end if
            else
               if(allray) then
                  ipen = icolor(4)
                  CALL RAYplt(X,Z,nnew-1,ipen)
               end if
            end if
            if(evtype(ievent).eq.'d') beta = bold

            beta = beta + deltag

            go to 750

         end if



         if(samebr) then

c           look for next ray on this branch
c           shoot a ray at takeoff angle beta
            CALL SHOOT(X,z,BETA,PI,drec,nnew,xstart,xend,
     :      lref,sinthr)

            call xzwell(x,z,xcross,zcross,lref,norder,n,nnew,nint,fail,
     :                 icross,iint,iintp1,slayer(irecd),left,right,
     :                 zrwell,nrwell,rw0,rw1,rw2,rw3,xw,zw,deltax,
     :                 deltaz,d,icp1)

            if(.not.fail) then
               x(icp1) = xw
               z(icp1) = zw
c              check for caustic
               intlay = max(iint,iintp1)
               nseg = min(icp1,icold)
               call chkcst(xold,zold,x,z,icp1,nseg,icaus2)
               if(icaus1.eq.icaus2.and.intlay.eq.ilprev) then
                  newbrn = .false.
                  ilprev = intlay
               else
                  newbrn = .true.
               end if
               if(icaus1.eq.0) then
                  caustc = .true.
               else
                  caustc = .false.
               end if
               if(icaus1.ne.icaus2) then
                  if(zold(icold).gt.z(icp1)) then
                     turnup = .true.
                  else
                     turndn = .true.
                  end if
               end if

               dw = sqrt( (xw-xwprev)**2 + (zw-zwprev)**2 )
   
               if(.not.newbrn) then
                  if(tinfo) then
                     call ttime(n,d,v,ttmp,icross)
                  end if
                  if(shtrec) then
c                    compute in-plane spreading
                     if(dw.gt.0.)then
                        inplan = sqrt( v(1)*db*pi / (dw*180.) )/fourpi
                     else
                        inplan = 0.
                     end if
c                    compute rest of amplitude factors
                     call RAYDAT(zw,VREF,irefl,ievent,amptmp,phstmp,
     :               maxevt,maxref,rw1,rw2,rw3,zrwell,
     :               nrwell,icross,icp1,norder,tc,.false.)

                     nt = nt + 1
                     t(nt) = ttmp
                     amp(nt) = amptmp * inplan
                     phase(nt) = phstmp
                     zend(nt) = zw
                  end if
                  IF(list) THEN
c                    write(rayout,*)n+2,ttmp
c                    call xzout(x,z,n+1,rayout)
                     call xzout(x,z,n+1,raylst)
                     WRITE(raylst,'(3X,A,F10.6/)') 't = ',ttmp
                  END IF
               end if

c              now calculate db from change in end points of ray
c              don't let db get too big though
               if(dw.gt.0.)db = db * drec / (dw*rayden)
               db = min(db,deltab)
ccc            watch out for db=0.

               xwprev = xw
               zwprev = zw
               icold = icp1
               icaus1 = icaus2
               do 700 i = 0, icp1
                  xold(i) = x(i)
                  zold(i) = z(i)
700               continue
               if(pltray) then
                  ipen = icolor(5)
                  CALL RAYplt(X,Z,icross,ipen)
               end if
            else
               newbrn = .true.
               samebr = .false.
               restart = .true.
               db = deltab
               if(allray) then
                  ipen = icolor(4)
                  CALL RAYplt(X,Z,nnew-1,ipen)
               end if
            end if

            if(evtype(ievent).eq.'d') beta = bold
            beta = beta + db

         end if


         if(newbrn) then

c           Ouput data from previous branch

            if(nt.ge.2.and.nrlayr(ilprev).gt.0) then
               call linint(zend,t,amp,phase,work,nt,
     :         d0,d1,spfail,firstr(ilprev),lastr(ilprev),
     :         nrlayr(ilprev),zrec,nrec,trec,
     :         amprec,phsrec,nrec1,nrecn,turnup,turndn)

               if(shtrec) then
c                 if(outt) then
c                    call output(nrec1,nrecn,
c    :               zrec,nrec,trec,zend,t,
c    :               nt,nrlayr(ilprev),rayout,irecd,ievent)
c                 else if(outa) then
c                    call output(nrec1,nrecn,
c    :               zrec,nrec,amprec,zend,amp,
c    :               nt,nrlayr(ilprev),rayout,irecd,ievent)
c                 else if(outp) then
c                    call output(nrec1,nrecn,
c    :               zrec,nrec,phsrec,zend,phase,
c    :               nt,nrlayr(ilprev),rayout,irecd,ievent)
c                 end if

                  call wrtsht(nrec1,nrecn,zrec,nrec,
     :            trec,amprec,phsrec,caustc,
     :            nrlayr,shtout,irecd,ievent,unform,.false.)
               end if

            end if
            nt = 0
            newbrn = .false.
            turnup = .false.
            turndn = .false.
            ilprev = intlay
      
         end if

         go to 750

      end if

      if(list) then
         write(raylst,'(/2x,a/)')
     :   'End of Event'
      end if


1000  CONTINUE

      if(list) then
         write(raylst,'(/2x,a//)')
     :   'End of Shot'
      end if

2000  CONTINUE

c     close files
      IF(PLTray) THEN
         call plote
      END IF

      IF(shtrec) THEN
         CLOSE(UNIT=SHTOUT,STATUS='keep')
      END IF

      IF(list) THEN
         CLOSE(UNIT=RAYOUT,STATUS='keep')
         CLOSE(UNIT=RAYLST,STATUS='keep')
      END IF


      STOP

      END

*--------------- end of main program -------------------------------
@


1.1
log
@Initial revision
@
text
@d91 2
a92 2
     :           BETA,       BETAI,       BETAF,
     :           DELTAB, 
@
