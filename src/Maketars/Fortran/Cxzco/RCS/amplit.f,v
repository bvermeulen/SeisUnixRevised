head	1.1;
access;
symbols;
locks
	john:1.1; strict;
comment	@c @;


1.1
date	97.01.28.19.53.49;	author john;	state Exp;
branches;
next	;


desc
@amplit.f
@


1.1
log
@Initial revision
@
text
@c
      subroutine amplit(sinmax,sins,amp,sigma,cosbf,icontr)
c...................................................................
c     Calculates the amplitude weighting factor to be applied to
c     the data, given the raypath.  The amplitude factor is made up
c     of transmission coefficients, change in area of ray tube at each
c     interface, emergence angle of ray, and the ray parameter sigma.
c...................................................................
      real        sinmax,      amp
      integer     maxn,        maxnp1,       maxnp3
      parameter ( maxn   = 50)
      parameter ( maxnp1 = maxn + 1,
     :            maxnp3 = maxn + 3)
      real        f(0:maxnp1),     df(maxn),      ddf(maxn),
     :            c(0:maxnp1),     d(maxnp1),
     :            deltac(maxnp1),  deltaf(maxnp1),
     :            deltax(maxnp1),  deltaz(maxnp1),
     :            v(maxnp1) 
      integer     n,               icontr 
      common /b/  f,               df,            ddf,
     :            c,               d,
     :            deltac,          deltaf,
     :            deltax,          deltaz,
     :            v,
     :            n
c...................................................................
c    local     variables
c     ARG       argument of square root used in the expression
c               for the transmission coefficient
c     COSBF     cosine of emergence angle of ray and the vertical
c     COSINC    cosine of angle between incident ray and normal
c     COSTRA    cosine of angle between transmitted ray and normal
c     K         loop variable
c     SIGMA     running parameter along the ray
c     TRANS     product of transmission coefficients
c     VALNOR    magnitude of normal to interface
c     XSECTN    factor due to changes in cross-sectional area
c               of ray tube at interfaces
c...................................................................
      real        arg,           cosbf,
     :            cosinc,        costra,
     :            sigma,         trans,
     :            valnor,        xsectn
      integer     k

c     Initialising
      trans  = 1.
      xsectn = 1.
c
      if(icontr.eq.1)then
c       Checking for aliasing, Only true for rays to receivers.
      	if(deltax(1).eq.0.) then
c		?????
      	else
        	if(abs(deltax(1)/d(1)+sins).gt.sinmax) then
        		amp = 0.
            		return
         	end if
      	end if
      end if
c
      if(n.eq.0) then
c	??????
      else
c        Find transmission coefficient at each  intersection point.
c        Take scalar product of ray with normal to get
c        cosine of angle between.
         do 10  k = 1,  n
            valnor = sqrt( 1. + df(k)**2 )  
            costra = abs( ( deltax(k) * df(k) - deltaz(k) )
     :                 / ( d(k) * valnor ) )
            cosinc = abs( ( deltax(k+1) * df(k) - deltaz(k+1) )
     :                 / ( d(k+1) * valnor ) )
            if(cosinc.lt..1.or.costra.lt..1) then
               amp = 0.
               return
            end if
            arg = ( v(k+1) / v(k) )**2 - 1. + cosinc**2  
c           no transmitted ray at this angle of incidence
            if(arg.lt.0.) then
               amp = 0.
               return
            else
               trans = trans*2.*cosinc/(cosinc + sqrt(arg))
            end if
            xsectn = xsectn * costra / cosinc
10       continue
      end if
c
c     Calculating sigma
      sigma = 0.
      do 100  k = 1,  n + 1
         sigma = sigma + d(k) * v(k)
100   continue
c     Need the cosine of the emergence angle ray makes with vertical.
      cosbf = abs( deltaz(1) / d(1) )
c     Do the amplitude calculation for this ray.
      amp = sqrt(cosbf)/( sqrt(v(n+1)*xsectn ) * trans)
c
      return
      end
c
c---------------------------------------------------------------------
        subroutine anglesv(deltax,deltaz,angle)
c...................................................................
c    subroutine to determine the angle of the ray from output
c    to shot or receiver from vertical.
c...................................................................
        real deltax, deltaz, angle
c
        angle=atan(deltax/deltaz)
c
        return
        end
c---------------------------------------------------------------------
      subroutine cuspln(nint,x,z,npts,a0,a1,a2,a3)
c...................................................................
c     This subroutine fits a cubic spline through the points
c     defining each interface.  The curvatures at each end are
c     taken to be zero.  The remaining curvatures are found by
c     inverting a tridiagonal matrix.  Knowing the curvatures we
c     evaluate the spline coefficients.
c     Reference: Numerical Computing and Mathematical Analysis
c                by Stephen M. Pizer.  Science Research Associates, Inc.
c                Pages 307-311.
c...................................................................
      integer     maxn,                    mxspm1
c     MXSPM1 should equal MAXSPL in main, less one
c     MAXN   is maximum value of N
      parameter ( maxn   = 50,
     :            mxspm1 = 150)
      real        x(maxn,0:mxspm1),        z(maxn,0:mxspm1),
     :            a0(maxn,mxspm1),         a1(maxn,mxspm1),
     :            a2(maxn,mxspm1),         a3(maxn,mxspm1)
      integer     nint,                    npts(nint)
c...................................................................
cc    local   variables
c     B()     right hand side of matrix equation for curvatures
c     C()     subdiagonal of matrix to be solved for curvatures
c     CV()    curvatures at spline points
c     D()     diagonal of matrix to be solve for curvatues
c     E()     superdiagonal of matrix to be solved for curvatures
c     I       loop variable
c     INFO    indicates if matrix is singular
c     J       loop variable over interfaces
c     M       loop variable
c     MAXN    maximum value of N
c     MXSPM1  maximum number of points in interface, less one
c     N       number of unknown curvatures
c     STDOUT  unit number of standard output for error messages
c...................................................................
      real      c(mxspm1),               d(mxspm1),
     :          e(mxspm1),               b(mxspm1),
     :          cv(0:mxspm1)
      integer   i,     info,     j,      n,     m,    stdout
      parameter ( stdout = 0)
c
      do 200 j = 1,  nint
         if(npts(j).le.1) then
            write(stdout,'(a)') 'CUSPLN : error defining  interface.'
            stop
         end if
c        Interface is a straight line.
         if(npts(j).eq.2) then
            a0(j,1) = (z(j,0)*x(j,1)-z(j,1)*x(j,0))/(x(j,1)-x(j,0))
            a1(j,1) = ( z(j,1) - z(j,0) ) / ( x(j,1) - x(j,0) )
            a2(j,1) = 0.
            a3(j,1) = 0.
            go to 200
         end if
c
c        evaluating bands of tridiagonal matrix, to be inverted
c        for the curvatures ( see reference, eqn. (142) )
         n = npts(j) - 2	!n is the number of unknown curvatures
         do 50  i = 1,  n	!diagonal
            d(i) = 2. * ( x(j,i+1) - x(j,i-1) )
50       continue
         do 60  i = 1,  n-1	!superdiagonal
            e(i) = x(j,i+1) - x(j,i)
60       continue
         do 70  i = 2,  n       !subdiagonal
            c(i) = x(j,i) - x(j,i-1)
70       continue
         do 80  i = 1,  n	!right hand side
            b(i) = 6. * ( (z(j,i+1)-z(j,i)) / (x(j,i+1)-x(j,i))
     :                - (z(j,i)-z(j,i-1)) / (x(j,i)-x(j,i-1)) )
80       continue
c
         call tridi(n,c,d,e,b,info)	!invert the matrix
         if(info.ne.0) then
            write(stdout,'(a)') 'CUSPLN : failed to fit spline.'
            stop
         end if
c        curvature at end points is set to zero
         cv(0) = 0.
         cv(n+1) = 0.
c        set the remaining curvatures found by tridi.
         do 90  i = 1, n
            cv(i) = b(i)
90       continue
c
c        using the curvatures, solve for the spline coefficients
c        here we have expanded the product terms in reference eqn. (132)
         do 100  m = 0,  n
            a0(j,m+1) = ( cv(m)*x(j,m+1)**3 - cv(m+1)*x(j,m)**3 
     :                + 6.*z(j,m)*x(j,m+1)
     :                - cv(m)*x(j,m+1)*(x(j,m+1)-x(j,m))**2
     :                - 6.*z(j,m+1)*x(j,m) + cv(m+1)*x(j,m)
     :                *(x(j,m+1)-x(j,m))**2)/(6.*(x(j,m+1)-x(j,m)))
            a1(j,m+1) = (-.5*cv(m)*x(j,m+1)**2+.5*cv(m+1)*x(j,m)**2
     :                -z(j,m)+(cv(m)*(x(j,m+1)-x(j,m))**2)/6.
     :		      +z(j,m+1)-(cv(m+1)*(x(j,m+1)-x(j,m))**2)/6.)
     :		      /(x(j,m+1)-x(j,m))
            a2(j,m+1) = (cv(m)*x(j,m+1)-cv(m+1)*x(j,m) )
     :                /(2.*(x(j,m+1)-x(j,m)))
            a3(j,m+1) = ( cv(m+1) - cv(m) ) / (6.*(x(j,m+1)-x(j,m)))
100      continue
200   continue
      return
      end
c----------------------------------------------------------------------
      subroutine dophi(phi,alambd)
c........................................................................
c     Evaluates the system of equations, Phi.
c     For X to be a solution ( a raypath ), PHI must be
c     zero ( actually, its residual must be close to zero ).
c.........................................................................
      real        phi(*),      alambd
      integer     maxn,        maxnp1,       maxnp3
      parameter ( maxn   = 50)
      parameter ( maxnp1 = maxn + 1,
     :            maxnp3 = maxn + 3)
      real        f(0:maxnp1),     df(maxn),      ddf(maxn),
     :            c(0:maxnp1),     d(maxnp1),
     :            deltac(maxnp1),  deltaf(maxnp1),
     :            deltax(maxnp1),  deltaz(maxnp1),
     :            v(maxnp1)
      integer     n
      common /b/  f,               df,            ddf,
     :            c,               d,
     :            deltac,          deltaf,
     :            deltax,          deltaz,
     :            v,
     :            n
c........................................................................
cc    local  variables
c     K      loop variable
c........................................................................
      integer     k
c
      do 100  k = 1, n
         phi(k) = v(k+1) * ( deltax(k) + alambd * df(k) * deltaz(k) ) /
     :    d(k) - v(k) * (deltax(k+1) + alambd * df(k) * deltaz(k+1) ) /
     :    d(k+1)
100   continue
      return
      end
c----------------------------------------------------------------------
      subroutine dxdlam(x,alambd,dxdl,info)
c...................................................................
c     x is an argument that is not really used, as far I can see.  jkc
c     Calculates the derivative of x with respect to alambd,
c     used in finding the first ray.
c...................................................................
      real        x(0:*),  alambd,       dxdl(*)
      integer     info
      integer     maxn,        maxnp1
      parameter ( maxn   = 50)
      parameter ( maxnp1 = maxn + 1)
      real        f(0:maxnp1),     df(maxn),      ddf(maxn),
     :            c(0:maxnp1),     d(maxnp1),
     :            deltac(maxnp1),  deltaf(maxnp1),
     :            deltax(maxnp1),  deltaz(maxnp1),
     :            v(maxnp1)
      integer     n
      common /b/  f,               df,            ddf,
     :            c,               d,
     :            deltac,          deltaf,
     :            deltax,          deltaz,
     :            v,
     :            n
c...................................................................
cc    local    variables
c     DJ()     diagonal of the tridiagonal jacobian matrix
c     DPHIDL() derivative of phi w.r.t. ALAMBD
c     K        loop variable
c     SUBDJ()  subdiagonal of tridiagonal jacobian matrix
c     SUPDJ    superdiagonal of tridiagonal jacobian matrix
c...................................................................
      real        dj(maxn),        dphidl(maxn),
     :            subdj(maxn),     supdj(maxn)
      integer     k
c
c     Evaluate the jacobian matrix.
      call jacob(alambd,subdj,dj,supdj)
c     Evaluate the derivative with respect to ALAMBD.
      do 325 k = 1, n
         dphidl(k) = v(k+1)*(df(k)*(deltaz(k)+alambd*deltaf(k))
     :    	   -(deltaz(k)/d(k)**2)*(deltax(k)+alambd*df(k)*
     :             deltaz(k))*deltaf(k))/d(k)-v(k)*(df(k)*(
     :		   deltaz(k+1)+alambd*deltaf(k+1))-(deltaz(k+1)
     :		   /d(k+1)**2)*(deltax(k+1)+alambd*df(k)*
     :    	   deltaz(k+1))*deltaf(k+1))/d(k+1)
325   continue
      if(n.eq.1) then
         dxdl(1) = - dphidl(1) / dj(1)
      else
         call tridi(n,subdj,dj,supdj,dphidl,info)
         if(info.ne.0) return
c        tridi returns the value of -dxdl in the variable dphidl.
         do 350  k = 1, n
            dxdl(k) = - dphidl(k)
350      continue
      end if
      return
      end
c------------------------------------------------------------------
      subroutine dxdrl(geoinc,dxdl,info)
c...................................................................
c     Finds the derivative of x with respect to rlambd,
c     used in receiver continuation.
c...................................................................
      real        geoinc,      dxdl(*)
      integer     info
      integer     maxn,        maxnp1,       maxnp3
      parameter ( maxn   = 50)
      parameter ( maxnp1 = maxn + 1,
     :            maxnp3 = maxn + 3)
      real        f(0:maxnp1),     df(maxn),      ddf(maxn),
     :            c(0:maxnp1),     d(maxnp1),
     :            deltac(maxnp1),  deltaf(maxnp1),
     :            deltax(maxnp1),  deltaz(maxnp1),
     :            v(maxnp1)
      integer     n
      common /b/  f,               df,            ddf,
     :            c,               d,
     :            deltac,          deltaf,
     :            deltax,          deltaz,
     :            v,
     :            n
c...................................................................
cc    local    variables
c     DJ()     diagonal of the tridiagonal jacobian matrix
c     DPHIDR() derivative of PHI w.r.t. x-coordinate of receiver
c     K        loop variable
c     SUBDJ()  subdiagonal of tridiagonal jacobian matrix
c     SUPDJ    superdiagonal of tridiagonal jacobian matrix
c...................................................................
      real       dj(maxn),        dphidr(maxn),
     :           subdj(maxn),     supdj(maxn)
      integer    k
c
c     Evaluste the jacobian matrix.
      call jacob(1.,subdj,dj,supdj)
c     Only PHI(1) is a function of the receiver location, X(0).
c     Also including here the receiver spacing (reference, eqn.(15)).
      dphidr(1) = -v(2)*(1.0-(deltax(1)/d(1))**2-
     :		(df(1)*deltax(1)*deltaz(1))/d(1)**2)*geoinc/d(1)
      if(n.eq.1) then
         dxdl(1) = - dphidr(1) / dj(1)
      else
         do 325  k = 2, n
            dphidr(k) = 0.0
325      continue
         call tridi(n,subdj,dj,supdj,dphidr,info)
         if(info.ne.0) return
c        tridi returns the value of -dxdl as dphidr.
         do 350  k = 1, n
            dxdl(k) = - dphidr(k)
350      continue
      end if
      return
      end
c---------------------------------------------------------------------
      subroutine eval(x,alambd,splnok)
c.....................................................................
c     Evaluates quantities used frequently by other subroutines.
c.....................................................................
      real        x(0:*),      alambd
      logical     splnok
      integer     maxn,        maxnp1,       maxnp3,
     :            maxspl,      mxspm1
      parameter ( maxn   = 50,
     :            maxspl = 151)
      parameter ( maxnp1 = maxn + 1,
     :            maxnp3 = maxn + 3,
     :            mxspm1 = maxspl - 1)
      real        xint(maxn,maxspl),        zint(maxn,maxspl),
     :            a0(maxn,mxspm1),          a1(maxn,mxspm1),
     :            a2(maxn,mxspm1),          a3(maxn,mxspm1)
      integer     npts(maxn),    nint
      common /a/  xint,          zint,
     :            a0,            a1,        a2,         a3,
     :            npts,          nint
      real        f(0:maxnp1),     df(maxn),      ddf(maxn),
     :            c(0:maxnp1),     d(maxnp1),
     :            deltac(maxnp1),  deltaf(maxnp1),
     :            deltax(maxnp1),  deltaz(maxnp1),
     :            v(maxnp1)
      integer     n,               na
      common /b/  f,               df,            ddf,
     :            c,               d,
     :            deltac,          deltaf,
     :            deltax,          deltaz,
     :            v,
     :            n
      common /coor/cx,cy
c.....................................................................
cc    local variables
c     I     loop variable over intersection points
c     K     loop variable over intersection points
c     J     identifies section of interface
c.....................................................................
      integer     i,j,k
c
      splnok = .true.
c     If x falls outside the range of definition of the splined
c     interface, then return.
      do 3 i = 1,  n
         if(x(i).lt.xint(i,1).or.x(i).ge.xint(i,npts(i))) then
            splnok = .false.
            return
         end if
3     continue
c
c     Finding the section of the spline on which x lies and evaluating
c     the function and derivatives.
c
      do 10 i = 1,  n
         j = 1
5        if(x(i).ge.xint(i,j)) then
            j = j + 1
            go to 5
         end if
         j = j - 1
c
         f(i)   = a0(i,j) - c(i) + a1(i,j) * x(i) + a2(i,j) * x(i)**2
     :		+ a3(i,j) * x(i)**3
         df(i)  = a1(i,j)  +   2.* a2(i,j) * x(i) + 3.*a3(i,j) * x(i)**2
         ddf(i) =              2.* a2(i,j)        + 6.*a3(i,j) * x(i)
10    continue
      do 100 k = 1,  n + 1
         deltax(k) = x(k) - x(k-1)
         deltaf(k) = f(k) - f(k-1)
         deltaz(k) = deltac(k) + alambd * deltaf(k)
         d(k) = sqrt( deltax(k)**2 + deltaz(k)**2 )
100   continue
      return
      end
c---------------------------------------------------------------------------
      real function fx(x,a,thick,np1)
c...........................................................................
c     Calculates distance travelled by ray (see Fawcett eqn. (A-3)).
c...........................................................................
      integer  np1
      real     x,    a(np1),     thick(np1)
c...........................................................................
cc    local    variables
c     j        loop variable
c...........................................................................
      integer  j
c
      fx = 0.0
      do 500 j = 1,  np1
         fx = fx + thick(j) * a(j) * x /
     :   sqrt( 1.- a(j) * a(j) * x * x )
500   continue
      return
      end
c------------------------------------------------------------------------
      subroutine guessx(x,n,deltal,dxdl)
c........................................................................
c     Calculates the initial value of x to be used in newton's method.
c     See reference, eqn. (9).
c........................................................................
      integer   n
      real      x(0:n+1),      dxdl(n),      deltal
c........................................................................
cc    local variables
c     K     loop variable
c........................................................................
      integer   k
c
      do 100  k = 1,  n
         x(k) = x(k) + deltal * dxdl(k)
100   continue
      return
      end
c-------------------------------------------------------------------
      subroutine jacob(alambd,subdj,dj,supdj)
c...................................................................
c     Calculates the elements of the jacobian (dphi / dx ).
c     Note that this matrix is tridiagonal.
c     The jacobian is inverted in the Newton iteration and
c     in calculating dX/drlambd and dX/dalambd.
c...................................................................
      real        alambd,      subdj(*),     dj(*),    supdj(*)
      integer     maxn,        maxnp1,       maxnp3
      parameter ( maxn   = 50)
      parameter ( maxnp1 = maxn + 1,
     :            maxnp3 = maxn + 3)
      real        f(0:maxnp1),     df(maxn),      ddf(maxn),
     :            c(0:maxnp1),     d(maxnp1),
     :            deltac(maxnp1),  deltaf(maxnp1),
     :            deltax(maxnp1),  deltaz(maxnp1),
     :            v(maxnp1)
      integer     n
      common /b/  f,               df,            ddf,
     :            c,               d,
     :            deltac,          deltaf,
     :            deltax,          deltaz,
     :            v,
     :            n
c...................................................................
cc    local variables
c     K     loop variable
c...................................................................
      integer     k
c
c     Calculating the diagonal.
c
      do 100  k = 1, n
         dj(k) = v(k+1) * ( 1.0 + ( alambd * df(k) )**2 +
     :	       alambd*deltaz(k)*ddf(k)-((deltax(k)+alambd*df(k)
     :	       *deltaz(k))/d(k))**2)/d(k)+v(k)*(1.0+(alambd*df(k))**2 
     :	       -alambd*deltaz(k+1)*ddf(k)-((deltax(k+1)+alambd*df(k)
     :	       *deltaz(k+1))/d(k+1))**2)/d(k+1)
100   continue
      if(n.eq.1) go to 500
c
c     Calculating the subdiagonal
c
      do 200  k = 2, n
         subdj(k) = - v(k+1)*(1.0+(alambd**2)*df(k)*df(k-1) 
     :	          -(deltax(k)+alambd*df(k)*deltaz(k))*
     :		  (deltax(k)+alambd*df(k-1)*deltaz(k))/d(k)**2)/d(k)
200   continue
c
c     Calculating the superdiagonal
c
      do 300  k = 1, n-1
         supdj(k) = - v(k)*(1.0+(alambd**2)*df(k)*df(k+1)
     :		  -(deltax(k+1)+alambd*df(k)*deltaz(k+1))*
     :		  (deltax(k+1)+alambd*df(k+1)*deltaz(k+1))/
     :		  d(k+1)**2 ) / d(k+1)
300   continue
500   return
      end
cc--------------------------------------------------------------------
c       subroutine line(xarry,yarry,npnts)
cc...................................................................
cc
c        real xarry(npnts+2),yarry(npnts+2)
c        integer npnts,i,k
c        real xarry2(1000),yarry2(1000)
cc
cc       scale the data into the window
cc
c        do 1000  k=1,npnts
c            xarry2(k) = xarry(k)/xarry(npnts+2) 
c            yarry2(k) = yarry(k)/yarry(npnts+2) 
c1000    continue        
cc
c        call  umove(xarry2(1),yarry2(1))
c        do 100 i=2,npnts
c                call  udraw(xarry2(i),yarry2(i))
c100     continue
c        return
c        end

c------------------------------------------------------------------
        subroutine magnitude(angles,angler,gradtau2)
c...................................................................
c    this subroutine is to determine the magnitude of the sum of
c    the two slowness vectors at the output points.
c...................................................................
        real angles, angler, gradtau2, root2
c
        root2=sqrt(2.)
        gradtau2=root2*sqrt(1.+cos(angles-angler))/2.
c       write(0,*)"gradtau2=",gradtau2
        return
        end
c...................................................................
      subroutine newton(x,n,alambd,resid,fail)
c.......................................................................
c     Carries out the newton iteration for the continuation
c     procedures RAYONE and RECCON.
c.......................................................................
      integer    n
      real       x(0:n+1),    alambd,     resid
      logical    fail
c.......................................................................
cc    local    variables
c     DJ()     diagonal of the tridiagonal jacobian matrix
c     INFO     tells us if the jacobian is singular
c     K        loop variable
c     MAXN     max value of N
c     PHI()    system of equations to be solved
c     SPLNOK   tells us if X lies within range of the interfaces
c     SUBDJ()  subdiagonal of tridiagonal jacobian matrix
c     SUM      sum of squares of PHI
c     SUPDJ    superdiagonal of tridiagonal jacobian matrix
c.......................................................................
      integer   k,     maxn,     info
      parameter ( maxn = 50)
      real      subdj(maxn),    dj(maxn),
     :          supdj(maxn),    phi(maxn),
     :          sum
      logical splnok
c
      fail = .false.
c     Evaluate frequently used quantities.
      call eval(x,alambd,splnok)
c
c     If X outside range of splined interfaces, return.
      if(.not.splnok) then
         fail = .true.
         return
      end if
c
c     Evaluate the elements of the tridiagonal jacobian.
      call jacob(alambd,subdj,dj,supdj)
c
c     Evaluate phi.
      call dophi(phi,alambd)
c     Do the Newton iteration.
      if(n.eq.1) then
          x(1) = x(1) - phi(1) / dj(1)
      else
          call tridi(n,subdj,dj,supdj,phi,info)
          if(info.ne.0) then
             fail = .true.
             return
          end if
c         Tridi solves the matrix equation jx = phi for x.
c         The solution, x, is returned as the vector phi .
          do 100  k = 1,  n
             x(k) = x(k) - phi(k)
100       continue
      end if
c
c     Evaluate necessary quantities with new value of X
c     from the Newton iteration.
c
      call eval(x,alambd,splnok)
c     New X has to lie within range of splined interfaces.
      if(.not.splnok) then
         fail = .true.
         return
      end if
c     Evaluating PHI again.
      call dophi(phi,alambd)
c     Finding the l2 norm of phi.
      sum = 0.0
      do 200  k = 1,  n
         sum = sum + phi(k)**2
200   continue
      resid = sqrt( sum )
      return
      end
c...................................................................
      subroutine plasol(n,xr,xs,zs,c,v,x,noconv)
c...........................................................................
c     Plasol finds the coordinates of the ray in the stratified
c     medium. it follows the procedure outlined in appendix a of
c     John Fawcett's thesis ( 3D Ray Tracing and Ray inversion
c     in Layered Media, Caltech, 1983).
c...........................................................................
      integer     n
      real        xr,      xs,       zs,    c(0:n+1),
     :            v(n+1),  x(0:n+1)
      logical     noconv
c...........................................................................
cc    Local    variables
c     A()      ratio of layer velocity to velocity in layer one
c     AMIN     largest value of sin(takeoff angle) - one over
c              maximum value of A.
c     CLOSE    a measure of how close ray is to receiver
c     DELTAX   change in sin(takeoff angle)- see reference above
c     DFDX     derivative of x distance travelled
c     DIST     distance between source and end of ray
c     FX       function that calculates the distance travelled (DIST)
c              by the ray
c     IBIS     counts number of bisections
c     I        loop variable
c     K        loop variable
c     INEWT    counts number of newton iterations
c     IBIS     counts number of bisections
c     INTVAL   number of intervals to divide range of values 
c              of sine of takeoff angle
c     MAXBIS   maximum allowed number of bisections
c     MAXNP1   maximum value of N plus one
c     MAXNWT   maximum allowed number of newton iterations
c     NP1      N plus one
c     OFFSET   distance (positive) between source and receiver
c     SIGN     + or - one, depending on receiver location
c     THICK()  thickness of layers
c     VCLOSE   if the ray is this close to the receiver then
c              we've found the solution.
c     VMAX     maximum layer velocity
c     X1,X2    values of sin(takeoff angle) used in bisection
c     XNEW     next value to use in bisection or newton iteration
c...........................................................................
      integer  maxnp1
      parameter( maxnp1 = 51)
      real     a(maxnp1),    thick(maxnp1)
      real     fx
      real     amin,         close,     deltax,
     :         dfdx,         dist,      offset,     sign,
     :         vclose,       vmax,
     :         x1,           x2,        xnew
      parameter (  close = 10.,
     :            vclose = 1. )
      integer  i,            inewt,     intval,     maxbis,
     :         maxnwt,       ibis,      np1,        k
      parameter ( maxbis = 100,
     :            maxnwt  = 100,
     :            intval = 10 )
c
      noconv = .false.
      np1 = n + 1
c     initialize the iteration counters
      ibis = 0
      inewt = 0
c
c     The depths of the interfaces at the x coordinate of the source
c     are supplied by the main program. C(1) is the shallowest, etc.
c     Calculate the layer thicknesses from depths.
c
      thick(1) = c(1)
      do 30 i = 2, n
         thick(i) = c(i) - c(i-1)
30    continue
c     Bottom of last layer set at depth of source.
      thick(np1) = zs - c(n)
c     If receiver is above source then all x coordinates are equal.
      if(xr.eq.xs) then
         do 40  i = 0,  np1
            x(i) = xr
40       continue
         return
      end if
c
c     Setting alpha (in Fawcett's thesis).
c
      a(1) = 1.
      do 50 i = 2,  np1
         a(i) = v(i) / v(1)
50    continue
c     Find the maximum velocity.
      vmax = v(1)
      do 60 i = 2,  np1
         if(vmax.lt.v(i)) then
            vmax = v(i)
         end if
60    continue
c
c     Setting minimum of 1 / alpha
c
      amin = v(1) / vmax
      offset = abs( xs - xr )
c     Divide up the interval.
      deltax = amin / intval
c     Find part of interval on which solution lies.
      x2 = deltax
      dist = fx(x2,a,thick,np1)
      i = 2
80    if(dist.lt.offset.and.i.lt.intval) then    
         x2 = x2 + deltax
         dist = fx(x2,a,thick,np1)
         i  = i + 1
         go to 80
      end if
      if(dist.lt.offset) then
c        X lies inside last interval.
         x2 = .9999 * amin
         dist = fx(x2,a,thick,np1)
         if(dist.lt.offset) then
c           ray is too close to grazing
            noconv = .true.
            return
         end if
      end if
      x1 = ( i - 2 ) * deltax
c
c     Use bisection to get close.
c
      if(abs(dist-offset).lt.close) then
c        ??????
      else
         xnew =  ( x2 + x1 ) / 2.
         dist = fx(xnew,a,thick,np1)
100      if(abs(dist-offset).lt.close) then
         else
            ibis = ibis + 1
            if(ibis.gt.maxbis) then
               noconv = .true.
               return
            end if
            if((dist-offset).lt.0.) then
               x1 = xnew
            else
               x2 = xnew
            end if
            xnew =  ( x2 + x1 ) / 2.
            dist = fx(xnew,a,thick,np1)
            go to 100
        end if
      end if
c
c     Use newton's method to get very close.
c
140   if(abs(dist-offset).le.vclose) then
c        ???????
      else
         inewt = inewt + 1
         if(inewt.gt.maxnwt) then
            noconv = .true.
            return
         end if
         dfdx = 0.0
         do 150 k = 1,  np1
            dfdx = dfdx+thick(k)*a(k)/(1-(a(k)*xnew)**2)**1.5
150      continue
         xnew = xnew - ( dist - offset ) / dfdx
c
         do 160 k = 1,  np1
            if(abs(a(k)*xnew).ge.1.0) then
c              Newton's method can be unpredictable.
c              If the above product is greater than 1., we
c              get into trouble with square roots below.
               noconv = .true.
               return
            end if
160      continue
         dist = fx(xnew,a,thick,np1)
         go to 140
      end if
c
      if((xs-xr).lt.0.) then 
         sign = - 1.0
      else
         sign = 1.0
      end if
c
      x(1) = xr + sign * thick(1) * a(1) * xnew /
     :       sqrt( 1. - ( a(1) * xnew )**2 )
      do 200 i = 2,  n
         x(i) = x(i-1) + sign * thick(i) * a(i) * xnew /
     :          sqrt( 1. - ( a(i) * xnew )**2 )
200   continue
      x(np1) = xs
      x(0)   = xr
      return
      end
c-----------------------------------------------------------------
      subroutine rayone(xr,xs,zs,n,v,c,x,noconv)
c.......................................................................
c     This subroutine performs continuation in interfaces
c     Starting with a stratified earth, subroutine rayone deforms the
c     interfaces, using the continuation parameter alambd, until the
c     desired model is achieved.
c.......................................................................
cc    local    variables
c     ALAMBD   continuation parameter
c     DELTAL   increment in continuation parameter
c     DXDL()   derivative of X w.r.t. ALAMBD
c     EPS      lower limit on DELTAL
c     FAIL     true when Newton's method breaks down
c     I        counts the number of Newton iterations
c     INFO     indicates if jacobian is singular
c     K        loop variable
c     MAXIT    maximum number of newton iterations at each
c              continuation step
c     MAXN     max allowed value of N
c     RESID    residual of the system of equations to be solved
c     SAVEX()  stores solution of last continuation step
c     SOLN     residual must fall below this for a solution
c     SPLNOK   indicates whether X is within range of splined interfaces
c.......................................................................
      integer     n
      real        xr,        xs,           zs,
     :            v(n+1),    c(0:n+1),     x(0:n+1)
      logical     noconv
c
      integer   i,   info,   k,   maxit,    maxn
      parameter ( maxit = 6,
     :            maxn  = 50)
      real      savex(maxn+1),    dxdl(maxn),
     :          deltal,           eps,
     :          resid,            alambd,
     :          soln
      logical   fail,             splnok
      parameter ( eps  = 0.065)
c
c     Initialising some variables.
c
      soln   = v(1)*0.005
      noconv = .false.
      alambd = 0.0
      deltal = 1.0
c
c     Finding the flat earth solution.
c
      call plasol(n,xr,xs,zs,c,v,x,noconv)
      if(noconv) return
c
c     Evaluate some frequently used quantities for a known solution.
c
      call eval(x,alambd,splnok)
c
c     Finding the derivative of x with respect to alambd.
c
50    call dxdlam(x,alambd,dxdl,info)
      if(info.ne.0) then
	 noconv = .true.
         return
      end if
c
c     Save the value of X.  If Newton's method fails to converge
c     we will return to this value and reduce the continuation step.
c
      do 75  k = 1, n
         savex(k) = x(k)
75    continue
c
c     Calculate the first guess to be put into Newton's method.
c
      call guessx(x,n,deltal,dxdl)
c     Increment the continuation parameter.
      alambd = alambd + deltal
c
c     Start the Newton iterations.
c     After each iteration we check to see if the
c     iteration has been carried out successfully, and 
c     if so, check to see if it has found a solution.
c
      i = 0
      call newton(x,n,alambd,resid,fail)
100   if(fail.or.resid.gt.soln) then
         i = i + 1
         if(.not.fail.and.i.lt.maxit) then
            call newton(x,n,alambd,resid,fail)
         else
c           Newton has failed.  Reduce the continuation step.
            alambd = alambd - deltal
            deltal = deltal / 2.0
c
c           If deltal is not too small, return to the previous 
c           solution and proceed with the continuation.
c
            if(deltal.gt.eps) then
               do 150  k = 1,  n
                  x(k) = savex(k)
150            continue
               call guessx(x,n,deltal,dxdl)
               alambd = alambd + deltal
c              reset the iteration counter
               i = 0
               call newton(x,n,alambd,resid,fail)
            else
c              The continuation procedure has failed.
               noconv = .true.
               return
            end if
         end if
         go to 100
      end if
c     Continuation is not done until ALAMBD = 1.
      if(alambd.lt.1.0) go to 50
      return
      end
c-----------------------------------------------------------------
      subroutine reccon(x,n,xr,geoinc,v1,noconv)
c.................................................................
c     This subroutine performs receiver continuation.
c     Using a ray from some source to receiver, subroutine reccon
c     finds the ray from that same source position to an adjacent
c     receiver. The continuation parameter is rlambd.
c.................................................................
      integer    n
      real       x(0:n+1),    xr,    geoinc,	v1
      logical    noconv
c.................................................................
cc    local    variables
c     DELTAL   increment in continuation parameter
c     DXDL()   derivative of X r.r.t. RLAMBD
c     EPS      lower limit on DELTAL
c     FAIL     true when Newton's method breaks down
c     I        counts the number of Newton iterations
c     INFO     indicates if jacobian is singular
c     K        loop variable
c     MAXIT    maximum number of newton iterations at each
c              continuation step
c     MAXN     max allowed value of N
c     RESID    residual of the system of equations to be solved
c     RLAMBD   continuation parameter
c     SAVEX()  stores solution of last continuation step
c     SOLN     residual must fall below this for a solution
c.................................................................
      integer   i,   info,   k,   maxit,    maxn
      parameter ( maxit = 6,
     :            maxn  = 50)
      real      savex(maxn+1),    dxdl(maxn),
     :          deltal,           eps,
     :          resid,            rlambd,
     :          soln
      logical   fail
      parameter ( eps  = 0.065)
c
c     Initialise some variables.
c
      soln = v1*0.005
      noconv = .false.
      deltal = 1.0
      rlambd = 0.0
c     Finding the derivative of x with respect to rlambd.
50    call dxdrl(geoinc,dxdl,info)
      if(info.ne.0) then
         noconv = .true.
         return
      end if
c
c     Save the value of X.  If Newton's method fails to converge
c     we will return to this value and reduce the continuation step.
c
      do 75  k = 1, n
         savex(k) = x(k)
75    continue
c     Calculate the first guess to put in Newton's method.
      call guessx(x,n,deltal,dxdl)
c     Increment the continuation parameter and the end point of the ray.
      rlambd = rlambd + deltal
      x(0) = xr + geoinc * rlambd
c
c     Start the Newton iterations.
c     After each iteration we check to see if the
c     iteration has been carried out successfully, and
c     if so, check to see if it has found a solution.
c
      i = 0
c     Since the interfaces are now fixed in their true positions,
c     we set ALAMBD equal to one.
      call newton(x,n,1.,resid,fail)
100   if(fail.or.resid.gt.soln) then
         i = i + 1
         if(.not.fail.and.i.lt.maxit) then
            call newton(x,n,1.,resid,fail)
         else
c           Newton has failed.  Reduce the continuation step.
            rlambd = rlambd - deltal
            deltal = deltal / 2.0
c           If deltal is not too small, return to the previous
c           solution and proceed with the continuation.
            if(deltal.gt.eps) then
               do 150 k = 1,  n
                  x(k) = savex(k)
150            continue
               call guessx(x,n,deltal,dxdl)
               rlambd = rlambd + deltal
               x(0) = xr + geoinc * rlambd
c              reset the iteration counter
               i = 0
               call newton(x,n,1.,resid,fail)
            else
c              The continuation procedure has failed.
               noconv = .true.
               return
            end if
         end if
         go to 100
      end if
c     Continuation is not done until RLAMBD = 1.
      if(rlambd.lt.1.0) go to 50
c     Updating the receiver position
      xr = xr + geoinc
      return
      end
c---------------------------------------------------------------------
      subroutine setn(zs,c,nint,n,znear,deltac,f)
c.......................................................................
c     The number of interfaces between source and receiver
c     may change when the depth of the source changes,
c     ( ie the source passes through an interface ).
c     Setn finds the number of interfaces between source
c     and receiver, and evaluates a few other things
c     that remain constant until the source is moved again.
c.......................................................................
      integer    n,          nint
      real       c(0:n+1),   f(0:n+1),     deltac(n+1),
     :           zs
c.......................................................................
cc    local   variables
c     I       loop variable
c     ZNEAR   If the source point is below the interface but less
c             than ZNEAR vertical distance from it, then the interface
c             is ignored. ZNEAR = LAMDA/4. = Cmax/Fmax/4.
c.......................................................................
      integer    i
      real       znear
c
c     Calculating the number of interfaces between source and receiver
c     for the direct ray.  If the source is on or just below the
c     interface then the interface is ignored.
c
      do 20 i = 1,  nint
         if(zs.le.(c(i)+znear)) then
            n = i - 1
            go to 25
         end if
20    continue
      n = nint
25    continue
c
c     Setting values at the end of the ray.
      f(n+1) = 0.
      deltac(n+1) = zs - c(n)
      do 40 i = 1,  n
         deltac(i) = c(i) - c(i-1)
40    continue
50    return
      end
c...................................................................
      subroutine strat(xs,c,exit)
c........................................................................
c     Each time the source is moved it is necessary to 
c     calculate the depths of the interfaces in the horizontally
c     stratified model.
c........................................................................
      real        xs,          c(0:*)
      logical     exit
      integer     maxn,        maxspl,      mxspm1
      parameter ( maxn   = 50,
     :            maxspl = 151)
      parameter ( mxspm1 = maxspl - 1)
      real        xint(maxn,maxspl),        zint(maxn,maxspl),
     :            a0(maxn,mxspm1),          a1(maxn,mxspm1),
     :            a2(maxn,mxspm1),          a3(maxn,mxspm1)
      integer     npts(maxn),    nint
      common /a/  xint,          zint,
     :            a0,            a1,        a2,         a3,
     :            npts,          nint
c........................................................................
cc    local   variables
c     I       loop variable over interfaces
c     J       identifies section of interface
c........................................................................
      integer    i,             j
c
c     Finding the depth of each interface at the
c     x coordinate of the source.  The shallowest depth is c(1)
c     and c(nint) is the deepest. These depths will be used 
c     in the stratified model.
c
      do 10 i = 1,  nint
         if(xs.lt.xint(i,1).or.xs.ge.xint(i,npts(i))) then
            exit = .true.
            return
         end if
         j = 1
5        if(xs.ge.xint(i,j)) then
            j = j + 1
            go to 5
         end if
         j = j - 1
         c(i) = a0(i,j) + a1(i,j) * xs + a2(i,j) * xs**2
     :            + a3(i,j) * xs**3
10    continue
c
      return
      end
c...................................................................
      subroutine tridi(n,c,d,e,b,info)
c...................................................................
c     Tridi solves the equation JX = B for X.  J is the tridiagonal
c     jacobian whose bands here are C (subdiagonal), D (diagonal),
c     and E (superdiagonal). The solution is returned as B.
c     The code is from a LINPAK listing.
c
c     REFERENCE : LINPACK USER'S GUIDE,  J.J. DONGARRA et al,
c                 SIAM, 1979.
c...................................................................
      integer    n,      info
      real       c(n),   d(n),    e(n),    b(n)
      integer    k,      kb,      kp1,     nm1,     nm2
      real       t
c
      info = 0
      c(1) = d(1)
      nm1 = n - 1
      if(nm1.lt.1) go to 40
         d(1) = e(1)
         e(1) = 0.0e0
         e(n) = 0.0e0
c
         do 30  k = 1,  nm1
            kp1 = k + 1
            if(abs(c(kp1)).lt.abs(c(k))) go to 10
               t = c(kp1)
               c(kp1) = c(k)
               c(k) = t
               t = d(kp1)
               d(kp1) = d(k)
               d(k) = t
               t = e(kp1)
               e(kp1) = e(k)
               e(k) = t
               t = b(kp1)
               b(kp1) = b(k)
               b(k) = t
10          continue
c
            if(c(k).ne.0.0e0) go to 20
               info = k
               go to 100
20          continue
c
            t = -c(kp1)/c(k)
            c(kp1) = d(kp1) + t*d(k)
            d(kp1) = e(kp1) + t*e(k)
            e(kp1) = 0.0e0
            b(kp1) = b(kp1) + t*b(k)
30       continue
40    continue
c
      if(c(n).ne.0.0e0) go to 50
         info = n
         go to 90
50    continue
c
      nm2 = n - 2
      b(n) = b(n)/c(n)
      if(n.eq.1) go to 80
         b(nm1) = (b(nm1) - d(nm1)*b(n))/c(nm1)
         if(nm2.lt.1) go to 70
            do 60  kb = 1,  nm2
               k = nm2 - kb + 1
               b(k) = (b(k) - d(k)*b(k+1) - e(k)*b(k+2))/c(k)
60          continue
70       continue
80    continue
90    continue
100   continue
      return
      end
c-------------------------------------------------------------------
      subroutine ttime(d,v,n,time)
c...................................................................
c     Calculates the traveltime along a ray.
c...................................................................
      integer    n
      real       d(n+1),      v(n+1),       time
c...................................................................
cc    local  variables
c     K      loop variable
c...................................................................
      integer    k
c
      time = 0.0
      do 100 k = 1, n + 1
         time  = time  + d(k) / v(k)
100   continue
c
      return
      end
@
