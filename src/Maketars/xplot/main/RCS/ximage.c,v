head	1.47;
access;
symbols;
locks
	john:1.47; strict;
comment	@ * @;


1.47
date	2011.11.21.17.03.51;	author john;	state Exp;
branches;
next	1.46;

1.46
date	2011.11.21.17.03.15;	author john;	state Exp;
branches;
next	1.45;

1.45
date	2011.11.12.00.48.17;	author john;	state Exp;
branches;
next	1.44;

1.44
date	2011.09.09.22.36.52;	author john;	state Exp;
branches;
next	1.43;

1.43
date	2005.10.04.17.28.06;	author john;	state Exp;
branches;
next	1.42;

1.42
date	2005.10.04.16.56.08;	author john;	state Exp;
branches;
next	1.41;

1.41
date	2005.10.04.16.50.24;	author john;	state Exp;
branches;
next	1.40;

1.40
date	2005.03.21.18.03.03;	author john;	state Exp;
branches;
next	1.39;

1.39
date	2005.02.02.00.12.31;	author john;	state Exp;
branches;
next	1.38;

1.38
date	2004.12.24.19.04.53;	author john;	state Exp;
branches;
next	1.37;

1.37
date	99.02.18.18.14.56;	author john;	state Exp;
branches;
next	1.36;

1.36
date	99.01.11.22.23.03;	author john;	state Exp;
branches;
next	1.35;

1.35
date	97.07.29.15.42.44;	author john;	state Exp;
branches;
next	1.34;

1.34
date	96.10.16.15.54.29;	author john;	state Exp;
branches;
next	1.33;

1.33
date	96.10.04.15.03.21;	author john;	state Exp;
branches;
next	1.32;

1.32
date	96.10.02.21.45.50;	author john;	state Exp;
branches;
next	1.31;

1.31
date	96.10.02.17.02.41;	author john;	state Exp;
branches;
next	1.30;

1.30
date	96.09.26.16.28.38;	author john;	state Exp;
branches;
next	1.29;

1.29
date	96.09.25.17.01.30;	author john;	state Exp;
branches;
next	1.28;

1.28
date	96.09.23.20.01.28;	author jkc;	state Exp;
branches;
next	1.27;

1.27
date	96.09.09.19.36.09;	author john;	state Exp;
branches;
next	1.26;

1.26
date	96.07.01.16.00.29;	author jkc;	state Exp;
branches;
next	1.25;

1.25
date	96.06.27.22.00.50;	author jkc;	state Exp;
branches;
next	1.24;

1.24
date	96.06.27.21.47.13;	author jkc;	state Exp;
branches;
next	1.23;

1.23
date	96.04.09.19.29.19;	author jkc;	state Exp;
branches;
next	1.22;

1.22
date	96.02.27.20.21.48;	author jkc;	state Exp;
branches;
next	1.21;

1.21
date	96.02.09.15.54.13;	author jkc;	state Exp;
branches;
next	1.20;

1.20
date	95.09.14.15.22.00;	author jkc;	state Exp;
branches;
next	1.19;

1.19
date	95.09.06.18.23.30;	author jkc;	state Exp;
branches;
next	1.18;

1.18
date	95.08.30.18.52.09;	author jkc;	state Exp;
branches;
next	1.17;

1.17
date	95.07.31.14.07.40;	author jkcohen;	state Exp;
branches;
next	1.16;

1.16
date	95.07.31.14.05.48;	author jkcohen;	state Exp;
branches;
next	1.15;

1.15
date	93.08.13.10.08.41;	author jstockwe;	state Exp;
branches;
next	1.14;

1.14
date	93.06.16.14.07.36;	author jstockwe;	state Exp;
branches;
next	1.13;

1.13
date	92.10.29.15.13.21;	author jstockwe;	state Exp;
branches;
next	1.12;

1.12
date	92.09.02.13.43.48;	author cartley;	state Exp;
branches;
next	1.11;

1.11
date	91.03.28.12.44.27;	author jkcohen;	state Exp;
branches;
next	1.10;

1.10
date	91.02.12.14.35.28;	author jkcohen;	state Exp;
branches;
next	1.9;

1.9
date	91.02.05.10.36.47;	author jkc;	state Exp;
branches;
next	1.8;

1.8
date	91.02.05.10.19.15;	author dhale;	state Exp;
branches;
next	1.7;

1.7
date	90.10.27.12.17.51;	author dhale;	state Exp;
branches;
next	1.6;

1.6
date	90.10.24.19.04.40;	author dhale;	state Exp;
branches;
next	1.5;

1.5
date	90.10.01.18.25.01;	author dhale;	state Exp;
branches;
next	1.4;

1.4
date	90.08.11.13.36.13;	author dhale;	state Exp;
branches;
next	1.3;

1.3
date	90.06.14.13.45.24;	author dhale;	state Exp;
branches;
next	1.2;

1.2
date	90.06.08.15.05.02;	author dhale;	state Exp;
branches;
next	1.1;

1.1
date	90.05.25.15.09.38;	author dhale;	state Exp;
branches;
next	;


desc
@plot image via X
@


1.47
log
@Reg Beardsley's checkpars()
@
text
@/* Copyright (c) Colorado School of Mines, 2011.*/
/* All rights reserved.                       */

/* XIMAGE: $Revision: 1.44 $ ; $Date: 2011/09/09 22:36:52 $	*/

#include "par.h"
#include "xplot.h"
#include <X11/Xatom.h>
#include <X11/keysym.h>

/* ZM: interpolate the amplitude from dataset */
float getamp(float *zz,float f1,float d1,int n1,
             float f2,float d2,int n2,float x1,float x2,int verbose);

/*********************** self documentation **********************/
char *sdoc[] = {
"									",
" XIMAGE - X IMAGE plot of a uniformly-sampled function f(x1,x2)     	",
"									",
" ximage n1= [optional parameters] <binaryfile			        ",
"									",
" X Functionality:							",
" Button 1	Zoom with rubberband box				",
" Button 2	Show mouse (x1,x2) coordinates while pressed		",
" q or Q key	Quit							",
" s key		Save current mouse (x1,x2) location to file		",
" p or P key	Plot current window with pswigb (only from disk files)	",
" a or page up keys		enhance clipping by 10%			",
" c or page down keys		reduce clipping by 10%			",
" up,down,left,right keys	move zoom window by half width/height	",
" i or +(keypad) 		zoom in by factor 2 			",
" o or -(keypad) 		zoom out by factor 2 			",
"									",
" ... change colormap interactively					",
" r	     install next RGB - colormap				",
" R	     install previous RGB - colormap				",
" h	     install next HSV - colormap				",
" H	     install previous HSV - colormap				",
" H	     install previous HSV - colormap				",
" (Move mouse cursor out and back into window for r,R,h,H to take effect)",
" 									",
" Required Parameters:							",
" n1			 number of samples in 1st (fast) dimension	",
"									",
" Optional Parameters:							",
" d1=1.0		 sampling interval in 1st dimension		",
" f1=0.0		 first sample in 1st dimension			",
" n2=all		 number of samples in 2nd (slow) dimension	",
" d2=1.0		 sampling interval in 2nd dimension		",
" f2=0.0		 first sample in 2nd dimension			",
" mpicks=/dev/tty	 file to save mouse picks in			",
" perc=100.0		 percentile used to determine clip		",
" clip=(perc percentile) clip used to determine bclip and wclip		",
" bperc=perc		 percentile for determining black clip value	",
" wperc=100.0-perc	 percentile for determining white clip value	",
" bclip=clip		 data values outside of [bclip,wclip] are clipped",
" wclip=-clip		 data values outside of [bclip,wclip] are clipped",
" balance=0		 bclip & wclip individually			",
"			 =1 set them to the same abs value		",
"			   if specified via perc (avoids colorbar skew)	",
" cmap=hsv\'n\' or rgb\'m\'	\'n\' is a number from 0 to 13		",
"				\'m\' is a number from 0 to 11		",
"				cmap=rgb0 is equal to cmap=gray		",
"				cmap=hsv1 is equal to cmap=hue		",
"				(compatibility to older versions)	",
" legend=0	        =1 display the color scale			",
" units=		unit label for legend				",
" legendfont=times_roman10    font name for title			",
" verbose=1		=1 for info printed on stderr (0 for no info)	",
" xbox=50		x in pixels of upper left corner of window	",
" ybox=50		y in pixels of upper left corner of window	",
" wbox=550		width in pixels of window			",
" hbox=700		height in pixels of window			",
" lwidth=16		colorscale (legend) width in pixels		",
" lheight=hbox/3	colorscale (legend) height in pixels		",
" lx=3			colorscale (legend) x-position in pixels	",
" ly=(hbox-lheight)/3   colorscale (legend) y-position in pixels	",
" x1beg=x1min		value at which axis 1 begins			",
" x1end=x1max		value at which axis 1 ends			",
" d1num=0.0		numbered tic interval on axis 1 (0.0 for automatic)",
" f1num=x1min		first numbered tic on axis 1 (used if d1num not 0.0)",
" n1tic=1		number of tics per numbered tic on axis 1	",
" grid1=none		grid lines on axis 1 - none, dot, dash, or solid",
" label1=		label on axis 1					",
" x2beg=x2min		value at which axis 2 begins			",
" x2end=x2max		value at which axis 2 ends			",
" d2num=0.0		numbered tic interval on axis 2 (0.0 for automatic)",
" f2num=x2min		first numbered tic on axis 2 (used if d2num not 0.0)",
" n2tic=1		number of tics per numbered tic on axis 2	",
" grid2=none		grid lines on axis 2 - none, dot, dash, or solid",
" label2=		label on axis 2					",
" labelfont=Erg14	font name for axes labels			",
" title=		title of plot					",
" titlefont=Rom22	font name for title				",
" windowtitle=ximage	title on window					",
" labelcolor=blue	color for axes labels				",
" titlecolor=red	color for title					",
" gridcolor=blue	color for grid lines				",
" style=seismic	        normal (axis 1 horizontal, axis 2 vertical) or  ",
"			seismic (axis 1 vertical, axis 2 horizontal)	",
" blank=0		This indicates what portion of the lower range  ",
"			to blank out (make the background color).  The  ",
"			value should range from 0 to 1.			",
" plotfile=plotfile.ps  filename for interactive ploting (P)  		",
" curve=curve1,curve2,...  file(s) containing points to draw curve(s)   ",
" npair=n1,n2,n2,...            number(s) of pairs in each file         ",
" curvecolor=color1,color2,...  color(s) for curve(s)                   ",
" blockinterp=0       whether to use block interpolation (0=no, 1=yes)  ",
"									",
"									",
" NOTES:								",
" The curve file is an ascii file with the points  specified as x1 x2	",
" pairs separated by a space, one pair to a line.  A \"vector\" of curve",
" files and curve colors may be specified as curvefile=file1,file2,etc. ",
" and curvecolor=color1,color2,etc, and the number of pairs of values   ",
" in each file as npair=npair1,npair2,... .                             ",
"									",
NULL};
/*
 * AUTHOR:  Dave Hale, Colorado School of Mines, 08/09/90
 *
 * Stewart A. Levin, Mobil - Added ps print option
 *
 * Brian Zook, Southwest Research Institute, 6/27/96, added blank option
 *
 * Toralf Foerster, Baltic Sea Research Institute, 9/15/96, new colormaps
 *
 * Berend Scheffers, Delft, colorbar (legend)
 *
 * Brian K. Macy, Phillips Petroleum, 11/27/98, added curve plotting option
 * 
 * G.Klein, GEOMAR Kiel, 2004-03-12, added cursor scrolling and
 *                                   interactive change of zoom and clipping.
 * 
 * Zhaobo Meng, ConocoPhillips, 12/02/04, added amplitude display
 * 
 * Garry Perratt, Geocon, 08/04/05, modified perc handling to center colorbar if balance==1.
 */
/**************** end self doc ********************************/

/* functions defined and used internally */
static void zoomBox (int x, int y, int w, int h, 
	int xb, int yb, int wb, int hb,
	int nx, int ix, float x1, float x2,
	int ny, int iy, float y1, float y2,
	int *nxb, int *ixb, float *x1b, float *x2b,
	int *nyb, int *iby, float *y1b, float *y2b);
static unsigned char *newInterpBytes (int n1in, int n2in, unsigned char *bin,
	int n1out, int n2out, int newInterpBytes);
void xMouseLoc(Display *dpy, Window win, XEvent event, int style, Bool show,
	int x, int y, int width, int height,
	float x1begb, float x1endb, float x2begb, float x2endb,
        float *z, float f1, float d1, int n1,float f2, float d2, 
        int n2, int verbose);
void xMousePrint(XEvent event, int style, FILE *mpicksfp,
	int x, int y, int width, int height,
	float x1begb, float x1endb, float x2begb, float x2endb);
/* JG... */
void intl2b_block(int nxin, float dxin, float fxin,
				  int nyin, float dyin, float fyin, unsigned char *zin,
				  int nxout, float dxout, float fxout,
				  int nyout, float dyout, float fyout, unsigned char *zout);
/* .... JG */

int
main (int argc,char **argv)
{
	int n1,n2,n1tic,n2tic,
		i1,i2,grid1,grid2,style,
		n1c,n2c,i1beg,i1end,i2beg,i2end,i1c,i2c,
		nz,iz,i1step,i2step,verbose,
		xbox,ybox,wbox,hbox,
		xb,yb,wb,hb,
		x,y,width,height,
		i,j,nx,ny,nxb,nyb,ixb,iyb,
		imageOutOfDate,winwidth=-1,winheight=-1,
		showloc=0,
		balance,
		legend,lwidth,lheight,lx,ly; /* BEREND */

	int blockinterp=0; /* JG */
        int base;
        float fact;
        unsigned char* ptr;

	unsigned long nfloats;
	float labelsize,titlesize,perc,clip,bperc,wperc,bclip,wclip,
		d1,f1,d2,f2,*z,*temp,zscale,zoffset,zi,dx,dy,
		x1beg,x1end,x2beg,x2end,
		x1min,x1max,x2min,x2max,
		d1num,f1num,d2num,f2num,
		x1begb,x1endb,x2begb,x2endb,blank; /* dx,dy added GK */

	unsigned char *cz,*czp,*czb,*czbp,*czbi=NULL;
	char *label1="",*label2="",*title="",*windowtitle="ximage",
		*units="", *legendfont="times_roman10",
		*labelfont="Erg14",*titlefont="Rom22",
		*styles="seismic",*grid1s="none",*grid2s="none",
		*labelcolor="blue",*titlecolor="red",
		*gridcolor="blue",*cmap="",keybuf[256],*mpicks;
	FILE *infp=stdin, *mpicksfp;
	Display *dpy;
	Window win;
	XEvent event;
	KeySym keysym;
	XComposeStatus keystat;
	XImage *image=NULL;
	XImage *image_legend=NULL; /* BEREND */
	unsigned char *data_legend; /* BEREND */
	GC gci;
	int scr;
	unsigned long black,white,pmin,pmax;

        float **x1curve,**x2curve;
        int curve,*npair,ncurvecolor;
        char **curvefile,**curvecolor=NULL;
        FILE *curvefp;
	
	char *plotfile;         /* filename of plotfile GK */
	int lock=0;		/* lock/unlock zoom while scrolling */
	float mve;		/* distance for scrolling */
	float mvefac=8.;	/* window factor for scrolldistance 
	                         * 2=half window size; 
				 * 8=one eighths of the window size */
	char  *msg="";		/* message on screen */

	/* initialize getpar */
	initargs(argc,argv);
	requestdoc(1);

	/* get parameters describing 1st dimension sampling */
	if (!getparint("n1",&n1))
		err("Must specify number of samples in 1st dimension!\n");
	d1 = 1.0;  getparfloat("d1",&d1);
	f1 = 0.0;  getparfloat("f1",&f1);
	x1min = (d1>0.0)?f1:f1+(n1-1)*d1;
	x1max = (d1<0.0)?f1:f1+(n1-1)*d1;

	/* get parameters describing 2nd dimension sampling */
	if (!getparint("n2",&n2)) {
		if (efseeko(infp, (off_t) 0, SEEK_END)!=0)
			err("must specify n2 if in a pipe!");

		nfloats = (int) (eftello(infp)/( (off_t) sizeof(float)));
		efseeko(infp, (off_t) 0,SEEK_SET);
		n2 = (int) (nfloats/n1);
	}
	d2 = 1.0;  getparfloat("d2",&d2);
	f2 = 0.0;  getparfloat("f2",&f2);
	x2min = (d2>0.0)?f2:f2+(n2-1)*d2;
	x2max = (d2<0.0)?f2:f2+(n2-1)*d2;

	/* set up file to save postscript plot * GK */
	if (!getparstring("plotfile", &plotfile))  plotfile = "plotfile.ps" ;

	/* set up file to save mouse picks */
	if (!getparstring("mpicks", &mpicks)) mpicks = "/dev/tty";
	mpicksfp = efopen(mpicks, "w");

	/* set up curve plotting */
	if ((curve=countparval("curve"))!=0) {
		curvefile=(char**)ealloc1(curve,sizeof(void*));
		getparstringarray("curve",curvefile);
		if ((x1curve=(float**)malloc(curve*sizeof(void*)))==NULL)
			err("Could not allocate x1curve pointers\n");
		if ((x2curve=(float**)malloc(curve*sizeof(void*)))==NULL)
			err("Could not allocate x2curve pointers\n");
                npair=ealloc1int(curve);
                getparint("npair",npair);
	} else {
		npair=(int *)NULL;
		curvefile=(char **)NULL;
		x1curve=(float **)NULL;
		x2curve=(float **)NULL;
	}
	if ((ncurvecolor=countparval("curvecolor"))<curve) {
		curvecolor=(char**)ealloc1(curve,sizeof(void*));
		if (!getparstringarray("curvecolor",curvecolor)) {
			curvecolor[0]=(char *)cwp_strdup("blue\0");
			ncurvecolor=1;
		}
		for (i=ncurvecolor; i<curve; i++)
			curvecolor[i]=(char *)cwp_strdup(curvecolor[ncurvecolor-1]);
	} else if( ncurvecolor ) {
		curvecolor=(char**)ealloc1(ncurvecolor,sizeof(void*));
		getparstringarray("curvecolor",curvecolor);
	}
	for (j=0; j<curve; j++) {
		curvefp=efopen(curvefile[j],"r");
		x1curve[j]=ealloc1float(npair[j]);
		x2curve[j]=ealloc1float(npair[j]);
		for (i=0; i<npair[j]; i++) {
			fscanf(curvefp,"%f",&x1curve[j][i]);
			fscanf(curvefp,"%f",&x2curve[j][i]);
		}
		efclose(curvefp);
	}

        if (!getparfloat("d2",&d2)) d2 = 1.0;

	f2 = 0.0;  getparfloat("f2",&f2);
	x2min = (d2>0.0)?f2:f2+(n2-1)*d2;
	x2max = (d2<0.0)?f2:f2+(n2-1)*d2;

	/* read binary data to be plotted */
	nz = n1*n2;
	z = ealloc1float(nz);

	if (fread(z,sizeof(float),nz,infp)!=nz)
		err("error reading input file");

	/* if necessary, determine clips from percentiles */
	if (getparfloat("clip",&clip)) {
		bclip = clip;
		wclip = -clip;
	}
	if ((!getparfloat("bclip",&bclip) || !getparfloat("wclip",&wclip)) &&
		!getparfloat("clip",&clip)) {
		perc = 100.0;  getparfloat("perc",&perc);
		balance=0 ; getparint("balance",&balance);
		temp = ealloc1float(nz);
		/* Modded by GCP to balance bclip & wclip */

		if (balance==0)
			for (iz=0; iz<nz; ++iz) {
				temp[iz] = z[iz];
			} else { 
				for (iz=0; iz<nz; ++iz) temp[iz] = abs(z[iz]);
				perc=100.0;
			}

		/* End of modded code */
		if (!getparfloat("bclip",&bclip)) {
			bperc = perc;	getparfloat("bperc",&bperc);
			iz = (nz*bperc/100.0);
			if (iz<0) iz = 0;
			if (iz>nz-1) iz = nz-1;
			qkfind(iz,nz,temp);
			bclip = temp[iz];
		}
		if (!getparfloat("wclip",&wclip)) {
			wperc = 100.0-perc;  getparfloat("wperc",&wperc);
			iz = (nz*wperc/100.0);
			if (iz<0) iz = 0;
			if (iz>nz-1) iz = nz-1;
			qkfind(iz,nz,temp);
			/* Modded by GCP to balance bclip & wclip */
			if (balance==0) wclip = temp[iz];
			else wclip = -1*bclip;
			/* End of modded code */
		}
		free1float(temp);
	}
	verbose = 1;  getparint("verbose",&verbose);
	if (verbose) warn("bclip=%g wclip=%g",bclip,wclip);

	/* get colormap specification */
	if (!(getparstring("cmap",&cmap))) {
		cmap = (char *)alloc1(5,1);
		sprintf(cmap,"%s","gray");
	}
	
	/* get interpolation style JG */
	if (!(getparint("blockinterp", &blockinterp))) blockinterp=0;

	/* get legend specs BEREND */
	legend = 0; getparint("legend", &legend); /* BEREND */
	getparstring("units", &units); /* BEREND */
	getparstring("legendfont", &legendfont);     /* BEREND */

	blank = 0; getparfloat("blank",&blank);

	/* get axes parameters */
	xbox = 50; getparint("xbox",&xbox);
	ybox = 50; getparint("ybox",&ybox);
	wbox = 550; getparint("wbox",&wbox);
	hbox = 700; getparint("hbox",&hbox);

	/* legend dimensions */
	if (!(getparint("lwidth",&lwidth)))	lwidth = 16;
	if (!(getparint("lheight",&lheight)))	lheight = hbox/3;
	if (!(getparint("lx",&lx)))	lx = 3;
	if (!(getparint("ly",&ly)))	ly = (hbox-lheight)/3;

	x1beg = x1min; getparfloat("x1beg",&x1beg);
	x1end = x1max; getparfloat("x1end",&x1end);
	d1num = 0.0; getparfloat("d1num",&d1num);
	f1num = x1min; getparfloat("f1num",&f1num);
	n1tic = 1; getparint("n1tic",&n1tic);
	getparstring("grid1",&grid1s);
	if (STREQ("dot",grid1s)) grid1 = DOT;
	else if (STREQ("dash",grid1s)) grid1 = DASH;
	else if (STREQ("solid",grid1s)) grid1 = SOLID;
	else grid1 = NONE;
	getparstring("label1",&label1);
	x2beg = x2min; getparfloat("x2beg",&x2beg);
	x2end = x2max; getparfloat("x2end",&x2end);
	d2num = 0.0; getparfloat("d2num",&d2num);
	f2num = 0.0; getparfloat("f2num",&f2num);
	n2tic = 1; getparint("n2tic",&n2tic);
	getparstring("grid2",&grid2s);
	if (STREQ("dot",grid2s)) grid2 = DOT;
	else if (STREQ("dash",grid2s)) grid2 = DASH;
	else if (STREQ("solid",grid2s)) grid2 = SOLID;
	else grid2 = NONE;
	getparstring("label2",&label2);
	getparstring("labelfont",&labelfont);
	labelsize = 18.0; getparfloat("labelsize",&labelsize);
	getparstring("title",&title);
	getparstring("titlefont",&titlefont);
	titlesize = 24.0; getparfloat("titlesize",&titlesize);
	getparstring("style",&styles);
	if (STREQ("normal",styles)) style = NORMAL;
	else style = SEISMIC;
	getparstring("titlecolor",&titlecolor);
	getparstring("labelcolor",&labelcolor);
	getparstring("gridcolor",&gridcolor);
	getparstring("windowtitle",&windowtitle);
        checkpars();

	/* adjust x1beg and x1end to fall on sampled values */
	i1beg = NINT((x1beg-f1)/d1);
	i1beg = MAX(0,MIN(n1-1,i1beg));
	x1beg = f1+i1beg*d1;
	i1end = NINT((x1end-f1)/d1);
	i1end = MAX(0,MIN(n1-1,i1end));
	x1end = f1+i1end*d1;

	/* adjust x2beg and x2end to fall on sampled values */
	i2beg = NINT((x2beg-f2)/d2);
	i2beg = MAX(0,MIN(n2-1,i2beg));
	x2beg = f2+i2beg*d2;
	i2end = NINT((x2end-f2)/d2);
	i2end = MAX(0,MIN(n2-1,i2end));
	x2end = f2+i2end*d2;

	/* allocate space for image bytes */
	n1c = 1+abs(i1end-i1beg);
	n2c = 1+abs(i2end-i2beg);
	cz = ealloc1(n1c*n2c,sizeof(unsigned char));

	/* convert data to be imaged into signed characters */
	zscale = (wclip!=bclip)?255.0/(wclip-bclip):1.0e10;
	zoffset = -bclip*zscale;
	i1step = (i1end>i1beg)?1:-1;
	i2step = (i2end>i2beg)?1:-1;
	if (style==NORMAL) {
		for (i2c=0,i2=i2beg; i2c<n2c; i2c++,i2+=i2step) {
			czp = cz+n1c*n2c-(i2c+1)*n1c;
			for (i1c=0,i1=i1beg; i1c<n1c; i1c++,i1+=i1step) {
				zi = zoffset+z[i1+i2*n1]*zscale;
				if (zi<0.0) zi = 0.0;
				if (zi>255.0) zi = 255.0;
				*czp++ = (unsigned char)zi;
			}
		}
	} else {
		czp = cz;
		for (i1c=0,i1=i1beg; i1c<n1c; i1c++,i1+=i1step) {
			for (i2c=0,i2=i2beg; i2c<n2c; i2c++,i2+=i2step) {
				zi = zoffset+z[i1+i2*n1]*zscale;
				if (zi<0.0) zi = 0.0;
				if (zi>255.0) zi = 255.0;
				*czp++ = (unsigned char)zi;
			}
		}
	}
/*	free1float(z);      keep data for plotting GK */
	
	/* initialize zoom box parameters */
	dx = (style==NORMAL ? d1 : d2);
	dy = (style==NORMAL ? d2 : d1);
	nxb = nx = (style==NORMAL ? n1c : n2c);
	nyb = ny = (style==NORMAL ? n2c : n1c);
	ixb = iyb = 0;
	czb = cz;
	x1begb = x1beg;	 x1endb = x1end;
	x2begb = x2beg;	 x2endb = x2end;

	/* connect to X server */
	if ((dpy=XOpenDisplay(NULL))==NULL)
		err("Cannot connect to display %s!\n",XDisplayName(NULL));
	scr = DefaultScreen(dpy);
	black = BlackPixel(dpy,scr);
	white = WhitePixel(dpy,scr);
	
	/* create window */
	win = xNewWindow(dpy,xbox,ybox,wbox,hbox,(int) black,(int) white,windowtitle);

	/* backwards compatibility */
	if (STREQ(cmap,"gray")) {
		sprintf(cmap,"%s","rgb0");

	} else if (STREQ(cmap,"hue")) {
		/* free1(cmap); */
		cmap = (char *)alloc1(5,1);
		sprintf(cmap,"%s","hsv1");

	} else  if ((strncmp(cmap,"hsv",3)) && (strncmp(cmap,"rgb",3))){
			if (verbose) warn ("cmap=%s using cmap=gray", cmap);

			/* free1(cmap); */
			cmap = (char *)alloc1(5,1);
       			sprintf (cmap, "%s", "rgb0");
	} 
	

	/* here are the new colormaps				*/
	if (strncmp(cmap, "rgb", 3) == 0)
		XSetWindowColormap(dpy,win,
			xCreateRGBColormap(dpy,win, cmap, verbose));
	else if (strncmp (cmap, "hsv", 3) == 0)
		XSetWindowColormap(dpy,win,
			xCreateHSVColormap(dpy,win, cmap, verbose));
	
	/* determine min and max pixels from standard colormap */
	pmin = xGetFirstPixel(dpy);
	pmax = xGetLastPixel(dpy);
	if (verbose) warn("pmin=%x,pmax=%x\n",pmin,pmax);
	if(pmax==0L)pmax=255L;

	if (verbose) warn("pmin=%x,pmax=%x\n",pmin,pmax);
	data_legend = (unsigned char *) malloc(lwidth * lheight);

        if( bclip < wclip ){
           base=256;
           fact=-256.0;
        }else{
           base=0;
           fact=256.0;
        }
        ptr = data_legend;
	for (i=0; i<lheight; i++){
           for( j=0; j<lwidth; j++ ){
	      *ptr++ = (unsigned char) 
                            (base + (fact*i)/lheight);
           }
           /* fprintf(stderr," %d ",*(ptr-1) ); */
	}
		
	/* make GC for image */
	gci = XCreateGC(dpy,win,0,NULL);
	
	/* set normal event mask */
	XSelectInput(dpy,win,
		StructureNotifyMask |
		ExposureMask |
		KeyPressMask |
		PointerMotionMask |
		ButtonPressMask |
		ButtonReleaseMask |
		Button1MotionMask |
		Button2MotionMask);
	
	/* map window */
	XMapWindow(dpy,win);
					
	/* determine good size for axes box */
	xSizeAxesBox(dpy,win,
		labelfont,titlefont,style,
		&x,&y,&width,&height);
	
	/* clear the window */
	XClearWindow(dpy,win);
	
	/* note that image is out of date */
	imageOutOfDate = 1;

	/* main event loop */
	while(imageOutOfDate|(~imageOutOfDate)/*True*/) {
		XNextEvent(dpy,&event);

		/* if window was resized */
		if (event.type==ConfigureNotify &&
			(event.xconfigure.width!=winwidth ||
			 event.xconfigure.height!=winheight)) {
			winwidth = event.xconfigure.width;
			winheight = event.xconfigure.height;
							
			/* determine good size for axes box */
			xSizeAxesBox(dpy,win,
				labelfont,titlefont,style,
				&x,&y,&width,&height);
			
			/* clear the window */
			XClearWindow(dpy,win);
			
			/* note that image is out of date */
			imageOutOfDate = 1;

		/* else if window exposed */
		} else if (event.type==Expose) {
			
			/* clear all expose events from queue */
			while (XCheckTypedEvent(dpy,Expose,&event));
			
			/* if necessary, make new image */
			if (imageOutOfDate) {
				 czbi = newInterpBytes(nxb,nyb,czb,
							width,height,blockinterp);

				if (image!=NULL) XDestroyImage(image);
				image = xNewImage(dpy,pmin,pmax,
					width,height,blank,czbi);

				/* BEREND create image */
				if (legend) {
					if (image_legend!=NULL) XDestroyImage(image_legend);
					image_legend = xNewImage(dpy,pmin,pmax,lwidth,lheight,0,data_legend);
				}

				imageOutOfDate = 0;
			}
	
			/* draw image (before axes so grid lines visible) */
			XPutImage(dpy,win,gci,image,0,0,x,y,
				image->width,image->height);

			/* BEREND display image */
			if (legend)
				XPutImage(dpy,win,gci,image_legend,
					0,0,lx,y+ly,lwidth,lheight);

			/* BEREND draw legend axes on top of image */
			if (legend)
				xDrawLegendBox(dpy,win,
					lx,y+ly,lwidth,lheight,
					bclip,wclip,units,legendfont,
					labelfont,title,titlefont,
					labelcolor,titlecolor,gridcolor,
					style);

                        /* draw curve on top of image */
			for (i=0; i<curve; i++)
				xDrawCurve(dpy,win,
					   x,y,width,height,
					   x1begb,x1endb,0.0,0.0,
					   x2begb,x2endb,0.0,0.0,
					   x1curve[i],x2curve[i],npair[i],
					   curvecolor[i],style);

	                /* draw axes on top of image */
			xDrawAxesBox(dpy,win,
				x,y,width,height,
				x1begb,x1endb,0.0,0.0,
				d1num,f1num,n1tic,grid1,label1,
				x2begb,x2endb,0.0,0.0,
				d2num,f2num,n2tic,grid2,label2,
				labelfont,title,titlefont,
				labelcolor,titlecolor,gridcolor,
				style);

		/* else if key down */
		} else if (event.type==KeyPress) {

			XLookupString(&(event.xkey),keybuf,0,&keysym,&keystat);

                     /*  added moving, clipping and zooming GK */
			if (keysym==XK_s) {
				xMousePrint(event,style, mpicksfp,
					    x,y,width,height,
					    x1begb,x1endb,x2begb,x2endb);

			} else if (keysym==XK_l ) {
				/* set lock */		  
			     lock = 1 ;
			  if (verbose) warn("zoom lock set  %d\n",lock);

 			} else if (keysym==XK_u ) {
				/* unset lock */		  
			     lock = 0 ;
			  if (verbose) warn("zoom lock released %d\n",lock);

 			} else if (keysym==XK_Shift_L ) { 
			     /* if (verbose) 
			     fprintf(stderr,"Shift Left pressed \n");*/
			} else if (keysym==XK_KP_1 || keysym==XK_1 ) { 
			     mvefac=1.;
			     fprintf(stderr,"Zoom/Move factor = 1 \n");
			} else if (keysym==XK_KP_2 || keysym==XK_2 ) { 
			     mvefac=2.;
			     fprintf(stderr,"Zoom/Move factor = 2 \n");
			} else if (keysym==XK_KP_3 || keysym==XK_3 ) { 
			     mvefac=3.;
			     if (verbose) 
			     fprintf(stderr,"Zoom/Move factor = 3 \n");
			} else if (keysym==XK_KP_4 || keysym==XK_4 ) { 
			     mvefac=4.;
			     if (verbose) 
			     fprintf(stderr,"Zoom/Move factor = 4 \n");
			} else if (keysym==XK_KP_5 || keysym==XK_5 ) { 
			     mvefac=5.;
			     if (verbose) 
			     fprintf(stderr,"Zoom/Move factor = 5 \n");
			} else if (keysym==XK_KP_6 || keysym==XK_6 ) { 
			     mvefac=6.;
			     if (verbose) 
			     fprintf(stderr,"Zoom/Move factor = 6 \n");
			} else if (keysym==XK_KP_7 || keysym==XK_7 ) { 
			     mvefac=7.;
			     if (verbose) 
			     fprintf(stderr,"Zoom/Move factor = 7 \n");
			} else if (keysym==XK_KP_8 || keysym==XK_8 ) { 
			     mvefac=8.;
			     if (verbose) 
			     fprintf(stderr,"Zoom/Move factor = 8\n");
			} else if (keysym==XK_KP_9 || keysym==XK_9 ) { 
			     mvefac=9.;
			     if (verbose) 
			     fprintf(stderr,"Zoom/Move factor = 9\n");
			} else if (keysym==XK_Left ) {
 			  /* move zoom box to left by half window width */
			  mve = (x2endb - x2begb)/mvefac ;
			  x2begb = x2begb - mve ;
			  x2endb = x2endb - mve ;
			  msg="move "; 
			  /* check for bounds of full window */
			  if (x2begb < x2beg){
			    if ( lock ) { x2begb = x2begb + mve ;
			                  x2endb = x2endb + mve ;
					  msg="limit ";
					  mve=0;
			    } else {  x2begb = x2beg ;
			              nxb=(int)((x2endb-x2begb)/dx);
				   }
			  }

			  if (verbose) fprintf(stderr,"%s %g\n",msg,mve);

			   ixb+=-(int)(mve/dx);
			   if ( (ixb<0) || 
			        ((ixb+nxb)>nx) || 
			        (nxb<2) || 
			        (nxb>nx)) {ixb=0;nxb=nx;
				           x2begb=x2beg;
					   x2endb=x2end;}

			   if (czb!=cz) free1(czb);
			   czb = ealloc1(nxb*nyb,
				     sizeof(signed char));
			   for (i=0,czbp=czb; i<nyb; i++) {
			       czp = cz+(iyb+i)*nx+ixb;
			       for (j=0; j<nxb; j++)
				    *czbp++ = *czp++; 
			   }						
			  
			  /* clear area and force an expose event */
			  XClearArea(dpy,win,0,0,0,0,True);
			  /* note that image is out of date */
			  imageOutOfDate = 1;
								
			} else if (keysym==XK_Right ) {
			  /* move zoom box to right by half window width*/
			  mve = (x2endb - x2begb)/mvefac ;
			  x2begb = x2begb + mve ;
			  x2endb = x2endb + mve ;
			  msg="move "; 
			  /* check for bounds of full window */
			  if (x2endb > x2end){
			    if ( lock ) { x2begb = x2begb - mve ;
			                  x2endb = x2endb - mve ;
					  msg="limit ";
					  mve=0;
			    } else { x2endb = x2end;
			             nxb=(int)((x2endb-x2begb)/dx);
				   }
			  }
			  if (verbose) fprintf(stderr,"%s %g\n",msg,mve);
			  
			  /* for replot require 
			   * ixb,iyb   start samples of image
			   * nxb,nyb   number of samples of image */
			   
			   ixb+=(int)(mve/dx);
			   if ( (ixb<0) || 
			        ((ixb+nxb)>nx) || 
			        (nxb<2) || 
			        (nxb>nx)) {ixb=0;nxb=nx;
				           x2begb=x2beg;
					   x2endb=x2end;}


     			   if (czb!=cz) free1(czb);
			   czb = ealloc1(nxb*nyb,
				     sizeof(signed char));
			   for (i=0,czbp=czb; i<nyb; i++) {
			       czp = cz+(iyb+i)*nx+ixb;
			       for (j=0; j<nxb; j++)
				    *czbp++ = *czp++; 
			   }						
			  
	
			  /* clear area and force an expose event */
			  XClearArea(dpy,win,0,0,0,0,True);
			  /* note that image is out of date */
			  imageOutOfDate = 1;
								
			} else if (keysym==XK_Down ) {
			  /* move zoom box down by half window height */
			  mve = (x1endb - x1begb)/mvefac ;
			  x1begb = x1begb + mve ;
			  x1endb = x1endb + mve ;
			  msg="move "; 
			  /* check for bounds of full window */
			  if (x1endb > x1end){
			    if ( lock ) { x1begb = x1begb - mve ;
			                  x1endb = x1endb - mve ;
					  msg="limit ";
					  mve=0;
			    } else { x1endb = x1end;
			             nyb=(int)((x1endb-x1begb)/dy);
				   }
			  }
			  if (verbose) fprintf(stderr,"%s %g\n",msg,mve);

			   iyb+=(int)(mve/dy);
			   
			   /* reset to original if out of range */
			   if ( (iyb<0) || 
			        ((iyb+nyb)>ny) || 
			        (nyb<2) || 
			        (nyb>ny)) {iyb=0;nyb=ny;
				           x1begb=x1beg;
					   x1endb=x1end;}


			  /* clear area and force an expose event */
			  XClearArea(dpy,win,0,0,0,0,True);
			  /* note that image is out of date */
			  imageOutOfDate = 1;

     			   if (czb!=cz) free1(czb);
			   czb = ealloc1(nxb*nyb,
				     sizeof(signed char));
			   for (i=0,czbp=czb; i<nyb; i++) {
			       czp = cz+(iyb+i)*nx+ixb;
			       for (j=0; j<nxb; j++)
				    *czbp++ = *czp++; 
			   }						

			} else if (keysym==XK_Up || keysym==XK_KP_Up ) {
			  /*********** 
			   * move zoom box up in .... vertical* 
			   ***********                          */
			  mve = (x1endb - x1begb)/mvefac ;
			  x1begb = x1begb - mve ;
			  x1endb = x1endb - mve ;
			  msg="move "; 
			  /* check for bounds of full window */
			  if (x1begb < x1beg){
			    if ( lock ) { x1begb = x1begb + mve ;
			                  x1endb = x1endb + mve ;
					  msg="limit ";
					  mve=0;
			    } else { x1begb = x1beg ;
			             nyb=(int)((x1endb-x1begb)/dy);
				   }
			  }
			  if (verbose) fprintf(stderr,"%s %g\n",msg,mve);

			  iyb+=-(int)(mve/dy);
			  
			  /* reset to original if out of range */
			   if ( (iyb<0) || 
			        (nyb<2) || 
			        (nyb>ny)) {iyb=0;nyb=ny;
				           x1begb=x1beg;
					   x1endb=x1end;}

     			   if (czb!=cz) free1(czb);
			   czb = ealloc1(nxb*nyb,
				     sizeof(signed char));
			   for (i=0,czbp=czb; i<nyb; i++) {
			       czp = cz+(iyb+i)*nx+ixb;
			       for (j=0; j<nxb; j++)
				    *czbp++ = *czp++; 
			   }						
				
			/* clear area and force an expose event */
			XClearArea(dpy,win,0,0,0,0,True);
			
			/* note that image is out of date */
			imageOutOfDate = 1;
									
			} else if (keysym==XK_o || keysym==XK_KP_Subtract ) {
			  /*********** 
			   *zoom out .... vertical* 
			   ***********            */
			  mve = (x1endb - x1begb)/mvefac ;
			  x1begb = x1begb - mve ;
			  x1endb = x1endb + mve ;
			  /* check for bounds of full window */
			  if (x1begb < x1beg){
			    if ( lock ) { x1begb = x1begb + mve ;
					  msg="limit ";
					  mve=0;
			    } else { x1begb = x1beg ;}
			  }
			  if (x1endb > x1end){
			    if ( lock ) { x1endb = x1endb - mve ;
					  msg="limit ";
					  mve=0;
			    } else { x1endb = x1end ;}
			  }
 		           nyb=(int)((x1endb-x1begb)/dy);
			   iyb+=-(int)(mve/dy);
			   if ( (iyb<0) || (nyb>ny)) {iyb=0;nyb=ny;}
			  
			  /*   .... and horizontal */
			  mve = (x2endb - x2begb)/mvefac ;
			  x2begb = x2begb - mve ;
			  x2endb = x2endb + mve ;
			  /* check bounds of original image */
			  if (x2begb < x2beg){
			    if ( lock ) { x2begb = x2begb + mve ;
					  msg="limit ";
					  mve=0;
			    } else { x2begb = x2beg ;}
			  }
			  if (x2endb > x2end){
			    if ( lock ) { x2endb = x2endb - mve ;
					  msg="limit ";
					  mve=0;
			    } else { x2endb = x2end ;}
			  }
			   nxb=(int)((x2endb-x2begb)/dx);
			   ixb+=-(int)(mve/dx);
 			   if ( (ixb<0)        || 
			        ((ixb+nxb)>nx) || 
			        (nxb<0)        || 
			        (nxb>nx))  { ixb=0;nxb=nx;
				             x2begb=x2beg;
					     x2endb=x2end;}
			   
			   if (czb!=cz) free1(czb);
			   czb = ealloc1(nxb*nyb,
				     sizeof(signed char));
			   for (i=0,czbp=czb; i<nyb; i++) {
			       czp = cz+(iyb+i)*nx+ixb;
			       for (j=0; j<nxb; j++)
				    *czbp++ = *czp++; 
			   }			 	
			  /* clear area and force an expose event */
		   	  XClearArea(dpy,win,0,0,0,0,True);
			 
			  /* note that image is out of date */
			  imageOutOfDate = 1;
								
			} else if (keysym==XK_i || keysym==XK_KP_Add ) {
			  /*********** 
			   *zoom in .... vertical* 
			   ***********           */
			  mve = (x1endb - x1begb)/(2.*mvefac) ;
			  x1begb = x1begb + mve ;
			  x1endb = x1endb - mve ;
			   iyb+=(int)(mve/dy);

			  /*   .... and horizontal */
			  mve = (x2endb - x2begb)/(2.*mvefac) ;
			  x2begb = x2begb + mve ;
			  x2endb = x2endb - mve ;
			   ixb+=(int)(mve/dx);

			   nxb=(int)((x2endb-x2begb)/dx);
			   nyb=(int)((x1endb-x1begb)/dy);
			   if ( (ixb<0) || 
			        (nxb>nx)||
				(ixb>nx)||
				(nxb<0) ) {ixb=0;nxb=nx;
				             x2begb=x2beg;
					     x2endb=x2end;}
			   if ( (iyb<0) || 
			        (nyb>ny)||
				(iyb>ny)||
				(nyb<0) ) {iyb=0;nyb=ny;
				             x1begb=x1beg;
					     x1endb=x1end;}

			  /* clear area and force an expose event */
			  XClearArea(dpy,win,0,0,0,0,True);
			 
			  /* note that image is out of date */
			  imageOutOfDate = 1;
			if (czb!=cz) free1(czb);
					czb = ealloc1(nxb*nyb,
						sizeof(signed char));
					for (i=0,czbp=czb; i<nyb; i++) {
					    czp = cz+(iyb+i)*nx+ixb;
					    for (j=0; j<nxb; j++)
						    *czbp++ = *czp++; 
					}					
			} else if (keysym==XK_c || keysym==XK_Page_Down) {
		  		
				/* Change clip for image */
 		       		clip += clip/10. ;
				if (verbose) warn("clip=%g\n",clip);
 				/* note that image is out of date */
				 imageOutOfDate = 1;				
				 
			} else if (keysym==XK_a || keysym==XK_Page_Up) {

				/* Change clip for image */
			        clip -= clip/10. ;
				if (verbose) warn("clip=%g\n",clip);
				/* note that image is out of date */
				imageOutOfDate = 1;
				
				if (czb!=cz) free1(czb);
					czb = ealloc1(nxb*nyb,
						sizeof(signed char));
					for (i=0,czbp=czb; i<nyb; i++) {
					    czp = cz+(iyb+i)*nx+ixb;
					    for (j=0; j<nxb; j++)
						    *czbp++ = *czp++; 
					}				
			/* end of section for moving clipping and zooming GK */		    

			} else if (keysym==XK_q || keysym==XK_Q) {
			/* This is the exit from the event loop */
				break;
			} else if (keysym==XK_p || keysym==XK_P) {
			/* invoke pswigb with appropriate data */
				char *cmdline, cmdtemp[256];
				float cmdfloat;
				int iargc;
				FILE *plotfp;	/*fp for plot data*/					

				cmdline = (char *) emalloc(BUFSIZ);				
				strcpy(cmdline,"psimage");
				for(iargc = 1; iargc < argc; iargc++) {
					strcat(cmdline," ");
					strcat(cmdline,argv[iargc]);
					}
				/* override incompatible arguments */
				sprintf(cmdtemp," axescolor=%s",labelcolor);
				strcat(cmdline,cmdtemp);
				cmdfloat = DisplayWidthMM(dpy,scr)/25.4;
				cmdfloat /= DisplayWidth(dpy,scr);
				sprintf(cmdtemp," wbox=%g", cmdfloat*width);
				strcat(cmdline,cmdtemp);
				sprintf(cmdtemp," xbox=%g", 0.5+cmdfloat*xbox);
				strcat(cmdline,cmdtemp);
				cmdfloat = DisplayHeightMM(dpy,scr)/25.4;
				cmdfloat /= DisplayHeight(dpy,scr);
				sprintf(cmdtemp," hbox=%g", cmdfloat*height);
				strcat(cmdline,cmdtemp);
				sprintf(cmdtemp," ybox=%g", 0.5+cmdfloat*ybox);
				strcat(cmdline,cmdtemp);
				sprintf(cmdtemp," x1beg=%g", x1begb);
				strcat(cmdline,cmdtemp);
				sprintf(cmdtemp," x1end=%g",x1endb);
				strcat(cmdline,cmdtemp);
				sprintf(cmdtemp," x2beg=%g", x2begb);
				strcat(cmdline,cmdtemp);
				sprintf(cmdtemp," x2end=%g",x2endb);
				strcat(cmdline,cmdtemp);
				if (STREQ(cmap,"gray")) {
					strcat(cmdline," brgb=0.0,0.0,0.0");
					strcat(cmdline," wrgb=1.0,1.0,1.0");
					}
				else if (STREQ(cmap,"hue")) {
					strcat(cmdline," bhls=0.75,0.5,1.0");
					strcat(cmdline," whls=0.0,0.5,1.0");
					}
				strcat(cmdline," title=\"");
				strcat(cmdline,title);
				strcat(cmdline,"\"");
				strcat(cmdline," label1=\"");
				strcat(cmdline,label1);
				strcat(cmdline,"\"");
				strcat(cmdline," label2=\"");
				strcat(cmdline,label2);
				strcat(cmdline,"\"");
				sprintf(cmdtemp," > %s ", plotfile);
				strcat(cmdline,cmdtemp);
				fprintf(stderr,"%i * %i = %i\n",n1,n2,nz);
				fprintf(stderr,"%s\n",cmdline);

                                /* pipe data to psimage and write to plotfile *GK*/
				plotfp = epopen(cmdline, "w");
				free(cmdline);
				efwrite(z,sizeof(float),nz,plotfp);
				epclose(plotfp);
				
			} else if (keysym==XK_r) {
				Colormap mycp=xCreateRGBColormap(dpy,win,"rgb_up",verbose);

				XSetWindowColormap(dpy,win,mycp);
				XInstallColormap(dpy,mycp);
                                /* clear area and force an expose event */
                                XClearArea(dpy,win,0,0,0,0,True);
                                /* note that image is out of date */
                                imageOutOfDate = 1;


			} else if (keysym==XK_R) {
                                Colormap mycp=xCreateRGBColormap(dpy,win,"rgb_down",verbose);

                                XSetWindowColormap(dpy,win,mycp);
				XInstallColormap(dpy,mycp);

                                /* clear area and force an expose event */
                                XClearArea(dpy,win,0,0,0,0,True);
                                /* note that image is out of date */
                                imageOutOfDate = 1;

			} else if (keysym==XK_h) {
                                Colormap mycp=xCreateHSVColormap(dpy,win,"hsv_up",verbose);

                                XSetWindowColormap(dpy,win,mycp);
				XInstallColormap(dpy,mycp);

                                /* clear area and force an expose event */
                                XClearArea(dpy,win,0,0,0,0,True);
                                /* note that image is out of date */
                                imageOutOfDate = 1;


			} else if (keysym==XK_H) {

                                Colormap mycp=xCreateHSVColormap(dpy,win,"hsv_down",verbose);
                                
                                XSetWindowColormap(dpy,win,mycp);
				XInstallColormap(dpy,mycp);

                                /* clear area and force an expose event */
                                XClearArea(dpy,win,0,0,0,0,True);
                                /* note that image is out of date */
                                imageOutOfDate = 1;

			} else {
				continue;
			}


		/* else if button down (1 == zoom, 2 == mouse tracking */
		} else if (event.type==ButtonPress) {
			/* if 1st button: zoom */
			if (event.xbutton.button==Button1) {

				/* track pointer and get new box */
				xRubberBox(dpy,win,event,&xb,&yb,&wb,&hb);
			
				/* if new box has tiny width or height */
				if (wb<4 || hb<4) {
				
					/* reset box to initial values */
					x1begb = x1beg;
					x1endb = x1end;
					x2begb = x2beg;
					x2endb = x2end;
					nxb = nx;
					nyb = ny;
					ixb = iyb = 0;
					if (czb!=cz) free1(czb);
					czb = cz;
			
				/* else, if new box has non-zero width */
				/* and height */
				} else {
			
					/* calculate new box parameters */
					if (style==NORMAL) {
					    zoomBox(x,y,width,height,
						    xb,yb,wb,hb,
						    nxb,ixb,x1begb,x1endb,
						    nyb,iyb,x2endb,x2begb,
						    &nxb,&ixb,&x1begb,&x1endb,
						    &nyb,&iyb,&x2endb,&x2begb);
					} else {
					    zoomBox(x,y,width,height,
						    xb,yb,wb,hb,
						    nxb,ixb,x2begb,x2endb,
						    nyb,iyb,x1begb,x1endb,
						    &nxb,&ixb,&x2begb,&x2endb,
						    &nyb,&iyb,&x1begb,&x1endb);
					}
			
					/* make new bytes in zoombox */
					if (czb!=cz) free1(czb);
					czb = ealloc1(nxb*nyb,
						sizeof(signed char));
					for (i=0,czbp=czb; i<nyb; i++) {
					    czp = cz+(iyb+i)*nx+ixb;
					    for (j=0; j<nxb; j++)
						    *czbp++ = *czp++; 
					}
				}
			
				/* clear area and force an expose event */
				XClearArea(dpy,win,0,0,0,0,True);
			
				/* note that image is out of date */
				imageOutOfDate = 1;
		
			/* else if 2nd button down: display mouse coords */
			} else if (event.xbutton.button==Button2) {

				showloc = 1;
				xMouseLoc(dpy,win,event,style,showloc,
					  x,y,width,height,x1begb,x1endb,
					  x2begb,x2endb,z,f1,d1,n1,f2,d2,
                                          n2,verbose);
			} else if (event.xbutton.button==Button3) {
                                /* ZM: Mouse-Button-3 shows the amplitude constantly */

				showloc = 1;
				xMouseLoc(dpy,win,event,style,showloc,
					  x,y,width,height,x1begb,x1endb,
					  x2begb,x2endb,z,f1,d1,n1,f2,d2,
                                          n2,verbose);

			} else {
				continue;
			}

		/* else if pointer has moved */
		} else if (event.type==MotionNotify) {
			
			/* if button2 down, show mouse location */
			if (showloc)
				xMouseLoc(dpy,win,event,style,True,
					x,y,width,height,x1begb,x1endb,
                                        x2begb,x2endb,z,f1,d1,n1,f2,d2,
                                        n2,verbose);

		/* else if button2 released, stop tracking */
		} else if (event.type==ButtonRelease &&
			   event.xbutton.button==Button2) {
			showloc = 0;
		}

	} /* end of event loop */

	/* close connection to X server */
	XCloseDisplay(dpy);
	if (curve) {
		free1int(npair);
		for (i=0; i<curve; i++) {
			free1float(x1curve[i]);
			free1float(x2curve[i]);
		}
		free((void**)x1curve);
		free((void**)x2curve);
		free((void**)curvefile);
		free((void**)curvecolor);
	}
    	free1float(z); 

	return EXIT_SUCCESS;
}

/* update parameters associated with zoom box */
static void zoomBox (int x, int y, int w, int h, 
	int xb, int yb, int wb, int hb,
	int nx, int ix, float x1, float x2,
	int ny, int iy, float y1, float y2,
	int *nxb, int *ixb, float *x1b, float *x2b,
	int *nyb, int *iyb, float *y1b, float *y2b)
{
	/* if width and/or height of box are zero, just copy values */
	if (wb==0 || hb==0) {
		*nxb = nx; *ixb = ix; *x1b = x1; *x2b = x2;
		*nyb = ny; *iyb = iy; *y1b = y1; *y2b = y2;
		return;		
	} 
	
	/* clip box */
	if (xb<x) {
		wb -= x-xb;
		xb = x;
	}
	if (yb<y) {
		hb -= y-yb;
		yb = y;
	}
	if (xb+wb>x+w) wb = x-xb+w;
	if (yb+hb>y+h) hb = y-yb+h;
	
	/* determine number of samples in rubber box (at least 2) */
	*nxb = MAX(nx*wb/w,2);
	*nyb = MAX(ny*hb/h,2);
	
	/* determine indices of first samples in box */
	*ixb = ix+(xb-x)*(nx-1)/w;
	*ixb = MIN(*ixb,ix+nx-*nxb);
	*iyb = iy+(yb-y)*(ny-1)/h;
	*iyb = MIN(*iyb,iy+ny-*nyb);
	
	
	/* determine box limits to nearest samples */
	*x1b = x1+(*ixb-ix)*(x2-x1)/(nx-1);
	*x2b = x1+(*ixb+*nxb-1-ix)*(x2-x1)/(nx-1);
	*y1b = y1+(*iyb-iy)*(y2-y1)/(ny-1);
	*y2b = y1+(*iyb+*nyb-1-iy)*(y2-y1)/(ny-1);
}

/* return pointer to new interpolated array of bytes */
static unsigned char *newInterpBytes (int n1in, int n2in, unsigned char *bin,
	int n1out, int n2out, int useBlockInterp) /* JG */
{
	unsigned char *bout;
	float d1in,d2in,d1out,d2out,f1in,f2in,f1out,f2out;
	
	f1in = f2in = f1out = f2out = 0.0;
	d1in = d2in = 1.0;
	d1out = d1in*(float)(n1in-1)/(float)(n1out-1);
	d2out = d2in*(float)(n2in-1)/(float)(n2out-1);
	bout = ealloc1(n1out*n2out,sizeof(unsigned char));
	 /* JG .... */
	if (!useBlockInterp)
	  {
		intl2b(n1in,d1in,f1in,n2in,d2in,f2in,bin,
			   n1out,d1out,f1out,n2out,d2out,f2out,bout);
	  }
	else
	  {
		intl2b_block(n1in,d1in,f1in,n2in,d2in,f2in,bin,
		n1out,d1out,f1out,n2out,d2out,f2out,bout);
	  }
	/* .... JG */
	return bout;
}

/*********************** self documentation **********************/
/*****************************************************************************
INTL2B_block - blocky interpolation of a 2-D array of bytes

intl2b_block		blocky interpolation of a 2-D array of bytes

******************************************************************************
Function Prototype:
void intl2b_block(int nxin, float dxin, float fxin,
	int nyin, float dyin, float fyin, unsigned char *zin,
	int nxout, float dxout, float fxout,
	int nyout, float dyout, float fyout, unsigned char *zout);

******************************************************************************
Input:
nxin		number of x samples input (fast dimension of zin)
dxin		x sampling interval input
fxin		first x sample input
nyin		number of y samples input (slow dimension of zin)
dyin		y sampling interval input
fyin		first y sample input
zin		array[nyin][nxin] of input samples (see notes)
nxout		number of x samples output (fast dimension of zout)
dxout		x sampling interval output
fxout		first x sample output
nyout		number of y samples output (slow dimension of zout)
dyout		y sampling interval output
fyout		first y sample output

Output:
zout		array[nyout][nxout] of output samples (see notes)

******************************************************************************
Notes:
The arrays zin and zout must passed as pointers to the first element of
a two-dimensional contiguous array of unsigned char values.

Constant extrapolation of zin is used to compute zout for
output x and y outside the range of input x and y.

******************************************************************************
Author:  James Gunning, CSIRO Petroleum 1999. Hacked from
intl2b() by Dave Hale, Colorado School of Mines, c. 1989-1991
*****************************************************************************/
/**************** end self doc ********************************/

void intl2b_block(int nxin, float dxin, float fxin,
	int nyin, float dyin, float fyin, unsigned char *zin,
	int nxout, float dxout, float fxout,
	int nyout, float dyout, float fyout, unsigned char *zout)
/*****************************************************************************
blocky interpolation of a 2-D array of bytes: gridblock effect
******************************************************************************
Input:
nxin		number of x samples input (fast dimension of zin)
dxin		x sampling interval input
fxin		first x sample input
nyin		number of y samples input (slow dimension of zin)
dyin		y sampling interval input
fyin		first y sample input
zin		    array[nyin][nxin] of input samples (see notes)
nxout		number of x samples output (fast dimension of zout)
dxout		x sampling interval output
fxout		first x sample output
nyout		number of y samples output (slow dimension of zout)
dyout		y sampling interval output
fyout		first y sample output

Output:
zout		array[nyout][nxout] of output samples (see notes)
******************************************************************************
Notes:
The arrays zin and zout must passed as pointers to the first element of
a two-dimensional contiguous array of unsigned char values.

Constant extrapolation of zin is used to compute zout for
output x and y outside the range of input x and y.
 
Mapping of bytes between arrays is done to preserve appearance of `gridblocks':
no smooth interpolation is performed.

*****************************************************************************/
{         
	int ixout,iyout,iin,jin;
	float xoff,yoff;
	
	xoff=fxout+0.5*dxin-fxin;
	yoff=fyout+0.5*dyin-fyin;
	for (iyout=0;iyout<nyout;iyout++) {
		jin=(int)((iyout*dyout+yoff)/dyin);
		jin=MIN(nyin-1,MAX(jin,0));						
		for (ixout=0;ixout<nxout;ixout++) {
			iin=(int)((ixout*dxout+xoff)/dxin);
			iin=MIN(nxin-1,MAX(iin,0));	
			zout[nxout*iyout+ixout]=zin[nxin*jin+iin];
		}
	}
}
   
void xMouseLoc(Display *dpy, Window win, XEvent event, int style, Bool show,
	int x, int y, int width, int height,
	float x1begb, float x1endb, float x2begb, float x2endb,
        float *z, float f1, float d1, int n1,float f2, float d2, 
        int n2, int verbose)
{
	static XFontStruct *fs=NULL;
	static XCharStruct overall;
	static GC gc;
	int dummy,xoffset=5,yoffset=5;
	float x1,x2,amp;
	char string[256];

	/* if first time, get font attributes and make gc */
	if (fs==NULL) {
		fs = XLoadQueryFont(dpy,"fixed");
		gc = XCreateGC(dpy,win,0,NULL);

		/* make sure foreground/background are black/white */
		XSetForeground(dpy,gc,BlackPixel(dpy,DefaultScreen(dpy)));
		XSetBackground(dpy,gc,WhitePixel(dpy,DefaultScreen(dpy)));

		XSetFont(dpy,gc,fs->fid);
		overall.width = 1;
		overall.ascent = 1;
		overall.descent = 1;
	}

	/* erase previous string */
	XClearArea(dpy,win,xoffset,yoffset,
		overall.width,overall.ascent+overall.descent,False);

	/* if not showing, then return */
	if (!show) return;

	/* convert mouse location to (x1,x2) coordinates */
	if (style==NORMAL) {
		x1 = x1begb+(x1endb-x1begb)*(event.xmotion.x-x)/width;
		x2 = x2endb+(x2begb-x2endb)*(event.xmotion.y-y)/height;
	} else {
		x1 = x1begb+(x1endb-x1begb)*(event.xmotion.y-y)/height;
		x2 = x2begb+(x2endb-x2begb)*(event.xmotion.x-x)/width;
	}

	/* draw string indicating mouse location */
       
        /* ZM: computing amplitude at the poked point from dataset */
        amp = getamp(z,f1,d1,n1,f2,d2,n2,x1,x2,verbose);
        sprintf(string,"(%0.6g,%0.6g,%0.6g)",x2,x1,amp); /* ZM */

	XTextExtents(fs,string,(int)strlen(string),&dummy,&dummy,&dummy,&overall);
	XDrawString(dpy,win,gc,xoffset,yoffset+overall.ascent,
		string,(int) strlen(string));
}

void xMousePrint(XEvent event, int style, FILE *mpicksfp,
		 int x, int y, int width, int height,
		 float x1begb, float x1endb, float x2begb, float x2endb)
{
	float x1,x2;

	/* convert mouse location to (x1,x2) coordinates */
	if (style==NORMAL) {
		x1 = x1begb+(x1endb-x1begb)*(event.xmotion.x-x)/width;
		x2 = x2endb+(x2begb-x2endb)*(event.xmotion.y-y)/height;
	} else {
		x1 = x1begb+(x1endb-x1begb)*(event.xmotion.y-y)/height;
		x2 = x2begb+(x2endb-x2begb)*(event.xmotion.x-x)/width;
	}

	/* write string indicating mouse location */
	fprintf(mpicksfp, "%0.6g  %0.6g\n", x1, x2);
}

float getamp(float *zz,float f1,float d1,int n1,
             float f2,float d2,int n2,float x1,float x2,int verbose)

/*****************************************************************************
return the amplitude value at x1,x2
******************************************************************************
Input:
zz		zz(n1*nz) is the data
f1		coordinate in first x
d1		x coordinate increment
n1		number samples in x
f2		coordinate in first y
d2		y coordinate increment
n2		number samples in y
x1              x1 coordinate of the probed point
x2              x2 coordinate of the probed point
******************************************************************************
Author: Zhaobo Meng, ConocoPhillips, Feb. 03,2004
*****************************************************************************/
{
        float x1last,x2last,x1i,x2i,xfrac,zfrac,xfrac0,zfrac0,temp;
        int ix1,ix2,i00;

        if (d1==0.0) err("d1 can not be 0.0");
        if (d2==0.0) err("d2 can not be 0.0");

	x1last = f1 + (n1-1)*d1;
	if (x1<f1 || x1>x1last) return -999.0; 	
	x2last = f2 + (n2-1)*d2;
	if (x2<f2 || x2>x2last) return -999.0; 	

        x1i = (x1-f1)/d1;
        ix1 = MIN(x1i,n1-1);
        xfrac = x1i-ix1;
        xfrac0 = 1.0-xfrac;

        x2i = (x2-f2)/d2;
        ix2 = MIN(x2i,n2-1);
        zfrac = x2i-ix2;
        zfrac0 = 1.0-zfrac;

        i00 = ix1 + n1*ix2;
        temp = zfrac *( xfrac*zz[i00+1+n1] + xfrac0*zz[i00+n1])
             + zfrac0*( xfrac*zz[i00+1   ] + xfrac0*zz[i00   ]);

        /*
        if (verbose) warn("x1=%g x2=%g,value=%g,ix1=%d,ix2=%d f1=%g d1=%g n1=%d f2=%g d2=%g n2=%d",
          x1,x2,temp,ix1,ix2,f1,d1,n1,f2,d2,n2);
        */

        return(temp);
}
@


1.46
log
@copyright
@
text
@d4 1
a4 4
/* Copyright (c) Colorado School of Mines, 2011.*/
/* All rights reserved.                       */

/* XIMAGE: $Revision: 1.45 $ ; $Date: 2011/11/12 00:48:17 $	*/
d419 1
@


1.45
log
@copyright
@
text
@d4 4
a7 1
/* XIMAGE: $Revision: 1.44 $ ; $Date: 2011/09/09 22:36:52 $	*/
@


1.44
log
@*** empty log message ***
@
text
@d1 4
a4 1
/* XIMAGE: $Revision: 1.43 $ ; $Date: 2005/10/04 17:28:06 $	*/
@


1.43
log
@*** empty log message ***
@
text
@d1 1
a1 1
/* XIMAGE: $Revision: 1.42 $ ; $Date: 2005/10/04 16:56:08 $	*/
d317 1
a317 1
		balance=1 ; getparint("balance",&balance);
@


1.42
log
@Garry Parrat's balance added
@
text
@d1 1
a1 1
/* XIMAGE: $Revision: 1.40 $ ; $Date: 2005/03/21 18:03:03 $	*/
d55 2
a56 1
" balance=0		 set bclip & wclip to the same abs values	",
a57 1
"			 =0 set them individually			",
d317 1
a317 1
		balance=0 ; getparint("balance",&balance);
d320 9
a328 2
		if (balance==0) for (iz=0; iz<nz; iz++) temp[iz] = z[iz];
		else for (iz=0; iz<nz; iz++) temp[iz] = abs(z[iz]);
d346 1
a346 1
			else wclip = bclip * -1;
@


1.41
log
@*** empty log message ***
@
text
@d55 3
d133 2
d175 1
d317 1
d319 4
a322 2
		for (iz=0; iz<nz; iz++)
			temp[iz] = z[iz];
d337 4
a340 1
			wclip = temp[iz];
@


1.40
log
@fseeko's returned to efsseeek
[A[D0o
@
text
@d1 1
a1 1
/* XIMAGE: $Revision: 1.39 $ ; $Date: 2005/02/02 00:12:31 $	*/
d173 3
d501 15
a515 3
	for (i=0; i<lwidth*lheight; i++){
	data_legend[i] = (unsigned char) (0 + (255+1)*(i/lwidth*1.0)/(1.0*lheight));
/*	fprintf(stderr," %d ",data_legend[i]);*/
@


1.39
log
@Zhaobo's 1 Feb update
@
text
@d1 1
a1 1
/* XIMAGE: $Revision: 1.38 $ ; $Date: 1999/02/23 01:00:00 $	*/
d229 3
a231 2
		if (efseeko(infp, (off_t) 0,SEEK_END)!=0)
			err("must specify n2 if in a pipe!\n");
@


1.38
log
@Gerald Klein addition
@
text
@d1 1
a1 1
/* XIMAGE: $Revision: 1.5 $ ; $Date: 2004/03/29 12:03:03 $	*/
d8 4
d15 1
a15 1
" XIMAGE - X IMAGE plot of a uniformly-sampled function f(x1,x2)       	",
d17 1
a17 1
" ximage n1= [optional parameters] <binaryfile				",
d60 1
a60 1
" legend=0	      =1 display the color scale			",
d63 36
a98 36
" verbose=1		 =1 for info printed on stderr (0 for no info)	",
" xbox=50		 x in pixels of upper left corner of window	",
" ybox=50		 y in pixels of upper left corner of window	",
" wbox=550		 width in pixels of window			",
" hbox=700		 height in pixels of window			",
" lwidth=16		 colorscale (legend) width in pixels		",
" lheight=hbox/3	 colorscale (legend) height in pixels		",
" lx=3			 colorscale (legend) x-position in pixels	",
" ly=(hbox-lheight)/3    colorscale (legend) y-position in pixels	",
" x1beg=x1min		 value at which axis 1 begins			",
" x1end=x1max		 value at which axis 1 ends			",
" d1num=0.0		 numbered tic interval on axis 1 (0.0 for automatic)",
" f1num=x1min		 first numbered tic on axis 1 (used if d1num not 0.0)",
" n1tic=1		 number of tics per numbered tic on axis 1	",
" grid1=none		 grid lines on axis 1 - none, dot, dash, or solid",
" label1=		 label on axis 1				",
" x2beg=x2min		 value at which axis 2 begins			",
" x2end=x2max		 value at which axis 2 ends			",
" d2num=0.0		 numbered tic interval on axis 2 (0.0 for automatic)",
" f2num=x2min		 first numbered tic on axis 2 (used if d2num not 0.0)",
" n2tic=1		 number of tics per numbered tic on axis 2	",
" grid2=none		 grid lines on axis 2 - none, dot, dash, or solid",
" label2=		 label on axis 2				",
" labelfont=Erg14	 font name for axes labels			",
" title=		 title of plot					",
" titlefont=Rom22	 font name for title				",
" windowtitle=ximage	 title on window				",
" labelcolor=blue	 color for axes labels				",
" titlecolor=red	 color for title				",
" gridcolor=blue	 color for grid lines				",
" style=seismic		 normal (axis 1 horizontal, axis 2 vertical) or ",
"			 seismic (axis 1 vertical, axis 2 horizontal)	",
" blank=0		 This indicates what portion of the lower range ",
"			 to blank out (make the background color).  The ",
"			 value should range from 0 to 1.		",
" plotfile=plotfile.ps   filename for interactive ploting (P)  		",
d128 2
d144 3
a146 1
	float x1begb, float x1endb, float x2begb, float x2endb);
d181 1
a181 1
		
d286 6
d298 1
a298 1
	
d562 1
a562 1
	
d594 1
a594 1
			/* draw curve on top of image */
d603 1
a603 1
			/* draw axes on top of image */
d978 1
a978 1
					    
d1039 2
a1040 2
				
				/* pipe data to psimage and write to plotfile *GK*/
d1163 10
a1172 1
					  x2begb,x2endb);
d1184 3
a1186 2
					x,y,width,height,
					x1begb,x1endb,x2begb,x2endb);
d1209 1
a1209 1
	free1float(z);
d1384 1
a1384 1
	
d1387 3
a1389 1
	float x1begb, float x1endb, float x2begb, float x2endb)
d1395 1
a1395 1
	float x1,x2;
d1430 5
a1434 1
	sprintf(string,"(%0.6g,%0.6g)",x1,x2);
d1457 53
@


1.37
log
@changed curve drawing to be compatible with the curve picking convention
@
text
@d1 1
a1 1
/* XIMAGE: $Revision: 1.35 $ ; $Date: 1997/07/29 15:42:44 $	*/
d21 5
d94 5
a98 3
" curve=curve1,curve2,...  file(s) containing points to draw curve(s)	",
" npair=n1,n2,n2,...	   	number(s) of pairs in each file		",
" curvecolor=color1,color2,...	color(s) for curve(s)			",
d102 5
a106 6
" Currently, the curve file must have the number of points specified	",
" at the top of the file.  This file is an ascii file with the points	",
" specified as (x1,x2) pairs, one pair to a line.  A \"vector\" of curve",
" files and curve colors may be specified as curvefile=file1,file2,etc.	",
" and curvecolor=color1,color2,etc, and the number of pairs of values	",
" in each file as npair=npair1,npair2,... .				",
d121 3
a123 3
 *
 * Baoniu Han, CWP, Jan 1999, extended graphics from 8 bit to 16,...
 *							
d135 1
a135 1
	int n1out, int n2out);
d142 6
d163 3
d168 1
a168 1
		d1,f1,d2,f2,*z,*temp,zscale,zoffset,zi,
d172 2
a173 1
		x1begb,x1endb,x2begb,x2endb,blank;
d194 12
a205 5
	float **x1curve,**x2curve;
	int curve,*npair,ncurvecolor;
	char **curvefile,**curvecolor;
	FILE *curvefp;

d221 1
a221 1
		if (fseek(infp,0L,2)!=0)
d223 2
a224 2
		nfloats = eftell(infp)/sizeof(float);
		efseek(infp,0L,0);
d232 3
a239 1
	/* ... get curve files */
d247 2
a248 2
		npair=ealloc1int(curve);
		getparint("npair",npair);
a254 2

	/* ... get curve colors */
d258 1
a258 1
			curvecolor[0]=(char *)strdup("blue\0");
d262 2
a263 2
			curvecolor[i]=(char *)strdup(curvecolor[ncurvecolor-1]);
	} else {
a266 2


d269 1
a270 1
		x1curve[j]=ealloc1float(npair[j]);
d281 1
d284 1
a284 1

d322 4
d427 1
a427 1
	free1float(z);
d430 2
d478 1
a478 1
warn("pmin=%x,pmax=%x\n",pmin,pmax);
d481 1
a481 1
warn("pmin=%x,pmax=%x\n",pmin,pmax);
d484 1
a484 2
	data_legend[i] = (unsigned char) (0 +
(255+1)*(i/lwidth*1.0)/(1.0*lheight));
d546 3
a548 3
				if (czbi!=NULL) free1(czbi);
				czbi = newInterpBytes(nxb,nyb,czb,
					width,height);
d604 2
d610 355
d970 1
a970 1
				char cmdline[1024], cmdtemp[256];
d973 1
d975 1
a975 1
				efseek(infp,0L,0);
d1021 3
d1025 7
a1031 1
				system(cmdline);
d1185 1
d1237 1
a1237 1
	int n1out, int n2out)
d1247 9
a1255 1
	intl2b(n1in,d1in,f1in,n2in,d2in,f2in,bin,
d1257 2
d1260 99
@


1.36
log
@Brian Macy's curve drawing materials
@
text
@d89 3
a91 2
" curve= 		 file(s) containing points to draw curve(s)	",
" curvecolor=		 color for curve(s)				",
d97 1
a97 1
" specified as (x2,x1) pairs, one pair to a line.  A \"vector\" of curve	",
d99 2
a100 1
" and curvecolor=color1,color2,etc.					",
d116 2
d173 1
a173 1
	char *data_legend; /* BEREND */
d177 1
d179 1
a179 1
	int curve,*ncurve,ncurvecolor;
d214 1
d222 2
a223 1
		ncurve=ealloc1int(curve);
d225 1
a225 1
		ncurve=(int *)NULL;
d230 2
d235 1
a235 1
			curvecolor[0]=strdup("blue\0");
d239 1
a239 1
			curvecolor[i]=strdup(curvecolor[ncurvecolor-1]);
d244 2
d248 4
a251 4
		fscanf(curvefp,"%d",&ncurve[j]);
		x2curve[j]=ealloc1float(ncurve[j]);
		x1curve[j]=ealloc1float(ncurve[j]);
		for (i=0; i<ncurve[j]; i++) {
a252 1
			fscanf(curvefp,"%f",&x1curve[j][i]);
d450 2
d453 6
a458 8
	/* BEREND create image */
	if (legend) {
	    data_legend = (char *) malloc(lwidth * lheight);
	    for (i=0; i<lwidth*lheight; i++)
		data_legend[i] = (char) (pmin + (pmax-pmin+1)*(i/lwidth)/lheight);
	    image_legend = XCreateImage(dpy, DefaultVisual(dpy,scr),
		DefaultDepth(dpy,scr), ZPixmap,
		0, data_legend, lwidth, lheight, BitmapPad(dpy), lwidth);
d525 7
d559 1
a559 1
					   x1curve[i],x2curve[i],ncurve[i],
d639 10
a648 3
				XSetWindowColormap(dpy,win,
					xCreateRGBColormap(dpy,win,"rgb_up",
					verbose));
d650 10
a659 3
				XSetWindowColormap(dpy,win,
					xCreateRGBColormap(dpy,win,"rgb_down",
					verbose));
d661 11
a671 3
				XSetWindowColormap(dpy,win,
					xCreateHSVColormap(dpy,win,"hsv_up",
					verbose));
d673 11
a683 3
				XSetWindowColormap(dpy,win,
					xCreateHSVColormap(dpy,win,"hsv_down",
					verbose));			
d781 1
a781 1
		free1int(ncurve);
@


1.35
log
@Levin fixes for SGI
@
text
@d1 1
a1 1
/* XIMAGE: $Revision: 1.34 $ ; $Date: 1996/10/16 15:54:29 $	*/
d89 10
d112 2
d173 5
d206 40
a245 1
		mpicksfp = efopen(mpicks, "w");
d535 10
a544 1
			
d733 11
@


1.34
log
@changed legend placement
@
text
@d1 1
a1 1
/* XIMAGE: $Revision: 1.33 $ ; $Date: 1996/10/04 15:03:21 $	*/
d124 1
a124 1
	int n1,n2,n1tic,n2tic,nfloats,
d135 1
d180 1
a180 1
		n2 = nfloats/n1;
d353 1
a353 1
	win = xNewWindow(dpy,xbox,ybox,wbox,hbox,black,white,windowtitle);
d360 1
a360 1
		free1(cmap);
d367 1
a367 1
			free1(cmap);
d389 1
a389 1
		data_legend[i] = pmin + (pmax-pmin+1)*(i/lwidth)/lheight;
d424 1
a424 1
	while(True) {
d778 1
a778 1
	XTextExtents(fs,string,strlen(string),&dummy,&dummy,&dummy,&overall);
d780 1
a780 1
		string,strlen(string));
@


1.33
log
@cosmetic changes to selfdoc
@
text
@d1 1
a1 1
/* XIMAGE: $Revision: 1.32 $ ; $Date: 1996/10/02 21:45:50 $	*/
d60 1
a60 1
" lheight=3*hbox/4	 colorscale (legend) height in pixels		",
d62 1
a62 1
" ly=(hbox-lheight)/2    colorscale (legend) y-position in pixels	",
d80 1
a80 1
" windowtitle=xwigb	 title on window				",
d248 1
a248 1
	if (!(getparint("lheight",&lheight)))	lheight = 3*hbox/4;
d250 1
a250 1
	if (!(getparint("ly",&ly)))	ly = (hbox-lheight)/2;
@


1.32
log
@small typo correction
@
text
@d1 1
a1 1
/* XIMAGE: $Revision: 1.31 $ ; $Date: 1996/10/02 17:02:41 $	*/
d46 2
a47 2
" cmap=hsv\'n\' or rgb\'m\'	\'n\' is a number between 0 and 3	",
"				\'m\' is a number between 0 and 11	",
d51 3
a53 3
" legend=0              =1 display the color scale                     ",
" units=		unit label for legend                          ",
" legendfont=times_roman10    font name for title                       ",
d155 2
a156 2
        XImage *image_legend=NULL; /* BEREND */
        char *data_legend; /* BEREND */
d233 1
a233 1
        /* get legend specs BEREND */
d384 9
a392 9
        /* BEREND create image */
        if (legend) {
            data_legend = (char *) malloc(lwidth * lheight);
            for (i=0; i<lwidth*lheight; i++)
                data_legend[i] = pmin + (pmax-pmin+1)*(i/lwidth)/lheight;
            image_legend = XCreateImage(dpy, DefaultVisual(dpy,scr),
                DefaultDepth(dpy,scr), ZPixmap,
                0, data_legend, lwidth, lheight, BitmapPad(dpy), lwidth);
        }
d465 13
a477 13
                        /* BEREND display image */
                        if (legend)
                                XPutImage(dpy,win,gci,image_legend,
                                        0,0,lx,y+ly,lwidth,lheight);

                        /* BEREND draw legend axes on top of image */
                        if (legend)
                                xDrawLegendBox(dpy,win,
                                        lx,y+ly,lwidth,lheight,
                                        bclip,wclip,units,legendfont,
                                        labelfont,title,titlefont,
                                        labelcolor,titlecolor,gridcolor,
                                        style);
@


1.31
log
@added Berend Sheffer's legend (i.e. colormap) stuff
@
text
@d1 1
a1 1
/* XIMAGE: $Revision: 1.30 $ ; $Date: 1996/09/26 16:28:38 $	*/
d51 2
a52 2
" legend=0               =1 display the color scale                     ",
" legendunits            unit label for legend                          ",
d60 1
a60 1
" lheight=3*wbox/4	 colorscale (legend) height in pixels		",
d248 1
a248 1
	if (!(getparint("lheight",&lheight)))	lheight = 3*wbox/4;
@


1.30
log
@modified structure of colormap selections to be more like other
codes.
@
text
@d1 1
a1 1
/* XIMAGE: $Revision: 1.29 $ ; $Date: 1996/09/25 17:01:30 $	*/
d51 3
d59 4
d99 3
d133 2
a134 1
		showloc=0;
d143 1
d155 2
d233 4
d245 7
d383 10
d464 14
@


1.29
log
@put in a variation on Toralf's fix for cmap=gray, cmap=hue, and
the failure of gray to be the default.
@
text
@d1 1
a1 1
/* XIMAGE: $Revision: 1.28 $ ; $Date: 1996/09/23 20:01:28 $	*/
d22 7
a28 5
" r             install next RGB - colormap				",
" R             install previous RGB - colormap				",
" h             install next HSV - colormap				",
" H             install previous HSV - colormap				",
" H             install previous HSV - colormap				",
d215 5
a219 1
	getparstring("cmap",&cmap);
d329 1
a329 1
	/* backwards compatibility 				*/
d332 4
a335 2
	}
	else if (STREQ(cmap,"hue")) {
d337 8
a344 6
	} else if (!(strncmp(cmap,"rgb",3) || strncmp(cmap,"hsv",3))
			|| STREQ(cmap,"")){
              	 if (verbose) warn ("cmap=%s using cmap=gray", cmap);
			cmap = (char *)alloc1(4,1);
               		sprintf (cmap, "%s", "rgb0");
	}
d346 1
d349 2
a350 2
                XSetWindowColormap(dpy,win,
                	xCreateRGBColormap(dpy,win, cmap, verbose));
d352 2
a353 2
                XSetWindowColormap(dpy,win,
                	xCreateHSVColormap(dpy,win, cmap, verbose));
@


1.28
log
@Toralf's new colormaps.
@
text
@d1 1
a1 1
/* XIMAGE: $Revision: 1.27 $ ; $Date: 1996/09/09 19:36:09 $	*/
d324 11
a334 6
	if (STREQ(cmap,"gray"))
		XSetWindowColormap(dpy,win,
                	xCreateRGBColormap(dpy,win, "rgb0", verbose));
	else if (STREQ(cmap,"hue"))
		XSetWindowColormap(dpy,win,
                	xCreateHSVColormap(dpy,win, "hsv1", verbose));
d337 1
a337 1
	else if (strncmp (cmap, "rgb", 3) == 0)
a342 4
        
        /* what else ?				*/
        else if (strlen (cmap) > 0)
        	warn ("cmap=%s not implemented, use installed", cmap);
@


1.27
log
@silenced a couple of -Wall messages
@
text
@d1 1
a1 1
/* XIMAGE: $Revision: 1.26 $ ; $Date: 1996/07/01 16:00:29 $	*/
d22 6
d44 5
a48 1
" cmap=gray		 gray, hue, or default colormaps may be specified",
d88 2
d133 1
a133 1
		*gridcolor="blue",*cmap="gray",keybuf[256],*mpicks;
d323 19
a341 6
	/* if necessary, create private colormap with gray scale */
	if (STREQ(cmap,"gray")) {
		XSetWindowColormap(dpy,win,xCreateGrayColormap(dpy,win));
	} else if (STREQ(cmap,"hue")) {
		XSetWindowColormap(dpy,win,xCreateHueColormap(dpy,win));
	}
d494 16
@


1.26
log
@Removed the xnewimage function to the lib image.c.
@
text
@d1 1
a1 1
/* XIMAGE: $Revision: 1.25 $ ; $Date: 1996/06/27 22:00:50 $	*/
d97 2
a98 2
main (argc,argv)
int argc; char **argv;
d496 1
a496 1
				/* else, if new box has non-zero width
d565 2
@


1.25
log
@Cosmetic (removed blanks before ;).
@
text
@d1 1
a1 1
/* XIMAGE: $Revision: 1.24 $ ; $Date: 1996/06/27 21:47:13 $	*/
a95 3
static XImage *zxNewImage (Display *dpy, unsigned long pmin,
	unsigned long pmax, int width, int height, float blank,
	unsigned char *bytes);
d384 1
a384 1
				image = zxNewImage(dpy,pmin,pmax,
a694 64
}


static XImage *zxNewImage (Display *dpy, unsigned long pmin,
			   unsigned long pmax, int width, int height,
			   float blank, unsigned char *bytes)
/*****************************************************************************
make a new image of pixels from bytes
******************************************************************************
Input:
dpy		display pointer
pmin		minimum pixel value (corresponding to byte=0)
pmax		maximum pixel value (corresponding to byte=255)
width		number of bytes in x dimension
height		number of bytes in y dimension
blank		Portion for blanking (0 to 1)
bytes		unsigned bytes to be mapped to an image
******************************************************************************
Author:		 Brian Zook, Southwest Research Institute, 6/27/96
*****************************************************************************/
{
	int scr=DefaultScreen(dpy);
	int i,j,k,line,iline,jline,widthpad;
	float base,scale;
	unsigned char map[256],bkgnd;
	unsigned char *data;

	/* build map for translating bytes to pixels */
	base = pmin+0.499;
	scale = (pmax-pmin)/255.0;
	for (i=0; i<=255; ++i)
		map[i] = base+i*scale;
	
	/* Blanking */
	bkgnd = WhitePixel(dpy,scr);
	j = MAX(0,MIN(256,(int)(256*blank)));
	for (i = 0 ; i < j ; i++)
		map[255-i] = bkgnd;

	/* allocate memory for image data */
	widthpad = (1+(width-1)/(BitmapPad(dpy)/8))*BitmapPad(dpy)/8;
	data = ealloc1(widthpad*height,sizeof(unsigned char));

	/* translate bytes to pixels, padding scanlines as necessary */
	for (line=0; line<height; line++) {
		iline = line*width;
		jline = line*widthpad;
		for (i=iline,j=jline,k=0; k<width; ++i,++j,++k)
			data[j] = map[bytes[i]];
		for (j=jline+width,k=width; k<widthpad; ++j,++k)
			data[j] = data[jline+width-1];
	}
	
	/* create and return image structure */
	return XCreateImage(	(Display *) dpy,
				(Visual *) DefaultVisual(dpy,scr),
				(unsigned int) DefaultDepth(dpy,scr),
				(int) ZPixmap,
				(int) 0,
				(char *) data,
				(unsigned int) widthpad,
				(unsigned int) height,
				(int) BitmapPad(dpy),
				(int) widthpad);
@


1.24
log
@Added Brian Zook's blank option.  Should extract his imagemaking
sub to image.c sometime (zxNewImage).
@
text
@d1 1
a1 1
/* XIMAGE: $Revision: 1.30 $ ; $Date: 1996/02/27 20:27:49 $	*/
d98 1
a98 1
	unsigned char *bytes) ;
d205 1
a205 1
	blank = 0 ; getparfloat("blank",&blank) ;
d732 2
a733 2
	bkgnd = WhitePixel(dpy,scr) ;
	j = MAX(0,MIN(256,(int)(256*blank))) ;
d735 1
a735 1
		map[255-i] = bkgnd ;
@


1.23
log
@pswigp option set wbox twice, should have been hbox the second time.
Thx to Stew for fixing his bug.
@
text
@d1 1
a1 1
/* ximage - X image plot of uniformly sampled 2D data */
d10 3
a12 3
" 									",
" XIMAGE - X IMAGE plot of a uniformly-sampled function f(x1,x2)		",
" 									",
d14 1
a14 1
" 									",
d18 1
a18 1
" q or Q key	Quit 							",
d20 2
a21 2
" p or P key	Plot current window with pswigb	(only from disk files)	",
" 									",
d23 2
a24 2
" n1                     number of samples in 1st (fast) dimension	",
" 									",
d26 7
a32 7
" d1=1.0                 sampling interval in 1st dimension		",
" f1=0.0                 first sample in 1st dimension			",
" n2=all                 number of samples in 2nd (slow) dimension	",
" d2=1.0                 sampling interval in 2nd dimension		",
" f2=0.0                 first sample in 2nd dimension			",
" mpicks=/dev/tty        file to save mouse picks in			",
" perc=100.0             percentile used to determine clip		",
d34 37
a70 33
" bperc=perc             percentile for determining black clip value	",
" wperc=100.0-perc       percentile for determining white clip value	",
" bclip=clip             data values outside of [bclip,wclip] are clipped",
" wclip=-clip            data values outside of [bclip,wclip] are clipped",
" cmap=gray              gray, hue, or default colormaps may be specified",
" verbose=1              =1 for info printed on stderr (0 for no info)	",
" xbox=50                x in pixels of upper left corner of window	",
" ybox=50                y in pixels of upper left corner of window	",
" wbox=550               width in pixels of window			",
" hbox=700               height in pixels of window			",
" x1beg=x1min            value at which axis 1 begins			",
" x1end=x1max            value at which axis 1 ends			",
" d1num=0.0              numbered tic interval on axis 1 (0.0 for automatic)",
" f1num=x1min            first numbered tic on axis 1 (used if d1num not 0.0)",
" n1tic=1                number of tics per numbered tic on axis 1	",
" grid1=none             grid lines on axis 1 - none, dot, dash, or solid",
" label1=                label on axis 1				",
" x2beg=x2min            value at which axis 2 begins			",
" x2end=x2max            value at which axis 2 ends			",
" d2num=0.0              numbered tic interval on axis 2 (0.0 for automatic)",
" f2num=x2min            first numbered tic on axis 2 (used if d2num not 0.0)",
" n2tic=1                number of tics per numbered tic on axis 2	",
" grid2=none             grid lines on axis 2 - none, dot, dash, or solid",
" label2=                label on axis 2				",
" labelfont=Erg14        font name for axes labels			",
" title=                 title of plot					",
" titlefont=Rom22        font name for title				",
" windowtitle=xwigb      title on window				",
" labelcolor=blue        color for axes labels				",
" titlecolor=red         color for title				",
" gridcolor=blue         color for grid lines				",
" style=seismic          normal (axis 1 horizontal, axis 2 vertical) or	",
"                        seismic (axis 1 vertical, axis 2 horizontal)	",
d76 2
d96 3
d118 1
a118 1
		x1begb,x1endb,x2begb,x2endb;
d205 1
d301 2
a302 2
	x1begb = x1beg;  x1endb = x1end;
	x2begb = x2beg;  x2endb = x2end;
d387 2
a388 2
				image = xNewImage(dpy,pmin,pmax,
					width,height,czbi);
d698 64
@


1.22
log
@Make formats for Mouse-2 and 's' saves consistent and more accurate.
Per suggestion of Toralf's and takes advantage of Alexander's previous
fix.
@
text
@d431 1
a431 1
				sprintf(cmdtemp," wbox=%g", cmdfloat*height);
@


1.21
log
@Added ps print option -- Stew Levin
@
text
@d665 1
a665 1
	sprintf(string,"(%0.4g,%0.4g)",x1,x2);
d687 1
a687 1
	fprintf(mpicksfp, "%0.4g  %0.4g\n", x1, x2);
@


1.20
log
@Changed f1,f2 defaults to 0.0.
@
text
@d20 1
d68 5
d408 54
@


1.19
log
@Corrected self-doc re disposition of picks.
@
text
@d26 1
a26 1
" f1=d1                  first sample in 1st dimension			",
d29 1
a29 1
" f2=d2                  first sample in 2nd dimension			",
d129 1
a129 1
	f1 = d1;  getparfloat("f1",&f1);
d142 1
a142 1
	f2 = d2;  getparfloat("f2",&f2);
@


1.18
log
@Added windowtitle parameter (useful when iconify window).
@
text
@d19 1
a19 1
" s key		Save current mouse (x1,x2) location to stdout		",
@


1.17
log
@Eliminated superfluous args in xMousePrint.
@
text
@d60 1
d105 1
a105 1
	char *label1="",*label2="",*title="",
d229 1
d296 1
a296 1
	win = xNewWindow(dpy,xbox,ybox,wbox,hbox,black,white,"ximage");
@


1.16
log
@Quit on q as well as Q.
@
text
@d80 2
a81 2
void xMousePrint(Display *dpy, Window win, XEvent event, int style,
	FILE *mpicksfp, int x, int y, int width, int height,
d394 3
a396 3
				xMousePrint(dpy,win,event,style,
					mpicksfp, x,y,width,height,
					x1begb,x1endb,x2begb,x2endb);
d609 3
a611 3
void xMousePrint(Display *dpy, Window win, XEvent event, int style,
	FILE *mpicksfp, int x, int y, int width, int height,
	float x1begb, float x1endb, float x2begb, float x2endb)
@


1.15
log
@changed event to (event.xkey)
@
text
@d18 1
a18 1
" Q key		Quit (can also use Motif Action button)			",
d397 1
a397 1
			} else if (keysym==XK_Q) {
@


1.14
log
@added dummy selfdocs for updatedoc to grab onto
@
text
@d392 1
a392 1
			XLookupString(&event,keybuf,0,&keysym,&keystat);
@


1.13
log
@new selfdoc installed
@
text
@@


1.12
log
@Explicitly set foreground/background to black/white.
@
text
@d1 2
d8 59
a66 57
/* self-documentation */
char *sdoc = 
"XIMAGE - X IMAGE plot of a uniformly-sampled function f(x1,x2)\n"
"\n"
"ximage n1= [optional parameters] <binaryfile\n"
"\n"
"X Functionality:\n"
"Button 1	Zoom with rubberband box\n"
"Button 2	Show mouse (x1,x2) coordinates while pressed\n"
"Q key		Quit (can also use Motif Action button)\n"
"s key		Save current mouse (x1,x2) location to stdout\n"
"\n"
"Required Parameters:\n"
"n1                     number of samples in 1st (fast) dimension\n"
"\n"
"Optional Parameters:\n"
"d1=1.0                 sampling interval in 1st dimension\n"
"f1=d1                  first sample in 1st dimension\n"
"n2=all                 number of samples in 2nd (slow) dimension\n"
"d2=1.0                 sampling interval in 2nd dimension\n"
"f2=d2                  first sample in 2nd dimension\n"
"mpicks=/dev/tty        file to save mouse picks in\n"
"perc=100.0             percentile used to determine clip\n"
"clip=(perc percentile) clip used to determine bclip and wclip\n"
"bperc=perc             percentile for determining black clip value\n"
"wperc=100.0-perc       percentile for determining white clip value\n"
"bclip=clip             data values outside of [bclip,wclip] are clipped\n"
"wclip=-clip            data values outside of [bclip,wclip] are clipped\n"
"cmap=gray              gray, hue, or default colormaps may be specified\n"
"verbose=1              =1 for info printed on stderr (0 for no info)\n"
"xbox=50                x in pixels of upper left corner of window\n"
"ybox=50                y in pixels of upper left corner of window\n"
"wbox=550               width in pixels of window\n"
"hbox=700               height in pixels of window\n"
"x1beg=x1min            value at which axis 1 begins\n"
"x1end=x1max            value at which axis 1 ends\n"
"d1num=0.0              numbered tic interval on axis 1 (0.0 for automatic)\n"
"f1num=x1min            first numbered tic on axis 1 (used if d1num not 0.0)\n"
"n1tic=1                number of tics per numbered tic on axis 1\n"
"grid1=none             grid lines on axis 1 - none, dot, dash, or solid\n"
"label1=                label on axis 1\n"
"x2beg=x2min            value at which axis 2 begins\n"
"x2end=x2max            value at which axis 2 ends\n"
"d2num=0.0              numbered tic interval on axis 2 (0.0 for automatic)\n"
"f2num=x2min            first numbered tic on axis 2 (used if d2num not 0.0)\n"
"n2tic=1                number of tics per numbered tic on axis 2\n"
"grid2=none             grid lines on axis 2 - none, dot, dash, or solid\n"
"label2=                label on axis 2\n"
"labelfont=Erg14        font name for axes labels\n"
"title=                 title of plot\n"
"titlefont=Rom22        font name for title\n"
"labelcolor=blue        color for axes labels\n"
"titlecolor=red         color for title\n"
"gridcolor=blue         color for grid lines\n"
"style=seismic          normal (axis 1 horizontal, axis 2 vertical) or\n"
"                       seismic (axis 1 vertical, axis 2 horizontal)\n"
"\n";
d122 1
a122 1
	askdoc(1);
@


1.11
log
@Changed refresh condition to <4 pixels from ==0 pixels
@
text
@a559 1
	XGCValues values;
d570 6
a575 1
		gc = XCreateGC(dpy,win,0,&values);
@


1.10
log
@Mouse tracking on button2 instead of ctrl-key toggle.
@
text
@d409 2
a410 2
				/* if new box has zero width or height */
				if (wb==0 || hb==0) {
@


1.9
log
@Changed X capability.  Now exit only on Q, etc. 
@
text
@d12 1
a12 1
"X Capability:\n"
d14 1
a14 1
"Crtl key	Toggle on/off display of mouse (x1,x2) coordinates\n"
d16 1
a16 1
"s key		Save current mouse (x1,x2) location to user's mpicks file\n"
a310 1
		KeyReleaseMask |
d314 2
a315 1
		Button1MotionMask);
a387 1
			/* Toggle mouse tracking */
d389 1
a389 7
			if (keysym==XK_Control_L) {
				showloc = !showloc;
				if (showloc)
					xMouseLoc(dpy,win,event,style,showloc,
						x,y,width,height,
						x1begb,x1endb,x2begb,x2endb);
			} else if (keysym==XK_s) {
a399 9
		/* else if key up */
		} else if (event.type==KeyRelease) {
			/*
			if (event.xkey.state&ControlMask) {
				xMouseLoc(dpy,win,event,style,False,
					x,y,width,height,
					x1begb,x1endb,x2begb,x2endb);
			}
			*/
d401 4
a404 12
		/* else if pointer has moved */
		} else if (event.type==MotionNotify) {
			
			/* if control key down, show mouse location */
			/*
			if (event.xmotion.state&ControlMask) {
			*/
			if (showloc) {
				xMouseLoc(dpy,win,event,style,True,
					x,y,width,height,
					x1begb,x1endb,x2begb,x2endb);
			}
d406 2
a407 7
		/* else if 1st button down */
		} else if (event.type==ButtonPress &&
			event.xbutton.button==Button1) {

			/* track pointer and get new box */
			xRubberBox(dpy,win,event,
				&xb,&yb,&wb,&hb);
d409 13
a421 2
			/* if new box has zero width or height */
			if (wb==0 || hb==0) {
d423 3
a425 10
				/* reset box to initial values */
				x1begb = x1beg;
				x1endb = x1end;
				x2begb = x2beg;
				x2endb = x2end;
				nxb = nx;
				nyb = ny;
				ixb = iyb = 0;
				if (czb!=cz) free1(czb);
				czb = cz;
d427 16
a442 2
			/* else, if new box has non-zero width and height */
			} else {
d444 9
a452 15
				/* calculate new box parameters */
				if (style==NORMAL) {
					zoomBox(x,y,width,height,
						xb,yb,wb,hb,
						nxb,ixb,x1begb,x1endb,
						nyb,iyb,x2endb,x2begb,
						&nxb,&ixb,&x1begb,&x1endb,
						&nyb,&iyb,&x2endb,&x2begb);
				 } else {
					zoomBox(x,y,width,height,
						xb,yb,wb,hb,
						nxb,ixb,x2begb,x2endb,
						nyb,iyb,x1begb,x1endb,
						&nxb,&ixb,&x2begb,&x2endb,
						&nyb,&iyb,&x1begb,&x1endb);
d455 16
a470 8
				/* make new bytes in zoombox */
				if (czb!=cz) free1(czb);
				czb = ealloc1(nxb*nyb,sizeof(signed char));
				for (i=0,czbp=czb; i<nyb; i++) {
					czp = cz+(iyb+i)*nx+ixb;
					for (j=0; j<nxb; j++)
						*czbp++ = *czp++; 
				}
d472 3
d476 10
a485 5
			/* clear area and force an expose event */
			XClearArea(dpy,win,0,0,0,0,True);
			
			/* note that image is out of date */
			imageOutOfDate = 1;
d487 2
a488 1
	}
@


1.8
log
@Changed some showloc lines (dave, but logged by jkc).
@
text
@d12 6
d27 1
d76 3
d104 2
a105 2
		*gridcolor="blue",*cmap="gray",keybuf[256];
	FILE *infp=stdin;
d141 4
d387 2
d396 7
d404 1
a404 1
				break;
d599 19
@


1.7
log
@added cmap option to specify a colormap (choice of 3).
@
text
@d81 2
a82 1
		imageOutOfDate,winwidth=-1,winheight=-1;
d375 5
a379 3
				xMouseLoc(dpy,win,event,style,True,
					x,y,width,height,
					x1begb,x1endb,x2begb,x2endb);
d386 1
d392 1
d398 1
d400 2
@


1.6
log
@Added option to report mouse position when left control key is pressed.
@
text
@d27 1
d93 1
a93 1
		*gridcolor="blue",keybuf[256];
a101 1
	Colormap cmap;
d168 3
d277 6
a282 3
	/* create private colormap with gray scale */
	cmap = xCreateGrayColormap(dpy,win);
	XSetWindowColormap(dpy,win,cmap);
d564 1
a564 1
	sprintf(string,"(%0.3g,%0.3g)",x1,x2);
@


1.5
log
@modified to build gray scale in private colormap
@
text
@d4 1
d51 1
a51 1
"gridcolor=yellow       color for grid lines\n"
d65 3
d92 1
a92 1
		*gridcolor="yellow";
d97 2
d288 6
a293 4
		ExposureMask|
		KeyPressMask|
		ButtonPressMask|
		ButtonReleaseMask|
d366 8
a373 1
			break;
d375 18
d519 44
@


1.4
log
@modified default wbox and hbox
@
text
@d95 1
a95 1
	XStandardColormap scmap;
a264 10
	/* determine min and max pixels from standard colormap */
	if (!XGetStandardColormap(dpy,RootWindow(dpy,scr),
		&scmap,XA_RGB_DEFAULT_MAP))
		err("Colormap RGB_DEFAULT_MAP does not exist!\n");
	pmin = scmap.base_pixel;
	pmax = scmap.base_pixel +
		scmap.red_max*scmap.red_mult +
		scmap.green_max*scmap.green_mult +
		scmap.blue_max*scmap.blue_mult;
	
d267 8
@


1.3
log
@Added initialization code because some X servers don't ConfigureNotify
before the first Expose event.
@
text
@d29 2
a30 2
"wbox=400               width in pixels of window\n"
"hbox=400               height in pixels of window\n"
d165 2
a166 2
	wbox = 400; getparint("wbox",&wbox);
	hbox = 400; getparint("hbox",&hbox);
@


1.2
log
@added check for ConfigureNotify events.
perform interpolation of bytes only when necessary.
eliminate unnecessary clearing of window.
use new xNewImage function.
@
text
@d292 11
@


1.1
log
@Initial revision
@
text
@d3 1
d56 2
a57 2
static void
zoomBox (int x, int y, int w, int h, int xb, int yb, int wb, int hb,
d62 2
d68 2
a69 2
	int n1,n2,n1tic,n2tic,nfloats,bbox[4],
		i1,i2,npar,grid1,grid2,style,
d75 2
a76 1
		i,j,nx,ny,nxb,nyb,ixb,iyb;
d83 1
a83 2

	signed char *cz,*czp,*czb,*czbp;
d93 3
d97 1
a97 1
	unsigned long black,white;
d104 1
a104 1
	if (!igetpar("n1",&n1))
d106 2
a107 2
	d1 = 1.0;  fgetpar("d1",&d1);
	f1 = d1;  fgetpar("f1",&f1);
d112 5
a116 4
	if (!igetpar("n2",&n2)) {
		fseek(infp,0L,2);
		nfloats = ftell(infp)/sizeof(float);
		fseek(infp,0L,0);
d119 2
a120 2
	d2 = 1.0;  fgetpar("d2",&d2);
	f2 = d2;  fgetpar("f2",&f2);
d126 1
a126 1
	z = (float *)malloc(nz*sizeof(float));
d128 1
a128 1
		err("Error reading input file; check n1*n2 = %d\n",n1*n2);
d131 1
a131 1
	if (fgetpar("clip",&clip)) {
d135 4
a138 4
	if ((!fgetpar("bclip",&bclip) || !fgetpar("wclip",&wclip)) &&
		!fgetpar("clip",&clip)) {
		perc = 100.0;  fgetpar("perc",&perc);
		temp = (float *)malloc(nz*sizeof(float));
d141 2
a142 2
		if (!fgetpar("bclip",&bclip)) {
			bperc = perc;	fgetpar("bperc",&bperc);
d149 2
a150 2
		if (!fgetpar("wclip",&wclip)) {
			wperc = 100.0-perc;  fgetpar("wperc",&wperc);
d157 1
a157 1
		free(temp);
d159 1
a159 1
	verbose = 1;  igetpar("verbose",&verbose);
d163 10
a172 10
	xbox = 50; igetpar("xbox",&xbox);
	ybox = 50; igetpar("ybox",&ybox);
	wbox = 400; igetpar("wbox",&wbox);
	hbox = 400; igetpar("hbox",&hbox);
	x1beg = x1min; fgetpar("x1beg",&x1beg);
	x1end = x1max; fgetpar("x1end",&x1end);
	d1num = 0.0; fgetpar("d1num",&d1num);
	f1num = x1min; fgetpar("f1num",&f1num);
	n1tic = 1; igetpar("n1tic",&n1tic);
	sgetpar("grid1",&grid1s);
d177 7
a183 7
	sgetpar("label1",&label1);
	x2beg = x2min; fgetpar("x2beg",&x2beg);
	x2end = x2max; fgetpar("x2end",&x2end);
	d2num = 0.0; fgetpar("d2num",&d2num);
	f2num = 0.0; fgetpar("f2num",&f2num);
	n2tic = 1; igetpar("n2tic",&n2tic);
	sgetpar("grid2",&grid2s);
d188 7
a194 7
	sgetpar("label2",&label2);
	sgetpar("labelfont",&labelfont);
	labelsize = 18.0; fgetpar("labelsize",&labelsize);
	sgetpar("title",&title);
	sgetpar("titlefont",&titlefont);
	titlesize = 24.0; fgetpar("titlesize",&titlesize);
	sgetpar("style",&styles);
d197 3
a199 3
	sgetpar("titlecolor",&titlecolor);
	sgetpar("labelcolor",&labelcolor);
	sgetpar("gridcolor",&gridcolor);
d220 1
a220 1
	cz = (signed char*)malloc(n1c*n2c*sizeof(signed char));
d224 1
a224 1
	zoffset = -128.0-bclip*zscale;
d232 3
a234 3
				if (zi<-128.0) zi = -128.0;
				if (zi>127.0) zi = 127.0;
				*czp++ = (char)zi;
d242 3
a244 3
				if (zi<-128.0) zi = -128.0;
				if (zi>127.0) zi = 127.0;
				*czp++ = (char)zi;
d248 1
a248 1
	free(z);
d259 2
a260 5
	if ((dpy=XOpenDisplay(NULL))==NULL) {
		fprintf(stderr,"Cannot connect to display %s\n",
			XDisplayName(NULL));
		exit(-1);
	}
d265 10
d277 3
d283 1
d297 7
a303 9
		/* if window exposed */
		if (event.type==Expose) {
			
			/* clear all expose events from queue */
			while (XCheckTypedEvent(dpy,Expose,&event));
			
			/* clear the window */
			XClearWindow(dpy,win);
			
d309 23
d333 2
a334 2
			xDrawImage(dpy,win,x,y,width,height,
				nxb,nyb,czb);
d370 1
a370 1
				if (czb!=cz) free(czb);
d393 3
a395 4
				/* make new image array */
				if (czb!=cz) free(czb);
				czb = (signed char*)malloc(nxb*nyb*
					sizeof(signed char));
d403 1
a403 1
			/* clear area to force an expose event */
d405 3
d415 3
a417 2
static void
zoomBox (int x, int y, int w, int h, int xb, int yb, int wb, int hb,
d459 18
@
