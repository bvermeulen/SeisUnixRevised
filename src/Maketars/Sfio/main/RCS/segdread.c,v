head	1.14;
access;
symbols;
locks
	john:1.14; strict;
comment	@ * @;


1.14
date	2013.07.08.20.27.17;	author john;	state Exp;
branches;
next	1.13;

1.13
date	2011.04.04.15.48.10;	author john;	state Exp;
branches;
next	1.12;

1.12
date	2011.04.04.15.46.19;	author john;	state Exp;
branches;
next	1.11;

1.11
date	2009.07.23.18.27.11;	author john;	state Exp;
branches;
next	1.10;

1.10
date	2009.06.01.03.16.21;	author john;	state Exp;
branches;
next	1.9;

1.9
date	2004.02.02.18.34.30;	author john;	state Exp;
branches;
next	1.8;

1.8
date	98.08.24.20.09.35;	author john;	state Exp;
branches;
next	1.7;

1.7
date	98.01.20.21.25.51;	author john;	state Exp;
branches;
next	1.6;

1.6
date	97.07.28.22.36.46;	author john;	state Exp;
branches;
next	1.5;

1.5
date	97.07.15.19.53.16;	author john;	state Exp;
branches;
next	1.4;

1.4
date	96.09.03.20.59.57;	author jkc;	state Exp;
branches;
next	1.3;

1.3
date	96.03.05.20.45.19;	author john;	state Exp;
branches;
next	1.2;

1.2
date	95.10.31.23.23.30;	author john;	state Exp;
branches;
next	1.1;

1.1
date	95.10.31.23.19.00;	author john;	state Exp;
branches;
next	;


desc
@This is the former third party code  "segdread".
@


1.14
log
@stew levin's recent changes
@
text
@/* Copyright (c) Colorado School of Mines, 2013.*/
/* All rights reserved.                       */


/* SEGDREAD: $Revisi n: 1.12 $ ; $Date: 2011/04/04 15:48:10 $	*/

#include "su_xdr.h"
#include "segd.h"

#include "sfio.h"
#include "header.h"	/* added for HDRBYTES in puttr workaround */

/* Portable decoding utilities to retrieve char/u_char/short/u_short from SEG-D byte stream */
static char GET_C(Sfio_t *f)
{
 int n;
 char c;

 n = sfgetc(f);
 c = (char) ((n > 127) ? (n-256) : n);

 return (c);
}

static unsigned int GET_UC(Sfio_t *f)
{
 int n;
 unsigned char uc;

 n = sfgetc(f);
 uc = (unsigned char) n;

 return (uc);
}

static short GET_S(Sfio_t *f)
{
 int n1, n2;
 int n;
 short s;

 n1 = sfgetc(f);
 n2 = sfgetc(f);
 n = (n1<<8) | n2;
 s = (short) ((n > 32767)? n - 65536 : n);

 return (s);
}

static unsigned short GET_US(Sfio_t *f)
{
 int n1, n2;
 int n;
 unsigned short us;

 n1 = sfgetc(f);
 n2 = sfgetc(f);
 n = (n1<<8) | n2;
 us = (unsigned short) n;

 return (us);
}

#define REC_L (1*20/*demux header*/ + 255*32 /*up to 255 header extensions*/ + 4*SU_NFLTS/*4 bytes per sample max*/) /* expected max record size: 20 + 10*(SU_NFLTS)/4 bytes */

#define BCD_FF (15+10*(15))		   /* bcd interpretation of FF */
#define BCD_FFF (15+10*(15+10*(15)))	  /* bcd interpretation of FFF */
#define BCD_FFFF (15+10*(15+10*(15+10*(15)))) /* bcd interpretation of FFFF */

/*********************** self documentation **********************/
char *sdoc[] = {
"									",
" SEGDREAD - read an SEG-D tape					",
"									",
" segdread > stdout tape=						",
"									",
"									",
" Required parameters:						 ",
"	tape=	   input tape device				",
" 			tape=- to read from stdin			",
"									",
" Optional parameters:						 ",
"	use_stdio=0	for record devices (9-track reel tape drive)   ",
"			=1 for pipe, disk and fixed-block 8mm drives   ",
"	verbose=0	silent operation				",
"			= 1 ; echo every 'vblock' traces		",
"			= 2 ; echo information about blocks	    ",
"	vblock=50	echo every 'vblock' traces under verbose option",
"	ptmin=1	 first shot to read				",
"	ptmax=INT_MAX   last shot to read				",
"	gain=0	  no application of gain			 ",
"	aux=0	   no recovery of auxiliary traces		",
"	errmax=0	allowable number of consecutive tape IO errors ",
"	ns=0		override of computed ns to work around SEG-D   ",
"			flaws.  Ignored when use_stdio=0.		",
"	pivot_year=30   Use current century for 2 digit yrs less than  ",
"			pivot_year, previous century otherwise.	",
"									",
"	 type:   sudoc segdread   for further information		",
" Notes:								",
" The SEGD data format is the \"elephant as mouse designed by committee\"",
" in that the format attempts to encompass a huge number of variations. ",
" For this reason it is not always possible to read a SEG D file	",
"									",
" Examples:								",
" Ordinary SEGD:							",
" segdread tape=file.segd verbose=1 ptmax=2 buff=0 aux=1 use_stdio=1 > file.su",
"									",
"									",
" Sercel SEGD:								",
"									",
" segdread tape=file.segd verbose=1 ptmax=2 buff=0 aux=1 use_stdio=1 > file.su",
"									",
" It may be that there are NaNs in the data, in which case you run:	",
"									",
" segdread tape=file.segd verbose=1 ptmax=2 buff=0 aux=1 use_stdio=1 |	",
" sunan verbose=1 >  $outfile						",
"									",
NULL};

/* Credits:
 *  for version 1:
 *    IPRA, Pau, France: Dominique Rousset, rousset@@iprrs1.univ-pau.fr
 *  for version 2.2:
 *    EOST, Strasbourg, France: Celine Girard
 *  for versions 2.3:
 *    EOST, Strasbourg, France: Marc Schaming, mschaming@@eost.u-strasbg.fr
 *  for version 2.4:
 *    SEP, Stanford University: Stew Levin, stew@@sep.stanford.edu
 *    a) Changed definitions of BCD_FF/BCD_FFFF
 *    b) Corrected decoding of general_header_1 in info_gh1.
 *    c) Changed buff=0 to use_stdio=1 to avoid confusion (stdio
 *	IS buffered I/O). Kept old buff= internally for backwards
 *	compatibility.
 *    d) Changed F8015 decoding of negative mantissas to avoid
 *	1 part in 2^14th decoding error on 2's complement platforms.
 *    e) Adapted F8015 to F0015 decoding routine. Unused, but now available.
 *    f) Use AT&T sfio package for tape read.
 *    g) Handle endian and wordsize dependencies portably (I think).
 *    g) Allow tape=- command line argument to accept input from stdin.
 *    h) Compute trace length explicitly from headers so that disk data
 *	input can work.
 *    i) Correct tape trace length calculation to account for demux
 *	trace header extensions.
 *    j) Fix a couple of typos in comments and selfdoc
 *    k) Added F8022 for 1 byte quaternary exponent demux.
 *    l) Added F8024 for 2 byte quaternary exponent demux.
 *    m) Added F8042 for 1 byte hexadecimal exponent demux.
 *    n) Added F8044 for 2 byte hexadecimal exponent demux.
 *    o) Added F8048 for 4 byte hexadecimal exponent demux.
 *    p) Added F8036 for 2 byte 2's complement integer demux.
 *    q) Added F8038 for 4 byte 2's complement integer demux.
 *    r) Added F8058 for 4 byte IEEE float demux.
 *    s) Added ns= parameter to work around bad SEG-D trace
 *	length specifications in headers.
 *  for version 2.5:
 *    SEP, Stanford University: Stew Levin, stew@@sep.stanford.edu
 *    a) Added pivot_year to disambiguate decoding of 2-digit yrs
 *    b) Modified decode of 2-byte BCD to avoid endian problems
 *    c) Modified debug printout to fix endian BCD display problems
 *    d) Don't let dem_trace_header override ns specified on command line
 *    e) Removed extra factor of two in decoding of general_header_1.r
 *    f) Removed conditional disabling of sfio
 *  for version 2.6:
 *    SEP, Stanford University: Stew Levin, stew@@sep.stanford.edu
 *    a) tightened test for Sercel 358
 *    b) modified 8015 conversion to handle Sercel 358/368 misuse of
 *	two's complement instead of one's complement.
 *  for version 2.7:
 *    SEP, Stanford Unviersity: Stew Levin, stew@@sep.stanford.edu
 *    a) repaired workaround hacked in to avoid puttr seg fault
 *    b) place general header 3 shotpoint number into 'ep' header field
 *
 *--------------------------------------------------------------------
 * SEGDREAD: Version 2.1, 10/10/94
 *	   Version 2.2, 17/08/95
 *	   Version 2.3, 04/1997 Thu Apr 10 11:55:45 DFT 1997
 *	   Version 2.4, 10/03/98 Tue Mar 10 1998
 *	   Version 2.5, Feb 4, 2001
 *	   Version 2.6, May 26, 2009
 *	   Version 2.7, Jul 2, 2013
 *--------------------------------------------------------------------
 */
/**************** end self doc ***********************************/

/* subroutine prototypes */
static int bcd (unsigned char *ptr, int begin, int n) ;
#if 0
/* not used */
static void F0015_to_float (Sfio_t *from, float to[], int len);
#endif
static void F8015_to_float (Sfio_t *from, float to[], int len, int cvt2s);
static void F8022_to_float (Sfio_t *from, float to[], int len, int cvt2s);
static void F8024_to_float (Sfio_t *from, float to[], int len, int cvt2s);
static void F8036_to_float (Sfio_t *from, float to[], int len);
static void F8038_to_float (Sfio_t *from, float to[], int len);
static void F8042_to_float (Sfio_t *from, float to[], int len);
static void F8044_to_float (Sfio_t *from, float to[], int len);
static void F8048_to_float (Sfio_t *from, float to[], int len);
static void F8058_to_float (Sfio_t *from, float to[], int len);

int get_gh1(general_header_1 * gh1, Sfio_t *tapeun) ;
int get_gh2(general_header_2 * gh2, Sfio_t *tapeun) ;
int get_ghn(general_header_n * ghn, Sfio_t *tapeun) ;
int get_gn_sn358(gen_head_sn358 * gh358, Sfio_t *tapeun) ;
int get_csh(channel_set_header * csh, Sfio_t *tapeun) ;
int get_ssh(sample_skew * ssh, Sfio_t *tapeun) ;
int get_ech(extended_header * ech, Sfio_t *tapeun) ;
int get_exh(external_header * exh, Sfio_t *tapeun) ;
int get_gt(general_trailer * gt, Sfio_t *tapeun) ;
int get_dth(dem_trace_header * dth, Sfio_t *tapeun) ;
int get_the(trace_header_ext * the, Sfio_t *tapeun) ;

void info_gh1(general_header_1 * gh1) ;
void info_gh2(general_header_2 * gh2) ;
void info_ghn(general_header_n * ghn) ;
void info_gn_sn358(gen_head_sn358 * gh358);
void info_csh(channel_set_header * csh) ;
void info_ssh(sample_skew * ssh) ;
void info_ech(extended_header * ech);
void info_exh(external_header * exh);
void info_gt(general_trailer * gt);
void info_dth(dem_trace_header * dth);

segy tr;

static int imp0 = 0; 
static int imp1 = 1;

int
main(int argc, char **argv)
{
 general_header_1   segd_general_header_1;
 general_header_2   segd_general_header_2;
 general_header_n   segd_general_header_n;
 gen_head_sn358	segd_gen_head_sn358;
 channel_set_header *segd_channel_set_header;
 sample_skew	segd_sample_skew;
 extended_header    segd_extended_header;
 external_header    segd_external_header;
 general_trailer    segd_general_trailer;
 dem_trace_header   segd_dem_trace_header;
 trace_header_ext   segd_trace_header_ext;

 channel_set_header **csd = NULL;
			/* array[n_str][n_cs] of channel_set_header */

 char *tape=NULL;	/* name of raw tape device */
 int tapefd=0;	   /* file descriptor for tape */
/* segdread.c:213: warning: `tapeun' might be used uninitialized in this function */
 Sfio_t  *tapeun = NULL;		/* input for Sfio_t reads. May be memory or stdio */
 Sfoff_t startpos;		/* for rewind on memory Sfio_t */

 short scan_type;	/* scan type number */
 short chan_set;	 /* channel set number */

 register int i, j;
 register int i_scan, i_cs, i_tr;
 int i_ss;
/* segdread.c:222: warning: `nread' might be used uninitialized in this function */
 int nread = 0;		/* bytes read */
 int ns;				  /* number of data samples */
 int n_gh;	 /* number of additional blocks in general header */
 int n_str;			/* number of scan types per record */
 int n_cs;		  /* number of channel sets per scan type */
 int n_sk;		/* number of 32 byte field for sample skew */
 int n_ec;				/* extended header length */
 int n_ex;				/* external header length */
 int n_gt=0;		 /* number of blocks of general trailer */
 int n_chan;			    /* total number of channels */
 int itr;				   /* current trace number */
 int ipt;				    /* current shot number */
 int ptmin;				  /* first trace to read */
 int ptmax;				   /* last trace to read */
 int verbose;		   /* echo every ...		   */
 int vblock;		    /* ... vblock traces with verbose=1 */
 int buff;		   /* flag for buffered/unbuffered device */
 int gain;				/* flag for applying gain */
 int aux;			/* flag for keeping auxiliary traces */
 int errmax;			/* max consecutive tape io errors */
 int pivot_year;		  /* for choosing correct century   */
 int errcount = 0;		    /* counter for tape io errors */
 int isSN358=0, isSN368=0; /* special case Sercel glitches */
 int hdr1_i, hdr1_r;		   /* i and r decoded from hdr1 */
 int ns_override;				/* for trace length fudging */
 int icvt2s = 0;			/* Sercel glitch flag */
 unsigned int nsamp_hdr1;		   /* number of samples/trace using */
			    /* only general header 1 i and r fields */
 unsigned int nsamp_hdr2;	    /* number of samples/trace from general */
			/* header 2 erl and general header 1 i fields */
 unsigned int nsamp_hdr358;   /* Sercel header rec_length plus hdr1_i fields */
 unsigned int nsamp_cs;	/* nsamp from channel set named in demux header */
 unsigned int nsamp_the;	 /* nsamp from demux trace header extensions */

 float  mp;				   /* descaling exponent */
 float **mmp = NULL;    /* array[n_cs][n_str] for escaling exponent */

 char *bloc1;				/* pointer on data block */

 unsigned databytes = 0;	/* added for puttr workaround */

#ifdef SUXDR
 XDR *segy_xdr;
 char *segy_xdr_buf;
 unsigned int segy_xdr_bufstart;
#endif

 /* Initialize */
 initargs(argc, argv);
 requestdoc(0); /* stdin not used */

 /* Make sure stdout is a file or pipe */
 switch(filestat(STDOUT)) {
 case TTY:
 	err("stdout can't be tty");
 break;
 case DIRECTORY:
 	err("stdout must be a file, not a directory");
 break;
 case BADFILETYPE:
 	err("stdout is illegal filetype");
 break;
 default: /* Others OK */
 break;
 }

 /* Set filenames */
 MUSTGETPARSTRING("tape",  &tape);

 /* Set parameters */
 if (!getparint("ptmin", &ptmin))	ptmin = 1;
 if (!getparint("ptmax", &ptmax))	ptmax = INT_MAX;
 if (!getparint("verbose", &verbose))    verbose = 0;
 if (verbose==2) {ptmax=ptmin; warn("ptmax set to ptmin for verbose=2");}
 if (!getparint("vblock", &vblock))	vblock = 50;
 if (verbose==2) vblock = 1;
 if (!getparint("use_stdio",&buff)) {
	if (!getparint("buff", &buff))	  buff = 1;
 } else {
	buff = !buff;
 }
 if (!getparint("gain", &gain))	  gain = 0;
 if (!getparint("aux", &aux))	    aux = 0;
 if (!getparint("errmax", &errmax))	errmax = 0;
 if (!getparint("pivot_year", &pivot_year))	pivot_year = 30;
 if (!getparint("ns", &ns_override))		 ns_override = 0;

#ifdef SUXDR
 segy_xdr = (XDR *) malloc(sizeof(XDR));
 segy_xdr_buf = ealloc1(sizeof(segy),sizeof(char));
 xdrmem_create(segy_xdr, segy_xdr_buf,sizeof(segy), XDR_ENCODE);
 segy_xdr_bufstart = xdr_getpos(segy_xdr);
#endif

 /* Allocate space for the record block */
 if ((bloc1 = alloc1(REC_L, sizeof(char))) == NULL) err("error at bloc1 allocation");
 if ((unsigned long) bloc1 % 2)
	warn("there may be a problem since bloc1 is not on a short boundary (%ul)",(unsigned long) bloc1);

 /* Open the tape */
 if ( STREQ(tape,"-") ) {
    if (buff) tapefd = fileno(stdin);
    else tapeun = sfstdin;
 } else {
	 if (buff) tapefd = eopen(tape, O_RDONLY, 0444);
	 else	{
			tapeun = sfopen((Sfio_t *) 0, tape, "rb");
			if (tapeun == ((Sfio_t *) 0)) err("Unable to open tape %s\n");
			}
 }
 if (verbose) warn("tape opened successfully");

 /* Create Sfio_t input stream */
 if(buff)
	tapeun = sfnew((Sfio_t *) 0, (Void_t *) bloc1, (size_t) REC_L, 0, SF_STRING|SF_READ);
 startpos = sftell(tapeun);

 /* Read the traces */
 ipt = 0;    /*current shot number */
 itr = 0;    /*current trace number */
 while (ipt < ptmax) {

 	/************************
 	* Read the Header Block *
 	************************/

 	if (buff) {
 		if (-1 == (nread = (int) read(tapefd, (void *) bloc1, (size_t) REC_L))){
 			if (verbose)
 				warn("tape read error on header block from shot %d", (ipt+1));
 			if (++errcount > errmax)
 				err("exceeded maximum io errors");
 		} else { /* Reset counter on successful tape IO */
 			errcount = 0;
 		}
	(void) sfseek(tapeun,startpos,SEEK_SET);  /* reset Sfio_t pointer to start of block */
 	if (!nread) break; /* middle exit loop instead of mile-long while */
	}

 	/* General Header #1 */

	if ( EXIT_FAILURE == get_gh1(&segd_general_header_1, tapeun) ) break;

	ns = 0;
	nsamp_hdr1 = 0; nsamp_hdr2 = 0; nsamp_hdr358 = 0;
	hdr1_r = bcd(&segd_general_header_1.z_r1,1,3);
	hdr1_i = segd_general_header_1.i;
	if(hdr1_r != BCD_FFF && hdr1_i != 0) {
		hdr1_r *= 2;  /* range is 10 to 1990 */
		nsamp_hdr1 = (hdr1_r*512*16)/(10*hdr1_i)  + 1;
			 /* 20*r*512 msec /10*(i/16) msec */
		if(ns == 0) ns = nsamp_hdr1;
	  if(verbose) warn("nsamp_hdr1=%d\n",nsamp_hdr1);
	}


 	tr.fldr =   bcd ((unsigned char *) &(segd_general_header_1.f[0]), 0, 4);
 	tr.year =   bcd ((unsigned char *) &segd_general_header_1.yr, 0, 2);
	if(tr.year < pivot_year) tr.year += 2000;
	else tr.year += 1900;
 	n_gh =	bcd ((unsigned char *) &segd_general_header_1.gh_dy1, 0, 1);
 	tr.day =    bcd ((unsigned char *) &segd_general_header_1.gh_dy1, 1, 3);
 	tr.hour =   bcd ((unsigned char *) &segd_general_header_1.h, 0, 2);
 	tr.minute = bcd ((unsigned char *) &segd_general_header_1.mi, 0, 2);
 	tr.sec =    bcd ((unsigned char *) &segd_general_header_1.se, 0, 2);
 	tr.dt =	(segd_general_header_1.i*1000) >> 4;
 	n_str =	bcd ((unsigned char *) &segd_general_header_1.str, 0, 2);
 	n_cs =	bcd ((unsigned char *) &segd_general_header_1.cs, 0, 2);
 	n_sk =	bcd ((unsigned char *) &segd_general_header_1.sk, 0, 2);
 	n_ec =	bcd ((unsigned char *) &segd_general_header_1.ec, 0, 2);
 	n_ex =	bcd ((unsigned char *) &segd_general_header_1.ex, 0, 2);

 	if (verbose==2) info_gh1(&segd_general_header_1);

 	/* Additional general headers */

	if(segd_general_header_1.m[0] == 0x13) { /* set Sercel flags */
	    isSN358 = (n_gh == 2) && (n_str == 2) && (n_sk == 8) &&
			(n_ex == 8) && (n_cs == 12);
	    isSN368 = (n_gh == 9) && (n_str == 1) && (n_sk == 76) &&
			(n_ex == 11) && (n_cs == 44) && (n_ec == 99);
	}
	if(isSN358 || isSN368) { /* repair byte swap of MP gain */
	    imp0 = 1; imp1 = 0; icvt2s = 1;
	}
 	if(isSN358) { /* Special case for Sercel SN358 */
	if( EXIT_FAILURE == get_gn_sn358(&segd_gen_head_sn358, tapeun) ) break;

 		if (verbose==2) info_gn_sn358(&segd_gen_head_sn358);
		if(hdr1_i != 0) {
			nsamp_hdr358 = bcd(&(segd_gen_head_sn358.rec_length[0]),1,3)*100 /* 10ths sec to msec */ * 16 /* base scan per msec */ /hdr1_i + 1;
	  if(verbose) warn("nsamp_hdr358=%d\n",nsamp_hdr358);
			if (ns != 0 && nsamp_hdr358 != 0 && ns != nsamp_hdr358)
				warn("General Header 1 nsamp %u not equal to Sercel Header nsamp %u\n",nsamp_hdr1, nsamp_hdr358);
			if (nsamp_hdr358 != 0) ns = nsamp_hdr358;
		}
 	}
 	else {
 		for (i = 0; i < n_gh; i++) {
 			if (i == 0) {

 				/* General header #2 */

				if ( EXIT_FAILURE == get_gh2(&segd_general_header_2, tapeun) ) break;
				if ((segd_general_header_2.rev[0] <= 1) && (segd_general_header_2.rev[0] != 0)) { /* looks like SEGD rev 1 */
 				if (tr.fldr == BCD_FFFF) tr.fldr = 65536 * segd_general_header_2.ef[0] +
					256 * segd_general_header_2.ef[1] + segd_general_header_2.ef[2];
 				if (n_cs == BCD_FF) n_cs = 256 * segd_general_header_2.en[0] + segd_general_header_2.en[1];
 				if (n_ec == BCD_FF) n_ec = 256 * segd_general_header_2.ecx[0] + segd_general_header_2.ecx[1];
 				if (n_ex == BCD_FF) n_ex = 256 * segd_general_header_2.eh[0] + segd_general_header_2.eh[1];
 				n_gt = segd_general_header_2.gt;
 				if (verbose==2) info_gh2(&segd_general_header_2);
			 if (hdr1_r == BCD_FFF && hdr1_i != 0)
				nsamp_hdr2 = segd_general_header_2.erl[2] +
					256 * (segd_general_header_2.erl[1] +
					256 * (segd_general_header_2.erl[0])) *
					16 / hdr1_i + 1;
			 else nsamp_hdr2 = 0;
	  if(verbose) warn("nsamp_hdr2=%d\n",nsamp_hdr2);
			 if(nsamp_hdr2 != 0 && ns != 0 && ns != nsamp_hdr2)
				warn("General Header 2 nsamp %u differs from previous General Header(s) nsamp %u\n", nsamp_hdr2, ns);
			 if(nsamp_hdr2 != 0) ns = nsamp_hdr2;
			} else {
 				if (verbose==2) info_gh2(&segd_general_header_2);
			}
 			}
 			else {

 				/* General header #n */

				if ( EXIT_FAILURE == get_ghn(&segd_general_header_n, tapeun) ) break;
 				if (verbose==2) info_ghn(&segd_general_header_n);
                                if(i == 1) tr.ep = 65536*segd_general_header_n.spn[0]+256*segd_general_header_n.spn[1]+segd_general_header_n.spn[2];
 			}
 	 	}
 	}

 	/* Verify the length of the first record */
	if(!buff) nread = sftell(tapeun) - startpos;
 	if (buff && nread != ((1 + n_gh + n_str * (n_cs + n_sk) + n_ec + n_ex) * 32))
 		err("Error with length of first record\n"
 			"\t... first record = %d bytes differs from ((1 + n_gh + n_str * (n_cs + n_sk) + n_ec + n_ex) * 32)\n"
 			"\t    with n_gh=%d, n_str=%d, n_cs=%d, n_sk=%d, n_ec=%d, n_ex=%d\n",
 			nread, n_gh, n_str, n_cs, n_sk, n_ec, n_ex);

 	/* Allocate space for array csd */
	if (csd == NULL)
 		if ((csd = (channel_set_header **) alloc2 ((size_t) n_cs, (size_t) n_str, (size_t) sizeof(channel_set_header))) == NULL)
 			err("error at csd allocation");

 	/* if gain allocate space for mmp array */
 	if (gain && (mmp == NULL))
 		if ((mmp = (float **) alloc2float ((size_t) n_cs, (size_t) n_str)) == NULL)
 			err("error at mmp allocation");

 	/* For each scan type */

 	n_chan = 0;
 	for (i_scan = 0; i_scan < n_str; i_scan ++) {

 		/* For each channel set */

 		for (i_cs = 0; i_cs < n_cs; i_cs ++) {
			segd_channel_set_header = &csd[i_scan][i_cs];
			if ( EXIT_FAILURE == get_csh(segd_channel_set_header, tapeun) ) break;
 			n_chan += bcd((unsigned char*) &(segd_channel_set_header->cs), 0, 4);
 			if (gain) {
 				mp = ((float) ((segd_channel_set_header->mp[imp1] & 0x7f) << 8 | segd_channel_set_header->mp[imp0])) / 1024.;
 				if (segd_channel_set_header->mp[imp1] >> 7) mp *= -1.;
 				mmp[i_scan][i_cs] = pow ((double) 2., (double) mp);

 				/* For the seismic traces */
 				if (verbose && segd_channel_set_header->c == 0x10)
 					warn("Multiplier value for channel set %d of scan type %d is : %7.3e", i_cs, i_scan, mmp[i_scan][i_cs]);
 			}
 			if (verbose==2) info_csh(segd_channel_set_header);
 		}

 		/* Sample skew header */
 		for (i_ss = 0; i_ss < n_sk; i_ss ++) {
			if ( EXIT_FAILURE ==  get_ssh(&segd_sample_skew, tapeun) ) break;
 			if (verbose==2) info_ssh(&segd_sample_skew);
 		}
 	}

 	/* Extended Header */
 	for (j = 0; j < n_ec; j ++) {
		if( EXIT_FAILURE == get_ech(&segd_extended_header, tapeun) ) break;
		/* Local decoding */
 		/* (void) sscanf(&segd_extended_header[11], "%2hd:%2hd:%2hd", &tr.hour, &tr.minute, &tr.sec); */
 		if (verbose==2) info_ech(&segd_extended_header);
 	}

 	/* External Header */
 	for (j = 0; j < n_ex; j ++) {
		if( EXIT_FAILURE == get_exh(&segd_external_header, tapeun) ) break;
 		if (verbose==2) info_exh(&segd_external_header);
 	}
 	if (verbose==2) warn ("there are %d channels", n_chan);

 	/*************************
 	* Read the n_chan traces *
 	*************************/

 	for (i_tr=0; i_tr<n_chan; i_tr++) {

 		if (buff) {
 			if (-1 == (nread = (int) read(tapefd, (void *) bloc1, (size_t) REC_L))){
 				if (verbose)
 					warn("tape read error on trace %d", itr);
 				if (++errcount > errmax)
 					err("exceeded maximum io errors");
 			} else { /* Reset counter on successful tape IO */
 				errcount = 0;
 			}
		(void) sfseek(tapeun,startpos,SEEK_SET);
		if (!nread) break;  /* middle exit loop instead of mile-long while */
		}

 			if (!(segd_general_header_1.y & 0x8000)) { /* multiplexed data */
				/* decode data regarding the format */
 				switch (segd_general_header_1.y) {
 					case 0x0015:			   /* 20 bit binary multiplexed */
 						err("Format 0015 (20 bit binary multiplexed) not yet implemented"); break;
 					case 0x0022:			/* 8 bit quaternary multiplexed */
 						err("Format 0022 (8 bit quaternary multiplexed) not yet implemented"); break;
 					case 0x0024:			/* 16 bit quaternary multiplexed */
 						err("Format 0024 (16 bit quaternary multiplexed) not yet implemented"); break;
 					case 0x0036:	   /* 24 bit 2's compliment integer multiplexed */
 						err("Format 0036 (24 bit 2's compliment integer multiplexed) not yet implemented"); break;
 					case 0x0038:	   /* 32 bit 2's compliment integer multiplexed */
 						err("Format 0038 (32 bit 2's compliment integer multiplexed) not yet implemented"); break;
 					case 0x0042:			/* 8 bit hexadecimal multiplexed */
 						err("Format 0042 (8 bit hexadecimal multiplexed) not yet implemented"); break;
 					case 0x0044:			/* 16 bit hexadecimal multiplexed */
 						err("Format 0044 (16 bit hexadecimal multiplexed) not yet implemented"); break;
 					case 0x0048:			/* 32 bit hexadecimal multiplexed */
 						err("Format 0048 (32 bit hexadecimal multiplexed) not yet implemented"); break;
 					case 0x0058:				/* 32 bit IEEE multiplexed */
 						err("Format 0058 (32 bit IEEE multiplexed) not yet implemented"); break;
 					case 0x0200:						/* illegal */
 						err("Format 0200 illegal, do not use"); break;
 					case 0x0000:						/* illegal */
 						err("Format 0000 illegal, do not use"); break;
 					default:
 						err("Data format code: %04x not recognized",segd_general_header_1.y);
 				}
 			}
 			else { /* demultiplexed data */
				nsamp_cs = 0; nsamp_the = 0;
				if( EXIT_FAILURE == get_dth(&segd_dem_trace_header, tapeun) ) break;
 				if (verbose==2) info_dth(&segd_dem_trace_header);
 				scan_type = bcd ((unsigned char *) &segd_dem_trace_header.st, 0, 2) -1;
 				chan_set = bcd ((unsigned char *) &segd_dem_trace_header.cn, 0, 2) -1;
				nsamp_the = 0;
				nsamp_cs = 0;
				if (csd[scan_type][chan_set].te != 0 && hdr1_i != 0)
					nsamp_cs = 2*(csd[scan_type][chan_set].te - csd[scan_type][chan_set].tf)*(16<<bcd(&csd[scan_type][chan_set].sc_j,0,1))/hdr1_i + 1 ;
				else nsamp_cs = ((ns-1)<<bcd(&csd[scan_type][chan_set].sc_j,0,1)) + 1 ;
				if (nsamp_cs != 0 && ns_override == 0) ns = nsamp_cs;
	  if(verbose) warn("nsamp_cs=%d\n",nsamp_cs);


				for (i=0; i < segd_dem_trace_header.the; i++) { /* read the trace header extension blocks */
					if ( EXIT_FAILURE == get_the(&segd_trace_header_ext, tapeun) ) break;
				warn ("segd_dem_trace_header.the = %d", segd_dem_trace_header.the);
				if (i == 0) { nsamp_the = segd_trace_header_ext.nbs[2] + 256*(segd_trace_header_ext.nbs[1]+256*(segd_trace_header_ext.nbs[0]));
	  if(verbose) warn("nsamp_the=%d\n",nsamp_the); }
				if (nsamp_the != 0 && nsamp_cs != 0 && nsamp_cs != nsamp_the)
				warn("Demux channel set header nsamp %u != Demux trace header nsamp %u\n", nsamp_cs, nsamp_the);
				if (nsamp_the != 0) ns = nsamp_the;
				}


  				/* set trace identification code from channel type */
 				switch (csd[scan_type][chan_set].c) {
 					case 0xc0: tr.trid = TDUMMY; break; /* Auxiliary data trailer */
 					case 0x90: tr.trid = TDUMMY; break; /* Signature, filtered */
 					case 0x80: tr.trid = TDUMMY; break; /* Signature, unfiltered */
 					case 0x70: tr.trid = TDUMMY; break; /* Other */
 					case 0x60: tr.trid = TDUMMY; break; /* External data */
 					case 0x50: tr.trid = TIMING; break; /* timing traces */
 					case 0x40: tr.trid = WBREAK; break; /* Water break traces */
 					case 0x30: tr.trid = UPHOLE; break; /* Uphole traces */
 					case 0x20: tr.trid = TBREAK; break; /* Time break traces*/
 					case 0x10: tr.trid = TREAL;  break; /* Real time traces*/
 					case 0x00: tr.trid = TDUMMY; break; /* Unused */
 					default: tr.trid = TDUMMY; warn("channel type %02x unknown", csd[scan_type][chan_set].c); break;
 				}

 				tr.tracf = bcd ((unsigned  char *) &(segd_dem_trace_header.tn[0]), 0, 4);
 				tr.delrt = csd[scan_type][chan_set].tf * 2;

				if(ns_override != 0) ns = ns_override;

				/* decode data regarding the format */
 				switch (segd_general_header_1.y) {
 					case 0x8015:			/* 20 bits binary demultiplexed */
						if(buff) tr.ns = ((nread-20-32*segd_dem_trace_header.the)*4)/10; /* number of samples from block length */
						else tr.ns = ns;
 						if (tr.ns != ns)
						   warn("Tape read length for trace %d inconsistent with trace length computed from header(s)\n",nread,ns*5/2);
						ns = tr.ns;
 						F8015_to_float (tapeun, (float *) tr.data, ns, icvt2s); break;
 					case 0x8022:			/* 8 bit quaternary demultiplexed */
						if(buff) tr.ns = ((nread-20-32*segd_dem_trace_header.the))/1; /* number of samples from block length */
						else tr.ns = ns;
 						if (tr.ns != ns)
						   warn("Tape read length for trace %d inconsistent with trace length computed from header(s)\n",nread,ns*1);
						ns = tr.ns;
 						F8022_to_float (tapeun, (float *) tr.data, ns, icvt2s); break;
 					case 0x8024:			/* 16 bit quaternary demultiplexed */
						if(buff) tr.ns = ((nread-20-32*segd_dem_trace_header.the))/2; /* number of samples from block length */
						else tr.ns = ns;
 						if (tr.ns != ns)
						   warn("Tape read length for trace %d inconsistent with trace length computed from header(s)\n",nread,ns*2);
						ns = tr.ns;
 						F8024_to_float (tapeun, (float *) tr.data, ns, icvt2s); break;
 					case 0x8036:	  /* 24 bit 2's compliment integer demultiplexed */
						if(buff) tr.ns = ((nread-20-32*segd_dem_trace_header.the))/3; /* number of samples from block length */
						else tr.ns = ns;
 						if (tr.ns != ns)
						   warn("Tape read length for trace %d inconsistent with trace length computed from header(s)\n",nread,ns*3);
						ns = tr.ns;
 						F8036_to_float (tapeun, (float *) tr.data, ns); break;
 					case 0x8038:	  /* 32 bit 2's compliment integer demultiplexed */
						if(buff) tr.ns = ((nread-20-32*segd_dem_trace_header.the))/4; /* number of samples from block length */
						else tr.ns = ns;
 						if (tr.ns != ns)
						   warn("Tape read length for trace %d inconsistent with trace length computed from header(s)\n",nread,ns*4);
						ns = tr.ns;
 						F8038_to_float (tapeun, (float *) tr.data, ns); break;
 					case 0x8042:			/* 8 bit hexadecimal demultiplexed */
						if(buff) tr.ns = ((nread-20-32*segd_dem_trace_header.the))/1; /* number of samples from block length */
						else tr.ns = ns;
 						if (tr.ns != ns)
						   warn("Tape read length for trace %d inconsistent with trace length computed from header(s)\n",nread,ns*1);
						ns = tr.ns;
 						F8042_to_float (tapeun, (float *) tr.data, ns); break;
 					case 0x8044:			/* 16 bit hexadecimal demultiplexed */
						if(buff) tr.ns = ((nread-20-32*segd_dem_trace_header.the))/2; /* number of samples from block length */
						else tr.ns = ns;
 						if (tr.ns != ns)
						   warn("Tape read length for trace %d inconsistent with trace length computed from header(s)\n",nread,ns*2);
						ns = tr.ns;
 						F8044_to_float (tapeun, (float *) tr.data, ns); break;
 					case 0x8048:			/* 32 bit hexadecimal demultiplexed */
						if(buff) tr.ns = ((nread-20-32*segd_dem_trace_header.the))/4; /* number of samples from block length */
						else tr.ns = ns;
 						if (tr.ns != ns)
						   warn("Tape read length for trace %d inconsistent with trace length computed from header(s)\n",nread,ns*4);
						ns = tr.ns;
 						F8048_to_float (tapeun, (float *) tr.data, ns); break;
 					case 0x8058:			    /* 32 bit IEEE demultiplexed */
						if(buff) tr.ns = ((nread-20-32*segd_dem_trace_header.the))/4; /* number of samples from block length */
						else tr.ns = ns;
 						if (tr.ns != ns)
						   warn("Tape read length for trace %d inconsistent with trace length computed from header(s)\n",nread,ns*4);
						ns = tr.ns;
 						F8058_to_float (tapeun, (float *) tr.data, ns); break;
 					default:
 						err("Data format code: %04x not recognized",segd_general_header_1.y);
 				}

  				/* Apply gain if requested */
 				if (gain) {
 					for (i = 0; i<tr.ns; i++)
 						tr.data[i] *= mmp[scan_type][chan_set];
 				}
				if (ipt >= ptmin-1) {
 				/* Write the trace */
 				/* if aux = 0, skip auxiliary channels */
 				if (aux!=0 || csd[scan_type][chan_set].c == 0x10)
				{
				/* this essentially does the important part of
				 * what puttr does without seg faulting with
				 * gcc 3.2.1, 3.4.5, 4.1.{1,2} */
					databytes = ns * sizeof(float);
#ifdef SUXDR
xdr_setpos(segy_xdr, segy_xdr_bufstart);
(void) xdrhdrsub(segy_xdr,&tr);
(void) xdr_vector(segy_xdr,(char *) (&(tr.data[0])),
                  ns, sizeof(float),
                  (xdrproc_t) xdr_float);
(void) fwrite(segy_xdr_buf, 1, HDRBYTES+databytes, stdout);
#else
					fwrite(&tr, 1, HDRBYTES, stdout);
					fwrite(tr.data, 1, databytes, stdout);
#endif
/*
 *				puttr(&tr);
 */
				}

 				/* Echo under verbose option */
 				if (verbose && ++itr % vblock == 0)
 					warn(" %d traces from tape", itr);

				}
 			}
 	}

 	/***************************
 	* Read the General Trailer *
 	***************************/

 	for (j = 0; j < n_gt; j ++) {
		if( EXIT_FAILURE == get_gt(&segd_general_trailer, tapeun) ) break;
 		if (verbose==2) info_gt(&segd_general_trailer);
 	}

 	/* EOF = end of shot */
 	if (buff) {
 		if (-1 == (nread = (int) read(tapefd, (void *) bloc1, (size_t) REC_L))){
 			if (verbose)
 				warn("tape read error on header block from shot %d", (ipt+1));
 			if (++errcount > errmax)
 				err("exceeded maximum io errors");
 		} else { /* Reset counter on successful tape IO */
 			errcount = 0;
 		}
	(void) sfseek(tapeun, startpos, SEEK_SET);
 	if (nread) warn("not at EOF as should be!");
	}
 	ipt++ ;
 }

 /* Clean up */
 ipt = ipt - ptmin + 1;
 if (verbose) warn ("%d shots (%d traces) from tape", ipt, itr);
 (void) sfclose(tapeun);
 if(buff) eclose(tapefd);

 if (verbose) warn("tape closed successfully");
 if(mmp != NULL) free2float (mmp);
 if(csd != NULL) free2 ((void **) csd);
 if(bloc1 != NULL) free1 (bloc1);

 return EXIT_SUCCESS;
}

/* bcd - convert bcd to int
 *
 * Credits:
 *	EOPG: Marc, Jdt
 *
 * Parameters:
 *    ptr    - address of first byte of the number
 *    begin  - 0 or 1, position of the first digit of the number
 *    n	- number of digits
 *
 */

static int bcd (unsigned char * ptr , int begin , int n)
{
 register int i;
 unsigned int val;

 val = 0;
 if (n == 0) return (val);

 for (i = 0; i<n; i++) {
 	val *= 10;
 	if (begin++ & 1) val += (*ptr++ & 15);
 	else val += (*ptr >> 4) & 15;
 }
 return (val);
}

#if 0
/* segdread.c:809: warning: `F0015_to_float' defined but not used */
/* F0015_to_float - convert 20 bit binary multiplexed data into floating numbers
 *
 * Credits:
 *	EOPG: Marc Schaming, Jean-Daniel Tissot
 *	SEP:  Stew Levin - fixed low-order bit error in conversion
 *	    of negative values on 2's complement machines.
 *	    Use ldexp() function instead of much slower value*pow(2,expo)
 *	SEP:  Adapted F8015 to F0015 conversion
 *
 *
 * Parameters:
 *    from   - input vector
 *    to	- output vector
 *    len    - number of packets of 4 floats in vectors
 *
 */

/*
 *
 * Format 0015 is a 10 byte per 4 words (2 1/2 bytes per word)
 * representation.  According to the SEG specifications, the
 * bit layout of the 10 bytes is:
 *
 *
 *  Bit	0	1	2	3	4	5	6	7
 *-----------------------------------------------------------
 * Byte 1    C3    C2    C1    C0    C3    C2    C1    C0    Exponents for
 * Byte 2    C3    C2    C1    C0    C3    C2    C1    C0    channels 1 thru 4
 *
 * Byte 3	S    Q-1   Q-2   Q-3   Q-4   Q-5   Q-6   Q-7   Channel 1
 * Byte 4    Q-8   Q-9   Q-10  Q-11  Q-12  Q-13  Q-14   0
 * Byte 5	S    Q-1   Q-2   Q-3   Q-4   Q-5   Q-6   Q-7   Channel 2
 * Byte 6    Q-8   Q-9   Q-10  Q-11  Q-12  Q-13  Q-14   0
 * Byte 7	S    Q-1   Q-2   Q-3   Q-4   Q-5   Q-6   Q-7   Channel 3
 * Byte 8    Q-8   Q-9   Q-10  Q-11  Q-12  Q-13  Q-14   0
 * Byte 9	S    Q-1   Q-2   Q-3   Q-4   Q-5   Q-6   Q-7   Channel 4
 * Byte 10   Q-8   Q-9   Q-10  Q-11  Q-12  Q-13  Q-14   0
 *
 * S=sign bit. - (One = negative number)
 * C=binary exponents. - This is a 4 bit positive binary exponent of 2
 *		CCCC
 *   written as 2	where CCCC can assume values of 0-15.  The four
 *   exponents are in channel number order for the four channels starting
 *   with channel one in bits 0-3 of Byte 1.
 * Q1-14-fraction. - This is a 14 bit one's complement binary fraction.
 *   The radix point is to the left of the most significant bit (Q-1)
 *				  -1
 *   with the MSB being defined as 2 .  The sign and fraction can assume
 *		  -14	-14
 *   values from 1-2   to -1+2  .  Note that bit 7 of the second byte
 *   of each sample must be zero in order to guarantee the uniqueness of
 *   the start of scan.  Negative zero is invalid and must be converted
 *   to positive zero.
 *					CCCC    MP		   MP
 * Input signal = S.QQQQ,QQQQ,QQQQ,QQ x 2    x 2    millivolts where 2
 *   is the value required to descale the data word to the recording
 *   system input level.  MP is defined in Byte 8 of each of the corre-
 *   sponding channel set descriptors in the scan type header.
 * Note that in utilizing this data recording method, the number of data
 *   channels per channel set must be exactly divisible by 4 in order to
 *   preserve the data grouping of this method.
 */

static void F0015_to_float (Sfio_t *from, float to[], int len, int cvt2s)
{
 register int i;
 register short ex1_4;
 int expo;
 short fraction;

 for (i = 0; i < len; i += 4) {
	ex1_4 = GET_S(from);
 	expo = ((ex1_4 >> 12) & 0x0F) - 15;
	fraction = GET_S(from);
	if (fraction < 0 && cvt2s == 0) fraction = -((~fraction)&(~1));
 	*(to++) = ldexp((double) fraction, expo);

 	expo = ((ex1_4 >> 8) & 0x0F) - 15;
	fraction = GET_S(from);
	if (fraction < 0 && cvt2s == 0) fraction = -((~fraction)&(~1));
 	*(to++) = ldexp((double) fraction, expo);

 	expo = ((ex1_4 >> 4) & 0x0F) - 15;
	fraction = GET_S(from);
	if (fraction < 0 && cvt2s == 0) fraction = -((~fraction)&(~1));
 	*(to++) = ldexp((double) fraction, expo);

 	expo = (ex1_4 & 0x0F) - 15;
	fraction = GET_S(from);
	if (fraction < 0 && cvt2s == 0) fraction = -((~fraction)&(~1));
 	*(to++) = ldexp((double) fraction, expo);
 }
}
#endif

static void F8015_to_float (Sfio_t *from, float to[], int len, int cvt2s)
/* F8015_to_float - convert 20 bit binary demultiplexed data into floating numbers
 *
 * Credits:
 *	EOPG: Marc Schaming, Jean-Daniel Tissot
 *	SEP:  Stew Levin - fixed low-order bit error in conversion
 *	    of negative values on 2's complement machines.
 *	    Use ldexp() function instead of much slower value*pow(2,expo)
 *
 * Parameters:
 *    from   - input vector
 *    to	- output vector
 *    len    - number of packets of 4 floats in vectors
 *    cvt2s  - two's complement instead of ones' complement
 *
 */
/*
 *
 * Format 8015 is a 10 byte per 4 words (2 1/2 bytes per word)
 * representation.  According to the SEG specifications, the
 * bit layout of the 10 bytes is:
 *
 *
 *  Bit	0	1	2	3	4	5	6	7
 *-----------------------------------------------------------
 * Byte 1    C3    C2    C1    C0    C3    C2    C1    C0    Exponents for
 * Byte 2    C3    C2    C1    C0    C3    C2    C1    C0    channels 1 thru 4
 *
 * Byte 3	S    Q-1   Q-2   Q-3   Q-4   Q-5   Q-6   Q-7   Channel 1
 * Byte 4    Q-8   Q-9   Q-10  Q-11  Q-12  Q-13  Q-14  Q-15
 * Byte 5	S    Q-1   Q-2   Q-3   Q-4   Q-5   Q-6   Q-7   Channel 2
 * Byte 6    Q-8   Q-9   Q-10  Q-11  Q-12  Q-13  Q-14  Q-15
 * Byte 7	S    Q-1   Q-2   Q-3   Q-4   Q-5   Q-6   Q-7   Channel 3
 * Byte 8    Q-8   Q-9   Q-10  Q-11  Q-12  Q-13  Q-14  Q-15
 * Byte 9	S    Q-1   Q-2   Q-3   Q-4   Q-5   Q-6   Q-7   Channel 4
 * Byte 10   Q-8   Q-9   Q-10  Q-11  Q-12  Q-13  Q-14  Q-15
 *
 * S=sign bit. - (One = negative number)
 * C=binary exponents. - This is a 4 bit positive binary exponent of 2
 *		CCCC
 *   written as 2	where CCCC can assume values of 0-15.  The four
 *   exponents are in channel number order for the four channels starting
 *   with channel one in bits 0-3 of Byte 1.
 * Q1-15-fraction. - This is a 15 bit one's complement binary fraction.
 *   The radix point is to the left of the most significant bit (Q-1)
 *				  -1
 *   with the MSB being defined as 2 .  The sign and fraction can assume
 *		  -15	-15
 *   values from 1-2   to -1+2  .  Negative zero is invalid and must be
 *   converted to positive zero.
 *					CCCC    MP		   MP
 * Input signal = S.QQQQ,QQQQ,QQQQ,QQQ x 2    x 2    millivolts where 2
 *   is the value required to descale the data word to the recording
 *   system input level.  MP is defined in Byte 8 of each of the corre-
 *   sponding channel set descriptors in the scan type header.
 * Note that in utilizing this data recording method, the number of data
 *   channels per channel set must be exactly divisible by 4 in order to
 *   preserve the data grouping of this method.
 */

{
 register int i;
 register short ex1_4;
 int expo;
 short fraction;

 for (i = 0; i < len; i += 4) {
	ex1_4 = GET_S(from);
 	expo = ((ex1_4 >> 12) & 15) - 15;
	fraction = GET_S(from);
	if (fraction < 0 && cvt2s == 0) fraction = -(~fraction);
 	*(to++) = ldexp((double) fraction, expo);

 	expo = ((ex1_4 >> 8) & 15) - 15;
	fraction = GET_S(from);
	if (fraction < 0 && cvt2s == 0) fraction = -(~fraction);
 	*(to++) = ldexp((double) fraction, expo);

 	expo = ((ex1_4 >> 4) & 15) - 15;
	fraction = GET_S(from);
	if (fraction < 0 && cvt2s == 0) fraction = -(~fraction);
 	*(to++) = ldexp((double) fraction, expo);

 	expo = (ex1_4 & 15) - 15;
	fraction = GET_S(from);
	if (fraction < 0 && cvt2s == 0) fraction = -(~fraction);
 	*(to++) = ldexp((double) fraction, expo);
 }
}

static void F8022_to_float (Sfio_t *from, float to[], int len, int cvt2s)
/* F8022_to_float - convert 8 bit quaternary demultiplexed data into floating numbers
 *
 * Credits:
 *	SEP:  Stew Levin
 *
 * Parameters:
 *    from   - input sfio unit
 *    to	- output vector
 *    len    - number of packets of 4 floats in vectors
 *
 */
/*
 *
 * Format 8022 is a 1 byte per word representation.
 * According to the SEG specifications, the bit
 * layout of the byte is:
 *
 *
 *  Bit	0	1	2	3	4	5	6	7
 *-----------------------------------------------------------
 * Byte 1	S    C2    C1    C0    Q-1   Q-2   Q-3   Q-4
 *
 * S=sign bit. - (One = negative number)
 * C=quaternary exponent. - This is a 3 bit positive binary exponent of 4
 *		CCC
 *   written as 4    where CCC can assume values of 0-7.
 * Q1-4-fraction. - This is a 4 bit one's complement binary fraction.
 *   The radix point is to the left of the most significant bit (Q-1)
 *				  -1
 *   with the MSB being defined as 2 .  The fraction can have values
 *	   -4	-4
 *   from 1-2   to -1+2  .  Negative zero is invalid and must be
 *   converted to positive zero.
 *			  CCC   MP		   MP
 * Input signal = S.QQQQ x 4   x 2   millivolts where 2    is the
 *   value required to descale the data word to the recording system
 *   input level.  MP is defined in Byte 8 of each of the corre-
 *   sponding channel set descriptors in the scan type header.
 */

{
 register int i;
 register int ex1_4;
 int expo;
 short fraction;
 register short sgnext = (-1) & (~15);

 for (i = 0; i < len; i ++) {
	ex1_4 = GET_C(from);
	expo = ((ex1_4 >> 3) & 14) - 4;
	fraction = ex1_4 & 15;
	if (ex1_4 & 128) fraction = cvt2s ? (sgnext | fraction) : -(15^fraction);
	*(to++) = ldexp((double) fraction, expo);
 }
}

static void F8024_to_float (Sfio_t *from, float to[], int len, int cvt2s)
/* F8024_to_float - convert 16 bit quaternary demultiplexed data into floating numbers
 *
 * Credits:
 *	SEP:  Stew Levin
 *
 * Parameters:
 *    from   - input sfio unit
 *    to	- output vector
 *    len    - number of packets of 4 floats in vectors
 *
 */
/*
 *
 * Format 8024 is a 2 byte per word representation.
 * According to the SEG specifications, the bit
 * layout of the bytes is:
 *
 *
 *  Bit	0	1	2	3	4	5	6	7
 *-----------------------------------------------------------
 * Byte 1	S    C2    C1    C0    Q-1   Q-2   Q-3   Q-4
 * Byte 2    Q-5   Q-6   Q-7   Q-8   Q-9   Q-10  Q-11  Q-12
 *
 * S=sign bit. - (One = negative number)
 * C=quaternary exponent. - This is a 3 bit positive binary exponent of 4
 *		CCC
 *   written as 4    where CCC can assume values of 0-7.
 * Q1-12-fraction. - This is a 12 bit one's complement binary fraction.
 *   The radix point is to the left of the most significant bit (Q-1)
 *				  -1
 *   with the MSB being defined as 2 .  The fraction can have values
 *	   -12	-12
 *   from 1-2    to -1+2   .  Negative zero is invalid and must be
 *   converted to positive zero.
 *				    CCC   MP		   MP
 * Input signal = S.QQQQ,QQQQ,QQQQ x 4   x 2   millivolts where 2
 *   is the value required to descale the data word to the recording
 *   system input level.  MP is defined in Byte 8 of each of the corre-
 *   sponding channel set descriptors in the scan type header.
 */

{
 register int i;
 register int ex1_4;
 int expo;
 short fraction;
 register short sgnext = (-1) & (~4095);

 for (i = 0; i < len; i ++) {
	ex1_4 = GET_S(from);
	expo = ((ex1_4 >> 11) & 14) - 12;
	fraction = ex1_4 & 4095;
	if (ex1_4 & 32768) fraction = cvt2s ? (sgnext | fraction) : -(4095^fraction);
	*(to++) = ldexp((double) fraction, expo);
 }
}

/* F8036_to_float - convert 24 bit quaternary demultiplexed data into floating numbers
 *
 * Credits:
 *	SEP:  Stew Levin
 *
 * Parameters:
 *    from   - input sfio unit
 *    to	- output vector
 *    len    - number of packets of 4 floats in vectors
 *
 */
/*
 *
 * Format 8036 is a 3 byte per word representation.
 * According to the SEG specifications, the bit
 * layout of the bytes is:
 *
 *
 *  Bit	0	1	2	3	4	5	6	7
 *-----------------------------------------------------------
 * Byte 1    Q-1   Q-2   Q-3   Q-4   Q-5   Q-6   Q-7   Q-8
 * Byte 2    Q-9   Q-10  Q-11  Q-12  Q-13  Q-14  Q-15  Q-16
 * Byte 3    Q-17  Q-18  Q-19  Q-20  Q-21  Q-22  Q-23  Q-24
 *
 * Q1-24-integer. - This is a 24 bit two's complement binary integer.
 *			 MP		   MP
 * Input signal = Q...Q x 2   millivolts where 2
 *   is the value required to descale the data word to the recording
 *   system input level.  MP is defined in Byte 8 of each of the corre-
 *   sponding channel set descriptors in the scan type header.
 */

static void F8036_to_float (Sfio_t *from, float to[], int len)
{
 register int i;
 register long int ival;

 for (i = 0; i < len; i ++) {
	ival = GET_UC(from);
	ival <<= 8; ival |= GET_UC(from);
	ival <<= 8; ival |= GET_UC(from);
	if(ival > 8388607) ival -= 16777216;
	*(to++) = (float) ival;
 }
}

/* F8038_to_float - convert 32 bit quaternary demultiplexed data into floating numbers
 *
 * Credits:
 *	SEP:  Stew Levin
 *
 * Parameters:
 *    from   - input sfio unit
 *    to	- output vector
 *    len    - number of packets of 4 floats in vectors
 *
 */
/*
 *
 * Format 8038 is a 4 byte per word representation.
 * According to the SEG specifications, the bit
 * layout of the bytes is:
 *
 *
 *  Bit	0	1	2	3	4	5	6	7
 *-----------------------------------------------------------
 * Byte 1    Q-1   Q-2   Q-3   Q-4   Q-5   Q-6   Q-7   Q-8
 * Byte 2    Q-9   Q-10  Q-11  Q-12  Q-13  Q-14  Q-15  Q-16
 * Byte 3    Q-17  Q-18  Q-19  Q-20  Q-21  Q-22  Q-23  Q-24
 * Byte 4    Q-25  Q-26  Q-27  Q-28  Q-29  Q-30  Q-31  Q-32
 *
 * Q1-32-fraction. - This is a 32 bit two's complement binary integer.
 *			 MP		   MP
 * Input signal = Q...Q x 2   millivolts where 2
 *   is the value required to descale the data word to the recording
 *   system input level.  MP is defined in Byte 8 of each of the corre-
 */
 /* Note this conversion routine assumes the target architecture is
  * already 2's complement.
  */

static void F8038_to_float (Sfio_t *from, float to[], int len)
{
 int i;
 long int ex1_4;
 long int ex2_4;
 long int value;

 for (i = 0; i < len; i ++) {
	ex1_4 = GET_S(from);
	ex2_4 = GET_S(from);
	value = (ex1_4<<16) | (ex2_4&65535);
	*(to++) = (float) value;
 }
}

/* F8042_to_float - convert 8 bit hexadecimal demultiplexed data into floating numbers
 *
 * Credits:
 *	SEP:  Stew Levin
 *
 * Parameters:
 *    from   - input sfio unit
 *    to	- output vector
 *    len    - number of floats in vector
 *
 */
/*
 *
 * Format 8042 is a 1 byte per word representation.
 * According to the SEG specifications, the bit
 * layout of the byte is:
 *
 *
 *  Bit	0	1	2	3	4	5	6	7
 *-----------------------------------------------------------
 * Byte 1	S    C1    C0    Q-1   Q-2   Q-3   Q-4   Q-5
 *
 * S=sign bit. - (One = negative number)
 * C=hexadecimal exponent. - This is a 2 bit positive binary exponent of 16
 *		CC
 *   written as 16    where CC can assume values of 0-3.
 * Q1-5-fraction. - This is a 5 bit positive binary fraction.
 *   The radix point is to the left of the most significant bit (Q-1)
 *				  -1
 *   with the MSB being defined as 2 .  The fraction can have values
 *	   -5	-5
 *   from 1-2   to -1+2  .
 *				CC    MP		   MP
 * Input signal = S.QQQQ,Q x 16   x 2   millivolts where 2    is the
 *   value required to descale the data word to the recording system
 *   input level.  MP is defined in Byte 8 of each of the corre-
 *   sponding channel set descriptors in the scan type header.
 */

static void F8042_to_float (Sfio_t *from, float to[], int len)
{
 register int i;
 register int ex1_4;
 int expo;
 short fraction;

 for (i = 0; i < len; i ++) {
	ex1_4 = GET_C(from);
	expo = ((ex1_4 >> 3) & 12) - 5;
	fraction = ex1_4 & 31;
	if (ex1_4 & 128) fraction = -fraction;
	*(to++) = ldexp((double) fraction, expo);
 }
}

/* F8044_to_float - convert 16 bit hexadecimal demultiplexed data into floating numbers
 *
 * Credits:
 *	SEP:  Stew Levin
 *
 * Parameters:
 *    from   - input sfio unit
 *    to	- output vector
 *    len    - number of floats in vector
 *
 */
/*
 *
 * Format 8044 is a 2 byte per word representation.
 * According to the SEG specifications, the bit
 * layout of the bytes is:
 *
 *
 *  Bit	0	1	2	3	4	5	6	7
 *-----------------------------------------------------------
 * Byte 1	S    C1    C0    Q-1   Q-2   Q-3   Q-4   Q-5
 * Byte 2    Q-6   Q-7   Q-8   Q-9   Q-10  Q-11  Q-12  Q-13
 *
 * S=sign bit. - (One = negative number)
 * C=hexadecimal exponent. - This is a 2 bit positive binary exponent of 16
 *		CC
 *   written as 16    where CC can assume values of 0-3.
 * Q1-13-fraction. - This is a 13 bit positive binary fraction.
 *   The radix point is to the left of the most significant bit (Q-1)
 *				  -1
 *   with the MSB being defined as 2 .  The fraction can have values
 *	   -13	-13
 *   from 1-2    to -1+2   .
 *					CC    MP		   MP
 * Input signal = S.QQQQ,QQQQ,QQQQ,Q x 16   x 2   millivolts where 2
 *   is the value required to descale the data word to the recording system
 *   input level.  MP is defined in Byte 8 of each of the corre-
 *   sponding channel set descriptors in the scan type header.
 */

static void F8044_to_float (Sfio_t *from, float to[], int len)
{
 register int i;
 register int ex1_4;
 int expo;
 short fraction;

 for (i = 0; i < len; i ++) {
	ex1_4 = GET_S(from);
	expo = ((ex1_4 >> 11) & 12) - 13;
	fraction = ex1_4 & 8191;
	if (ex1_4 & 32768) fraction = -fraction;
	*(to++) = ldexp((double) fraction, expo);
 }
}

/* F8048_to_float - convert 32 bit hexadecimal demultiplexed data into floating numbers
 *
 * Credits:
 *	SEP:  Stew Levin
 *
 * Parameters:
 *    from   - input sfio unit
 *    to	- output vector
 *    len    - number of floats in vector
 *
 */
/*
 *
 * Format 8048 is a 4 byte per word representation.
 * According to the SEG specifications, the bit
 * layout of the bytes is:
 *
 *
 *  Bit	0	1	2	3	4	5	6	7
 *-----------------------------------------------------------
 * Byte 1	S    C6    C5    C4    C3    C2    C1    C0
 * Byte 2    Q-1   Q-2   Q-3   Q-4   Q-5   Q-6   Q-7   Q-8
 * Byte 3    Q-9   Q-10  Q-11  Q-12  Q-13  Q-14  Q-15  Q-16
 * Byte 4    Q-17  Q-18  Q-19  Q-20  Q-21  Q-22  Q-23  0
 *
 * S=sign bit. - (One = negative number)
 * C=hexadecimal exponent. - This is a binary exponent of 16
 *		(CCCCCCC-64)
 *   written as 16		where CC can assume values of 0-127.
 * Q1-23-fraction. - This is a 23 bit positive binary fraction.
 *   The radix point is to the left of the most significant bit (Q-1)
 *				  -1
 *   with the MSB being defined as 2 .  The sign and fraction can have
 *		 -23	-23
 *   values from 1-2    to -1+2   .
 *				   C-64    MP		   MP
 * Input signal = S.QQQQ,...,QQQ x 16	x 2   millivolts where 2
 *   is the value required to descale the data word to the recording system
 *   input level.  MP is defined in Byte 8 of each of the corre-
 *   sponding channel set descriptors in the scan type header.
 *   The data recording method has more than sufficient range to
 *   handle the dynamic range of a typical seismic system.  Thus, MP
 *   may not be needed to account for any scaling and may be recorded
 *   as zero.
 */

static void F8048_to_float (Sfio_t *from, float to[], int len)
{
 register int i;
 register int ex1_4;
 int expo;
 long int fraction;

 for (i = 0; i < len; i ++) {
	ex1_4 = GET_S(from);
	expo = ((ex1_4 >> 6) & 508) - (24+256);
	fraction = ex1_4 & 255;
	fraction <<= 16; fraction |= (GET_S(from)&65535);
	if (ex1_4 & 32768) fraction = -fraction;
	*(to++) = ldexp((double) fraction, expo);
 }
}

/* F8058_to_float - convert 32 bit IEEE float demultiplexed data into floating numbers
 *
 * Credits:
 *	SEP:  Stew Levin
 *
 * Parameters:
 *    from   - input sfio unit
 *    to	- output vector
 *    len    - number of floats in vector
 *
 */
/*
 *
 * Format 8058 is a 4 byte per word representation.
 * According to the SEG specifications, the bit
 * layout of the bytes is:
 *
 *
 *  Bit	0	1	2	3	4	5	6	7
 *-----------------------------------------------------------
 * Byte 1	S    C7    C6    C5    C4    C3    C2    C1
 * Byte 2    C0    Q-1   Q-2   Q-3   Q-4   Q-5   Q-6   Q-7
 * Byte 3    Q-8   Q-9   Q-10  Q-11  Q-12  Q-13  Q-14  Q-15
 * Byte 4    Q-16  Q-17  Q-18  Q-19  Q-20  Q-21  Q-22  Q-23
 *
 * S=sign bit. - (One = negative number)
 * C=exponent. - This is a excess-127 binary exponent of 2
 *		(CCCCCCCC-127)
 *   written as 2		where CC can assume values of 0-255.
 * Q1-23-fraction. - This is a 23 bit positive binary fraction.
 *   The radix point is to the left of the most significant bit (Q-1)
 *				  -1
 *   with the MSB being defined as 2 .  With the exceptions noted below:
 *
 *		    S		    C-127    MP		   MP
 * Input signal = (-1) x 1.QQQQ,...,QQQ x 2	x 2   millivolts where 2
 *   is the value required to descale the data word to the recording system
 *   input level.  MP is defined in Byte 8 of each of the corre-
 *   sponding channel set descriptors in the scan type header.
 *   The data recording method has more than sufficient range to
 *   handle the dynamic range of a typical seismic system.  Thus, MP
 *   may not be needed to account for any scaling and may be recorded
 *   as zero.
 *
 * Exceptions:
 *
 * If C=0 then
 *		    S		    -126	MP
 * Input signal = (-1) x 0.QQQQ,...,QQQ x 2	x 2   millivolts
 *
 * If C=255 and Q=0, then
 *		    S
 * Input signal = (-1) x infinity  (overflow)
 *
 * If C=255 and Q!=0, then
 *
 * Input signal = NaN  (Not-a-Number)
 */

static void F8058_to_float (Sfio_t *from, float to[], int len)
{
 register int i;
 register int ex1_4, ex2_4;
 int expo;
 long int fraction;

 for (i = 0; i < len; i ++) {
	ex1_4 = GET_S(from);
	ex2_4 = GET_S(from);
	expo = ((ex1_4 >> 7) & 255);
	fraction = ex1_4 & 127;
	fraction <<= 16; fraction |= (ex2_4&65535);
	if(expo) fraction |= 8388608;
	else fraction <<= 1;
	if (ex1_4 & 32768) fraction = -fraction;
	*(to++) = ldexp((double) fraction, expo-(23+127));
 }
}

int
get_gh1(general_header_1 * gh1, Sfio_t *tapeun)
{
  int status;

  gh1->f[0]=GET_UC(tapeun);
  gh1->f[1]=GET_UC(tapeun);
  gh1->y=GET_US(tapeun);
  gh1->k1_k2=GET_C(tapeun);
  gh1->k3_k4=GET_C(tapeun);
  gh1->k5_k6=GET_C(tapeun);
  gh1->k7_k8=GET_C(tapeun);
  gh1->k9_k10=GET_C(tapeun);
  gh1->k11_k12=GET_C(tapeun);
  gh1->yr=GET_UC(tapeun);
  gh1->gh_dy1=GET_UC(tapeun);

  gh1->dy=GET_UC(tapeun);
  gh1->h=GET_UC(tapeun);
  gh1->mi=GET_UC(tapeun);
  gh1->se=GET_UC(tapeun);

  gh1->m[0]=GET_UC(tapeun);
  gh1->m[1]=GET_UC(tapeun);
  gh1->m[2]=GET_UC(tapeun);
  gh1->b[0]=GET_UC(tapeun);

  gh1->b[1]=GET_UC(tapeun);
  gh1->b[2]=GET_UC(tapeun);
  gh1->i=GET_UC(tapeun);
  gh1->p_sbx=GET_UC(tapeun);

  gh1->sb=GET_UC(tapeun);
  gh1->z_r1=GET_UC(tapeun);
  gh1->r=GET_UC(tapeun);
  gh1->str=GET_UC(tapeun);

  gh1->cs=GET_UC(tapeun);
  gh1->sk=GET_UC(tapeun);
  gh1->ec=GET_UC(tapeun);
  gh1->ex=GET_UC(tapeun);

  status = (sferror(tapeun)||sfeof(tapeun));

  return (status?EXIT_FAILURE:EXIT_SUCCESS);
}

int
get_gh2(general_header_2 * gh2, Sfio_t *tapeun)
{
  int status;

  gh2->ef[0]=GET_UC(tapeun);
  gh2->ef[1]=GET_UC(tapeun);
  gh2->ef[2]=GET_UC(tapeun);
  gh2->en[0]=GET_UC(tapeun);

  gh2->en[1]=GET_UC(tapeun);
  gh2->ecx[0]=GET_UC(tapeun);
  gh2->ecx[1]=GET_UC(tapeun);
  gh2->eh[0]=GET_UC(tapeun);

  gh2->eh[1]=GET_UC(tapeun);
  gh2->x1=GET_C(tapeun);
  gh2->rev[0]=GET_UC(tapeun);
  gh2->rev[1]=GET_UC(tapeun);

  gh2->gt=GET_US(tapeun);
  gh2->erl[0]=GET_UC(tapeun);
  gh2->erl[1]=GET_UC(tapeun);

  gh2->erl[2]=GET_UC(tapeun);
  gh2->x2=GET_C(tapeun);
  gh2->bn=GET_UC(tapeun);
  gh2->x3[0]=GET_C(tapeun);

  gh2->x3[1]=GET_C(tapeun);
  gh2->x3[2]=GET_C(tapeun);
  gh2->x3[3]=GET_C(tapeun);
  gh2->x3[4]=GET_C(tapeun);

  gh2->x3[5]=GET_C(tapeun);
  gh2->x3[6]=GET_C(tapeun);
  gh2->x3[7]=GET_C(tapeun);
  gh2->x3[8]=GET_C(tapeun);

  gh2->x3[9]=GET_C(tapeun);
  gh2->x3[10]=GET_C(tapeun);
  gh2->x3[11]=GET_C(tapeun);
  gh2->x3[12]=GET_C(tapeun);

  status = (sferror(tapeun)||sfeof(tapeun));

  return (status?EXIT_FAILURE:EXIT_SUCCESS);
}

int
get_ghn(general_header_n * ghn, Sfio_t *tapeun)
{
  int status;

  ghn->x1[0]=GET_C(tapeun);
  ghn->x1[1]=GET_C(tapeun);
  ghn->x1[2]=GET_C(tapeun);
  ghn->sln[0]=GET_UC(tapeun);

  ghn->sln[1]=GET_UC(tapeun);
  ghn->sln[2]=GET_UC(tapeun);
  ghn->sln[3]=GET_UC(tapeun);
  ghn->sln[4]=GET_UC(tapeun);

  ghn->spn[0]=GET_UC(tapeun);
  ghn->spn[1]=GET_UC(tapeun);
  ghn->spn[2]=GET_UC(tapeun);
  ghn->spn[3]=GET_UC(tapeun);

  ghn->spn[4]=GET_UC(tapeun);
  ghn->spi=GET_UC(tapeun);
  ghn->pc=GET_UC(tapeun);
  ghn->v=GET_UC(tapeun);

  ghn->pa=GET_S(tapeun);
  ghn->bn=GET_UC(tapeun);
  ghn->ss=GET_UC(tapeun);

  ghn->x2[0]=GET_C(tapeun);
  ghn->x2[1]=GET_C(tapeun);
  ghn->x2[2]=GET_C(tapeun);
  ghn->x2[3]=GET_C(tapeun);

  ghn->x2[4]=GET_C(tapeun);
  ghn->x2[5]=GET_C(tapeun);
  ghn->x2[6]=GET_C(tapeun);
  ghn->x2[7]=GET_C(tapeun);

  ghn->x2[8]=GET_C(tapeun);
  ghn->x2[9]=GET_C(tapeun);
  ghn->x2[10]=GET_C(tapeun);
  ghn->x2[11]=GET_C(tapeun);

  status = (sferror(tapeun)||sfeof(tapeun));

  return (status?EXIT_FAILURE:EXIT_SUCCESS);
}

int
get_gn_sn358(gen_head_sn358 * gh358, Sfio_t *tapeun)
{
  int status;

  gh358->fc1=GET_UC(tapeun);
  gh358->lc1=GET_UC(tapeun);
  gh358->fc2=GET_UC(tapeun);
  gh358->f_lc2=GET_UC(tapeun);

  gh358->lc2=GET_UC(tapeun);
  gh358->fc3=GET_UC(tapeun);
  gh358->f_lc3=GET_UC(tapeun);
  gh358->lc3=GET_UC(tapeun);

  gh358->fc4=GET_UC(tapeun);
  gh358->f_lc4=GET_UC(tapeun);
  gh358->lc4=GET_UC(tapeun);
  gh358->f_lac1=GET_UC(tapeun);

  gh358->fsc1=GET_UC(tapeun);
  gh358->f_lsc1=GET_UC(tapeun);
  gh358->lsc1=GET_UC(tapeun);
  gh358->sam_int1=GET_UC(tapeun);

  gh358->fac2=GET_UC(tapeun);
  gh358->fsc2=GET_UC(tapeun);
  gh358->f_lsc2=GET_UC(tapeun);
  gh358->lsc2=GET_UC(tapeun);

  gh358->sam_int2=GET_UC(tapeun);
  gh358->bl_sig_le=GET_UC(tapeun);
  gh358->rec_length[0]=GET_UC(tapeun);
  gh358->rec_length[1]=GET_UC(tapeun);

  gh358->dyn_swit_del[0]=GET_UC(tapeun);
  gh358->dyn_swit_del[1]=GET_UC(tapeun);
  gh358->rec_del[0]=GET_UC(tapeun);
  gh358->rec_del[1]=GET_UC(tapeun);

  gh358->ty_a_cha12=GET_UC(tapeun);
  gh358->ty_a_cha34=GET_UC(tapeun);
  gh358->ty_a_cha56=GET_UC(tapeun);
  gh358->ty_a_cha78=GET_UC(tapeun);

  gh358->mode_num=GET_UC(tapeun);
  gh358->an_sys_co=GET_UC(tapeun);
  gh358->reel_num[0]=GET_UC(tapeun);
  gh358->reel_num[1]=GET_UC(tapeun);

  gh358->file_num[0]=GET_UC(tapeun);
  gh358->file_num[1]=GET_UC(tapeun);
  gh358->sp_num[0]=GET_UC(tapeun);
  gh358->sp_num[1]=GET_UC(tapeun);

  gh358->lc_nf=GET_UC(tapeun);
  gh358->fg_ic=GET_UC(tapeun);
  gh358->of1=GET_UC(tapeun);
  gh358->of2=GET_UC(tapeun);

  gh358->of3=GET_UC(tapeun);
  gh358->osc_att=GET_UC(tapeun);
  gh358->t_sig_ph=GET_UC(tapeun);
  gh358->m_gain=GET_UC(tapeun);

  gh358->dum[0]=GET_UC(tapeun);
  gh358->dum[1]=GET_UC(tapeun);
  gh358->dum[2]=GET_UC(tapeun);
  gh358->dum[3]=GET_UC(tapeun);

  gh358->dum[4]=GET_UC(tapeun);
  gh358->dum[5]=GET_UC(tapeun);
  gh358->dum[6]=GET_UC(tapeun);
  gh358->dum[7]=GET_UC(tapeun);

  gh358->dum[8]=GET_UC(tapeun);
  gh358->dum[9]=GET_UC(tapeun);
  gh358->dum[10]=GET_UC(tapeun);
  gh358->dum[11]=GET_UC(tapeun);

  gh358->dum[12]=GET_UC(tapeun);
  gh358->dum[13]=GET_UC(tapeun);
  gh358->dum[14]=GET_UC(tapeun);
  gh358->dum[15]=GET_UC(tapeun);

  status = (sferror(tapeun)||sfeof(tapeun));

  return (status?EXIT_FAILURE:EXIT_SUCCESS);
}

int
get_csh(channel_set_header * csh, Sfio_t *tapeun)
{
  int status;

  csh->st=GET_UC(tapeun);
  csh->cn=GET_UC(tapeun);
  csh->tf=GET_US(tapeun);

  csh->te=GET_US(tapeun);
  csh->mp[0]=GET_UC(tapeun);
  csh->mp[1]=GET_UC(tapeun);

  csh->cs[0]=GET_UC(tapeun);
  csh->cs[1]=GET_UC(tapeun);
  csh->c=GET_UC(tapeun);
  csh->sc_j=GET_UC(tapeun);

  csh->af=GET_US(tapeun);
  csh->as=GET_US(tapeun);

  csh->lc=GET_US(tapeun);
  csh->ls=GET_US(tapeun);

  csh->nt[0]=GET_US(tapeun);
  csh->nt[1]=GET_US(tapeun);

  csh->nt[2]=GET_US(tapeun);
  csh->ecs=GET_US(tapeun);

  csh->efh=GET_UC(tapeun);
  csh->vs=GET_UC(tapeun);
  csh->cab=GET_UC(tapeun);
  csh->ary=GET_UC(tapeun);

  status = (sferror(tapeun)||sfeof(tapeun));

  return (status?EXIT_FAILURE:EXIT_SUCCESS);
}


int
get_the(trace_header_ext * the, Sfio_t *tapeun)
{
  int status;

  the->rln[0]=GET_UC(tapeun);
  the->rln[1]=GET_UC(tapeun);
  the->rln[2]=GET_UC(tapeun);
  the->rpn[0]=GET_UC(tapeun);

  the->rpn[1]=GET_UC(tapeun);
  the->rpn[2]=GET_UC(tapeun);
  the->rpi=GET_UC(tapeun);
  the->nbs[0]=GET_UC(tapeun);

  the->nbs[1]=GET_UC(tapeun);
  the->nbs[2]=GET_UC(tapeun);
  the->x[0]=GET_C(tapeun);
  the->x[1]=GET_C(tapeun);

  the->x[2]=GET_C(tapeun);
  the->x[3]=GET_C(tapeun);
  the->x[4]=GET_C(tapeun);
  the->x[5]=GET_C(tapeun);

  the->x[6]=GET_C(tapeun);
  the->x[7]=GET_C(tapeun);
  the->x[8]=GET_C(tapeun);
  the->x[9]=GET_C(tapeun);

  the->x[10]=GET_C(tapeun);
  the->x[11]=GET_C(tapeun);
  the->x[12]=GET_C(tapeun);
  the->x[13]=GET_C(tapeun);

  the->x[14]=GET_C(tapeun);
  the->x[15]=GET_C(tapeun);
  the->x[16]=GET_C(tapeun);
  the->x[17]=GET_C(tapeun);

  the->x[18]=GET_C(tapeun);
  the->x[19]=GET_C(tapeun);
  the->x[20]=GET_C(tapeun);
  the->x[21]=GET_C(tapeun);

 status = (sferror(tapeun)||sfeof(tapeun));

  return (status?EXIT_FAILURE:EXIT_SUCCESS);
}

int get_ssh(sample_skew * ssh, Sfio_t *tapeun)
{
  int status;
  int i;

  for(i=0; i<32; i++ ) {
	ssh->skew[i] = GET_UC(tapeun);
	}

  status = (sferror(tapeun)||sfeof(tapeun));

  return (status?EXIT_FAILURE:EXIT_SUCCESS);
}

int get_ech(extended_header * ech, Sfio_t *tapeun)
{
  int status;
  int i;

  for(i=0; i<32; i++ ) {
	ech->dummy[i] = GET_UC(tapeun);
	}

  status = (sferror(tapeun)||sfeof(tapeun));

  return (status?EXIT_FAILURE:EXIT_SUCCESS);
}

int get_exh(external_header * exh, Sfio_t *tapeun)
{
  int status;
  int i;

  for(i=0; i<32; i++ ) {
	exh->dummy[i] = GET_UC(tapeun);
	}

  status = (sferror(tapeun)||sfeof(tapeun));

  return (status?EXIT_FAILURE:EXIT_SUCCESS);
}

int get_gt(general_trailer * gt, Sfio_t *tapeun)
{
  int status;
  int i;

  gt->gt = GET_US(tapeun);
  for(i=0; i<8; i++ ) {
	gt->x1[i] = GET_C(tapeun);
  }

  gt->c = GET_UC(tapeun);

  for(i=0; i<21; i++ ) {
	gt->x2[i] = GET_C(tapeun);
  }

  status = (sferror(tapeun)||sfeof(tapeun));

  return (status?EXIT_FAILURE:EXIT_SUCCESS);
}

int get_dth(dem_trace_header * dth, Sfio_t *tapeun)
{
  int status;

  dth->f = GET_S(tapeun);
  dth->st = GET_UC(tapeun);
  dth->cn = GET_UC(tapeun);
  dth->tn[0] = GET_UC(tapeun);
  dth->tn[1] = GET_UC(tapeun);
  dth->t[0] = GET_UC(tapeun);
  dth->t[1] = GET_UC(tapeun);
  dth->t[2] = GET_UC(tapeun);
  dth->the = GET_UC(tapeun);
  dth->ss = GET_UC(tapeun);
  dth->tr = GET_UC(tapeun);
  dth->tw[0] = GET_UC(tapeun);
  dth->tw[1] = GET_UC(tapeun);
  dth->tw[2] = GET_UC(tapeun);
  dth->en[0] = GET_UC(tapeun);
  dth->en[1] = GET_UC(tapeun);
  dth->efn[0] = GET_UC(tapeun);
  dth->efn[1] = GET_UC(tapeun);
  dth->efn[2] = GET_UC(tapeun);

  status = (sferror(tapeun)||sfeof(tapeun));

  return (status?EXIT_FAILURE:EXIT_SUCCESS);
}


void info_gh1(general_header_1 * gh1)
{
int n_gh, n_str, n_cs;
 n_gh = (*gh1).gh_dy1 >> 4;
 n_str = bcd ((unsigned char *)  (&(gh1->str)), 0, 2);
 n_cs = bcd ((unsigned char *) (&(gh1->cs)), 0, 2);

 warn("\n********************************\n"
 	"segd_general_header_1 (%2d bytes)\n"
 	"********************************", sizeof(*gh1));
 warn("file number: %d", tr.fldr);
 warn("\t\tformat code: %0.4hx\n", gh1->y);
 warn("general constants K1-K12 not decoded");
 warn("\t\tyear: %d\n", tr.year % 100);
 warn("#blks in general header extension: %d\n", n_gh);
 warn("day: %02d", tr.day);
 warn("\t\thour: %02d", tr.hour);
 warn("\t\tminute: %02d", tr.minute);
 warn("\t\tsecond: %02d\n", tr.sec);
 warn("manufacturer s code: %2x", (*gh1).m[0]);
 warn("\t\tmanufacturer's serial number: %02x%02x\n", (*gh1).m[1], (*gh1).m[2]);
 warn("bytes per scan (multiplexed formats) : not decoded");
 warn("\t\tbase scan interval: %d microseconds\n", tr.dt);
 warn("polarity: %x", (*gh1).p_sbx >> 4);
 warn("\t\tscan/block: %d x 2 **%d\n", (*gh1).sb, ((*gh1).p_sbx & 0xff));
 warn("record type (8=normal record) : %x", (*gh1).z_r1 >> 4);
 warn("\t\trecord length: %d units\n", bcd ((unsigned char *) &(*gh1).z_r1, 1, 3));
 warn("scan types / records: %d", n_str);
 warn("\t\tchannel sets per scan type: %d\n", n_cs);
 warn("number of 32-bytes fields for sample skew: %x\n", (*gh1).sk);
 warn("extended header length: %x", (*gh1).ec);
 warn("\t\texternal header length: %x\n", (*gh1).ex);
}

void info_gh2(general_header_2 *gh2)
{
 warn("\n********************************\n"
 	"segd_general_header_2 (%2d bytes)\n"
 	"********************************\n", sizeof(*gh2));
 warn("expanded file number: %2x%2x%2x\n", (*gh2).ef[0], (*gh2).ef[1], (*gh2).ef[1] );
 warn("extended channel sets/scantype: %02x%02x\n", (*gh2).en[0], (*gh2).en[1]);
 warn("extended header blocks: %02x%02x\n", (*gh2).ecx[0], (*gh2).ecx[1] );
 warn("external header blocks: %02x%02x\n", (*gh2).eh[0], (*gh2).eh[1]);
 warn("seg-d revision number: %02x%02x\n", (*gh2).rev[0], (*gh2).rev[1]);
 warn("general trailer number of blocks:  %d\n", (*gh2).gt);
 warn("extended record length: %02x%02x%02x\n", (*gh2).erl[0], (*gh2).erl[1], (*gh2).erl[2]);
}

void info_ghn(general_header_n *ghn)
{
 warn("\n********************************\n"
 	"segd_general_header_n (%2d bytes)\n"
 	"********************************\n", sizeof(*ghn));
 warn("source line number: %02x%02x%02x%02x%02x\n", (*ghn).sln[0], (*ghn).sln[1], (*ghn).sln[2], (*ghn).sln[3], (*ghn).sln[4]);
 warn("source point number: %02x%02x%02x%02x%02x\n", (*ghn).spn[0], (*ghn).spn[1], (*ghn).spn[2], (*ghn).spn[3], (*ghn).spn[4]);
 warn("source point index: %2x\n", (*ghn).spi);
 warn("phase control: %2x\n", (*ghn).pc);
 warn("vibrator type: %2x\n", (*ghn).v);
 warn("phase angle:  %0.4hx\n", (*ghn).pa);
 warn("general header block number: %2x\n", (*ghn).bn);
 warn("source set number: %2x\n", (*ghn).ss);
}

void info_gn_sn358(gen_head_sn358 * gh358)
{
 warn("\n************************************\n"
 	"segd_general_header_sn358 (%2d bytes)\n"
 	"************************************\n", sizeof(*gh358));
 warn("first channel of seismic parameter set 1: 1");
 warn("\tlast1: %d\n", bcd ((unsigned char*) &(*gh358).fc1, 1, 3));
 warn("first channel of seismic parameter set 2: %d", bcd ((unsigned char*) &(*gh358).fc2, 0, 3));
 warn("\tlast: %d\n", bcd ((unsigned char*) &(*gh358).f_lc2, 1, 3));
 warn("first channel of seismic parameter set 3: %d", bcd ((unsigned char*) &(*gh358).fc3, 0, 3));
 warn("\tlast: %d\n", bcd ((unsigned char*) &(*gh358).f_lc3, 1, 3));
 warn("first channel of seismic parameter set 4: %d", bcd ((unsigned char*) &(*gh358).fc4, 0, 3));
 warn("\tlast: %d\n", bcd ((unsigned char*) &(*gh358).f_lc4, 1, 3));
 warn("first auxiliary channel of scan type 1: %d", bcd ((unsigned char*) &(*gh358).f_lac1, 0, 1));
 warn("\tlast: %d\n", bcd ((unsigned char*) &(*gh358).f_lac1, 1, 1));
 warn("first seismic channel of scan type 1: %d", bcd ((unsigned char*) &(*gh358).fsc1, 0, 3));
 warn("\tlast: %d\n", bcd ((unsigned char*) &(*gh358).f_lsc1, 1, 3));
 warn("sample interval of scan type 1: %d\n", ((*gh358).sam_int1*1000) >> 4);
 warn("first auxiliary channel of scan type 2: %d", bcd ((unsigned char*) &(*gh358).fac2, 0, 1));
 warn("\tlast: %d\n", bcd ((unsigned char*) &(*gh358).fac2, 1, 1));
 warn("first seismic channel of scan type 2: %d", bcd ((unsigned char*) &(*gh358).fsc2, 0, 3));
 warn("\tlast: %d\n", bcd ((unsigned char*) &(*gh358).f_lsc2, 1, 3));
 warn("sample interval of scan type 2: %d\n", ((*gh358).sam_int2*1000) >> 4);
 warn("signature length: %3.1f", ((*gh358).bl_sig_le*.1));
 warn("\trecord length: %4.1f\n", bcd((unsigned char*) &((*gh358).rec_length[0]), 1, 3)*.1);
 warn("dynamically switching delay: %4.1f", bcd((unsigned char*) &((*gh358).dyn_swit_del[0]), 1, 3)*.1);
 warn("\trecording delay: %4.1f\n", bcd((unsigned char*) &((*gh358).rec_del[0]), 1, 3)*.1);
 warn("type of auxiliary channels 1 to 8: %1d %1d %1d %1d %1d %1d %1d %1d\n",
 	bcd ((unsigned char*) &(*gh358).ty_a_cha12, 0, 1), bcd ((unsigned char*) &(*gh358).ty_a_cha12, 1, 1),
 	bcd ((unsigned char*) &(*gh358).ty_a_cha34, 0, 1), bcd ((unsigned char*) &(*gh358).ty_a_cha34, 1, 1),
 	bcd ((unsigned char*) &(*gh358).ty_a_cha56, 0, 1), bcd ((unsigned char*) &(*gh358).ty_a_cha56, 1, 1),
 	bcd ((unsigned char*) &(*gh358).ty_a_cha78, 0, 1), bcd ((unsigned char*) &(*gh358).ty_a_cha78, 1, 1));
 warn("mode number: %d", bcd ((unsigned char *) &(*gh358).mode_num, 0, 2));
 warn("\tanalog system count: %d", bcd ((unsigned char *) &(*gh358).an_sys_co, 0, 1));
 warn("\ttape transport number: %d\n", bcd ((unsigned char *) &(*gh358).an_sys_co, 1, 1));
 warn("reel number: %d", bcd ((unsigned char*) &((*gh358).reel_num[0]), 0, 4));
 warn("\tfile logicial number: %d", bcd ((unsigned char*) &((*gh358).file_num[0]), 1, 3));
 warn("\tshot point number: %d\n",  bcd ((unsigned char*) &((*gh358).sp_num[0]), 0, 4));
 warn("LC=%d, NF=%d, FG=%d, IC=%d\n", bcd ((unsigned char *)&(*gh358).lc_nf, 0, 1), bcd (&(*gh358).lc_nf, 1, 1),
 	bcd (&(*gh358).fg_ic, 0, 1), bcd ((unsigned char *)&(*gh358).fg_ic, 1, 1));
 warn("oscillator frequency: %d", bcd ((unsigned char *)&(*gh358).of1, 1, 5));
 warn("\toscillator amplitude: %d\n", bcd ((unsigned char *)&(*gh358).osc_att, 0, 2));
 warn("test signal: %d", bcd ((unsigned char *)&(*gh358).t_sig_ph, 1, 1));
 warn("\tmain gain amplifier: %d\n", bcd ((unsigned char *)&(*gh358).m_gain, 0, 2));
}

void info_csh(channel_set_header *csh)
{
 warn("\n**********************************\n"
 	"segd_channel_set_header (%2d bytes)\n"
 	"**********************************\n", sizeof(*csh));
 warn("scan type number: %2x", (*csh).st);
 warn("\tchannel set number: %2x\n", (*csh).cn);
 warn("channel set start time: %d", (*csh).tf*2 );
 warn("\tchannel set end time: %d\n", (*csh).te*2 );
 warn("descale multiplier: %02x%02x\n", (unsigned int) ((*csh).mp[imp0]),
					(unsigned int) ((*csh).mp[imp1]) );
 warn("number of channels: %02x%02x", (unsigned int) ((*csh).cs[0]),
					(unsigned int) ((*csh).cs[1]) );
 warn("\tchannel type (1=Seis, 8=Sig/unfiltered): %x\n", (*csh).c >> 4);
 warn("sample/channel: %x", (*csh).sc_j >> 4);
 warn("\tchannel gain: %x\n", (*csh).sc_j & 0xf);
 warn("alias filter frequency: %0.4hx", (*csh).af);
 warn("\talias filter slope: %0.4hx\n" ,(*csh).as);
 warn("low cut filter frequency: %0.4hx", (*csh).lc);
 warn("\tlow cut filter slope: %0.4hx\n", (*csh).ls);
 warn("first notch filter: %0.4hx", (*csh).nt[0]);
 warn("\tsecond: %0.4hx", (*csh).nt[1]);
 warn("\tthird: %0.4hx\n", (*csh).nt[2]);
 warn("extended channel set number: %0.4hx", (*csh).ecs);
 warn("\textended header flag: %x\n" , (*csh).efh >> 4);
 warn("vertical stack: %2x\n", (*csh).vs);
 warn("streamer cable number: %2x", (*csh).cab);
 warn("\tarray forming: %2x\n", (*csh).ary);
}

void info_ssh(sample_skew *ssh)
{
 warn("\n**********************************\n"
 	"segd_sample_skew_header (%2d bytes)\n"
 	"**********************************\n", sizeof(*ssh));
 warn("not decoded\n");
}

void info_ech(extended_header * ech)
{
 register int i;
 warn("\n**********************************\n"
 	"segd_extended_header (%2d bytes)\n"
 	"**********************************\n", sizeof(*ech));
 for (i=0; i<sizeof(*ech); i+=4) {
 	warn("%02x %02x %02x %02x\n", ech->dummy[i], ech->dummy[i+1], ech->dummy[i+2], ech->dummy[i+3]);
 }
}

void info_exh(external_header * exh)
{
	register int i;
	/*  unsigned char *ptr; */
	/*  ptr= (unsigned char *) &(exh->dummy[0]); */
	unsigned char *p;
	p = (unsigned char *) &(exh->dummy[0]);
	warn("\n*******************************\n"
		"segd_external_header (%2d bytes)\n"
		"*******************************\n", sizeof(*exh));
	for (i=0; i<sizeof(*exh); i+=16 ) {
/* segdread.c:1978: warning: operation on `i' may be undefined */
/* 		warn("%02x%02x %02x%02x %02x%02x %02x%02x %02x%02x %02x%02x %02x%02x %02x%02x\n", */
/* 		ptr[i++], ptr[i++], ptr[i++], ptr[i++], ptr[i++], ptr[i++], ptr[i++], ptr[i++], */
/* 		ptr[i++], ptr[i++], ptr[i++], ptr[i++], ptr[i++], ptr[i++], ptr[i++], ptr[i++]); */
		warn("%02x%02x %02x%02x %02x%02x %02x%02x "
			"%02x%02x %02x%02x %02x%02x %02x%02x\n",
			p[0], p[1], p[2], p[3], p[4], p[5], p[6], p[7],
			p[8], p[9], p[10], p[11], p[12], p[13], p[14], p[15]);
 }
}

void info_dth(dem_trace_header * dth)
{
 warn("\n********************************\n"
 	"segd_dem_trace_header (%2d bytes)\n"
 	"********************************\n", sizeof(*dth));
 warn("file number: %hx", (*dth).f);
 warn("\tscan type: %x, channel set: %x\n", (*dth).st, (*dth).cn);
 warn("trace_number: %02x%02x", (*dth).tn[0],(*dth).tn[1]);
 warn("\tfirst timing word: %x%x%X\n", (*dth).t[0], (*dth).t[1], (*dth).t[2]);
 warn("trace header extension: %x", (*dth).the);
 warn("\tsample skew: %x", (*dth).ss);
 warn("\ttrace edit: %x\n", (*dth).tr);
 warn("time break window: %02x%02x%02x\n", (*dth).tw[0], (*dth).tw[1], (*dth).tw[2]);
 warn("extended channel set number: %x%x", (*dth).en[0], (*dth).en[1]);
 warn("\textended file number: %x%x%x\n", (*dth).efn[0], (*dth).efn[1], (*dth).efn[2]);
}

void info_gt(general_trailer * gt)
{
 warn("\n********************************\n"
 	"segd_general_traler (%2d bytes)\n"
 	"********************************\n", sizeof(*gt));
 warn("General trailer number: %d", (*gt).gt);
 warn("\tchannel type identification: %01x\n", (*gt).c >> 4);
}
@


1.13
log
@Richard Hobb's fix "segdread (su42) will go into an infinite loop if used
with "verbose=2" because the increment counter is miss"
@
text
@d1 2
a2 1
/* SEGDREAD: $Revisi n: 1.12 $ ; $Date: 2011/04/04 15:46:19 $	*/
d4 4
a7 2
#include "su.h"
#include "segy.h"
d100 19
d169 4
d181 1
d302 5
d348 7
d493 1
d630 1
a630 1
				warn("Demux trace header nsamp %u != Demux trace header nsamp %u\n", nsamp_cs, nsamp_the);
a734 1
/*  				puttr(&tr); */
d738 9
a747 1
					databytes = ns * sizeof(float);
d749 4
@


1.12
log
@*** empty log message ***
@
text
@d1 1
a1 1
/* SEGDREAD: $Revision: 1.9 $ ; $Date: 2004/02/02 18:34:30 $	*/
d2017 1
a2017 1
	for (i=0; i<sizeof(*exh); ) {
@


1.11
log
@*** empty log message ***
@
text
@d63 2
a64 2
#define BCD_FF (15+10*(15))                   /* bcd interpretation of FF */
#define BCD_FFF (15+10*(15+10*(15)))          /* bcd interpretation of FFF */
d69 22
a90 22
"                                                                      ",
" SEGDREAD - read an SEG-D tape                                        ",
"                                                                      ",
" segdread > stdout tape=                                              ",
"                                                                      ",
"                                                                      ",
" Required parameters:                                                 ",
"       tape=           input tape device                              ",
" 			tape=- to read from stdin                      ",
"                                                                      ",
" Optional parameters:                                                 ",
"       use_stdio=0     for record devices (9-track reel tape drive)   ",
"                       =1 for pipe, disk and fixed-block 8mm drives   ",
"       verbose=0       silent operation                               ",
"                       = 1 ; echo every 'vblock' traces               ",
"                       = 2 ; echo information about blocks            ",
"       vblock=50       echo every 'vblock' traces under verbose option",
"       ptmin=1         first shot to read                             ",
"       ptmax=INT_MAX   last shot to read                              ",
"       gain=0          no application of gain                         ",
"       aux=0           no recovery of auxiliary traces                ",
"       errmax=0        allowable number of consecutive tape IO errors ",
d92 1
a92 1
"			flaws.  Ignored when use_stdio=0.              ",
d94 3
a96 3
"	                pivot_year, previous century otherwise.        ",
"                                                                      ",
"         type:   sudoc segdread   for further information             ",
d111 2
a112 2
 *       IS buffered I/O). Kept old buff= internally for backwards
 *       compatibility.
d114 1
a114 1
 *       1 part in 2^14th decoding error on 2's complement platforms.
d120 1
a120 1
 *       input can work.
d122 1
a122 1
 *       trace header extensions.
d133 1
a133 1
 *       length specifications in headers.
d142 5
d150 5
a154 4
 *           Version 2.2, 17/08/95
 *           Version 2.3, 04/1997 Thu Apr 10 11:55:45 DFT 1997
 *           Version 2.4, 10/03/98 Tue Mar 10 1998
 *           Version 2.5, Feb 4, 2001
d165 3
a167 3
static void F8015_to_float (Sfio_t *from, float to[], int len);
static void F8022_to_float (Sfio_t *from, float to[], int len);
static void F8024_to_float (Sfio_t *from, float to[], int len);
d200 3
d209 1
a209 1
 gen_head_sn358     segd_gen_head_sn358;
d211 1
a211 1
 sample_skew        segd_sample_skew;
d221 2
a222 2
 char *tape=NULL;        /* name of raw tape device */
 int tapefd=0;           /* file descriptor for tape */
d227 2
a228 2
 short scan_type;        /* scan type number */
 short chan_set;         /* channel set number */
d234 20
a253 20
 int nread = 0;               /* bytes read */
 int ns;                                  /* number of data samples */
 int n_gh;         /* number of additional blocks in general header */
 int n_str;                      /* number of scan types per record */
 int n_cs;                  /* number of channel sets per scan type */
 int n_sk;               /* number of 32 byte field for sample skew */
 int n_ec;                                /* extended header length */
 int n_ex;                                /* external header length */
 int n_gt=0;                 /* number of blocks of general trailer */
 int n_chan;                            /* total number of channels */
 int itr;                                   /* current trace number */
 int ipt;                                    /* current shot number */
 int ptmin;                                  /* first trace to read */
 int ptmax;                                   /* last trace to read */
 int verbose;                   /* echo every ...                   */
 int vblock;                    /* ... vblock traces with verbose=1 */
 int buff;                   /* flag for buffered/unbuffered device */
 int gain;                                /* flag for applying gain */
 int aux;                      /* flag for keeping auxiliary traces */
 int errmax;                      /* max consecutive tape io errors */
d255 3
a257 2
 int errcount = 0;                    /* counter for tape io errors */
 int hdr1_i, hdr1_r;                   /* i and r decoded from hdr1 */
d259 5
a263 4
 unsigned int nsamp_hdr1;                   /* number of samples/trace using */
                            /* only general header 1 i and r fields */
 unsigned int nsamp_hdr2;            /* number of samples/trace from general */
                      /* header 2 erl and general header 1 i fields */
d265 2
a266 2
 unsigned int nsamp_cs;      /* nsamp from channel set named in demux header */
 unsigned int nsamp_the;         /* nsamp from demux trace header extensions */
d268 1
a268 1
 float  mp;                                   /* descaling exponent */
d271 1
a271 1
 char *bloc1;                              /* pointer on data block */
d299 2
a300 2
 if (!getparint("ptmin", &ptmin))        ptmin = 1;
 if (!getparint("ptmax", &ptmax))        ptmax = INT_MAX;
d303 1
a303 1
 if (!getparint("vblock", &vblock))      vblock = 50;
d306 1
a306 1
	if (!getparint("buff", &buff))          buff = 1;
d310 5
a314 5
 if (!getparint("gain", &gain))          gain = 0;
 if (!getparint("aux", &aux))            aux = 0;
 if (!getparint("errmax", &errmax))      errmax = 0;
 if (!getparint("pivot_year", &pivot_year))      pivot_year = 30;
 if (!getparint("ns", &ns_override))      	 ns_override = 0;
d327 1
a327 1
	 else      {
d330 1
a330 1
		     }
d365 2
a366 2
      ns = 0;
      nsamp_hdr1 = 0; nsamp_hdr2 = 0; nsamp_hdr358 = 0;
d368 7
a374 7
        hdr1_i = segd_general_header_1.i;
        if(hdr1_r != BCD_FFF && hdr1_i != 0) {
              hdr1_r *= 2;  /* range is 10 to 1990 */
              nsamp_hdr1 = (hdr1_r*512*16)/(10*hdr1_i)  + 1;
                         /* 20*r*512 msec /10*(i/16) msec */
	      if(ns == 0) ns = nsamp_hdr1;
          if(verbose) warn("nsamp_hdr1=%d\n",nsamp_hdr1);
d380 3
a382 3
        if(tr.year < pivot_year) tr.year += 2000;
        else tr.year += 1900;
 	n_gh =      bcd ((unsigned char *) &segd_general_header_1.gh_dy1, 0, 1);
d387 6
a392 6
 	tr.dt =     (segd_general_header_1.i*1000) >> 4;
 	n_str =     bcd ((unsigned char *) &segd_general_header_1.str, 0, 2);
 	n_cs =      bcd ((unsigned char *) &segd_general_header_1.cs, 0, 2);
 	n_sk =      bcd ((unsigned char *) &segd_general_header_1.sk, 0, 2);
 	n_ec =      bcd ((unsigned char *) &segd_general_header_1.ec, 0, 2);
 	n_ex =      bcd ((unsigned char *) &segd_general_header_1.ex, 0, 2);
d398 11
a408 3
 	if((n_gh == 2) && (segd_general_header_1.m[0] == 0x13) &&
           (segd_general_header_1.y == 0x8015)) { /* Special case for Sercel SN358 */
        if( EXIT_FAILURE == get_gn_sn358(&segd_gen_head_sn358, tapeun) ) break;
d411 1
a411 1
	        if(hdr1_i != 0) {
d413 1
a413 1
          if(verbose) warn("nsamp_hdr358=%d\n",nsamp_hdr358);
d436 3
a438 3
			               256 * (segd_general_header_2.erl[1] +
				       256 * (segd_general_header_2.erl[0])) *
				       16 / hdr1_i + 1;
d440 1
a440 1
          if(verbose) warn("nsamp_hdr2=%d\n",nsamp_hdr2);
d459 1
a459 1
        if(!buff) nread = sftell(tapeun) - startpos;
d488 2
a489 2
 				mp = ((float) ((segd_channel_set_header->mp[1] & 0x7f) << 8 | segd_channel_set_header->mp[0])) / 1024.;
 				if (segd_channel_set_header->mp[1] >> 7) mp *= -1.;
d543 1
a543 1
 					case 0x0015:                           /* 20 bit binary multiplexed */
d545 1
a545 1
 					case 0x0022:                        /* 8 bit quaternary multiplexed */
d547 1
a547 1
 					case 0x0024:                       /* 16 bit quaternary multiplexed */
d549 1
a549 1
 					case 0x0036:           /* 24 bit 2's compliment integer multiplexed */
d551 1
a551 1
 					case 0x0038:           /* 32 bit 2's compliment integer multiplexed */
d553 1
a553 1
 					case 0x0042:                       /* 8 bit hexadecimal multiplexed */
d555 1
a555 1
 					case 0x0044:                      /* 16 bit hexadecimal multiplexed */
d557 1
a557 1
 					case 0x0048:                      /* 32 bit hexadecimal multiplexed */
d559 1
a559 1
 					case 0x0058:                             /* 32 bit IEEE multiplexed */
d561 1
a561 1
 					case 0x0200:                                             /* illegal */
d563 1
a563 1
 					case 0x0000:                                             /* illegal */
d581 1
a581 1
          if(verbose) warn("nsamp_cs=%d\n",nsamp_cs);
d588 1
a588 1
          if(verbose) warn("nsamp_the=%d\n",nsamp_the); }
d618 1
a618 1
 					case 0x8015:                        /* 20 bits binary demultiplexed */
d624 2
a625 2
 						F8015_to_float (tapeun, (float *) tr.data, ns); break;
 					case 0x8022:                      /* 8 bit quaternary demultiplexed */
d631 2
a632 2
 						F8022_to_float (tapeun, (float *) tr.data, ns); break;
 					case 0x8024:                      /* 16 bit quaternary demultiplexed */
d638 2
a639 2
 						F8024_to_float (tapeun, (float *) tr.data, ns); break;
 					case 0x8036:          /* 24 bit 2's compliment integer demultiplexed */
d646 1
a646 1
 					case 0x8038:          /* 32 bit 2's compliment integer demultiplexed */
d653 1
a653 1
 					case 0x8042:                      /* 8 bit hexadecimal demultiplexed */
d660 1
a660 1
 					case 0x8044:                     /* 16 bit hexadecimal demultiplexed */
d667 1
a667 1
 					case 0x8048:                     /* 32 bit hexadecimal demultiplexed */
d674 1
a674 1
 					case 0x8058:                            /* 32 bit IEEE demultiplexed */
d754 1
a754 1
 *      EOPG: Marc, Jdt
d759 1
a759 1
 *    n      - number of digits
d784 5
a788 5
 *      EOPG: Marc Schaming, Jean-Daniel Tissot
 *      SEP:  Stew Levin - fixed low-order bit error in conversion
 *            of negative values on 2's complement machines.
 *            Use ldexp() function instead of much slower value*pow(2,expo)
 *      SEP:  Adapted F8015 to F0015 conversion
d793 1
a793 1
 *    to     - output vector
d797 1
d805 1
a805 1
 *  Bit       0     1     2     3     4     5     6     7
d810 1
a810 1
 * Byte 3     S    Q-1   Q-2   Q-3   Q-4   Q-5   Q-6   Q-7   Channel 1
d812 1
a812 1
 * Byte 5     S    Q-1   Q-2   Q-3   Q-4   Q-5   Q-6   Q-7   Channel 2
d814 1
a814 1
 * Byte 7     S    Q-1   Q-2   Q-3   Q-4   Q-5   Q-6   Q-7   Channel 3
d816 1
a816 1
 * Byte 9     S    Q-1   Q-2   Q-3   Q-4   Q-5   Q-6   Q-7   Channel 4
d821 2
a822 2
 *               CCCC
 *   written as 2     where CCCC can assume values of 0-15.  The four
d827 1
a827 1
 *                                  -1
d829 1
a829 1
 *                  -14       -14
d834 1
a834 1
 *                                       CCCC    MP                   MP
d844 1
a844 1
static void F0015_to_float (Sfio_t *from, float to[], int len)
d855 1
a855 1
	if (fraction < 0) fraction = -((~fraction)&(~1));
d860 1
a860 1
	if (fraction < 0) fraction = -((~fraction)&(~1));
d865 1
a865 1
	if (fraction < 0) fraction = -((~fraction)&(~1));
d870 1
a870 1
	if (fraction < 0) fraction = -((~fraction)&(~1));
d876 1
d880 4
a883 4
 *      EOPG: Marc Schaming, Jean-Daniel Tissot
 *      SEP:  Stew Levin - fixed low-order bit error in conversion
 *            of negative values on 2's complement machines.
 *            Use ldexp() function instead of much slower value*pow(2,expo)
d887 1
a887 1
 *    to     - output vector
d889 1
d899 1
a899 1
 *  Bit       0     1     2     3     4     5     6     7
d904 1
a904 1
 * Byte 3     S    Q-1   Q-2   Q-3   Q-4   Q-5   Q-6   Q-7   Channel 1
d906 1
a906 1
 * Byte 5     S    Q-1   Q-2   Q-3   Q-4   Q-5   Q-6   Q-7   Channel 2
d908 1
a908 1
 * Byte 7     S    Q-1   Q-2   Q-3   Q-4   Q-5   Q-6   Q-7   Channel 3
d910 1
a910 1
 * Byte 9     S    Q-1   Q-2   Q-3   Q-4   Q-5   Q-6   Q-7   Channel 4
d915 2
a916 2
 *               CCCC
 *   written as 2     where CCCC can assume values of 0-15.  The four
d921 1
a921 1
 *                                  -1
d923 1
a923 1
 *                  -15       -15
d926 1
a926 1
 *                                        CCCC    MP                   MP
a935 1
static void F8015_to_float (Sfio_t *from, float to[], int len)
d943 1
a943 1
      ex1_4 = GET_S(from);
d945 2
a946 2
      fraction = GET_S(from);
	if (fraction < 0) fraction = -(~fraction);
d950 2
a951 2
      fraction = GET_S(from);
	if (fraction < 0) fraction = -(~fraction);
d955 2
a956 2
      fraction = GET_S(from);
	if (fraction < 0) fraction = -(~fraction);
d960 2
a961 2
      fraction = GET_S(from);
	if (fraction < 0) fraction = -(~fraction);
d966 1
d970 1
a970 1
 *      SEP:  Stew Levin
d974 1
a974 1
 *    to     - output vector
d985 1
a985 1
 *  Bit       0     1     2     3     4     5     6     7
d987 1
a987 1
 * Byte 1     S    C2    C1    C0    Q-1   Q-2   Q-3   Q-4
d991 1
a991 1
 *               CCC
d995 1
a995 1
 *                                  -1
d997 1
a997 1
 *           -4        -4
d1000 1
a1000 1
 *                          CCC   MP                   MP
a1006 1
static void F8022_to_float (Sfio_t *from, float to[], int len)
d1012 1
d1015 5
a1019 5
      ex1_4 = GET_C(from);
      expo = ((ex1_4 >> 3) & 14) - 4;
      fraction = ex1_4 & 15;
	if (ex1_4 & 128) fraction = -(15^fraction);
 	*(to++) = ldexp((double) fraction, expo);
d1023 1
d1027 1
a1027 1
 *      SEP:  Stew Levin
d1031 1
a1031 1
 *    to     - output vector
d1042 1
a1042 1
 *  Bit       0     1     2     3     4     5     6     7
d1044 1
a1044 1
 * Byte 1     S    C2    C1    C0    Q-1   Q-2   Q-3   Q-4
d1049 1
a1049 1
 *               CCC
d1053 1
a1053 1
 *                                  -1
d1055 1
a1055 1
 *           -12        -12
d1058 1
a1058 1
 *                                    CCC   MP                   MP
a1064 1
static void F8024_to_float (Sfio_t *from, float to[], int len)
d1070 1
d1073 5
a1077 5
      ex1_4 = GET_S(from);
      expo = ((ex1_4 >> 11) & 14) - 12;
      fraction = ex1_4 & 4095;
      if (ex1_4 & 32768) fraction = -(4095^fraction);
      *(to++) = ldexp((double) fraction, expo);
d1084 1
a1084 1
 *      SEP:  Stew Levin
d1088 1
a1088 1
 *    to     - output vector
d1099 1
a1099 1
 *  Bit       0     1     2     3     4     5     6     7
d1106 1
a1106 1
 *                         MP                   MP
d1119 5
a1123 5
      ival = GET_UC(from);
      ival <<= 8; ival |= GET_UC(from);
      ival <<= 8; ival |= GET_UC(from);
      if(ival > 8388607) ival -= 16777216;
      *(to++) = (float) ival;
d1130 1
a1130 1
 *      SEP:  Stew Levin
d1134 1
a1134 1
 *    to     - output vector
d1145 1
a1145 1
 *  Bit       0     1     2     3     4     5     6     7
d1153 1
a1153 1
 *                         MP                   MP
d1170 4
a1173 4
      ex1_4 = GET_S(from);
      ex2_4 = GET_S(from);
      value = (ex1_4<<16) | (ex2_4&65535);
      *(to++) = (float) value;
d1180 1
a1180 1
 *      SEP:  Stew Levin
d1184 1
a1184 1
 *    to     - output vector
d1195 1
a1195 1
 *  Bit       0     1     2     3     4     5     6     7
d1197 1
a1197 1
 * Byte 1     S    C1    C0    Q-1   Q-2   Q-3   Q-4   Q-5
d1201 1
a1201 1
 *                CC
d1205 1
a1205 1
 *                                  -1
d1207 1
a1207 1
 *           -5        -5
d1209 1
a1209 1
 *                             CC    MP                   MP
d1224 5
a1228 5
      ex1_4 = GET_C(from);
      expo = ((ex1_4 >> 3) & 12) - 5;
      fraction = ex1_4 & 31;
      if (ex1_4 & 128) fraction = -fraction;
      *(to++) = ldexp((double) fraction, expo);
d1235 1
a1235 1
 *      SEP:  Stew Levin
d1239 1
a1239 1
 *    to     - output vector
d1250 1
a1250 1
 *  Bit       0     1     2     3     4     5     6     7
d1252 1
a1252 1
 * Byte 1     S    C1    C0    Q-1   Q-2   Q-3   Q-4   Q-5
d1257 1
a1257 1
 *                CC
d1261 1
a1261 1
 *                                  -1
d1263 1
a1263 1
 *           -13        -13
d1265 1
a1265 1
 *                                       CC    MP                   MP
d1280 5
a1284 5
      ex1_4 = GET_S(from);
      expo = ((ex1_4 >> 11) & 12) - 13;
      fraction = ex1_4 & 8191;
      if (ex1_4 & 32768) fraction = -fraction;
      *(to++) = ldexp((double) fraction, expo);
d1291 1
a1291 1
 *      SEP:  Stew Levin
d1295 1
a1295 1
 *    to     - output vector
d1306 1
a1306 1
 *  Bit       0     1     2     3     4     5     6     7
d1308 1
a1308 1
 * Byte 1     S    C6    C5    C4    C3    C2    C1    C0
d1315 2
a1316 2
 *                (CCCCCCC-64)
 *   written as 16             where CC can assume values of 0-127.
d1319 1
a1319 1
 *                                  -1
d1321 1
a1321 1
 *                 -23        -23
d1323 2
a1324 2
 *                                   C-64    MP                   MP
 * Input signal = S.QQQQ,...,QQQ x 16     x 2   millivolts where 2
d1342 6
a1347 6
      ex1_4 = GET_S(from);
      expo = ((ex1_4 >> 6) & 508) - (24+256);
      fraction = ex1_4 & 255;
      fraction <<= 16; fraction |= (GET_S(from)&65535);
      if (ex1_4 & 32768) fraction = -fraction;
      *(to++) = ldexp((double) fraction, expo);
d1354 1
a1354 1
 *      SEP:  Stew Levin
d1358 1
a1358 1
 *    to     - output vector
d1369 1
a1369 1
 *  Bit       0     1     2     3     4     5     6     7
d1371 1
a1371 1
 * Byte 1     S    C7    C6    C5    C4    C3    C2    C1
d1378 2
a1379 2
 *               (CCCCCCCC-127)
 *   written as 2               where CC can assume values of 0-255.
d1382 1
a1382 1
 *                                  -1
d1385 2
a1386 2
 *                    S                    C-127    MP                   MP
 * Input signal = (-1) x 1.QQQQ,...,QQQ x 2     x 2   millivolts where 2
d1398 2
a1399 2
 *                    S                    -126     MP
 * Input signal = (-1) x 0.QQQQ,...,QQQ x 2     x 2   millivolts
d1402 1
a1402 1
 *                    S
d1418 9
a1426 9
      ex1_4 = GET_S(from);
      ex2_4 = GET_S(from);
      expo = ((ex1_4 >> 7) & 255);
      fraction = ex1_4 & 127;
      fraction <<= 16; fraction |= (ex2_4&65535);
      if(expo) fraction |= 8388608;
      else fraction <<= 1;
      if (ex1_4 & 32768) fraction = -fraction;
      *(to++) = ldexp((double) fraction, expo-(23+127));
d1967 2
a1968 2
 warn("descale multiplier: %02x%02x\n", (unsigned int) ((*csh).mp[0]),
					(unsigned int) ((*csh).mp[1]) );
d1970 1
a1970 1
				      (unsigned int) ((*csh).cs[1]) );
d2015 2
a2016 2
	     "segd_external_header (%2d bytes)\n"
	     "*******************************\n", sizeof(*exh));
d2023 3
a2025 3
		     "%02x%02x %02x%02x %02x%02x %02x%02x\n",
		     p[0], p[1], p[2], p[3], p[4], p[5], p[6], p[7],
		     p[8], p[9], p[10], p[11], p[12], p[13], p[14], p[15]);
@


1.10
log
@31 May version
@
text
@a0 3
/* Copyright (c) Colorado School of Mines, 2007.*/
/* All rights reserved.                       */

d387 2
a388 1
 	if((n_gh == 2) && (segd_general_header_1.m[0] == 0x13)) { /* Special case for Sercel SN358 */
@


1.9
log
@*** empty log message ***
@
text
@d1 4
a4 1
/* SEGDREAD: $Revision: 2.5 $ ; $Date: 2001/02/04 18:53:57 $	*/
d11 1
d24 1
a24 1
 
d97 1
a97 1
"	                pivot_year, previous century otherwise.        ",  
d144 1
a144 1
 *    f) Removed conditional disabling of sfio 
d157 3
a159 1
static int bcd (unsigned char *ptr, int begin, int n) ;            
d161 1
d217 2
a218 1
 Sfio_t  *tapeun;		/* input for Sfio_t reads. May be memory or stdio */
d227 2
a228 1
 int nread;               /* bytes read */
d232 1
a232 1
 int n_cs;                  /* number of channel sets per scan type */ 
d260 1
a260 1
 float  mp;                                   /* descaling exponent */  
d264 3
a266 1
 
d339 1
a339 1
 
d368 1
a368 1
  
d441 1
a441 1
 	/* Verify the length of the first record */ 
d455 1
a455 1
 	if (gain && (mmp == NULL)) 
d525 1
a525 1
 				switch (segd_general_header_1.y) { 
d600 1
a600 1
 				switch (segd_general_header_1.y) { 
d604 1
a604 1
 						if (tr.ns != ns) 
d611 1
a611 1
 						if (tr.ns != ns) 
d618 1
a618 1
 						if (tr.ns != ns) 
d625 1
a625 1
 						if (tr.ns != ns) 
d632 1
a632 1
 						if (tr.ns != ns) 
d639 1
a639 1
 						if (tr.ns != ns) 
d646 1
a646 1
 						if (tr.ns != ns) 
d653 1
a653 1
 						if (tr.ns != ns) 
d660 1
a660 1
 						if (tr.ns != ns) 
d677 9
a685 1
 				puttr(&tr);
d703 1
a703 1
 
d756 1
a756 1
 	if (begin++ & 1) val += (*ptr++ & 15); 
d762 2
d825 1
a825 1
 
d855 2
a856 1
} 
d945 1
a945 1
} 
d1001 1
a1001 1
} 
d1038 1
a1038 1
 * Input signal = S.QQQQ,QQQQ,QQQQ x 4   x 2   millivolts where 2  
d1058 1
a1058 1
} 
d1086 1
a1086 1
 * Input signal = Q...Q x 2   millivolts where 2  
d1104 1
a1104 1
} 
d1133 1
a1133 1
 * Input signal = Q...Q x 2   millivolts where 2  
d1154 1
a1154 1
} 
d1187 1
a1187 1
 *   from 1-2   to -1+2  .  
d1209 1
a1209 1
} 
d1243 1
a1243 1
 *   from 1-2    to -1+2   .  
d1245 1
a1245 1
 * Input signal = S.QQQQ,QQQQ,QQQQ,Q x 16   x 2   millivolts where 2    
d1265 1
a1265 1
} 
d1287 2
a1288 2
 * Byte 1     S    C6    C5    C4    C3    C2    C1    C0 
 * Byte 2    Q-1   Q-2   Q-3   Q-4   Q-5   Q-6   Q-7   Q-8 
d1301 1
a1301 1
 *   values from 1-2    to -1+2   .  
d1303 1
a1303 1
 * Input signal = S.QQQQ,...,QQQ x 16     x 2   millivolts where 2    
d1321 1
a1321 1
      ex1_4 = GET_S(from); 
d1328 1
a1328 1
} 
d1350 1
a1350 1
 * Byte 1     S    C7    C6    C5    C4    C3    C2    C1 
d1365 1
a1365 1
 * Input signal = (-1) x 1.QQQQ,...,QQQ x 2     x 2   millivolts where 2    
d1381 1
a1381 1
 *                    S 
d1385 1
a1385 1
 *                      
d1397 1
a1397 1
      ex1_4 = GET_S(from); 
d1407 1
a1407 1
} 
d1425 1
a1425 1
  
d1430 1
a1430 1
  
d1435 1
a1435 1
  
d1440 1
a1440 1
  
d1445 1
a1445 1
  
d1452 1
a1452 1
  
d1460 1
a1460 1
  
d1465 1
a1465 1
  
d1470 1
a1470 1
  
d1475 1
a1475 1
  
d1479 1
a1479 1
  
d1484 1
a1484 1
  
d1489 1
a1489 1
  
d1494 1
a1494 1
  
d1509 1
a1509 1
  
d1514 1
a1514 1
  
d1519 1
a1519 1
  
d1524 1
a1524 1
  
d1529 1
a1529 1
  
d1533 1
a1533 1
  
d1538 1
a1538 1
  
d1543 1
a1543 1
  
d1558 1
a1558 1
  
d1563 1
a1563 1
  
d1568 1
a1568 1
  
d1573 1
a1573 1
  
d1578 1
a1578 1
  
d1583 1
a1583 1
  
d1588 1
a1588 1
  
d1593 1
a1593 1
  
d1598 1
a1598 1
  
d1603 1
a1603 1
  
d1608 1
a1608 1
  
d1613 1
a1613 1
  
d1618 1
a1618 1
  
d1623 1
a1623 1
  
d1628 1
a1628 1
  
d1633 1
a1633 1
  
d1648 1
a1648 1
  
d1652 1
a1652 1
  
d1656 1
a1656 1
  
d1661 1
a1661 1
  
d1664 1
a1664 1
  
d1667 1
a1667 1
  
d1670 1
a1670 1
  
d1673 1
a1673 1
  
d1694 1
a1694 1
  
d1699 1
a1699 1
  
d1704 1
a1704 1
  
d1709 1
a1709 1
  
d1714 1
a1714 1
  
d1719 1
a1719 1
  
d1724 1
a1724 1
  
d1729 1
a1729 1
  
d1867 1
a1867 1
 warn("expanded file number: %2x%2x%2x\n", (*gh2).ef[0], (*gh2).ef[1], (*gh2).ef[1] );    
d1873 1
a1873 1
 warn("extended record length: %02x%02x%02x\n", (*gh2).erl[0], (*gh2).erl[1], (*gh2).erl[2]); 
d1918 1
a1918 1
 warn("type of auxiliary channels 1 to 8: %1d %1d %1d %1d %1d %1d %1d %1d\n", 
d1964 1
a1964 1
 warn("\tarray forming: %2x\n", (*csh).ary); 
d1988 17
a2004 10
 register int i;
 unsigned char *ptr;
 ptr= (unsigned char *) &(exh->dummy[0]);
 warn("\n*******************************\n"
 	"segd_external_header (%2d bytes)\n"
 	"*******************************\n", sizeof(*exh));
 for (i=0; i<sizeof(*exh); ) {
 	warn("%02x%02x %02x%02x %02x%02x %02x%02x %02x%02x %02x%02x %02x%02x %02x%02x\n",
		ptr[i++], ptr[i++], ptr[i++], ptr[i++], ptr[i++], ptr[i++], ptr[i++], ptr[i++],
		ptr[i++], ptr[i++], ptr[i++], ptr[i++], ptr[i++], ptr[i++], ptr[i++], ptr[i++]);
@


1.8
log
@Stew Levin's update
@
text
@d1 1
a1 1
/* SEGDREAD: $Revision: 2.4 $ ; $Date: 1998/03/03 15:58:27 $	*/
a6 4
#ifdef SUXDR_DUMMY   /* The version to use with XDR is in $CWPROOT/src/Sfio */  
#define _SFSTDIO_H
#endif
#ifdef _SFSTDIO_H
a59 2
#endif/*_SFSTDIO_H*/

d86 1
a86 1
"       ptmax=INT_MAX  last shot to read                              ",
d91 3
a93 1
"			flaws.  Not used with tape input.              ",
d133 8
a141 1
 *  For any problems, send message to mschaming@@eost.u-strasbg.fr
d145 3
a147 2
 *           Version 2.3,  04/1997 Thu Apr 10 11:55:45 DFT 1997
 *           Version 2.4,  10/03/98 Tue Mar 10 1998
a153 1
#ifdef _SFSTDIO_H
d164 1
a164 13
#else
static void F0015_to_float (short from[], float to[], int len);
static void F8015_to_float (short from[], float to[], int len);
static void F8022_to_float (char  from[], float to[], int len);
static void F8024_to_float (short from[], float to[], int len);
static void F8036_to_float (unsigned char from[], float to[], int len);
static void F8038_to_float (short from[], float to[], int len);
static void F8042_to_float (char  from[], float to[], int len);
static void F8044_to_float (short from[], float to[], int len);
static void F8048_to_float (short from[], float to[], int len);
static void F8058_to_float (short from[], float to[], int len);
#endif
#ifdef _SFSTDIO_H
d176 1
a176 1
#endif/* _SFSTDIO_H */
a209 1
#ifdef _SFSTDIO_H
a211 3
#else
 FILE *tapefp = NULL;	/* file pointer for tape */
#endif/* _SFSTDIO_H */
d239 1
d285 1
d294 1
a304 1
#ifdef _SFSTDIO_H
a305 3
#else
    else tapefp = stdin;
#endif
a307 1
#ifdef _SFSTDIO_H
a311 3
#else
	 else      tapefp = efopen(tape, "r");
#endif
a314 1
#ifdef _SFSTDIO_H
a318 1
#endif/* _SFSTDIO_H */
a337 15
#ifndef _SFSTDIO_H
 	} else {
 		nread = (int) fread(bloc1, 1, REC_L, tapefp);
 		if (ferror(tapefp)) {
 			if (verbose)
 				warn("tape read error on header block from shot %d", (ipt+1));
 			if (++errcount > errmax)
 				err("exceeded maximum io errors");
 			clearerr(tapefp);
 		} else { /* Reset counter on successful tape IO */
 			errcount = 0;
 		}
 	}
 	if (!nread) break; /* middle exit loop instead of mile-long while */
#else/*_SFSTDIO_H*/
a340 1
#endif/*_SFSTDIO_H*/
a343 4
#ifndef _SFSTDIO_H
 	(void) memcpy (&segd_general_header_1, bloc1, 32);
 	bloc1 += 32;
#else/*_SFSTDIO_H*/
a344 1
#endif/*_SFSTDIO_H*/
d352 2
a353 2
              nsamp_hdr1 = (hdr1_r*512*16)/(20*hdr1_i)  + 1;
                         /* 20*r*512 msec /20*(i/16) msec */
d360 3
a362 1
 	tr.year =   1900 + bcd ((unsigned char *) &segd_general_header_1.yr, 0, 2);
a379 1
#ifdef _SFSTDIO_H
a381 4
#else/*_SFSTDIO_H*/
 		(void) memcpy (&segd_gen_head_sn358, bloc1, 64);
 		bloc1 += 64;
#endif/*_SFSTDIO_H*/
a396 1
#ifdef _SFSTDIO_H
a397 3
#else/*_SFSTDIO_H*/
 				(void) memcpy (&segd_general_header_2, bloc1, 32);
#endif/*_SFSTDIO_H*/
a423 1
#ifdef _SFSTDIO_H
a424 3
#else/*_SFSTDIO_H*/
 				(void) memcpy (&segd_general_header_n, bloc1, 32);
#endif/*_SFSTDIO_H*/
a426 3
#ifndef _SFSTDIO_H
 			bloc1 += 32;
#endif/*_SFSTDIO_H*/
a430 1
#ifdef _SFSTDIO_H
a431 1
#endif/*_SFSTDIO_H*/
a456 1
#ifdef _SFSTDIO_H
a457 4
#else/*_SFSTDIO_H*/
 			(void) memcpy (&csd[i_scan][i_cs], bloc1, 32);
 			bloc1 += 32;
#endif/*_SFSTDIO_H*/
a472 1
#ifdef _SFSTDIO_H
a473 4
#else/*_SFSTDIO_H*/
 			(void) memcpy (&segd_sample_skew, bloc1, 32);
 			bloc1 += 32;
#endif/*_SFSTDIO_H*/
a479 1
#ifdef _SFSTDIO_H
a480 4
#else/* _SFSTDIO_H */
 		(void) memcpy (&segd_extended_header, bloc1, 32);
 		bloc1 += 32;
#endif/* _SFSTDIO_H */
a487 1
#ifdef _SFSTDIO_H
a488 4
#else/* _SFSTDIO_H */
 		(void) memcpy (&segd_external_header, bloc1, 32);
 		bloc1 += 32;
#endif/* _SFSTDIO_H */
a507 16
#ifndef _SFSTDIO_H
 		} else {
 			nread = (int) fread(bloc1, 1, REC_L, tapefp);
 			if (ferror(tapefp)) {
 				if (verbose)
 					warn("tape read error on trace %d", itr);
 				if (++errcount > errmax)
 					err("exceeded maximum io errors");
 				clearerr(tapefp);
 			} else { /* Reset counter on successful tape IO */
 				errcount = 0;
 			}
 		}

 		if (!nread) break; /* middle exit loop instead of mile-long while */
#else/*_SFSTDIO_H*/
a510 1
#endif/*_SFSTDIO_H*/
a511 3
#ifndef _SFSTDIO_H
 		if (ipt >= ptmin-1) {
#endif
a542 1
#ifdef _SFSTDIO_H
a543 4
#else/*_SFSTDIO_H*/
 				(void) memcpy (&segd_dem_trace_header, bloc1, 20);
				bloc1 += 20;
#endif/*_SFSTDIO_H*/
d551 2
a552 2
				else nsamp_cs = (ns-1)<<bcd(&csd[scan_type][chan_set].sc_j,0,1) + 1 ;
				if (nsamp_cs != 0) ns = nsamp_cs;
a556 1
#ifdef _SFSTDIO_H
a557 4
#else/*_SFSTDIO_H*/
					(void) memcpy (&segd_trace_header_ext, bloc1, 32);
					bloc1 += 32;
#endif/* _SFSTDIO_H */
a565 4
#ifndef _SFSTDIO_H
 				/* if aux = 0, skip auxiliary channels */
 				if (aux==0 && csd[scan_type][chan_set].c != 0x10) continue;
#endif
d583 1
a583 1
 				tr.tracf = bcd ((unsigned  char *) &segd_dem_trace_header.tn, 0, 4);
a595 1
#ifdef _SFSTDIO_H
a596 3
#else
 						F8015_to_float ((short *) bloc1, (float *) tr.data, ns); break;
#endif
a602 1
#ifdef _SFSTDIO_H
a603 3
#else
 						F8022_to_float ((char *) bloc1, (float *) tr.data, ns); break;
#endif
a609 1
#ifdef _SFSTDIO_H
a610 3
#else
 						F8024_to_float ((short *) bloc1, (float *) tr.data, ns); break;
#endif
a616 1
#ifdef _SFSTDIO_H
a617 3
#else
 						F8036_to_float ((unsigned char *) bloc1, (float *) tr.data, ns); break;
#endif
a623 1
#ifdef _SFSTDIO_H
a624 3
#else
 						F8038_to_float ((short *) bloc1, (float *) tr.data, ns); break;
#endif
a630 1
#ifdef _SFSTDIO_H
a631 3
#else
 						F8042_to_float ((char *) bloc1, (float *) tr.data, ns); break;
#endif
a637 1
#ifdef _SFSTDIO_H
a638 3
#else
 						F8044_to_float ((short *) bloc1, (float *) tr.data, ns); break;
#endif
a644 1
#ifdef _SFSTDIO_H
a645 3
#else
 						F8048_to_float ((short *) bloc1, (float *) tr.data, ns); break;
#endif
a651 1
#ifdef _SFSTDIO_H
a652 3
#else
 						F8058_to_float ((short *) bloc1, (float *) tr.data, ns); break;
#endif
a661 1
#ifdef _SFSTDIO_H
a662 1
#endif
a663 1
#ifdef _SFSTDIO_H
a665 1
#endif
a671 1
#ifdef _SFSTDIO_H
a672 1
#endif
a673 3
#ifndef _SFSTDIO_H
 		}
#endif
a680 1
#ifdef _SFSTDIO_H
a681 4
#else
 		(void) memcpy (&segd_general_trailer, bloc1, 32);
 		bloc1 += 32;
#endif
a694 15
#ifndef _SFSTDIO_H
 	} else {
 		nread = (int) fread(bloc1, 1, REC_L, tapefp);
 		if (ferror(tapefp)) {
 			if (verbose)
 				warn("tape read error on header block from shot %d", (ipt+1));
 			if (++errcount > errmax)
 				err("exceeded maximum io errors");
 			clearerr(tapefp);
 		} else { /* Reset counter on successful tape IO */
 			errcount = 0;
 		}
 	}
 	if (nread) warn("not at EOF as should be!");
#else/*_SFSTDIO_H*/
a697 1
#endif/*_SFSTDIO_H*/
a703 1
#ifdef _SFSTDIO_H
a705 4
#else
 (buff) ? eclose(tapefd):
	    efclose(tapefp);
#endif/* _SFSTDIO_H */
a804 1
#ifdef _SFSTDIO_H
a805 7
#else
static void F0015_to_float (short from[], float to[], int len)
#ifdef GET_S
#undef GET_S
#endif
#define GET_S(FROM) (*((FROM)++))
#endif/* _SFSTDIO_H */
a893 1
#ifdef _SFSTDIO_H
a894 7
#else
static void F8015_to_float (short from[], float to[], int len)
#ifdef GET_S
#undef GET_S
#endif
#define GET_S(FROM) (*((FROM)++))
#endif/* _SFSTDIO_H */
a964 1
#ifdef _SFSTDIO_H
a965 7
#else
static void F8022_to_float (char from[], float to[], int len)
#ifdef GET_C
#undef GET_C
#endif
#define GET_C(FROM) (*((FROM)++))
#endif/* _SFSTDIO_H */
a1021 1
#ifdef _SFSTDIO_H
a1022 7
#else
static void F8024_to_float (short from[], float to[], int len)
#ifdef GET_S
#undef GET_S
#endif
#define GET_S(FROM) (*((FROM)++))
#endif/* _SFSTDIO_H */
a1069 1
#ifdef _SFSTDIO_H
a1070 7
#else
static void F8036_to_float (unsigned char from[], float to[], int len)
#ifdef GET_UC
#undef GET_UC
#endif
#define GET_UC(FROM) (*((FROM)++))
#endif/* _SFSTDIO_H */
a1118 1
#ifdef _SFSTDIO_H
a1119 7
#else
static void F8038_to_float (short from[], float to[], int len)
#ifdef GET_S
#undef GET_S
#endif
#define GET_S(FROM) (*((FROM)++))
#endif/* _SFSTDIO_H */
a1172 1
#ifdef _SFSTDIO_H
a1173 7
#else
static void F8042_to_float (char from[], float to[], int len)
#ifdef GET_C
#undef GET_C
#endif
#define GET_C(FROM) (*((FROM)++))
#endif/* _SFSTDIO_H */
a1228 1
#ifdef _SFSTDIO_H
a1229 7
#else
static void F8044_to_float (short from[], float to[], int len)
#ifdef GET_S
#undef GET_S
#endif
#define GET_S(FROM) (*((FROM)++))
#endif/* _SFSTDIO_H */
a1290 1
#ifdef _SFSTDIO_H
a1291 7
#else
static void F8048_to_float (short from[], float to[], int len)
#ifdef GET_S
#undef GET_S
#endif
#define GET_S(FROM) (*((FROM)++))
#endif/* _SFSTDIO_H */
a1366 1
#ifdef _SFSTDIO_H
a1367 7
#else
static void F8058_to_float (short from[], float to[], int len)
#ifdef GET_S
#undef GET_S
#endif
#define GET_S(FROM) (*((FROM)++))
#endif/* _SFSTDIO_H */
a1386 1
#ifdef _SFSTDIO_H
d1635 2
a1636 1
  csh->cs=GET_US(tapeun);
d1783 2
a1784 1
  dth->tn = GET_US(tapeun);
a1804 1
#endif/* _SFSTDIO_H */
d1817 1
a1817 1
 warn("\t\tformat code: %d\n", bcd ((unsigned char *) &(*gh1).y, 0, 4));
d1819 1
a1819 1
 warn("\t\tyear: %d\n", tr.year - 1900);
d1864 1
a1864 1
 warn("phase angle:  %d\n", bcd ((unsigned char*) &(*ghn).pa, 0, 4));
d1924 4
a1927 2
 warn("descale multiplier: %02x%02x\n", (*csh).mp[0], (*csh).mp[1]);
 warn("number of channels: %d", bcd((unsigned char*) &(*csh).cs, 0, 4));
d1931 8
a1938 8
 warn("alias filter frequency: %d", bcd ((unsigned char*) &(*csh).af, 0, 4));
 warn("\talias filter slope: %d\n" , bcd ((unsigned char*) &(*csh).as, 1, 3));
 warn("low cut filter frequency: %d", bcd ((unsigned char*) &(*csh).lc, 0, 4));
 warn("\tlow cut filter slope: %d\n", bcd ((unsigned char*) &(*csh).ls, 1, 3));
 warn("first notch filter: %d", bcd ((unsigned char*) &(*csh).nt[0], 0, 4));
 warn("\tsecond: %d", bcd ((unsigned char*) &(*csh).nt[1], 0, 4));
 warn("\tthird: %d\n", bcd ((unsigned char*) &(*csh).nt[2], 0, 4));
 warn("extended channel set number: %d", bcd ((unsigned char*) &(*csh).ecs, 0, 4));
d1984 1
a1984 1
 warn("file number: %x", (*dth).f);
d1986 1
a1986 1
 warn("trace_number: %x", (*dth).tn);
@


1.7
log
@added Rainer Herbst's extention, with caveats.
@
text
@d1 1
a1 1
/* SEGDREAD: $Revision: 1.54 $ ; $Date: 1997/07/28 22:36:46 $     */
a5 1
#include <memory.h>
d7 64
a70 3
#define REC_L (20 + 4*SU_NFLTS) /* record size: 20 + 10*(SU_NFLTS)/4 bytes */
#define BCD_FF 255          /* value of FF in bcd */
#define BCD_FFFF 16665      /* value of FFFF in bcd */
d82 1
d85 2
a86 2
"       buff=1          for buffered device (9-track reel tape drive)  ",
"                       =0 possibly useful for 8mm EXABYTE drives      ",
d89 1
a89 1
"                       = 2 ; echo informations about blocks           ",
d92 1
a92 1
"       ptmax=INT_MAX   last shot to read                              ",
d96 2
a97 2
"                                                                      ",
"  Notes: I have not tested if this program works for segd disk files  ",
d107 1
a107 1
 *  for versions 2.*:
d109 28
d143 1
a144 2
 * Rainer Herbst: Added - F8048 SEG-D format support  9 Jan 1998
 * Caveat: seems to work only on HP systems at the moment.
d150 13
d164 6
d171 15
d194 1
a195 1
void info_gt(general_trailer * gt);
d206 1
a206 1
 channel_set_header segd_channel_set_header;
d219 6
a224 1
 FILE *tapefp=NULL;      /* file pointer for tape */
d232 5
a236 5
 int nread;              /* bytes read */
 int ns;                 /* number of data samples */
 int n_gh;        	 /* number of additional blocks in general header */
 int n_str;              /* number of scan types per record */
 int n_cs;               /* number of channel sets per scan type */ 
d238 1
a238 1
 int n_ec;               /* extended header length */
d240 1
a240 1
 int n_gt=0;                   /* number of blocks of general trailer */
d253 9
d297 5
a301 1
 if (!getparint("buff", &buff))          buff = 1;
d305 1
d313 18
a330 2
 if (buff) tapefd = eopen(tape, O_RDONLY, 0444);
 else      tapefp = efopen(tape, "r");
d333 7
d358 1
d372 5
d380 1
d383 18
a400 1
 	tr.fldr =   bcd ((unsigned char *) &segd_general_header_1.f, 0, 4);
d402 1
a402 1
 	n_gh =      segd_general_header_1.gh_dy1 >> 4;
d419 4
d425 1
d427 7
d441 3
d445 2
d454 13
d472 3
d476 1
d479 1
d481 1
d486 4
a489 1
 	if (nread != ((1 + n_gh + n_str * (n_cs + n_sk) + n_ec + n_ex) * 32))
d513 4
a517 1
 			segd_channel_set_header = csd[i_scan][i_cs];
d519 2
a520 1
 			n_chan += bcd((unsigned char*) &segd_channel_set_header.cs, 0, 4);
d522 2
a523 2
 				mp = ((float) ((segd_channel_set_header.mp[1] & 0x7f) << 8 | segd_channel_set_header.mp[0])) / 1024.;
 				if (segd_channel_set_header.mp[1] >> 7) mp *= -1.;
d527 1
a527 1
 				if (verbose && segd_channel_set_header.c == 0x10)
d530 1
a530 1
 			if (verbose==2) info_csh(&segd_channel_set_header);
d535 3
d540 1
d547 3
d552 1
d560 3
d565 1
d585 1
d600 5
d606 1
d608 1
d639 4
d645 1
d649 9
d659 3
d664 1
d666 5
d673 1
d676 1
d697 2
d702 8
a709 2
 						tr.ns = ((nread-20)*4)/10; /* number of samples from block length */
 						ns = tr.ns/4;
d711 1
d713 10
a722 1
 						err("Format 8022 (8 bit quaternary demultiplexed) not yet implemented"); break;
d724 10
a733 1
 						err("Format 8024 (16 bit quaternary demultiplexed) not yet implemented"); break;
d735 10
a744 1
 						err("Format 8036 (24 bit 2's compliment integer demultiplexed) not yet implemented"); break;
d746 10
a755 1
 						err("Format 8038 (32 bit 2's compliment integer demultiplexed) not yet implemented"); break;
d757 10
a766 1
 						err("Format 8042 (8 bit hexadecimal demultiplexed) not yet implemented"); break;
d768 10
a777 2
 						err("Format 8044 (16 bit hexadecimal demultiplexed) not yet implemented"); break;
/*Changed R.Herbst 12.12.97*/
d779 10
a788 5
		warn("Format 8048 probably only supported on HP");
 						tr.ns = (nread-20)/4;
 						ns = nread;
 						F8048_to_float ((short *) bloc1, (float *) tr.data, ns); break; 					
/* end changes R.H.*/ 					
d790 10
a799 1
 						err("Format 8058 (32 bit IEEE demultiplexed) not yet implemented"); break;
d809 3
a811 1

d813 4
d823 3
d827 1
d829 1
d837 3
d842 1
d856 1
d870 5
d881 4
d886 3
a888 1
 	efclose(tapefp);
d890 3
a892 2
 free2float (mmp);
 free2 ((void **) csd);
d909 1
a909 1
static int bcd (unsigned char *ptr , int begin , int n)
d919 2
a920 2
 	if (begin++ & 1) val += (*ptr++ & 0xf); 
 	else val += (*ptr >> 4) & 0xf;
d925 1
a925 1
/* F8015_to_float - convert 20 bits binary demultiplexed data into IEEE floating numbers
d929 5
d941 55
a995 1
static void F8015_to_float (short from[], float to[], int len)
d1000 1
d1002 2
a1003 2
 for (i = 0; i <= len; i++) {
 	ex1_4 = *(from++);
d1005 3
a1007 1
 	*(to++) = *(from++) * pow ((double) 2., (double) expo);
d1010 3
a1012 1
 	*(to++) = *(from++) * pow ((double) 2., (double) expo);
d1015 3
a1017 1
 	*(to++) = *(from++) * pow ((double) 2., (double) expo);
d1020 3
a1022 1
 	*(to++) = *(from++) * pow ((double) 2., (double) expo);
d1026 1
a1026 2
/* Begin additions R.Herbst 07.01.97 */
/* F8048_to_float - convert 32 bits hexadecimal demultiplexed data into IEEE floating numbers
d1030 3
d1040 500
d1541 346
d1888 94
a1981 23
  unsigned short wort1;
  unsigned short wort2;
  signed short zeichen=1;
  short expo;
  double mantisse;	
  register int i, k;

 for (i = 0; i <= len; i++) {
 	wort1 = *(from++);
 	wort2 = *(from++);
 	switch ((wort1 >> 15 ) & 0x01) {
 	  	case 0 : zeichen = 1; break;
 	  	case 1 : zeichen = -1; break;
 	  	default : warn("Error in bit-wise shifting, see source code"); 
 	  		break;
 	  	}
 	expo = ((wort1 >> 8) & 127) - 64  ;
 	mantisse = 0.0;
	for (k=0; k<2; k++) {
		mantisse = mantisse + ((wort1 >> (4-4*k)) & 15) * (pow ( 16., (-k-1)));
	} 
	for (k=0; k<4; k++) {
		mantisse = mantisse + ((wort2 >> (12-4*k)) & 15) * (pow ( 16., (-k-3)));
a1982 3
	*(to++) = (float) (zeichen * mantisse * pow (16., expo));
    }
} 
d1984 83
a2066 1
/* end changes R.H */
d2072 2
a2073 2
 n_str = bcd ((unsigned char *)  (*gh1).str, 0, 2);
 n_cs = bcd ((unsigned char *) (*gh1).cs, 0, 2);
d2155 3
a2157 3
 warn("\trecord length: %4.1f\n", bcd((unsigned char*) &(*gh358).rec_length, 1, 3)*.1);
 warn("dynamically switching delay: %4.1f", bcd((unsigned char*) &(*gh358).dyn_swit_del, 1, 3)*.1);
 warn("\trecording delay: %4.1f\n", bcd((unsigned char*) &(*gh358).rec_del, 1, 3)*.1);
d2166 3
a2168 3
 warn("reel number: %d", bcd ((unsigned char*) &(*gh358).reel_num, 0, 4));
 warn("\tfile logicial number: %d", bcd ((unsigned char*) &(*gh358).file_num, 1, 3));
 warn("\tshot point number: %d\n",  bcd ((unsigned char*) &(*gh358).sp_num, 0, 4));
d2220 1
a2220 1
 	warn("%4x %4x %4x %4x\n", *ech[i], *ech[i+1], *ech[i+2], *ech[i+3]);
d2227 2
a2228 2
 char *ptr;
 ptr= (char *) exh;
a2263 1

@


1.6
log
@changes suggested by Stew Levin to silence SGI compiler warnings, etc
@
text
@d1 1
a1 1
/* SEGDREAD: $Revision: 1.5 $ ; $Date: 1997/07/15 19:53:16 $	*/
d31 1
a31 1
"       ptmax=INT_MAX  last shot to read                              ",
d55 2
d63 1
d105 5
a109 5
 int nread;               /* bytes read */
 int ns;                                  /* number of data samples */
 int n_gh;         /* number of additional blocks in general header */
 int n_str;                      /* number of scan types per record */
 int n_cs;                  /* number of channel sets per scan type */ 
d111 1
a111 1
 int n_ec;                                /* extended header length */
d439 1
d441 5
a445 1
 						err("Format 8048 (32 bit hexadecimal demultiplexed) not yet implemented"); break;
d529 1
a529 1
static int bcd (unsigned char * ptr , int begin , int n)
d577 44
@


1.5
log
@Marc Schaming's latest version, which changes by John Stockwell
@
text
@d1 1
a1 1
/* SEGDREAD: $Revision: 1.8 $ ; $Date: 1996/09/06 16:08:13 $	*/
d31 1
a31 1
"       ptmax=LONG_MAX  last shot to read                              ",
d154 1
a154 1
 if (!getparint("ptmax", &ptmax))        ptmax = LONG_MAX;
d165 2
a166 1
 if ((int) bloc1 % 2) warn("there may be a problem since bloc1 is not on a short boundary (%d)", bloc1);
d183 1
a183 1
 		if (-1 == (nread = read(tapefd, (void *) bloc1, (size_t) REC_L))){
d192 1
a192 1
 		nread = fread(bloc1, 1, REC_L, tapefp);
d331 1
a331 1
 			if (-1 == (nread = read(tapefd, (void *) bloc1, (size_t) REC_L))){
d340 1
a340 1
 			nread = fread(bloc1, 1, REC_L, tapefp);
d473 1
a473 1
 		if (-1 == (nread = read(tapefd, (void *) bloc1, (size_t) REC_L))){
d482 1
a482 1
 		nread = fread(bloc1, 1, REC_L, tapefp);
d521 1
a521 1
int bcd (unsigned char * ptr , int begin , int n)
d548 1
a548 1
void F8015_to_float (short from[], float to[], int len)
@


1.4
log
@Cleaned up -Wall stuff.
@
text
@d1 1
a1 1
/* SEGDREAD: $Revision: 1.3 $ ; $Date: 1996/03/05 20:45:19 $	*/
d6 1
d8 3
a10 2
#define F8015 0x8015
#define ENR_L (20 + 10*(SU_NFLTS)/4) /* record size: 20 + 10*(SU_NFLTS)/4 bytes */
d14 25
a38 24
"									",
" SEGDREAD - read an SEG-D tape						",
"									",
" segdread > stdout							",
"									",
" Required parameters:							",
"	tape=		tape device or disk file name to use, see	",
"									",
" Optional parameters:							",
"	buff=1	for buffered device (9-track reel tape drive)		",
"			=0 for unbuffered device (8mm EXABYTE drive)	",
"	verbose=0	silent operation				",
"			= 1 ; echo every 50 traces			",
"	ptmin=1	first shot to read					",
"	ptmax=LONG_MAX  last shot to read				",
"	gain=0	no application of gain					",
"	aux=0		no recovery of auxiliary traces			",
"									",
"  Notes: use  tape=filename for segd diskfile.				",
"	??? doesn't work for diskfile ???				",
"									",
"  Caveat: currently only SEG-D format 8015 is supported.		",
"									",
"	type:	sudoc segdread	for further information			",
d42 13
a54 2
 *	IPRA, Pau, France: Dominique Rousset
 *	EOPG, Strasbourg, France: Marc Schaming, marcs@@eopg.u-strasbg.fr
d59 12
a70 1
int bcd (unsigned char *ptr, int debut, int n);
a71 2
segd_head header;
segd_trace E;
d77 316
a392 97
	register int i, j;
	register short * p_samp4;
	register float * p_data;
	short scan_type;
	short chan_set;
	int nread;
	int expo;
	int ns;
	float mp;
	float mmp[2][12];

	char *tape;		/* name of raw tape device	*/
	int tapefd=0;		/* file descriptor for tape	*/
	FILE *tapefp=NULL;	/* file pointer for tape	*/

	int itr;		/* current trace number		*/
	int ipt;		/* current shot number		*/
	int ptmin;		/* first trace to read		*/
	int ptmax;		/* last trace to read			*/
	int verbose;		/* flag for echoing traces read	*/
	int buff;		/* flag for buffered/unbuffered device  */
	int gain;		/* flag for application of gain	*/
	int aux;		/* flag for recovery of auxiliary traces*/


	/* Initialize */
	initargs(argc, argv);
	requestdoc(0); /* stdin not used */

	/* Make sure stdout is a file or pipe */
	switch(filestat(STDOUT)) {
	case TTY:
		err("stdout can't be tty");
	break;
	case DIRECTORY:
		err("stdout must be a file, not a directory");
	break;
	case BADFILETYPE:
		err("stdout is illegal filetype");
	break;
	default: /* rest are OK */
	break;
	}

	/* Set filenames */
	if (!getparstring("tape",  &tape))
		err("Must supply tape device or diskfile");

	/* Set parameters */
	if (!getparint("ptmin", &ptmin))	ptmin = 1;
	if (!getparint("ptmax", &ptmax))	ptmax = LONG_MAX;
	if (!getparint("verbose", &verbose))	verbose = 0;
	if (!getparint("buff", &buff))	buff = 1;
	if (!getparint("gain", &gain))	gain = 0;
	if (!getparint("aux", &aux))		aux = 0;


	/* Open files - first the tape */
	if (buff) tapefd = eopen(tape, O_RDONLY, 0444);
	else	tapefp = efopen(tape, "r");
	if (verbose) warn("tape opened successfully");

	ipt = 0;
	itr = 0;
	while (ipt < ptmax) {

		/* Reads the Header Block */
		nread  = (buff) ? eread(tapefd, (char *) &header, 5000) :
				efread((char *) &header, 1, 5000, tapefp);
		if (!nread) break;

		/* General Header */
		if (header.segd_gen_head.segd_format != F8015)
			err ("Data format code: %x\n Only the format 8015 is decoded",
				header.segd_gen_head.segd_format);

		tr.fldr = bcd ((unsigned char *) &header.segd_gen_head.file_number, 0, 4);
		tr.day = bcd ((unsigned char *) &header.segd_gen_head.gen_ext_le, 1, 3);
		tr.year = 1900+bcd ((unsigned char *) &header.segd_gen_head.year, 0, 2);

		/* Base scan interval = sample interval */
		tr.dt = (header.segd_gen_head.base_scan_int*1000) >> 4;

		/* General Header Extension */

		/* Channel Set Descriptor */
		if (gain) {
			/* Il y a une incoherence entre la definition de mp:
				pour le labo Sercel SN358DMX (octets 7 et 8, MPs MP4 a MP-10)
				pour la CGG et la SEG (octet 8, MPs MP4 a MP-2; octet 7 = 0) */
			for (j = 0; j < 2; j++) 
				for (i = 0; i < 12; i++) {
					mp = (float) (((unsigned int) header.segd_scan_type_head[j].segd_chan_set_desc[i].sig_mag) & ((unsigned int) 0x7fff)) / 1024.;
					if (header.segd_scan_type_head[j].segd_chan_set_desc[i].sig_mag >> 15) mp *= -1.;
					mmp[j][i] = pow (2., mp);
					if (verbose && header.segd_scan_type_head[j].segd_chan_set_desc[i].ch_id == 0x10)
						warn("Multiplier value: %f", mmp[j][i]);
a393 1
		}
d395 2
a396 1
		/* Sample Skew Header */
d398 106
a503 2
		/* User Header */
		(void) sscanf((char *) (&(header.segd_user_head[11])), "%2hd:%2hd:%2hd", &tr.hour, &tr.minute, &tr.sec);
d505 2
a506 2
		while ((nread  = (buff) ? eread(tapefd, (char *) &E, ENR_L) :
							efread((char *) &E, 1, ENR_L, tapefp)) != 0) {
d508 11
a518 1
			if (ipt >= ptmin-1) {
d520 4
a523 11
				scan_type = bcd ((unsigned char *) &E.tr_head.sc_typ, 0, 2);
				chan_set = bcd ((unsigned char *) &E.tr_head.chan_set, 0, 2);
				if (header.segd_scan_type_head[scan_type].segd_chan_set_desc[chan_set].ch_id != 0x10) {
					/*  Auxiliary traces */
					/*if (verbose) warn("AUX: trace (scan_type, chan_set, E.tr_head.trac_num): %d %d %x\n",
						scan_type, chan_set, E.tr_head.trac_num);*/
				}
				else {
					/* Seismic traces */
					tr.trid = 1; /* real time trace */
				}
d525 2
a526 18
				tr.ns = ((nread-20)*4)/10; /* nombre d'echantillons */
				ns = tr.ns/4;
				tr.tracf = bcd ((unsigned char *) &E.tr_head.trac_num, 0, 4);
				tr.delrt = header.segd_scan_type_head[scan_type-1].segd_chan_set_desc[chan_set-1].ch_s_stt * 2;
				/*if (verbose) warn("SIS: trace (scan_type, chan_set, E.tr_head.trac_num, tr.tracf): %d %d %x=%d\n",
					scan_type, chan_set, E.tr_head.trac_num, tr.tracf);*/

				p_samp4 = &E.tr_data[0].mant[0];
				p_data = &tr.data[0];
				for (i = 0; i <= ns; i++) {
					expo = ((E.tr_data[i].ex1_2 >> 4) & 0x0F) - 15;
					*(p_data++) = *(p_samp4++) * pow ((double) 2., (double) expo);

					expo = (E.tr_data[i].ex1_2 & 0x0F) - 15;
					*(p_data++) = *(p_samp4++) * pow ((double) 2., (double) expo);
		
					expo = ((E.tr_data[i].ex3_4 >> 4) & 0x0F) - 15;
					*(p_data++) = *(p_samp4++) * pow ((double) 2., (double) expo);
d528 6
a533 32
					expo = (E.tr_data[i].ex3_4 & 0x0F) - 15;
					*(p_data++) = *(p_samp4++) * pow ((double) 2., (double) expo);

					p_samp4++;
				}

				if (gain) {
					for (i = 0; i<((int) tr.ns); i++)
						tr.data[i] *= mmp[scan_type][chan_set];
				}

				/* Write the trace to disk */
				puttr(&tr);

				/* Echo under verbose option */
				if (verbose && ++itr % 50 == 0)
					warn(" %d traces from tape", itr);

			}
		}
		/* At EOF */
		ipt++;
	}

	/* Clean up */
	ipt = ipt - ptmin + 1;
	if (verbose) warn ("%d shots (%d traces) from tape", ipt, itr);
	(buff) ? eclose(tapefd):
		efclose(tapefp);
	if (verbose) warn("tape closed successfully");

	return EXIT_SUCCESS;
d536 1
a536 1
/* bcd - convert bcd to int
d539 1
a539 1
 *	EOPG: Marc, Jdt
d542 3
a544 3
 *	ptr	- address of first byte of the number
 *	debut  - 0 or 1, position of the first digit of the number
 *	n	- number of digits
d547 21
d569 1
a569 1
int bcd (unsigned char *ptr, int debut, int n)
d571 31
a601 2
	register int i;
	unsigned int val;
d603 13
a615 2
	val = 0;
	if (n == 0) return (val);
d617 95
a711 6
	for (i = 0; i<n; i++) {
		val *= 10;
		if (debut++ & 1) val += (*ptr++ & 0xf); 
		else val += (*ptr >> 4) & 0xf;
	}
	return (val);
d713 53
@


1.3
log
@added Stew Levin's fixes
@
text
@d1 1
a1 1
/* SEGDREAD: $Revision: 1.2 $ ; $Date: 1995/10/31 23:23:30 $	*/
d51 1
a60 1
	int ntr;
d66 2
a67 2
	int tapefd;		/* file descriptor for tape	*/
	FILE *tapefp;		/* file pointer for tape	*/
d93 2
@


1.2
log
@added comment to selfdoc, cosmetics
@
text
@d1 1
a1 1
/* SEGDREAD: $Revision: 1.1 $ ; $Date: 1995/10/31 23:19:00 $	*/
d128 3
a130 3
		tr.fldr = bcd ((char *) &header.segd_gen_head.file_number, 0, 4);
		tr.day = bcd ((char *) &header.segd_gen_head.gen_ext_le, 1, 3);
		tr.year = 1900+bcd ((char *) &header.segd_gen_head.year, 0, 2);
d144 1
a144 1
					mp = (float) (header.segd_scan_type_head[j].segd_chan_set_desc[i].sig_mag & 0x7fff) / 1024.;
d155 1
a155 1
		(void) sscanf(&header.segd_user_head[11], "%2hd:%2hd:%2hd", &tr.hour, &tr.minute, &tr.sec);
d162 2
a163 2
				scan_type = bcd ((char *) &E.tr_head.sc_typ, 0, 2);
				chan_set = bcd ((char *) &E.tr_head.chan_set, 0, 2);
d176 1
a176 1
				tr.tracf = bcd ((char *) &E.tr_head.trac_num, 0, 4);
d200 1
a200 1
					for (i = 0; i<tr.ns; i++)
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/* SEGDREAD: $Revision: 1.9 $ ; $Date: 1995/08/02 19:42:37 $	*/
d13 1
a13 1
" SEGDREAD - read an SEG-D tape					",
d17 1
a17 1
" Required parameters:						",
d20 2
a21 2
" Optional parameters:						",
"	buff=1	for buffered device (9-track reel tape drive)	",
d25 1
a25 1
"	ptmin=1	first shot to read				",
d27 2
a28 2
"	gain=0	no application of gain			",
"	aux=0		no recovery of auxiliary traces		",
d30 1
a30 1
"  Notes: use  tape=filename for segd diskfile.			",
d33 3
a35 1
"	type:	sudoc segdread	for further information		",
a65 1

a66 1

d120 1
a120 1
						efread((char *) &header, 1, 5000, tapefp);
@
