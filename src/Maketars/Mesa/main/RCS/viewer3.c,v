head	1.10;
access;
symbols;
locks; strict;
comment	@ * @;


1.10
date	2011.11.21.16.29.34;	author john;	state Exp;
branches;
next	1.9;

1.9
date	2011.11.21.16.28.09;	author john;	state Exp;
branches;
next	1.8;

1.8
date	2011.11.21.16.27.56;	author john;	state Exp;
branches;
next	1.7;

1.7
date	97.11.17.16.07.55;	author john;	state Exp;
branches;
next	1.6;

1.6
date	97.11.14.20.12.03;	author john;	state Exp;
branches;
next	1.5;

1.5
date	97.07.31.17.10.19;	author john;	state Exp;
branches;
next	1.4;

1.4
date	97.05.16.20.15.59;	author john;	state Exp;
branches;
next	1.3;

1.3
date	97.05.09.21.35.50;	author john;	state Exp;
branches;
next	1.2;

1.2
date	97.05.09.21.28.00;	author john;	state Exp;
branches;
next	1.1;

1.1
date	97.03.19.22.20.12;	author john;	state Exp;
branches;
next	;


desc
@viewer3.c
@


1.10
log
@Reg Beardsley's checkpars() added
@
text
@/* Copyright (c) Colorado School of Mines, 2011.*/
/* All rights reserved.                       */

/* VIEWER3: $Revision: 1.5 $ ; $Date: 1997/07/31 17:10:19 $	*/

#include "par.h" /*this line must appear first*/
#include "GL/glut.h"
#include "MGL/trackball.h"
#include "MGL/viewer3.h"

/*********************** self documentation *****************************/
char *sdoc[] = {
"									",
" VIEWER3 - VIEWER for 3-dimensional model				", 
"									",
" viewer3 [parameters] < hzfile		 				",
" 									",
" Optional Parameters:							",	
" 									",
" hue=1		=1 for hue =0 for black/white				",
" q=-0.6,0.06,-0.06,0.8 define the quaternion			   	",
" tbs=0.8 	the lager the trackball size is, the slower it rotates  ",
" verbose=0     =1 print some useful information			",
" rayfile=NULL	ray path file to read in 				",
" wffile=NULL	wavefront file to read in				",
" sttfile=NULL  surface traveltime file to read in                      ",
"									",
" Menu: The rightmost mouse button, with cursor placed on the graphics  ",
"       window activates the following menu:				",
" Quit:			quits the application				",
" Full Screen:		expands graphics window to full screen		",
" White/Color Rays:		selects colored (default) or white rays	", 
" Plot Rays:			show the rays (default: off)		",
" Surface Traveltimes:	show surface traveltimes (default: off)		",
" Wired or Solid WFs:	style of wavefront display wireframe (default)	",
"			or solid					",	
" Plot Wavefronts:	turn on wavefronts default: off			",
" TRI or TETRA or LAYER or HORZ:	toggles display from wireframe	",
" 			triangulated horizons, to wireframe tetrahedra, ",
"			to solid layers, to solid horizons		",
" Layer1:		toggle layer on or off (default is on)		",
" ....									",
" 									",
" Notes:								",
" In general, the tetrahedra model should be generated by tetramod	",
" (tetrahedra modle builder) which outputs a file called hzfile, so	",
" that viewer3 can read input from stdin.				",
"									",
" If, in addition, you have 3D raypath information (rayfile), wavefronts",
" (wffile) and surface traveltimes (sttfile), typically generated by    ",
" sutetraray (tetrahedral wavefront construction ray tracing),	  	",
" then rays, wavefronts and surface traveltimes can be displayed as well",
" as the model.							 	",
"									",
" The plot may be rotated by depressing the leftmost mouse button	",
" and dragging the cursor in the desired direction of rotation. The speed",
" of rotation is controlled by the speed of the cursor.			",
" 									",
" The plot may be rescaled by depressing the shift key, while also	",
" depressing and dragging the cursor up or down on the display window.	",
" 									",
NULL};

/*
 * Credits:
 *  	CWP: Zhaobo Meng, 1996
 */
/**************** end self doc *******************************************/

int 
main(int argc, char **argv)
{
      int ix;	/*index for nx*/
      int iy;	/*index for ny*/
      int nx;	/*number of sampels in horizon*/
      int ny;	/*number of sampels in horizon*/

      float xmin,xmax;
      float ymin,ymax;
      float zmin,zmax;

      float ***databot;	/*data for plotting*/
      float ***datatop;
      float ***emisbot; /*color on top horizon*/
      float ***emistop; /*color right above base horizon*/
      float v0;

      int verbose;    /*if =1 print some useful information*/

      float eyez;

      int ihz;	/*index for interfaces*/

      int *ntris;	/*number of triangles*/
      int nt;		/*number of samples in each ray*/
      int iray; 	/*index for nrays*/
      int it;		/*index for nt*/
      int iw,iwf,nwf;
      int is,ns;        /*number of sources*/

      float q0[4];

      char *rayfile=""; /*ray file*/
      char *wffile="";
      char *sttfile="";

      FILE *rayfp=NULL;
      FILE *wffp=NULL;
      FILE *sttfp=NULL;

      Layer *horz;
      Layer *ray;
      Layer *wf;
      float vmin=99999.0;
      float vmax=0.0;

      float tt; /*debugging information in the ray file*/

      int itri;

      char names[10];

      int iflag;	/*flag: =1 means ray effective*/
      float emission[4];
      float tmax=0.0,tmin=FLT_MAX;
      float ***stt=NULL;
      float **ttt=NULL;
      int ntr;

      /* hook up getpar */
      initargs(argc,argv);
      requestdoc(1);

      /* get parameters */
      if (!getparint("verbose",&verbose)) verbose=0;

      /******************************************
      Read model parameters from hzfile
      ******************************************/
      fread(&nhz,sizeof(int),1,stdin);
      fread(&nx,sizeof(int),1,stdin);
      fread(&ny,sizeof(int),1,stdin);
      fread(&xmin,sizeof(float),1,stdin);
      fread(&xmax,sizeof(float),1,stdin);
      fread(&ymin,sizeof(float),1,stdin);
      fread(&ymax,sizeof(float),1,stdin);
      fread(&zmin,sizeof(float),1,stdin);
      fread(&zmax,sizeof(float),1,stdin);

      if (verbose)
            fprintf(stderr,"xmin=%f\nxmax=%f\nymin=%f\nymax=%f\nzmin=%f\nzmax=%f\n",
	          xmin,xmax,ymin,ymax,zmin,zmax);

      if (getparstring("rayfile",&rayfile))  
	    if ((rayfp=fopen(rayfile,"r"))==NULL)
		  err("Can not open rayfile %s",rayfile);

      if (getparstring("wffile",&wffile))
	    if ((wffp=fopen(wffile,"r"))==NULL)
		  err("Can not open wffile %s",wffile);

      if (getparstring("sttfile",&sttfile))
	    if ((sttfp=fopen(sttfile,"r"))==NULL)
		  err("Can not open sttfile %s",sttfile);

      if (!getparfloat("tbs",&tbs))   tbs=0.8;
      if (!getparint("hue",&glb_hue)) glb_hue=1; /*1 for glb_hue*/

      if (verbose) 
	    warn("nhz=%d, nx=%d, ny=%d\n",nhz,nx,ny);

      glb_on_or_off=(enum On_or_Off *)ealloc1int(3*nhz+6);
      for (ihz=0;ihz<nhz;ihz++) glb_on_or_off[ihz]=ON;

      horz=(Layer *)alloc1float(sizeof(Layer)*(nhz+1));

      /*********************************************************
      Do not use GLUT_INDEX, which gives no image;
      GLUT_SINGLE will cause redrawing every time you retate it;
      *********************************************************/
      glutInit(&argc, argv);
      glutInitWindowSize(768,768);
      glutInitDisplayMode(GLUT_RGBA | GLUT_DOUBLE | GLUT_DEPTH);
      glutCreateWindow("viewer3");
      glutDisplayFunc(redraw);
      glutIdleFunc(NULL);

      if (!getparfloat("q",q0)){
	    q0[0]=-0.6; 
	    q0[1]=0.05;
	    q0[2]=-0.06;
	    q0[3]=0.8;
      }
      checkpars();

      normalize_quat(q0);

      curquat[0]=q0[0];
      curquat[1]=q0[1];
      curquat[2]=q0[2];
      curquat[3]=q0[3];

      glutReshapeFunc(myReshape);
      glutVisibilityFunc(vis);
      glutMouseFunc(mouse);
      glutMotionFunc(motion);
      glutCreateMenu(controlLights);
      glutAddMenuEntry("Quit",-1);
      glutAddMenuEntry("Full Screen",0);      
      glutAddMenuEntry("White/Color Rays",1);
      glutAddMenuEntry("Plot Rays",2);
      glutAddMenuEntry("Surface Traveltimes",3);
      glutAddMenuEntry("Wired or Solid WFs",4);
      glutAddMenuEntry("Plot Wavefronts",5);
      glutAddMenuEntry("TRI or TETRA or LAYER or HORZ",6);
      for (ihz=0;ihz<nhz;ihz++) {
	    sprintf(names,"Layer %d",ihz+1);
	    glutAddMenuEntry(names,ihz+7);
      }
      glutAttachMenu(GLUT_RIGHT_BUTTON);

      glShadeModel(GL_SMOOTH);
      glEnable(GL_DEPTH_TEST);
      glEnable(GL_LIGHTING);

      eyez=25;
      glMatrixMode(GL_PROJECTION);
      gluPerspective(
            40.0,   /*fovy: view angle in y direction*/
            1.0,    /*aspect: ratio of width (x) to y (height)*/
            eyez-DIAMETER,  /*near clipping plane*/
            eyez+DIAMETER); /*far clipping plane*/

      glMatrixMode(GL_MODELVIEW);
      gluLookAt(
            0.0, 0.0, eyez, /*(eyex,eyey,eyez): the eye position*/
            0.0, 0.0, 0.0,  /*(centerx,centery,centerz): the center*/
            0.0, 1.0, 0.0); /*(upx,upy,upz): the up direction*/
      glPushMatrix();

      /*the order that tetramod uses is like this*/
      for (ihz=0;ihz<nhz;ihz++) {
            fprintf(stderr,"reading horizon information %d\n",ihz);
	    /**********************************************************
	    input the horizon information from file hzfile:
	    **********************************************************/
	    horz[ihz].x=ealloc2float(nx,ny);
	    horz[ihz].y=ealloc2float(nx,ny);
	    horz[ihz].z=ealloc2float(nx,ny);
	    horz[ihz].v0=ealloc2float(nx,ny);
	    horz[ihz].v1=ealloc2float(nx,ny);

            fprintf(stderr,"read horz[%d].x...\n",ihz);
	    if (fread(horz[ihz].x[0],sizeof(float),nx*ny,
		  stdin)!=nx*ny)
		  err("Can not read x to stdin");
           
            fprintf(stderr,"read horz[%d].y...\n",ihz);
	    if (fread(horz[ihz].y[0],sizeof(float),nx*ny,
		  stdin)!=nx*ny)
		  err("Can not read y to stdin");

	    fprintf(stderr,"read horz[%d].z...\n",ihz);
	    if (fread(horz[ihz].z[0],sizeof(float),nx*ny,
		  stdin)!=nx*ny)
		  err("Can not read z to stdin");

	    fprintf(stderr,"read horz[%d].v0...\n",ihz);
	    if (fread(horz[ihz].v0[0],sizeof(float),nx*ny,stdin)!=
		  nx*ny)
		  err("Can not read v0 to stdin");
 
	    fprintf(stderr,"read horz[%d].v1...\n",ihz);
	    if (fread(horz[ihz].v1[0],sizeof(float),nx*ny,stdin)!=
	      	  nx*ny)
		  err("Can not read v1 to stdin");

	    for (iy=0;iy<ny;iy++) {
	          for (ix=0;ix<nx;ix++) {
		        vmin=MIN(vmin,horz[ihz].v0[iy][ix]);
			vmax=MAX(vmax,horz[ihz].v0[iy][ix]);
		        vmin=MIN(vmin,horz[ihz].v1[iy][ix]);
			vmax=MAX(vmax,horz[ihz].v1[iy][ix]);
		  }
	    }
      }

      if (verbose)
	    fprintf(stderr,"vmin=%f, vmax=%f\n",vmin,vmax);

      horz[nhz].x=ealloc2float(nx,ny);
      horz[nhz].y=ealloc2float(nx,ny);
      horz[nhz].z=ealloc2float(nx,ny);

      fprintf(stderr,"assign horz[%d].x,y,z\n",nhz);
      for (ix=0;ix<nx;ix++) {
	    for (iy=0;iy<ny;iy++) {
	       	  horz[nhz].x[iy][ix]=horz[nhz-1].x[iy][ix];
		  horz[nhz].y[iy][ix]=horz[nhz-1].y[iy][ix];
		  horz[nhz].z[iy][ix]=zmax;
	    }
      }

      databot=ealloc3float(3,nx,ny);
      emisbot=ealloc3float(4,nx,ny);
      datatop=ealloc3float(3,nx,ny);
      emistop=ealloc3float(4,nx,ny);

      for (ihz=0;ihz<nhz;ihz++) {
	    fprintf(stderr,"assigning datatop for ihz=%d\n",ihz);
	    for (ix=0;ix<nx;ix++) {
		  for (iy=0;iy<ny;iy++) {

			datatop[iy][ix][0]=(
			      (horz[ihz].x[iy][ix]-xmin)/
			      (xmax-xmin)-0.5)*DIAMETER;
			datatop[iy][ix][1]=-(
			      (horz[ihz].y[iy][ix]-ymin)/
			      (ymax-ymin)-0.5)*DIAMETER;
			datatop[iy][ix][2]=(
			      (horz[ihz].z[iy][ix]-zmin)/
			      (zmax-zmin)-0.5)*DIAMETER;
			v0=horz[ihz].v0[iy][ix];

			vEmission(v0,vmin,vmax,emistop[iy][ix]);
		  }
	    }

	    fprintf(stderr,"assigning databot for ihz=%d\n",ihz);
	    for (ix=0;ix<nx;ix++) {
		  for (iy=0;iy<ny;iy++) {
			databot[iy][ix][0]=(
			      (horz[ihz+1].x[iy][ix]-xmin)
			      /(xmax-xmin)-0.5)*DIAMETER;
			databot[iy][ix][1]=-(
			      (horz[ihz+1].y[iy][ix]-ymin)
			      /(ymax-ymin)-0.5)*DIAMETER;	
			databot[iy][ix][2]=(
			      (horz[ihz+1].z[iy][ix]-zmin)
			      /(zmax-zmin)-0.5)*DIAMETER;
                                
			v0=horz[ihz].v1[iy][ix];
			vEmission(v0,vmin,vmax,emisbot[iy][ix]);
		  }
	    }

	    showLayer(ihz,databot,datatop,nx,ny,emisbot,emistop);
	    showHorz(ihz,datatop,nx,ny,emistop);
	    showTetra(ihz,databot,datatop,nx,ny,emisbot,emistop);
	    showTri(ihz,datatop,nx,ny,emistop);
      }

      free3float(databot);
      free3float(datatop);
      free3float(emisbot);
      free3float(emistop);

      /*******************************************************************
      The ray positions are generated by sutetraray, named by rayfile. 
      This part will be ignored if rayfile not specified.
      ********************************************************************/
      if (rayfp!=NULL) {

            fscanf(rayfp,
                 "%d =Number of shots\n",&ns);
            fprintf(stderr,"ns=%d\n",ns);

            if (ns<=0 || ns>100) {
                 ns=0;
                 rayfp=NULL;
            }

            ray=(Layer *)alloc1float(sizeof(Layer)*ns);

	    tmax=0.0;
            for (is=0;is<ns;is++) {
                  fscanf(rayfp,
                        "%d =Maximum number of segments\n",&nt);

                  fprintf(stderr,"%d =Maximum number of segments\n",nt);
                  fscanf(rayfp,
                        "%d =Number of rays\n",&ray[is].nrays);
		  fprintf(stderr,"%d =Number of rays\n",ray[is].nrays);

	          ray[is].x=ealloc2float(ray[is].nrays,nt);
	          ray[is].y=ealloc2float(ray[is].nrays,nt);
	          ray[is].z=ealloc2float(ray[is].nrays,nt);
                  ray[is].v0=ealloc2float(ray[is].nrays,nt);
		  ray[is].nseg=ealloc1int(ray[is].nrays);

                  for (iray=0;iray<ray[is].nrays;iray++) {
                        fscanf(rayfp,"%d=nseg %f=ttotal\n",&ray[is].nseg[iray],&tt);

                        if (nt<ray[is].nseg[iray]) err("nt should >=ray[is].nseg[iray]");
                        for (it=0;it<ray[is].nseg[iray];it++) {
                              fscanf(rayfp,"%f %f %f %f %f\n",
                                    &ray[is].x[it][iray],
                                    &ray[is].y[it][iray],
                                    &ray[is].z[it][iray],
				    &ray[is].v0[it][iray],&tt);
			      tmax=MAX(tmax,ray[is].v0[it][iray]);
                        }
                        
                        ray[is].z[ray[is].nseg[iray]-1][iray]=
			      MAX(0.001,ray[is].z[ray[is].nseg[iray]-1][iray]);
           
	                for (it=0;it<ray[is].nseg[iray];it++) {
		      	      ray[is].x[it][iray]=((ray[is].x[it][iray]-xmin)/
		       	            (xmax-xmin)-0.5)*DIAMETER;
		    	      ray[is].y[it][iray]=-((ray[is].y[it][iray]-ymin)/
		       	            (ymax-ymin)-0.5)*DIAMETER;
		       	      ray[is].z[it][iray]=((ray[is].z[it][iray]-zmin)/
		       	            (zmax-zmin)-0.5)*DIAMETER;
	                }
                  }
            }
	    fclose(rayfp);

            /*white rays*/
            glNewList(nhz*4+3,GL_COMPILE);
            emission[0]=emission[1]=emission[2]=emission[3]=1.0;
            glMaterialfv(GL_FRONT_AND_BACK,GL_EMISSION,emission);
            for (is=0;is<ns;is++) {
                  for (iray=0;iray<ray[is].nrays;iray++) {
                        iflag=0;
	                glBegin(GL_LINE_STRIP);
	                for (it=0;it<ray[is].nseg[iray];it++) {
		              if (fabs(ray[is].x[it][iray])<RADIUS &&
		                  fabs(ray[is].y[it][iray])<RADIUS &&
		                  fabs(ray[is].z[it][iray])<RADIUS) {
			            glVertex3f(ray[is].x[it][iray],ray[is].y[it][iray],
			                  ray[is].z[it][iray]);

                                    iflag=1;
		              } else if (iflag) break; /*once good, now bad*/    
	                }
	                glEnd();
                  }
            }
            glEndList();

            /*colored rays*/
            glNewList(nhz*4+4,GL_COMPILE);
            for (is=0;is<ns;is++) {
                  for (iray=0;iray<ray[is].nrays;iray++) {
                        iflag=0;
	                glBegin(GL_LINE_STRIP);
	                for (it=0;it<ray[is].nseg[iray];it++) {
		              if (fabs(ray[is].x[it][iray])<RADIUS &&
		                  fabs(ray[is].y[it][iray])<RADIUS &&
		                  fabs(ray[is].z[it][iray])<RADIUS) {

				    tEmission(
					  ray[is].v0[it][iray],
					  0.0,     /*tmin*/
					  tmax,
					  emission);
				    glMaterialfv(GL_FRONT_AND_BACK,GL_EMISSION,emission);
				    glVertex3f(
					  ray[is].x[it][iray],
					  ray[is].y[it][iray],
			                  ray[is].z[it][iray]);
                                    iflag=1;
		              } else if (iflag) break; /*once good, now bad*/    
	                }
	                glEnd();
                  }
            }
            glEndList();
      }

      /*************************************************************
      Plot the wavefront if it is given. If the wffile does not 
      contain effective data, ntris may be wild. In this case, do
      thing about the wavefront.
      *************************************************************/
      if (wffp!=NULL) {
            fscanf(wffp,"%d = nwf2dump\n",&nwf);
            fprintf(stderr,"nwf2dump=%d\n",nwf);
            if (nwf>200) wffp=NULL;
      }

      if (wffp!=NULL) {

   	    emission[0]=1.0;
            emission[1]=1.0; 
	    emission[2]=0.0;
	    emission[3]=1.0;

	    wf=(Layer *)alloc1float(sizeof(Layer)*nwf);
            ntris=ealloc1int(sizeof(int)*nwf);

	    for (iwf=0;iwf<nwf;iwf++) {

	          if (1!=fscanf(wffp,"%d = ntris\n",&ntris[iwf])) {
		        nwf=iwf;
                        break;
	          }

		  if (ntris[iwf]==0) {
                        nwf=iwf;
                        break;
	          }

		  if (verbose)
			warn("ntris=%d of nwf=%d\n",ntris[iwf],nwf);

		  wf[iwf].x=ealloc2float(3,ntris[iwf]);
		  wf[iwf].y=ealloc2float(3,ntris[iwf]);
		  wf[iwf].z=ealloc2float(3,ntris[iwf]);

		  for (it=0;it<ntris[iwf];it++) {
                        fscanf(wffp,"%f %f %f %f %f %f %f %f %f\n",
                              wf[iwf].x[it],  wf[iwf].y[it],  wf[iwf].z[it],
                              wf[iwf].x[it]+1,wf[iwf].y[it]+1,wf[iwf].z[it]+1,
                              wf[iwf].x[it]+2,wf[iwf].y[it]+2,wf[iwf].z[it]+2);
		  }

		  fprintf(stderr,"Totally read in %d wavefront triangles\n",ntris[iwf]);

		  for (it=0;it<ntris[iwf];it++) {
			for (iw=0;iw<3;iw++) {
			      wf[iwf].x[it][iw]=((wf[iwf].x[it][iw]-xmin)/
					(xmax-xmin)-0.5)*DIAMETER;
			      wf[iwf].y[it][iw]=-((wf[iwf].y[it][iw]-ymin)/
					(ymax-ymin)-0.5)*DIAMETER;
			      wf[iwf].z[it][iw]=((wf[iwf].z[it][iw]-zmin)/
					(zmax-zmin)-0.5)*DIAMETER;
			}
       	          }
	    }
	    fclose(wffp);

            fprintf(stderr,"Click right MB to get menu\n");
            fprintf(stderr,"Click left MB and drag to rotate\n");
            fprintf(stderr,"Press shift and push left MB to scale\n");

  	    glNewList(nhz*4+6,GL_COMPILE);
	    glMaterialfv(GL_FRONT_AND_BACK,GL_EMISSION,emission);

	    for (iwf=0;iwf<nwf;iwf++) {
	          for (itri=0;itri<ntris[iwf];itri++) {
		        glBegin(GL_LINE_LOOP);
		        if (fabs(wf[iwf].x[itri][0])<RADIUS &&
		            fabs(wf[iwf].y[itri][0])<RADIUS &&
		            fabs(wf[iwf].z[itri][0])<RADIUS && 
		            fabs(wf[iwf].x[itri][1])<RADIUS &&
		            fabs(wf[iwf].y[itri][1])<RADIUS &&
		            fabs(wf[iwf].z[itri][1])<RADIUS &&
                            fabs(wf[iwf].x[itri][2])<RADIUS &&
                            fabs(wf[iwf].y[itri][2])<RADIUS &&
                            fabs(wf[iwf].z[itri][2])<RADIUS) {
			          glVertex3f(wf[iwf].x[itri][0],
					     wf[iwf].y[itri][0],
					     wf[iwf].z[itri][0]);
			          glVertex3f(wf[iwf].x[itri][1],
					     wf[iwf].y[itri][1],
					     wf[iwf].z[itri][1]);
			          glVertex3f(wf[iwf].x[itri][2],
					     wf[iwf].y[itri][2],
					     wf[iwf].z[itri][2]);
		        } else {
                            fprintf(stderr,"warning: some triangles ignored\n");
                            glEnd();
                            break;
                        }                        
		        glEnd();
	          }
            }
            glEndList();

            /*solid wavefronts*/
  	    glNewList(nhz*4+7,GL_COMPILE);
	    glMaterialfv(GL_FRONT_AND_BACK,GL_EMISSION,emission);

	    for (iwf=0;iwf<nwf;iwf++) {
	          for (itri=0;itri<ntris[iwf];itri++) {
		        glBegin(GL_TRIANGLE_STRIP);
		        if (fabs(wf[iwf].x[itri][0])<RADIUS &&
		            fabs(wf[iwf].y[itri][0])<RADIUS &&
		            fabs(wf[iwf].z[itri][0])<RADIUS && 
		            fabs(wf[iwf].x[itri][1])<RADIUS &&
		            fabs(wf[iwf].y[itri][1])<RADIUS &&
		            fabs(wf[iwf].z[itri][1])<RADIUS &&
                            fabs(wf[iwf].x[itri][2])<RADIUS &&
                            fabs(wf[iwf].y[itri][2])<RADIUS &&
                            fabs(wf[iwf].z[itri][2])<RADIUS) {
			          glVertex3f(wf[iwf].x[itri][0],
					     wf[iwf].y[itri][0],
					     wf[iwf].z[itri][0]);
			          glVertex3f(wf[iwf].x[itri][1],
					     wf[iwf].y[itri][1],
					     wf[iwf].z[itri][1]);
			          glVertex3f(wf[iwf].x[itri][2],
					     wf[iwf].y[itri][2],
					     wf[iwf].z[itri][2]);
		        } else {
                            fprintf(stderr,"warning: some triangles ignored\n");
                            glEnd();
                            break;
                        }                        
		        glEnd();
	          }
            }
            glEndList();
      }

      /*surface traveltimes*/
      if (sttfp!=NULL) {
            fscanf(sttfp,"%d = ntris\n",&ntr);
            fprintf(stderr,"ntr=%d\n",ntr);
            if (ntr>2000) sttfp=NULL;
      }      

      if (sttfp!=NULL && ntr>0) {
            stt=ealloc3float(3,3,ntr);
            ttt=ealloc2float(3,ntr);

            tmax=0.0;
            tmin=1.0e+10;
	    for (itri=0;itri<ntr;itri++) {
	          fscanf(sttfp,"%f %f %f %f %f %f %f %f %f %f %f %f\n",
		       &stt[itri][0][0],
		       &stt[itri][0][1],
		       &stt[itri][0][2],
		       &ttt[itri][0],
		       &stt[itri][1][0],
		       &stt[itri][1][1],
		       &stt[itri][1][2],
		       &ttt[itri][1],
		       &stt[itri][2][0],
		       &stt[itri][2][1],
		       &stt[itri][2][2],
		       &ttt[itri][2]);

                  tmax=MAX(tmax,ttt[itri][0]);
		  tmax=MAX(tmax,ttt[itri][1]);
		  tmax=MAX(tmax,ttt[itri][2]);

                  tmin=MIN(tmin,ttt[itri][0]);
		  tmin=MIN(tmin,ttt[itri][1]);
		  tmin=MIN(tmin,ttt[itri][2]);

		  stt[itri][0][0]=((stt[itri][0][0]-xmin)/
		       (xmax-xmin)-0.5)*DIAMETER;
		  stt[itri][0][1]=-((stt[itri][0][1]-ymin)/
		       (ymax-ymin)-0.5)*DIAMETER;
		  stt[itri][0][2]=((stt[itri][0][2]-zmin)/
		       (zmax-zmin)-0.5)*DIAMETER;

		  stt[itri][1][0]=((stt[itri][1][0]-xmin)/
		       (xmax-xmin)-0.5)*DIAMETER;
		  stt[itri][1][1]=-((stt[itri][1][1]-ymin)/
		       (ymax-ymin)-0.5)*DIAMETER;
		  stt[itri][1][2]=((stt[itri][1][2]-zmin)/
		       (zmax-zmin)-0.5)*DIAMETER;

		  stt[itri][2][0]=((stt[itri][2][0]-xmin)/
		       (xmax-xmin)-0.5)*DIAMETER;
		  stt[itri][2][1]=-((stt[itri][2][1]-ymin)/
		       (ymax-ymin)-0.5)*DIAMETER;
		  stt[itri][2][2]=((stt[itri][2][2]-zmin)/
		       (zmax-zmin)-0.5)*DIAMETER;
            }
      }

      tmax=MAX(tmax,tmin+0.01);

      glNewList(nhz*4+5,GL_COMPILE);
      for (itri=0;itri<ntr;itri++) {
	    glBegin(GL_TRIANGLE_STRIP);

            tEmission(ttt[itri][0],tmin,tmax,emission);
	    glMaterialfv(GL_FRONT_AND_BACK,GL_EMISSION,emission);
	    glVertex3fv(stt[itri][0]);

	    tEmission(ttt[itri][1],tmin,tmax,emission);
	    glMaterialfv(GL_FRONT_AND_BACK,GL_EMISSION,emission);
	    glVertex3fv(stt[itri][1]);

	    tEmission(ttt[itri][2],tmin,tmax,emission);
	    glMaterialfv(GL_FRONT_AND_BACK,GL_EMISSION,emission);
	    glVertex3fv(stt[itri][2]);

	    glEnd();
      }
      glEndList();

      glutMainLoop();
      return 0;
}

/*********************************************************************
Author: Zhaobo Meng, CWP 1996
*********************************************************************/
void
showHorz(

      int ihz,float ***data,
      int nx,int ny,float ***emis)
{
      int ix,iy;
      int nxhalf;

      nxhalf=nx/2;

      glNewList(ihz+nhz+3,GL_COMPILE);
      glBegin(GL_QUAD_STRIP);
      for (ix=0;ix<nx-1;ix++) {
      	    for (iy=0;iy<ny;iy++) {
		  glMaterialfv(GL_FRONT_AND_BACK,GL_EMISSION,emis[iy][ix]);
		  glVertex3fv(data[iy][ix]);
		  glMaterialfv(GL_FRONT_AND_BACK,GL_EMISSION,emis[iy][ix+1]);
		  glVertex3fv(data[iy][ix+1]);
	    }

	    for (iy=ny-1;iy>=0;iy--) {
	       	  glMaterialfv(GL_FRONT_AND_BACK,GL_EMISSION,emis[iy][ix+1]);
		  glVertex3fv(data[iy][ix+1]);
		  glMaterialfv(GL_FRONT_AND_BACK,GL_EMISSION,emis[iy][ix]);
		  glVertex3fv(data[iy][ix]);
	    }
      }

      glEnd();
      glEndList();
}

void
showLayer(int ihz,float ***databot,float ***datatop,
      int nx,int ny,float ***emisbot,float ***emistop) 
{
      int ix,iy;

      glNewList(ihz+3,GL_COMPILE);
      glBegin(GL_QUAD_STRIP);
      for (ix=0;ix<nx-1;ix++) {
	    for (iy=0;iy<ny;iy++) {
		  if (databot[iy][ix][2]<EPS+datatop[iy][ix][2] &&
		      databot[iy][ix+1][2]<EPS+datatop[iy][ix+1][2]) continue; 
		  glMaterialfv(GL_FRONT_AND_BACK,GL_EMISSION,emisbot[iy][ix]);
		  glVertex3fv(databot[iy][ix]);
		  glMaterialfv(GL_FRONT_AND_BACK,GL_EMISSION,emisbot[iy][ix+1]);
		  glVertex3fv(databot[iy][ix+1]);
	    }
	    for (iy=ny-1;iy>=0;iy--) {
		  if (databot[iy][ix][2]<EPS+datatop[iy][ix][2] &&
		      databot[iy][ix+1][2]<EPS+datatop[iy][ix+1][2]) continue; 
		  glMaterialfv(GL_FRONT_AND_BACK,GL_EMISSION,emistop[iy][ix]);
		  glVertex3fv(datatop[iy][ix]);
		  glMaterialfv(GL_FRONT_AND_BACK,GL_EMISSION,emistop[iy][ix+1]);
		  glVertex3fv(datatop[iy][ix+1]);
	    }
      }

      for (iy=0;iy<ny;iy++) {
	    if (databot[iy][nx-1][2]<EPS+datatop[iy][nx-1][2]) continue;
	    glMaterialfv(GL_FRONT_AND_BACK,GL_EMISSION,emisbot[iy][nx-1]);
	    glVertex3fv(databot[iy][nx-1]);
	    glMaterialfv(GL_FRONT_AND_BACK,GL_EMISSION,emistop[iy][nx-1]);
	    glVertex3fv(datatop[iy][nx-1]);
      }
      for (ix=nx-1;ix>=0;ix--) {
	    if (databot[ny-2][ix][2]<EPS+datatop[ny-2][ix][2]) continue;
	    glMaterialfv(GL_FRONT_AND_BACK,GL_EMISSION,emisbot[ny-1][ix]);
	    glVertex3fv(databot[ny-1][ix]);
	    glMaterialfv(GL_FRONT_AND_BACK,GL_EMISSION,emistop[ny-1][ix]);
	    glVertex3fv(datatop[ny-1][ix]);
      }

      for (iy=ny-1;iy>=0;iy--) {
	    if (databot[iy][0][2]<EPS+datatop[iy][0][2]) continue;
	    glMaterialfv(GL_FRONT_AND_BACK,GL_EMISSION,emisbot[iy][0]);
	    glVertex3fv(databot[iy][0]);
	    glMaterialfv(GL_FRONT_AND_BACK,GL_EMISSION,emistop[iy][0]);
	    glVertex3fv(datatop[iy][0]);
      }

      for (ix=0;ix<nx;ix++) {
	    if (databot[0][ix][2]<EPS+datatop[0][ix][2]) continue;
	    glMaterialfv(GL_FRONT_AND_BACK,GL_EMISSION,emisbot[0][ix]);
	    glVertex3fv(databot[0][ix]);
	    glMaterialfv(GL_FRONT_AND_BACK,GL_EMISSION,emistop[0][ix]);
	    glVertex3fv(datatop[0][ix]);
      }
      glEnd();
      glEndList();
}

void    /*notice: I changed the order of 0 and 1 here to make it upside down*/
showTetra(int ihz,float ***datatop,float ***databot,
      int nx,int ny,float ***emistop,float ***emisbot) 
{
      int ix,iy;

      glNewList(ihz+3+nhz*2,GL_COMPILE);
      glBegin(GL_LINES);
      /**********************************************************
      Plot 2 grids like this

         (ix,iy+2)_____(ix+1,iy+2)
                 |    /|
                 |   / |
	         |  /  |
                 | /   |
                 |/    |
 	(ix,iy+1)|-----|(ix+1,iy+1)
		 |\    |
		 | \   |
		 |  \  |
		 |   \ |
	  (ix,iy)|____\|(ix+1,iy)

      **********************************************************/
      for (ix=0;ix<nx-1;ix++) {   /*horizontal edges*/
	    for (iy=0;iy<ny;iy++) {
		  glMaterialfv(GL_FRONT_AND_BACK,GL_EMISSION,emisbot[iy][ix]);
		  glVertex3fv(databot[iy][ix]);
		  glMaterialfv(GL_FRONT_AND_BACK,GL_EMISSION,emisbot[iy][ix+1]);
		  glVertex3fv(databot[iy][ix+1]);
            }
      }

      for (ix=0;ix<nx;ix++) {   /*vertical edges*/
	    for (iy=0;iy<ny-1;iy++) {
	          glMaterialfv(GL_FRONT_AND_BACK,GL_EMISSION,emisbot[iy][ix]);
		  glVertex3fv(databot[iy][ix]);
		  glMaterialfv(GL_FRONT_AND_BACK,GL_EMISSION,emisbot[iy+1][ix]);
		  glVertex3fv(databot[iy+1][ix]);
            }
      }

      for (ix=0;ix<nx-1;ix++) {   /*slant edges*/
	    for (iy=0;iy<ny-1;iy+=2) {
	          glMaterialfv(GL_FRONT_AND_BACK,GL_EMISSION,emisbot[iy+1][ix]);
		  glVertex3fv(databot[iy+1][ix]);
		  glMaterialfv(GL_FRONT_AND_BACK,GL_EMISSION,emisbot[iy][ix+1]);
		  glVertex3fv(databot[iy][ix+1]);
	    }
        
	    for (iy=1;iy<ny-1;iy+=2) {
		  glMaterialfv(GL_FRONT_AND_BACK,GL_EMISSION,emisbot[iy][ix]);
		  glVertex3fv(databot[iy][ix]);
		  glMaterialfv(GL_FRONT_AND_BACK,GL_EMISSION,emisbot[iy+1][ix]);
		  glVertex3fv(databot[iy+1][ix+1]);
	    }
      }

      /*the base horizon*/
      for (ix=0;ix<nx-1;ix++) {   /*horizontal edges*/
	    for (iy=0;iy<ny;iy++) {
		  glMaterialfv(GL_FRONT_AND_BACK,GL_EMISSION,emistop[iy][ix]);
		  glVertex3fv(datatop[iy][ix]);
		  glMaterialfv(GL_FRONT_AND_BACK,GL_EMISSION,emistop[iy][ix+1]);
		  glVertex3fv(datatop[iy][ix+1]);
            }
      }

      for (ix=0;ix<nx;ix++) {   /*vertical edges*/
	    for (iy=0;iy<ny-1;iy++) {
	          glMaterialfv(GL_FRONT_AND_BACK,GL_EMISSION,emistop[iy][ix]);
		  glVertex3fv(datatop[iy][ix]);
		  glMaterialfv(GL_FRONT_AND_BACK,GL_EMISSION,emistop[iy+1][ix]);
		  glVertex3fv(datatop[iy+1][ix]);
            }
      }

      for (ix=0;ix<nx-1;ix++) {   /*slant edges*/
	    for (iy=0;iy<ny-1;iy+=2) {
	          glMaterialfv(GL_FRONT_AND_BACK,GL_EMISSION,emistop[iy+1][ix]);
		  glVertex3fv(datatop[iy+1][ix]);
		  glMaterialfv(GL_FRONT_AND_BACK,GL_EMISSION,emistop[iy][ix+1]);
		  glVertex3fv(datatop[iy][ix+1]);
	    }
        
	    for (iy=1;iy<ny-1;iy+=2) {
		  glMaterialfv(GL_FRONT_AND_BACK,GL_EMISSION,emistop[iy][ix]);
		  glVertex3fv(datatop[iy][ix]);
		  glMaterialfv(GL_FRONT_AND_BACK,GL_EMISSION,emistop[iy+1][ix+1]);
		  glVertex3fv(datatop[iy+1][ix+1]);
	    }
      }

      /**********************************************************
      Plot vertical segments
      **********************************************************/
      for (ix=0;ix<nx;ix++) {
	    for (iy=0;iy<ny;iy++) {
		  glMaterialfv(GL_FRONT_AND_BACK,GL_EMISSION,emisbot[iy][ix]);
		  glVertex3fv(databot[iy][ix]);
		  glMaterialfv(GL_FRONT_AND_BACK,GL_EMISSION,emistop[iy][ix]);
		  glVertex3fv(datatop[iy][ix]);
            }
      }

      /**********************************************************
      Plot slant segments
      **********************************************************/
      for (ix=0;ix<nx-1;ix++) {
	    for (iy=0;iy<ny-1;iy+=2) {
		  glMaterialfv(GL_FRONT_AND_BACK,GL_EMISSION,emisbot[iy][ix]);
		  glVertex3fv(databot[iy][ix]);
		  glMaterialfv(GL_FRONT_AND_BACK,GL_EMISSION,emistop[iy][ix+1]);
		  glVertex3fv(datatop[iy][ix+1]);

		  glMaterialfv(GL_FRONT_AND_BACK,GL_EMISSION,emisbot[iy+1][ix]);
		  glVertex3fv(databot[iy+1][ix]);
		  glMaterialfv(GL_FRONT_AND_BACK,GL_EMISSION,emistop[iy][ix]);
		  glVertex3fv(datatop[iy][ix]);

		  glMaterialfv(GL_FRONT_AND_BACK,GL_EMISSION,emisbot[iy+1][ix]);
		  glVertex3fv(databot[iy+1][ix]);
		  glMaterialfv(GL_FRONT_AND_BACK,GL_EMISSION,emistop[iy][ix+1]);
		  glVertex3fv(datatop[iy][ix+1]);

		  glMaterialfv(GL_FRONT_AND_BACK,GL_EMISSION,emisbot[iy+1][ix+1]);
		  glVertex3fv(databot[iy+1][ix+1]);
		  glMaterialfv(GL_FRONT_AND_BACK,GL_EMISSION,emistop[iy+1][ix]);
		  glVertex3fv(datatop[iy+1][ix]);

		  glMaterialfv(GL_FRONT_AND_BACK,GL_EMISSION,emisbot[iy+1][ix+1]);
		  glVertex3fv(databot[iy+1][ix+1]);
		  glMaterialfv(GL_FRONT_AND_BACK,GL_EMISSION,emistop[iy][ix+1]);
		  glVertex3fv(datatop[iy][ix+1]);
	    }

	    for (iy=1;iy<ny-1;iy+=2) {
		  glMaterialfv(GL_FRONT_AND_BACK,GL_EMISSION,emisbot[iy][ix]);
		  glVertex3fv(databot[iy][ix]);
		  glMaterialfv(GL_FRONT_AND_BACK,GL_EMISSION,emistop[iy+1][ix]);
		  glVertex3fv(datatop[iy+1][ix]);

		  glMaterialfv(GL_FRONT_AND_BACK,GL_EMISSION,emisbot[iy][ix]);
		  glVertex3fv(databot[iy][ix]);
		  glMaterialfv(GL_FRONT_AND_BACK,GL_EMISSION,emistop[iy+1][ix+1]);
		  glVertex3fv(datatop[iy+1][ix+1]);

		  glMaterialfv(GL_FRONT_AND_BACK,GL_EMISSION,emisbot[iy+1][ix]);
		  glVertex3fv(databot[iy+1][ix]);
		  glMaterialfv(GL_FRONT_AND_BACK,GL_EMISSION,emistop[iy+1][ix+1]);
		  glVertex3fv(datatop[iy+1][ix+1]);

		  glMaterialfv(GL_FRONT_AND_BACK,GL_EMISSION,emisbot[iy][ix]);
		  glVertex3fv(databot[iy][ix]);
		  glMaterialfv(GL_FRONT_AND_BACK,GL_EMISSION,emistop[iy+1][ix+1]);
		  glVertex3fv(datatop[iy+1][ix+1]);

		  glMaterialfv(GL_FRONT_AND_BACK,GL_EMISSION,emisbot[iy][ix+1]);
		  glVertex3fv(databot[iy][ix+1]);
		  glMaterialfv(GL_FRONT_AND_BACK,GL_EMISSION,emistop[iy+1][ix+1]);
		  glVertex3fv(datatop[iy+1][ix+1]);
	    }
      }

      glEnd();
      glEndList();
}

void
showTri(int ihz,float ***data,
      int nx,int ny,float ***emis) 
{
      int ix,iy;

      glNewList(ihz+3+nhz*3,GL_COMPILE);
      glBegin(GL_LINES);

      /**********************************************************
	Plot 2 grids like this

         (ix,iy+2)_____(ix+1,iy+2)
                 |    /|
                 |   / |
	         |  /  |
                 | /   |
                 |/    |
 	(ix,iy+1)|-----|(ix+1,iy+1)
		 |\    |
		 | \   |
		 |  \  |
		 |   \ |
	  (ix,iy)|____\|(ix+1,iy)

      **********************************************************/
      for (ix=0;ix<nx-1;ix++) {   /*horizontal edges*/
	    for (iy=0;iy<ny;iy++) {
		  glMaterialfv(GL_FRONT_AND_BACK,GL_EMISSION,emis[iy][ix]);
		  glVertex3fv(data[iy][ix]);
		  glMaterialfv(GL_FRONT_AND_BACK,GL_EMISSION,emis[iy][ix+1]);
		  glVertex3fv(data[iy][ix+1]);
            }
      }

      for (ix=0;ix<nx;ix++) {   /*vertical edges*/
	    for (iy=0;iy<ny-1;iy++) {
	          glMaterialfv(GL_FRONT_AND_BACK,GL_EMISSION,emis[iy][ix]);
		  glVertex3fv(data[iy][ix]);
		  glMaterialfv(GL_FRONT_AND_BACK,GL_EMISSION,emis[iy+1][ix]);
		  glVertex3fv(data[iy+1][ix]);
            }
      }

      for (ix=0;ix<nx-1;ix++) {   /*slant edges*/
	    for (iy=0;iy<ny-1;iy+=2) {
	          glMaterialfv(GL_FRONT_AND_BACK,GL_EMISSION,emis[iy][ix]);
		  glVertex3fv(data[iy+1][ix]);
		  glMaterialfv(GL_FRONT_AND_BACK,GL_EMISSION,emis[iy][ix+1]);
		  glVertex3fv(data[iy][ix+1]);
	    }
        
	    for (iy=1;iy<ny-1;iy+=2) {
		  glMaterialfv(GL_FRONT_AND_BACK,GL_EMISSION,emis[iy][ix]);
		  glVertex3fv(data[iy][ix]);
		  glMaterialfv(GL_FRONT_AND_BACK,GL_EMISSION,emis[iy+1][ix+1]);
		  glVertex3fv(data[iy+1][ix+1]);
	    }
      }

      glEnd();
      glEndList();
}

void
recalcModelView(void)
{
      GLfloat m[4][4];		/*the matrix*/

      glPopMatrix();
      glPushMatrix();

      build_rotmatrix(m, curquat);
      glMultMatrixf(&m[0][0]);
      glScalef(glb_scalefactor, glb_scalefactor, glb_scalefactor);
      glb_newmodel=0;
}

/***************************************************************
function to print a message in the window
***************************************************************/
void
showMessage(GLfloat x, GLfloat y, GLfloat z, char *message)
{
      glPushMatrix();
      glDisable(GL_LIGHTING);
      glTranslatef(x, y, z);
      glScalef(.01, .01, .01);
      /* To rotate 90 degrees counterclockwise aroubd (0,0,1)*/
      glRotatef(90.0, 0.0, 0.0, 1.0);
      while (*message) {
       	    glutStrokeCharacter(GLUT_STROKE_ROMAN, *message);
	    message++;
      }
      glEnable(GL_LIGHTING);
      glPopMatrix();
}

/***************************************************
Called whenever glutPostRedisplay() is called
***************************************************/
void
redraw(void)
{
      int ihz;
      if (glb_newmodel) recalcModelView();
      glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

      for (ihz=0;ihz<nhz;ihz++) {
	    if (hlt==LAYER && glb_on_or_off[ihz]==ON)
		  glCallList(ihz+3);
	    else if (hlt==HORZ && glb_on_or_off[ihz]==ON)
		  glCallList(nhz+ihz+3);
	    else if (hlt==TETRA && glb_on_or_off[ihz]==ON)
		  glCallList(ihz+2*nhz+3);
	    else if (hlt==TRI && glb_on_or_off[ihz]==ON)
		  glCallList(ihz+3*nhz+3);
      }

      if (glb_plot_rays==PLOT_RAYS) {
	    if (wc_rays==WHITE)
	          glCallList(nhz*4+3);
	    else
	          glCallList(nhz*4+4);
      }

      if (plot_st==PLOT_SURFACE_TRAVELTIMES)
            glCallList(nhz*4+5);

      if (glb_plot_wf==PLOT_WF) {
	    if (wfs==WIRED)
                  glCallList(nhz*4+6);
	    else
	          glCallList(nhz*4+7);
      }

      glFlush();
      /*showMessage(0, 0, 0, "x direction");*/
      glutSwapBuffers();
}

/****************************************
This call back is called when the window
is rescaled
****************************************/
void
myReshape(int w, int h)
{
      glViewport(0, 0, w, h);
      glb_W=w;
      glb_H=h;
}

/*****************************************
This call back is called when the mouse is
pressed
*****************************************/
void
mouse(int button, int state, int x, int y)
{
      if (button==GLUT_LEFT_BUTTON && state==GLUT_DOWN) {
	    glb_spinning=0;
	    glutIdleFunc(NULL);
	    glb_moving=1;
	    glb_beginx=x;
	    glb_beginy=y;
	    if(glutGetModifiers() & GLUT_ACTIVE_SHIFT) 
		  glb_scaling=1;
	    else 
		  glb_scaling=0;
      }	
      if (button==GLUT_LEFT_BUTTON && state==GLUT_UP) {
	    glb_moving=0;
	    glb_spinning=0;
      }
}

/********************************************
Animate the object to continue its motion
********************************************/
void
animate(void)
{
      add_quats(lastquat, curquat, curquat);
      glb_newmodel=1;
      glutPostRedisplay();
}

/*********************************************
Called when the mouse is pressed while moved
*********************************************/
void
motion(int x,int y)
{
      if (glb_scaling) {
	    glb_scalefactor=glb_scalefactor*
		  (1.0+(((float)(glb_beginy-y))/glb_H));
	    glb_beginx=x;
	    glb_beginy=y;
	    glb_newmodel=1;
	    glutPostRedisplay();
	    return;
      }

      if (glb_moving) {
	    trackball(lastquat,
		  (2.0*glb_beginx-glb_W)/glb_W,
		  (glb_H-2.0*glb_beginy)/glb_H,
		  (2.0*x-glb_W)/glb_W,
		  (glb_H-2.0*y)/glb_H,tbs);

	    #ifdef DEBUG
	    fprintf(stderr,"q=%f,%f,%f,%f\n",curquat[0],curquat[1],
		  curquat[2],curquat[3]);
            #endif

	    glb_beginx=x;
	    glb_beginy=y;
	    glb_spinning=1;
	    glutIdleFunc(animate);
      }
}

/******************************************
switches
******************************************/
void
controlLights(int value)
{
      switch (value) {
	    case -1:
		  exit(0);
		  break;
	    case 0:
		  glutFullScreen();
		  break;
            case 1:
                  if (wc_rays==WHITE)
                        wc_rays=COLORED;
                  else
                        wc_rays=WHITE;
                  break;
            case 2:
		  if (glb_plot_rays==DO_NOT_PLOT_RAYS)
		       	glb_plot_rays=PLOT_RAYS;
		  else
			glb_plot_rays=DO_NOT_PLOT_RAYS;
                  break;
            case 3:
                  if (plot_st==DO_NOT_PLOT_SURFACE_TRAVELTIMES)
		        plot_st=PLOT_SURFACE_TRAVELTIMES;
                  else 
		        plot_st=DO_NOT_PLOT_SURFACE_TRAVELTIMES;
		  break;
            case 4:
                  if (wfs==WIRED)
                        wfs=SOLID;
                  else
	      	        wfs=WIRED;                  
                  break;
            case 5:
                  if (glb_plot_wf==DO_NOT_PLOT_WF)
                        glb_plot_wf=PLOT_WF;
                  else
                        glb_plot_wf=DO_NOT_PLOT_WF;
                  break;
            case 6:
		  if (hlt==HORZ)
		        hlt=TRI;
		  else if (hlt==TRI)
			hlt=TETRA;
		  else if (hlt==TETRA)
			hlt=LAYER;
		  else 
			hlt=HORZ;	
		  break;
	    default:
		  if (glb_on_or_off[value-7]==ON)
			glb_on_or_off[value-7]=OFF;
		  else 
		        glb_on_or_off[value-7]=ON;
	          break;	
      }
      glutPostRedisplay();
}

/************************************************
When it is not visible, do not waste the computer
resources
************************************************/
void
vis(int visible)
{
      if (visible==GLUT_VISIBLE) {
	    if (glb_spinning)
		  glutIdleFunc(animate);
      } else {
	    if (glb_spinning)
	       	  glutIdleFunc(NULL);
      }
}

/*********************************************************************
Author: Zhaobo Meng, CWP 1996

Set up the traveltime mapping: traveltime->color
************************************************/
void
vEmission(float v,float vmin,float vmax,
      float *emission)
{
      float color;
      color=(v-vmin)/(vmax-vmin);
      color=MAX(0.0,MIN(1.0,color));
      if (glb_hue==1) {
	    emission[0]=1.0;
	    emission[1]=color;
	    emission[2]=1.0;
      } else {
	    emission[0]=color;
	    emission[1]=color;
	    emission[2]=color;
      }
      emission[3]=glb_alpha;
}

/*********************************************************************
Author: Zhaobo Meng, CWP 1996

Set up the traveltime mapping: traveltime->color
*********************************************************************/
void
tEmission(float t,float tmin,float tmax,
      float *emission)
{
      if (fabs(tmax-tmin)==0.0)
            emission[1]=0.0;
      else  
            emission[1]=MAX(0.0,MIN(1.0,(t-tmin)/(tmax-tmin)));
      emission[0]=1.0;
      emission[2]=emission[1];
      emission[3]=glb_alpha;
}

static void 
normalize_quat(float q[4])
{
      int i;
      float mag;

      mag = (q[0]*q[0] + q[1]*q[1] + q[2]*q[2] + q[3]*q[3]);
      for (i = 0; i < 4; i++) q[i] /= mag;
}
@


1.9
log
@copyright
@
text
@d4 1
a4 1
/* VIEWER3: $Revision: 1.8 $ ; $Date: 2011/11/21 16:27:56 $	*/
d194 1
@


1.8
log
@21 Nov
@
text
@d1 4
a4 1
/* VIEWER3: $Revision: 1.5 $ ; $Date: 1997/07/31 17:10:19 $	*/
@


1.7
log
@14 Nov 1997 versio
@
text
@d11 1
a11 2
" VIEWER3 - VIEWER for 3-dimensional tetrahedrized models, ray plots,   ",
"            wavefronts, and traveltimes				",
d13 1
a13 1
"    viewer3 [parameters] < hzfile		 			",
d23 1
a23 1
" sttfile=NULL  surface traveltime file to read in		      	",
d96 1
a96 1
      int is,ns;	/*number of sources*/
d148 2
a149 2
	    fprintf(stderr,"xmin=%f\nxmax=%f\nymin=%f\nymax=%f\nzmin=%f\nzmax=%f\n",
		  xmin,xmax,ymin,ymax,zmin,zmax);
d225 4
a228 4
	    40.0,   /*fovy: view angle in y direction*/
	    1.0,    /*aspect: ratio of width (x) to y (height)*/
	    eyez-DIAMETER,  /*near clipping plane*/
	    eyez+DIAMETER); /*far clipping plane*/
d232 3
a234 3
	    0.0, 0.0, eyez, /*(eyex,eyey,eyez): the eye position*/
	    0.0, 0.0, 0.0,  /*(centerx,centery,centerz): the center*/
	    0.0, 1.0, 0.0); /*(upx,upy,upz): the up direction*/
d239 1
a239 1
	    fprintf(stderr,"reading horizon information %d\n",ihz);
d249 1
a249 1
	    fprintf(stderr,"read horz[%d].x...\n",ihz);
d253 2
a254 2
	   
	    fprintf(stderr,"read horz[%d].y...\n",ihz);
d275 2
a276 2
		  for (ix=0;ix<nx;ix++) {
			vmin=MIN(vmin,horz[ihz].v0[iy][ix]);
d278 1
a278 1
			vmin=MIN(vmin,horz[ihz].v1[iy][ix]);
d337 1
a337 1
				
d360 8
a367 8
	    fscanf(rayfp,
		 "%d =Number of shots\n",&ns);
	    fprintf(stderr,"ns=%d\n",ns);

	    if (ns<=0 || ns>100) {
		 ns=0;
		 rayfp=NULL;
	    }
d369 1
a369 1
	    ray=(Layer *)alloc1float(sizeof(Layer)*ns);
d372 7
a378 7
	    for (is=0;is<ns;is++) {
		  fscanf(rayfp,
			"%d =Maximum number of segments\n",&nt);

		  fprintf(stderr,"%d =Maximum number of segments\n",nt);
		  fscanf(rayfp,
			"%d =Number of rays\n",&ray[is].nrays);
d381 4
a384 4
		  ray[is].x=ealloc2float(ray[is].nrays,nt);
		  ray[is].y=ealloc2float(ray[is].nrays,nt);
		  ray[is].z=ealloc2float(ray[is].nrays,nt);
		  ray[is].v0=ealloc2float(ray[is].nrays,nt);
d387 2
a388 2
		  for (iray=0;iray<ray[is].nrays;iray++) {
			fscanf(rayfp,"%d=nseg %f=ttotal\n",&ray[is].nseg[iray],&tt);
d390 6
a395 6
			if (nt<ray[is].nseg[iray]) err("nt should >=ray[is].nseg[iray]");
			for (it=0;it<ray[is].nseg[iray];it++) {
			      fscanf(rayfp,"%f %f %f %f %f\n",
				    &ray[is].x[it][iray],
				    &ray[is].y[it][iray],
				    &ray[is].z[it][iray],
d398 3
a400 3
			}
			
			ray[is].z[ray[is].nseg[iray]-1][iray]=
d402 2
a403 2
	   
			for (it=0;it<ray[is].nseg[iray];it++) {
d405 1
a405 1
		       		    (xmax-xmin)-0.5)*DIAMETER;
d407 1
a407 1
		       		    (ymax-ymin)-0.5)*DIAMETER;
d409 4
a412 4
		       		    (zmax-zmin)-0.5)*DIAMETER;
			}
		  }
	    }
d415 33
a447 33
	    /*white rays*/
	    glNewList(nhz*4+3,GL_COMPILE);
	    emission[0]=emission[1]=emission[2]=emission[3]=1.0;
	    glMaterialfv(GL_FRONT_AND_BACK,GL_EMISSION,emission);
	    for (is=0;is<ns;is++) {
		  for (iray=0;iray<ray[is].nrays;iray++) {
			iflag=0;
			glBegin(GL_LINE_STRIP);
			for (it=0;it<ray[is].nseg[iray];it++) {
			      if (fabs(ray[is].x[it][iray])<RADIUS &&
				  fabs(ray[is].y[it][iray])<RADIUS &&
				  fabs(ray[is].z[it][iray])<RADIUS) {
				    glVertex3f(ray[is].x[it][iray],ray[is].y[it][iray],
					  ray[is].z[it][iray]);

				    iflag=1;
			      } else if (iflag) break; /*once good, now bad*/    
			}
			glEnd();
		  }
	    }
	    glEndList();

	    /*colored rays*/
	    glNewList(nhz*4+4,GL_COMPILE);
	    for (is=0;is<ns;is++) {
		  for (iray=0;iray<ray[is].nrays;iray++) {
			iflag=0;
			glBegin(GL_LINE_STRIP);
			for (it=0;it<ray[is].nseg[iray];it++) {
			      if (fabs(ray[is].x[it][iray])<RADIUS &&
				  fabs(ray[is].y[it][iray])<RADIUS &&
				  fabs(ray[is].z[it][iray])<RADIUS) {
d458 8
a465 8
					  ray[is].z[it][iray]);
				    iflag=1;
			      } else if (iflag) break; /*once good, now bad*/    
			}
			glEnd();
		  }
	    }
	    glEndList();
d474 3
a476 3
	    fscanf(wffp,"%d = nwf2dump\n",&nwf);
	    fprintf(stderr,"nwf2dump=%d\n",nwf);
	    if (nwf>200) wffp=NULL;
d482 1
a482 1
	    emission[1]=1.0; 
d487 1
a487 1
	    ntris=ealloc1int(sizeof(int)*nwf);
d491 4
a494 4
		  if (1!=fscanf(wffp,"%d = ntris\n",&ntris[iwf])) {
			nwf=iwf;
			break;
		  }
d497 3
a499 3
			nwf=iwf;
			break;
		  }
d509 4
a512 4
			fscanf(wffp,"%f %f %f %f %f %f %f %f %f\n",
			      wf[iwf].x[it],  wf[iwf].y[it],  wf[iwf].z[it],
			      wf[iwf].x[it]+1,wf[iwf].y[it]+1,wf[iwf].z[it]+1,
			      wf[iwf].x[it]+2,wf[iwf].y[it]+2,wf[iwf].z[it]+2);
d526 1
a526 1
       		  }
d530 3
a532 3
	    fprintf(stderr,"Click right MB to get menu\n");
	    fprintf(stderr,"Click left MB and drag to rotate\n");
	    fprintf(stderr,"Press shift and push left MB to scale\n");
d538 12
a549 12
		  for (itri=0;itri<ntris[iwf];itri++) {
			glBegin(GL_LINE_LOOP);
			if (fabs(wf[iwf].x[itri][0])<RADIUS &&
			    fabs(wf[iwf].y[itri][0])<RADIUS &&
			    fabs(wf[iwf].z[itri][0])<RADIUS && 
			    fabs(wf[iwf].x[itri][1])<RADIUS &&
			    fabs(wf[iwf].y[itri][1])<RADIUS &&
			    fabs(wf[iwf].z[itri][1])<RADIUS &&
			    fabs(wf[iwf].x[itri][2])<RADIUS &&
			    fabs(wf[iwf].y[itri][2])<RADIUS &&
			    fabs(wf[iwf].z[itri][2])<RADIUS) {
				  glVertex3f(wf[iwf].x[itri][0],
d552 1
a552 1
				  glVertex3f(wf[iwf].x[itri][1],
d555 1
a555 1
				  glVertex3f(wf[iwf].x[itri][2],
d558 9
a566 9
			} else {
			    fprintf(stderr,"warning: some triangles ignored\n");
			    glEnd();
			    break;
			}
			glEnd();
		  }
	    }
	    glEndList();
d568 1
a568 1
	    /*solid wavefronts*/
d573 12
a584 12
		  for (itri=0;itri<ntris[iwf];itri++) {
			glBegin(GL_TRIANGLE_STRIP);
			if (fabs(wf[iwf].x[itri][0])<RADIUS &&
			    fabs(wf[iwf].y[itri][0])<RADIUS &&
			    fabs(wf[iwf].z[itri][0])<RADIUS && 
			    fabs(wf[iwf].x[itri][1])<RADIUS &&
			    fabs(wf[iwf].y[itri][1])<RADIUS &&
			    fabs(wf[iwf].z[itri][1])<RADIUS &&
			    fabs(wf[iwf].x[itri][2])<RADIUS &&
			    fabs(wf[iwf].y[itri][2])<RADIUS &&
			    fabs(wf[iwf].z[itri][2])<RADIUS) {
				  glVertex3f(wf[iwf].x[itri][0],
d587 1
a587 1
				  glVertex3f(wf[iwf].x[itri][1],
d590 1
a590 1
				  glVertex3f(wf[iwf].x[itri][2],
d593 9
a601 9
			} else {
			    fprintf(stderr,"warning: some triangles ignored\n");
			    glEnd();
			    break;
			}			
			glEnd();
		  }
	    }
	    glEndList();
d606 3
a608 3
	    fscanf(sttfp,"%d = ntris\n",&ntr);
	    fprintf(stderr,"ntr=%d\n",ntr);
	    if (ntr>2000) sttfp=NULL;
d612 2
a613 2
	    stt=ealloc3float(3,3,ntr);
	    ttt=ealloc2float(3,ntr);
d615 2
a616 2
	    tmax=0.0;
	    tmin=1.0e+10;
d618 1
a618 1
		  fscanf(sttfp,"%f %f %f %f %f %f %f %f %f %f %f %f\n",
d632 1
a632 1
		  tmax=MAX(tmax,ttt[itri][0]);
d636 1
a636 1
		  tmin=MIN(tmin,ttt[itri][0]);
d660 1
a660 1
	    }
d669 1
a669 1
	    tEmission(ttt[itri][0],tmin,tmax,emission);
d797 6
a802 6
	 (ix,iy+2)_____(ix+1,iy+2)
		 |    /|
		 |   / |
		 |  /  |
		 | /   |
		 |/    |
d817 1
a817 1
	    }
d822 1
a822 1
		  glMaterialfv(GL_FRONT_AND_BACK,GL_EMISSION,emisbot[iy][ix]);
d826 1
a826 1
	    }
d831 1
a831 1
		  glMaterialfv(GL_FRONT_AND_BACK,GL_EMISSION,emisbot[iy+1][ix]);
d836 1
a836 1
	
d852 1
a852 1
	    }
d857 1
a857 1
		  glMaterialfv(GL_FRONT_AND_BACK,GL_EMISSION,emistop[iy][ix]);
d861 1
a861 1
	    }
d866 1
a866 1
		  glMaterialfv(GL_FRONT_AND_BACK,GL_EMISSION,emistop[iy+1][ix]);
d871 1
a871 1
	
d889 1
a889 1
	    }
d967 6
a972 6
	 (ix,iy+2)_____(ix+1,iy+2)
		 |    /|
		 |   / |
		 |  /  |
		 | /   |
		 |/    |
d987 1
a987 1
	    }
d992 1
a992 1
		  glMaterialfv(GL_FRONT_AND_BACK,GL_EMISSION,emis[iy][ix]);
d996 1
a996 1
	    }
d1001 1
a1001 1
		  glMaterialfv(GL_FRONT_AND_BACK,GL_EMISSION,emis[iy][ix]);
d1006 1
a1006 1
	
d1076 1
a1076 1
		  glCallList(nhz*4+3);
d1078 1
a1078 1
		  glCallList(nhz*4+4);
d1082 1
a1082 1
	    glCallList(nhz*4+5);
d1086 1
a1086 1
		  glCallList(nhz*4+6);
d1088 1
a1088 1
		  glCallList(nhz*4+7);
d1169 1
a1169 1
	    #endif
d1191 7
a1197 7
	    case 1:
		  if (wc_rays==WHITE)
			wc_rays=COLORED;
		  else
			wc_rays=WHITE;
		  break;
	    case 2:
d1202 6
d1209 13
a1221 19
	    case 3:
		  if (plot_st==DO_NOT_PLOT_SURFACE_TRAVELTIMES)
			plot_st=PLOT_SURFACE_TRAVELTIMES;
		  else 
			plot_st=DO_NOT_PLOT_SURFACE_TRAVELTIMES;
		  break;
	    case 4:
		  if (wfs==WIRED)
			wfs=SOLID;
		  else
	      		wfs=WIRED;		  
		  break;
	    case 5:
		  if (glb_plot_wf==DO_NOT_PLOT_WF)
			glb_plot_wf=PLOT_WF;
		  else
			glb_plot_wf=DO_NOT_PLOT_WF;
		  break;
	    case 6:
d1223 1
a1223 1
			hlt=TRI;
d1235 2
a1236 2
			glb_on_or_off[value-7]=ON;
		  break;	
d1291 1
a1291 1
	    emission[1]=0.0;
d1293 1
a1293 1
	    emission[1]=MAX(0.0,MIN(1.0,(t-tmin)/(tmax-tmin)));
@


1.6
log
@pre 14 November 1997 version
@
text
@d6 1
a6 1
#include "viewer3.h"
d11 2
a12 1
" VIEWER3 - VIEWER for 3-dimensional model				", 
d14 1
a14 1
" viewer3 [parameters] < hzfile		 				",
d24 1
a24 1
" sttfile=NULL  surface traveltime file to read in                      ",
d26 20
a45 1
" Remarks:								",
d47 1
a47 5
" In general, the tetrahedra model should be generated by tmb		",
" (tetrahedra modle builder) which outputs a file called hzfile, so 	",
" that viewer3 can read in from stdin.                                  ",
"                                                                       ",
" If, besides, you have 3D ray path information (rayfile), wavefronts   ",
d49 13
a61 3
" sutetrawfray (tetrahedral wavefront construction ray tracing),        ",
" the rays, wavefronts and surface traveltimes can be displayed as well ",
" as the model.                                                         ",NULL};
d97 1
a97 1
      int is,ns;        /*number of sources*/
d133 1
a133 1
      if (!getparint("verbose",&verbose)) 	verbose=0;
d149 2
a150 2
            fprintf(stderr,"xmin=%f\nxmax=%f\nymin=%f\nymax=%f\nzmin=%f\nzmax=%f\n",
	          xmin,xmax,ymin,ymax,zmin,zmax);
d164 2
a165 2
      if (!getparfloat("tbs",&tbs)) 	tbs=0.8;
      if (!getparint("hue",&glb_hue))	glb_hue=1; /*1 for glb_hue*/
d180 1
a180 1
      glutInitWindowSize(512, 512);
d226 4
a229 4
            40.0,   /*fovy: view angle in y direction*/
            1.0,    /*aspect: ratio of width (x) to y (height)*/
            eyez-DIAMETER,  /*near clipping plane*/
            eyez+DIAMETER); /*far clipping plane*/
d233 3
a235 3
            0.0, 0.0, eyez, /*(eyex,eyey,eyez): the eye position*/
            0.0, 0.0, 0.0,  /*(centerx,centery,centerz): the center*/
            0.0, 1.0, 0.0); /*(upx,upy,upz): the up direction*/
d240 1
a240 1
            fprintf(stderr,"reading horizon information %d\n",ihz);
d250 1
a250 1
            fprintf(stderr,"read horz[%d].x...\n",ihz);
d254 2
a255 2
           
            fprintf(stderr,"read horz[%d].y...\n",ihz);
d276 2
a277 2
	          for (ix=0;ix<nx;ix++) {
		        vmin=MIN(vmin,horz[ihz].v0[iy][ix]);
d279 1
a279 1
		        vmin=MIN(vmin,horz[ihz].v1[iy][ix]);
d338 1
a338 1
                                
d356 1
a356 1
      The ray positions are generated by sutetrawfray, named by rayfile. 
d361 8
a368 8
            fscanf(rayfp,
                 "%d =Number of shots\n",&ns);
            fprintf(stderr,"ns=%d\n",ns);

            if (ns<=0 || ns>100) {
                 ns=0;
                 rayfp=NULL;
            }
d370 1
a370 1
            ray=(Layer *)alloc1float(sizeof(Layer)*ns);
d373 7
a379 7
            for (is=0;is<ns;is++) {
                  fscanf(rayfp,
                        "%d =Maximum number of segments\n",&nt);

                  fprintf(stderr,"%d =Maximum number of segments\n",nt);
                  fscanf(rayfp,
                        "%d =Number of rays\n",&ray[is].nrays);
d382 4
a385 4
	          ray[is].x=ealloc2float(ray[is].nrays,nt);
	          ray[is].y=ealloc2float(ray[is].nrays,nt);
	          ray[is].z=ealloc2float(ray[is].nrays,nt);
                  ray[is].v0=ealloc2float(ray[is].nrays,nt);
d388 2
a389 2
                  for (iray=0;iray<ray[is].nrays;iray++) {
                        fscanf(rayfp,"%d=nseg %f=ttotal\n",&ray[is].nseg[iray],&tt);
d391 6
a396 6
                        if (nt<ray[is].nseg[iray]) err("nt should >=ray[is].nseg[iray]");
                        for (it=0;it<ray[is].nseg[iray];it++) {
                              fscanf(rayfp,"%f %f %f %f %f\n",
                                    &ray[is].x[it][iray],
                                    &ray[is].y[it][iray],
                                    &ray[is].z[it][iray],
d399 3
a401 3
                        }
                        
                        ray[is].z[ray[is].nseg[iray]-1][iray]=
d403 2
a404 2
           
	                for (it=0;it<ray[is].nseg[iray];it++) {
d406 1
a406 1
		       	            (xmax-xmin)-0.5)*DIAMETER;
d408 1
a408 1
		       	            (ymax-ymin)-0.5)*DIAMETER;
d410 4
a413 4
		       	            (zmax-zmin)-0.5)*DIAMETER;
	                }
                  }
            }
d416 33
a448 33
            /*white rays*/
            glNewList(nhz*4+3,GL_COMPILE);
            emission[0]=emission[1]=emission[2]=emission[3]=1.0;
            glMaterialfv(GL_FRONT_AND_BACK,GL_EMISSION,emission);
            for (is=0;is<ns;is++) {
                  for (iray=0;iray<ray[is].nrays;iray++) {
                        iflag=0;
	                glBegin(GL_LINE_STRIP);
	                for (it=0;it<ray[is].nseg[iray];it++) {
		              if (fabs(ray[is].x[it][iray])<RADIUS &&
		                  fabs(ray[is].y[it][iray])<RADIUS &&
		                  fabs(ray[is].z[it][iray])<RADIUS) {
			            glVertex3f(ray[is].x[it][iray],ray[is].y[it][iray],
			                  ray[is].z[it][iray]);

                                    iflag=1;
		              } else if (iflag) break; /*once good, now bad*/    
	                }
	                glEnd();
                  }
            }
            glEndList();

            /*colored rays*/
            glNewList(nhz*4+4,GL_COMPILE);
            for (is=0;is<ns;is++) {
                  for (iray=0;iray<ray[is].nrays;iray++) {
                        iflag=0;
	                glBegin(GL_LINE_STRIP);
	                for (it=0;it<ray[is].nseg[iray];it++) {
		              if (fabs(ray[is].x[it][iray])<RADIUS &&
		                  fabs(ray[is].y[it][iray])<RADIUS &&
		                  fabs(ray[is].z[it][iray])<RADIUS) {
d459 8
a466 8
			                  ray[is].z[it][iray]);
                                    iflag=1;
		              } else if (iflag) break; /*once good, now bad*/    
	                }
	                glEnd();
                  }
            }
            glEndList();
d475 3
a477 3
            fscanf(wffp,"%d = nwf2dump\n",&nwf);
            fprintf(stderr,"nwf2dump=%d\n",nwf);
            if (nwf>200) wffp=NULL;
d483 1
a483 1
            emission[1]=1.0; 
d488 1
a488 1
            ntris=ealloc1int(sizeof(int)*nwf);
d492 4
a495 4
	          if (1!=fscanf(wffp,"%d = ntris\n",&ntris[iwf])) {
		        nwf=iwf;
                        break;
	          }
d498 3
a500 3
                        nwf=iwf;
                        break;
	          }
d510 4
a513 4
                        fscanf(wffp,"%f %f %f %f %f %f %f %f %f\n",
                              wf[iwf].x[it],  wf[iwf].y[it],  wf[iwf].z[it],
                              wf[iwf].x[it]+1,wf[iwf].y[it]+1,wf[iwf].z[it]+1,
                              wf[iwf].x[it]+2,wf[iwf].y[it]+2,wf[iwf].z[it]+2);
d527 1
a527 1
       	          }
d531 4
d539 12
a550 12
	          for (itri=0;itri<ntris[iwf];itri++) {
		        glBegin(GL_LINE_LOOP);
		        if (fabs(wf[iwf].x[itri][0])<RADIUS &&
		            fabs(wf[iwf].y[itri][0])<RADIUS &&
		            fabs(wf[iwf].z[itri][0])<RADIUS && 
		            fabs(wf[iwf].x[itri][1])<RADIUS &&
		            fabs(wf[iwf].y[itri][1])<RADIUS &&
		            fabs(wf[iwf].z[itri][1])<RADIUS &&
                            fabs(wf[iwf].x[itri][2])<RADIUS &&
                            fabs(wf[iwf].y[itri][2])<RADIUS &&
                            fabs(wf[iwf].z[itri][2])<RADIUS) {
			          glVertex3f(wf[iwf].x[itri][0],
d553 1
a553 1
			          glVertex3f(wf[iwf].x[itri][1],
d556 1
a556 1
			          glVertex3f(wf[iwf].x[itri][2],
d559 9
a567 9
		        } else {
                            fprintf(stderr,"warning: some triangles ignored\n");
                            glEnd;
                            break;
                        }                        
		        glEnd();
	          }
            }
            glEndList();
d569 1
a569 1
            /*solid wavefronts*/
d574 12
a585 12
	          for (itri=0;itri<ntris[iwf];itri++) {
		        glBegin(GL_TRIANGLE_STRIP);
		        if (fabs(wf[iwf].x[itri][0])<RADIUS &&
		            fabs(wf[iwf].y[itri][0])<RADIUS &&
		            fabs(wf[iwf].z[itri][0])<RADIUS && 
		            fabs(wf[iwf].x[itri][1])<RADIUS &&
		            fabs(wf[iwf].y[itri][1])<RADIUS &&
		            fabs(wf[iwf].z[itri][1])<RADIUS &&
                            fabs(wf[iwf].x[itri][2])<RADIUS &&
                            fabs(wf[iwf].y[itri][2])<RADIUS &&
                            fabs(wf[iwf].z[itri][2])<RADIUS) {
			          glVertex3f(wf[iwf].x[itri][0],
d588 1
a588 1
			          glVertex3f(wf[iwf].x[itri][1],
d591 1
a591 1
			          glVertex3f(wf[iwf].x[itri][2],
d594 9
a602 9
		        } else {
                            fprintf(stderr,"warning: some triangles ignored\n");
                            glEnd;
                            break;
                        }                        
		        glEnd();
	          }
            }
            glEndList();
d607 3
a609 3
            fscanf(sttfp,"%d = ntris\n",&ntr);
            fprintf(stderr,"ntr=%d\n",ntr);
            if (ntr>2000) sttfp=NULL;
d613 2
a614 2
            stt=ealloc3float(3,3,ntr);
            ttt=ealloc2float(3,ntr);
d616 2
a617 2
            tmax=0.0;
            tmin=1.0e+10;
d619 1
a619 1
	          fscanf(sttfp,"%f %f %f %f %f %f %f %f %f %f %f %f\n",
d633 1
a633 1
                  tmax=MAX(tmax,ttt[itri][0]);
d637 1
a637 1
                  tmin=MIN(tmin,ttt[itri][0]);
d661 1
a661 1
            }
d670 1
a670 1
            tEmission(ttt[itri][0],tmin,tmax,emission);
d690 3
d694 3
a696 1
showHorz(int ihz,float ***data,
d798 6
a803 6
         (ix,iy+2)_____(ix+1,iy+2)
                 |    /|
                 |   / |
	         |  /  |
                 | /   |
                 |/    |
d818 1
a818 1
            }
d823 1
a823 1
	          glMaterialfv(GL_FRONT_AND_BACK,GL_EMISSION,emisbot[iy][ix]);
d827 1
a827 1
            }
d832 1
a832 1
	          glMaterialfv(GL_FRONT_AND_BACK,GL_EMISSION,emisbot[iy+1][ix]);
d837 1
a837 1
        
d853 1
a853 1
            }
d858 1
a858 1
	          glMaterialfv(GL_FRONT_AND_BACK,GL_EMISSION,emistop[iy][ix]);
d862 1
a862 1
            }
d867 1
a867 1
	          glMaterialfv(GL_FRONT_AND_BACK,GL_EMISSION,emistop[iy+1][ix]);
d872 1
a872 1
        
d890 1
a890 1
            }
d968 6
a973 6
         (ix,iy+2)_____(ix+1,iy+2)
                 |    /|
                 |   / |
	         |  /  |
                 | /   |
                 |/    |
d988 1
a988 1
            }
d993 1
a993 1
	          glMaterialfv(GL_FRONT_AND_BACK,GL_EMISSION,emis[iy][ix]);
d997 1
a997 1
            }
d1002 1
a1002 1
	          glMaterialfv(GL_FRONT_AND_BACK,GL_EMISSION,emis[iy][ix]);
d1007 1
a1007 1
        
d1077 1
a1077 1
	          glCallList(nhz*4+3);
d1079 1
a1079 1
	          glCallList(nhz*4+4);
d1083 1
a1083 1
            glCallList(nhz*4+5);
d1087 1
a1087 1
                  glCallList(nhz*4+6);
d1089 1
a1089 1
	          glCallList(nhz*4+7);
d1170 1
a1170 1
            #endif
d1192 7
a1198 7
            case 1:
                  if (wc_rays==WHITE)
                        wc_rays=COLORED;
                  else
                        wc_rays=WHITE;
                  break;
            case 2:
a1202 6
                  break;
            case 3:
                  if (plot_st==DO_NOT_PLOT_SURFACE_TRAVELTIMES)
		        plot_st=PLOT_SURFACE_TRAVELTIMES;
                  else 
		        plot_st=DO_NOT_PLOT_SURFACE_TRAVELTIMES;
d1204 19
a1222 13
            case 4:
                  if (wfs==WIRED)
                        wfs=SOLID;
                  else
	      	        wfs=WIRED;                  
                  break;
            case 5:
                  if (glb_plot_wf==DO_NOT_PLOT_WF)
                        glb_plot_wf=PLOT_WF;
                  else
                        glb_plot_wf=DO_NOT_PLOT_WF;
                  break;
            case 6:
d1224 1
a1224 1
		        hlt=TRI;
d1236 2
a1237 2
		        glb_on_or_off[value-7]=ON;
	          break;	
d1258 4
a1261 2
/************************************************
Set up the color mapping: velocity->color
d1271 1
a1271 1
	    emission[0]=0.5;
d1273 1
a1273 1
	    emission[2]=0.5;
d1282 3
a1284 1
/************************************************
d1286 1
a1286 1
************************************************/
d1292 1
a1292 1
            emission[1]=0.0;
d1294 3
a1296 3
            emission[1]=MAX(0.0,MIN(1.0,(t-tmin)/(tmax-tmin)));
      emission[0]=0.0;
      emission[2]=1.0;
@


1.5
log
@changed include from GL to MGL
@
text
@d1 1
a1 1
/* VIEWER3: $Revision: 1.4 $ ; $Date: 1997/05/16 20:15:59 $	*/
d6 1
a6 1
#include "MGL/viewer3.h"
d16 1
d23 1
a23 1
" dvdzhzfile=NULL dvdz file						",
d29 7
a35 9
" that viewer3 can read in from stdin. hzfile contains nhz, nxhz, nyhz, ",
" nzgd, and for each horizon: xhz, yhz, zhz, vhz.			",
"									",
" If, besides, you have 3D ray path information named rayfile, typically",
" generated by suwfrayt3d (wavefront construction ray tracing for 3D), 	",
" then the rays can be displayed too. The ray data structure: source    ",
" (xs,ys,zs) followed by nrays rays (the order does not matter), each 	",
" ray is defined by a sequence of intersection positions (x,y,z) of the ",
" ray and horizon 1, horizon 2, ..., horizon (nhz-1).			",NULL}; 
a41 64
#define DIAMETER 10 
#define RADIUS (DIAMETER*0.5)
#define EPS 0.000001

GLfloat angle=-150; 	/* in degrees */
GLint glb_spinning=0; 	/*flag: set when glb_spinning*/
GLint glb_moving=0;	/*flag: set when glb_moving*/
GLint glb_beginx; 	/*the last point (glb_beginx,glb_beginy)*/
GLint glb_beginy;
GLint glb_W=60;		/*window width in pixels*/ 
GLint glb_H=60;		/*window height in pixels*/
GLint glb_newmodel=1;	/*flag: set when the model is updated*/
GLint glb_scaling;	/*flag: set when glb_scaling*/
GLfloat glb_scalefactor=1.0;
GLfloat glb_alpha=1;
GLint glb_hue;
GLfloat tbs;

GLfloat curquat[4];       /*current quaternion*/
GLfloat lastquat[4];      /*last quaternion*/

static void normalize_quat(float q[4])
{
	int i;
	float mag;

	mag = (q[0]*q[0] + q[1]*q[1] + q[2]*q[2] + q[3]*q[3]);
	for (i = 0; i < 4; i++) q[i] /= mag;
}

enum H_L_T{HORZ,TRI,TETRA,LAYER};
enum H_L_T hlt=TRI;
enum On_or_Off{OFF,ON};
enum On_or_Off *glb_on_or_off;
enum Plot_Rays{DO_NOT_PLOT_RAYS,PLOT_RAYS};
enum Plot_Wf{DO_NOT_PLOT_WF,PLOT_WF};
enum Plot_Rays glb_plot_rays=DO_NOT_PLOT_RAYS;
enum Plot_Wf glb_plot_wf=DO_NOT_PLOT_WF;

/*number of interfaces except the surface*/
int nhz;

void showHorz(int ihz,float ***data0, int nx,int ny,
	float ***emis);
void showLayer(int ihz,float ***data0,float ***data1,
	int nx,int ny,float ***emis0,float ***emis1);
void showRay(int list,float **rixs,float **riys,float **rizs,
	float xs,float ys,float zs,int nrays,int nt);
void showWf(int list,float **wfx,float **wfy,float **wfz,int ntris);
void showTetra(int ihz,float ***data0,float ***data1,
	int nxhz,int nyhz,float ***emis0,float ***emis1);
void showTri(int ihz,float ***data,int nxhz,int nyhz,float ***emis);
void recalcModelView(void);
void recalcModelView(void);
void showMessage(GLfloat x, GLfloat y, GLfloat z, char *message);
void redraw();
void myReshape(int w, int h);
void mouse(int button, int state, int x, int y);
void animate(void);
void motion(int x,int y);
void controlLights(int value);
void vis(int visible);
void zmEmission(float v,float vmin,float vmax,float *emission);

d45 450
a494 365
	int ixhz;	/*index for nxhz*/
	int iyhz;	/*index for nyhz*/
	int nxhz;	/*number of sampels in horizon*/
	int nyhz;	/*number of sampels in horizon*/
	int nxhzc;	/*number of samples -1*/
	int nyhzc;	/*number of sampels -1*/

	float xs,ys,zs;	/*the source position*/

	float xmin,xmax;
	float ymin,ymax;
	float zmin,zmax;

	int nzgd;	/*zmax = nzgd*/

	float ***data0;	/*data for plotting*/
	float ***data1;
	float ***emis0; /*color on top horizon*/
	float ***emis1; /*color right above base horizon*/
	float ***emis2; /*color on base horizon*/
	float v0;

	float **rixs;	/*ray information: x*/
	float **riys;	/*ray information: y*/
	float **rizs;  /*ray information: z*/

	float **wfx;
	float **wfy;
	float **wfz;

	int verbose;    /*if =1 print some useful information*/

	float eyez;

	int ihz;	/*index for interfaces*/

	int nrays;	/*number of rays*/
	int ntris;	/*number of triangles*/
	int nt;		/*number of samples in each ray*/
	int iray; 	/*index for nrays*/
	int it;		/*index for nt*/
	int iwf;

	float q0[4];

	char *rayfile=""; /*ray file*/
	char *wffile="";
	char *dvdzhzfile="";

	FILE *hzfp=stdin; 
	FILE *rayfp=NULL;
	FILE *wffp=NULL;
	FILE *dvdzhzfp=NULL;

	Horizon *horz;
	float vmin=0.3;
	float vmax=5.0;

	char names[10];

	/* hook up getpar */
	initargs(argc,argv);
	requestdoc(1);

	/* get parameters */
	if (!getparint("verbose",&verbose)) 	verbose=0;

	/***************************************************
	Read in model parameters from file hzfile
	***************************************************/
	if (fread(&nhz,sizeof(int),1,hzfp)!=1) 
		err("Can not read nhz");
	if (fread(&nxhz,sizeof(int),1,hzfp)!=1) 
		err("Can not read nxhz");
	if (fread(&nyhz,sizeof(int),1,hzfp)!=1) 
		err("Can not read nyhz");
	if (fread(&nzgd,sizeof(int),1,hzfp)!=1)
		err("Can not read nzgd");

	zmax=(float)nzgd;

	nxhzc=MAX(1,nxhz-1);
	nyhzc=MAX(1,nyhz-1);

	if (getparstring("rayfile",&rayfile))  
		if ((rayfp=fopen(rayfile,"r"))==NULL)
			err("Can not open rayfile %s",rayfile);

	if (getparstring("wffile",&wffile))
		if ((wffp=fopen(wffile,"r"))==NULL)
			err("Can not open wffile %s",wffile);

	if (getparstring("dvdzhzfile",&dvdzhzfile))
		if ((dvdzhzfp=fopen(dvdzhzfile,"r"))==NULL)
			err("Can not open dvdzhzfile %s",dvdzhzfile);

	if (!getparfloat("tbs",&tbs)) 	tbs=0.8;
	if (!getparint("hue",&glb_hue))	glb_hue=1; /*1 for glb_hue*/

	if (verbose) 
		warn("nhz=%d, nxhz=%d, nyhz=%d\n",nhz,nxhz,nyhz);

	glb_on_or_off=(enum On_or_Off *)ealloc1int(3*nhz+6);
	for (ihz=0;ihz<nhz;ihz++) glb_on_or_off[ihz]=ON;

	horz=(Horizon *)alloc1float(sizeof(Horizon)*(nhz+1));

	/*********************************************************
	Do not use GLUT_INDEX, which gives no image;
	GLUT_SINGLE will cause redrawing every time you retate it;
	*********************************************************/
	glutInit(&argc, argv);
	glutInitWindowSize(512, 512);
	glutInitDisplayMode(GLUT_RGBA | GLUT_DOUBLE | GLUT_DEPTH);
	glutCreateWindow("viewer3");
	glutDisplayFunc(redraw);
	glutIdleFunc(NULL);

	if (!getparfloat("q",q0)){
		q0[0]=-0.6; 
		q0[1]=0.05;
		q0[2]=-0.06;
		q0[3]=0.8;
	}

	normalize_quat(q0);

	curquat[0]=q0[0];
	curquat[1]=q0[1];
	curquat[2]=q0[2];
	curquat[3]=q0[3];

	glutReshapeFunc(myReshape);
	glutVisibilityFunc(vis);
	glutMouseFunc(mouse);
	glutMotionFunc(motion);
	glutCreateMenu(controlLights);
	glutAddMenuEntry("Full screen",1);
	glutAddMenuEntry("Quit", 2);
	glutAddMenuEntry("HORZ or TRI or TETRA or LAYER",3);
	for (ihz=0;ihz<nhz;ihz++) {
		sprintf(names,"Layer %d",ihz+1);
		glutAddMenuEntry(names,ihz+4);
	}
	glutAddMenuEntry("Plot Rays",nhz+4);
	glutAddMenuEntry("Plot Wf",nhz+5);
	glutAttachMenu(GLUT_RIGHT_BUTTON);

	glShadeModel(GL_SMOOTH);
	glEnable(GL_DEPTH_TEST);
	glEnable(GL_LIGHTING);

	eyez=25;
	glMatrixMode(GL_PROJECTION);
        gluPerspective(
                40.0,   /*fovy: view angle in y direction*/
                1.0,    /*aspect: ratio of width (x) to y (height)*/
                eyez-DIAMETER,  /*near clipping plane*/
                eyez+DIAMETER); /*far clipping plane*/

        glMatrixMode(GL_MODELVIEW);
        gluLookAt(
                0.0, 0.0, eyez, /*(eyex,eyey,eyez): the eye position*/
                0.0, 0.0, 0.0,  /*(centerx,centery,centerz): the center*/
                0.0, 1.0, 0.0); /*(upx,upy,upz): the up direction*/
        glPushMatrix();


	for (ihz=0;ihz<nhz;ihz++) {
		/**********************************************************
		input the horizon information from file hzfile:
		**********************************************************/
		horz[ihz].xhz=alloc2float(nxhz,nyhz);
		horz[ihz].yhz=alloc2float(nxhz,nyhz);
		horz[ihz].zhz=alloc2float(nxhz,nyhz);
		horz[ihz].vhz=alloc2float(nxhzc,nyhzc);
		horz[ihz].dvdzhz=alloc2float(nxhzc,nyhzc);
		horz[ihz].n1llhz=alloc2float(nxhzc,nyhzc);
		horz[ihz].n1urhz=alloc2float(nxhzc,nyhzc);
		horz[ihz].n2llhz=alloc2float(nxhzc,nyhzc);
		horz[ihz].n2urhz=alloc2float(nxhzc,nyhzc);
		horz[ihz].n3llhz=alloc2float(nxhzc,nyhzc);
		horz[ihz].n3urhz=alloc2float(nxhzc,nyhzc);
		if (fread(horz[ihz].xhz[0],sizeof(float),nxhz*nyhz,
			hzfp)!=nxhz*nyhz)
			err("Can not read xhz to hzfp");
		if (fread(horz[ihz].yhz[0],sizeof(float),nxhz*nyhz,
			hzfp)!=nxhz*nyhz)
			err("Can not read yhz to hzfp");
		if (fread(horz[ihz].zhz[0],sizeof(float),nxhz*nyhz,
			hzfp)!=nxhz*nyhz)
			err("Can not read zhz to hzfp");

		if (fread(horz[ihz].vhz[0],sizeof(float),nxhzc*nyhzc,hzfp)!=
			nxhzc*nyhzc)
			err("Can not read vhz to hzfp");

		if (dvdzhzfp!=NULL) {
		if (fread(horz[ihz].dvdzhz[0],sizeof(float),nxhzc*nyhzc,hzfp)!=
			nxhzc*nyhzc)
			err("Can not read dvdzhz to hzfp");
		} else 
			memset((void *)horz[ihz].dvdzhz[0],(int)'\0',
				nxhzc*nyhzc*sizeof(float));

	}

	horz[nhz].xhz=alloc2float(nxhz,nyhz);
	horz[nhz].yhz=alloc2float(nxhz,nyhz);
	horz[nhz].zhz=alloc2float(nxhz,nyhz);

	for (ixhz=0;ixhz<nxhz;ixhz++) {
		for (iyhz=0;iyhz<nyhz;iyhz++) {
			horz[nhz].xhz[iyhz][ixhz]=horz[nhz-1].xhz[iyhz][ixhz];
			horz[nhz].yhz[iyhz][ixhz]=horz[nhz-1].yhz[iyhz][ixhz];
			horz[nhz].zhz[iyhz][ixhz]=zmax;
		}
	}

	xmin=horz[0].xhz[0][0];
	xmax=horz[0].xhz[0][nxhz-1];
	ymin=horz[0].yhz[0][0];
	ymax=horz[0].yhz[nyhz-1][0];
	zmin=horz[0].zhz[0][0];
	fprintf(stderr,"xmin=%e\nxmax=%e\nymin=%e\nymax=%e\nzmin=%e\nzmax=%e\n",
		xmin,xmax,ymin,ymax,zmin,zmax);

	for (ihz=0;ihz<nhz;ihz++) {
		data0=ealloc3float(3,nyhz,nxhz);
		emis0=ealloc3float(4,nyhz,nxhz);
		data1=ealloc3float(3,nyhz,nxhz);
		emis1=ealloc3float(4,nyhz,nxhz);
		emis2=ealloc3float(4,nyhz,nxhz);
		for (ixhz=0;ixhz<nxhz;ixhz++) {
			for (iyhz=0;iyhz<nyhz;iyhz++) {
				data1[ixhz][iyhz][0]=(
					(horz[ihz].xhz[iyhz][ixhz]-xmin)/
					(xmax-xmin)-0.5)*DIAMETER;
				data1[ixhz][iyhz][1]=(
					(horz[ihz].yhz[iyhz][ixhz]-ymin)/
					(ymax-ymin)-0.5)*DIAMETER;
				data1[ixhz][iyhz][2]=(
					(horz[ihz].zhz[iyhz][ixhz]-zmin)/
					(zmax-zmin)-0.5)*DIAMETER;
				v0=horz[ihz].vhz[MIN(iyhz,nyhzc-1)]
					      [MIN(ixhz,nxhzc-1)];
				zmEmission(v0,vmin,vmax,emis1[iyhz][ixhz]);
			}
		}
		for (ixhz=0;ixhz<nxhz;ixhz++) {
			for (iyhz=0;iyhz<nyhz;iyhz++) {
				data0[ixhz][iyhz][0]=(
				(horz[ihz+1].xhz[iyhz][ixhz]-xmin)
					/(xmax-xmin)-0.5)*DIAMETER;
				data0[ixhz][iyhz][1]=(
					(horz[ihz+1].yhz[iyhz][ixhz]-ymin)
					/(ymax-ymin)-0.5)*DIAMETER;	
				data0[ixhz][iyhz][2]=(
					(horz[ihz+1].zhz[iyhz][ixhz]-zmin)
					/(zmax-zmin)-0.5)*DIAMETER;
				v0=horz[ihz].vhz[MIN(iyhz,nyhzc-1)]
					[MIN(ixhz,nxhzc-1)]+
					(horz[ihz+1].zhz[iyhz][ixhz]
					-horz[ihz].zhz[iyhz][ixhz])*
					horz[ihz].dvdzhz[MIN(iyhz,nyhzc-1)]
					[MIN(ixhz,nxhzc-1)];
				zmEmission(v0,vmin,vmax,emis0[iyhz][ixhz]);
				if (ihz<nhz-1) 
					v0=horz[ihz+1].vhz[MIN(iyhz,nyhzc-1)]
						[MIN(ixhz,nxhzc-1)];
				zmEmission(v0,vmin,vmax,emis2[iyhz][ixhz]);
			}
		}

		showLayer(ihz,data0,data1,nxhz,nyhz,emis0,emis1);
		showHorz(ihz,data1,nxhz,nyhz,emis0);
		showTetra(ihz,data0,data1,nxhz,nyhz,emis2,emis1);
		showTri(ihz,data1,nxhz,nyhz,emis1);
		free3float(data0);
		free3float(data1);
		free3float(emis0);
		free3float(emis1);
	}

	/*******************************************************************
	The ray positions are generated by rayt3d, named by rayfile. The data
	structure is: source position: (xs,ys,zs) followed by (nhz-1)*nrays
	ray positions (triple coordinates).

	This part will be ignored if rayfile not specified.
	********************************************************************/
	if (rayfp!=NULL) {
		fread(&nt,sizeof(int),1,rayfp);
		fread(&nrays,sizeof(int),1,rayfp);
		fread(&xs,sizeof(float),1,rayfp);
		fread(&ys,sizeof(float),1,rayfp);
		fread(&zs,sizeof(float),1,rayfp);

		if (verbose)
			warn("nt=%d,nrays=%d,xs,ys,zs=%e %e %e\n",
				nt,nrays,xs,ys,zs);

		nt--;

		rixs=ealloc2float(nrays,nt);
		riys=ealloc2float(nrays,nt);
		rizs=ealloc2float(nrays,nt);
		
		for (it=0;it<nt;it++) {
			if (fread(rixs[it],sizeof(float),nrays,rayfp)!=nrays)
				err("Can not read in wavefront %d x\n",it);
			if (fread(riys[it],sizeof(float),nrays,rayfp)!=nrays)
				err("Can not read in wavefront %d y\n",it);
			if (fread(rizs[it],sizeof(float),nrays,rayfp)!=nrays)
				err("Can not read in wavefront %d z\n",it);

		}
		fprintf(stderr,"Totally read in %d samples for rays\n",nt);
		fclose(rayfp);

		xs=((xs-xmin)/(xmax-xmin)-0.5)*DIAMETER;
		ys=((ys-ymin)/(ymax-ymin)-0.5)*DIAMETER;
		zs=((zs-zmin)/(zmax-zmin)-0.5)*DIAMETER;
		for (it=0;it<nt;it++) {
			for (iray=0;iray<nrays;iray++) {
				rixs[it][iray]=((rixs[it][iray]-xmin)/
					(xmax-xmin)-0.5)*DIAMETER;
				riys[it][iray]=((riys[it][iray]-ymin)/
					(ymax-ymin)-0.5)*DIAMETER;
				rizs[it][iray]=((rizs[it][iray]-zmin)/
					(zmax-zmin)-0.5)*DIAMETER;
			}
		}

		showRay(nhz*4+3,rixs,riys,rizs,xs,ys,zs,nrays,nt);
	}

	/*************************************************************
	Plot the wavefront if it is given
	*************************************************************/
	if (wffp!=NULL) {
		fread(&ntris,sizeof(int),1,wffp);

		if (verbose)
			warn("ntris=%d\n",ntris);

		wfx=ealloc2float(3,ntris);
		wfy=ealloc2float(3,ntris);
		wfz=ealloc2float(3,ntris);

		for (it=0;it<ntris;it++) {
			for (iwf=0;iwf<3;iwf++) {
				fread(wfx[it]+iwf,sizeof(float),1,wffp);
				fread(wfy[it]+iwf,sizeof(float),1,wffp);
				fread(wfz[it]+iwf,sizeof(float),1,wffp);
			}
		}

		fprintf(stderr,"Totally read in %d wavefront triangles\n",ntris);

		fclose(wffp);

		for (it=0;it<ntris;it++) {
			for (iwf=0;iwf<3;iwf++) {
				wfx[it][iwf]=((wfx[it][iwf]-xmin)/
d496 1
a496 1
				wfy[it][iwf]=((wfy[it][iwf]-ymin)/
d498 1
a498 1
				wfz[it][iwf]=((wfz[it][iwf]-zmin)/
d501 154
a654 1
		}
d656 2
a657 6
		showWf(nhz*4+4,wfx,wfy,wfz,ntris);
	}


	glutMainLoop();
	return 0;
d662 1
a662 1
	int nx,int ny,float ***emis)
d664 2
a665 31
	int ix,iy;
	int nxhalf;

	nxhalf=nx/2;

	glNewList(ihz+nhz+3,GL_COMPILE);
	glBegin(GL_QUAD_STRIP);
	for (ix=0;ix<nx-2;ix++) {
		for (iy=0;iy<ny;iy++) {
			glMaterialfv(GL_FRONT,GL_EMISSION,emis[iy][ix]);
			glVertex3fv(data[ix][iy]);
			glVertex3fv(data[ix+1][iy]);
		}
		for (iy=ny-1;iy>=0;iy--) {
			glMaterialfv(GL_FRONT,GL_EMISSION,emis[iy][ix]);
			glVertex3fv(data[ix+1][iy]);
			glVertex3fv(data[ix+2][iy]);
		}
	}

	if (nxhalf*2!=nx) {
		for (iy=0;iy<ny;iy++) {
			glMaterialfv(GL_FRONT,GL_EMISSION,emis[iy][ix]);
			glVertex3fv(data[nx-2][iy]);
			glVertex3fv(data[nx-1][iy]);
		}
	}
	glEnd();
	glEndList();
}

d667 1
a667 36
void
showRay(int list,float **rixs,float **riys,float **rizs,
	float xs,float ys,float zs,int nrays,int nt)
{
	int iray;
	int it;
	int iflag;	/*flag: =1 means ray effective*/
	float emission[4];

	emission[0]=emission[1]=emission[2]=emission[3]=1.0;	

	glNewList(list,GL_COMPILE);
	glMaterialfv(GL_FRONT,GL_EMISSION,emission); 
	for (iray=0;iray<nrays;iray++) {
		glBegin(GL_LINE_STRIP);
		if (fabs(rixs[0][iray])<RADIUS &&
		    fabs(riys[0][iray])<RADIUS &&
		    fabs(rizs[0][iray])<RADIUS) {
			glVertex3f(xs,ys,zs);
			iflag=1;
		} else iflag=0;
		for (it=0;it<nt;it++) {
			if (fabs(rixs[it][iray])<RADIUS &&
			    fabs(riys[it][iray])<RADIUS &&
			    fabs(rizs[it][iray])<RADIUS) {
				glVertex3f(rixs[it][iray],riys[it][iray],
					   rizs[it][iray]);

				iflag=1;

			} else if (iflag) break;
		}
		glEnd();
	}
	glEndList();
}
d669 17
a685 4
void showWf(int list,float **wfx,float **wfy,float **wfz,int ntris)
{
	int itri;
	float emission[4];
d687 2
a688 26
	emission[0]=emission[1]=1.0; 
	emission[2]=0.0;
	emission[3]=1.0;

	glNewList(list,GL_COMPILE);
	glMaterialfv(GL_FRONT,GL_EMISSION,emission);

	for (itri=0;itri<ntris;itri++) {
		glBegin(GL_LINE_LOOP);
		if (fabs(wfx[itri][0])<RADIUS &&
		    fabs(wfy[itri][0])<RADIUS &&
		    fabs(wfz[itri][0])<RADIUS && 
		    fabs(wfx[itri][1])<RADIUS &&
		    fabs(wfy[itri][1])<RADIUS &&
		    fabs(wfz[itri][1])<RADIUS &&
                    fabs(wfx[itri][2])<RADIUS &&
                    fabs(wfy[itri][2])<RADIUS &&
                    fabs(wfz[itri][2])<RADIUS) {
			glVertex3f(wfx[itri][0],wfy[itri][0],wfz[itri][0]);
			glVertex3f(wfx[itri][1],wfy[itri][1],wfz[itri][1]);
			glVertex3f(wfx[itri][2],wfy[itri][2],wfz[itri][2]);
		} else
fprintf(stderr,"warning: some tri ignored\n");
		glEnd();
	}
	glEndList();
d692 2
a693 2
showLayer(int ihz,float ***data0,float ***data1,
	int nxhz,int nyhz,float ***emis0,float ***emis1) 
d695 1
a695 1
	int ix,iy;
d697 53
a749 54
	glNewList(ihz+3,GL_COMPILE);
	glBegin(GL_QUAD_STRIP);
	for (ix=0;ix<nxhz-1;ix++) {
		for (iy=0;iy<nyhz;iy++) {
			if (data0[ix][iy][2]<EPS+data1[ix][iy][2] &&
			    data0[ix+1][iy][2]<EPS+data1[ix+1][iy][2]) continue; 
			glMaterialfv(GL_FRONT,GL_EMISSION,emis0[iy][ix]);
			glVertex3fv(data0[ix][iy]);
			glVertex3fv(data0[ix+1][iy]);
		}
		for (iy=nyhz-1;iy>=0;iy--) {
			if (data0[ix][iy][2]<EPS+data1[ix][iy][2] &&
			    data0[ix+1][iy][2]<EPS+data1[ix+1][iy][2]) continue; 
			glMaterialfv(GL_FRONT,GL_EMISSION,emis1[iy][ix]);
			glVertex3fv(data1[ix][iy]);
			glVertex3fv(data1[ix+1][iy]);
		}
		glVertex3fv(data0[ix][0]);
		glVertex3fv(data0[ix+1][0]);
	}

	for (iy=0;iy<nyhz;iy++) {
		if (data0[nxhz-1][iy][2]<EPS+data1[nxhz-1][iy][2]) continue;
		if (iy!=nyhz-1) 
			glMaterialfv(GL_FRONT,GL_EMISSION,emis0[iy][nxhz-2]);
		glVertex3fv(data0[nxhz-1][iy]);
		glMaterialfv(GL_FRONT,GL_EMISSION,emis1[iy][nxhz-1]);
		glVertex3fv(data1[nxhz-1][iy]);
	}
	for (ix=nxhz-2;ix>=1;ix--) {
		if (data0[ix][nyhz-2][2]<EPS+data1[ix][nyhz-2][2]) continue;
		glMaterialfv(GL_FRONT,GL_EMISSION,emis0[nyhz-2][ix]);
		glVertex3fv(data0[ix][nyhz-1]);
		glMaterialfv(GL_FRONT,GL_EMISSION,emis1[nyhz-2][ix]);
		glVertex3fv(data1[ix][nyhz-1]);
	}

	for (iy=nyhz-1;iy>=0;iy--) {
		if (data0[0][iy][2]<EPS+data1[0][iy][2]) continue;
		glMaterialfv(GL_FRONT,GL_EMISSION,emis0[0][iy]);
		glVertex3fv(data0[0][iy]);
		glMaterialfv(GL_FRONT,GL_EMISSION,emis1[0][iy]);
		glVertex3fv(data1[0][iy]);
	}

	for (ix=1;ix<nxhz;ix++) {
		if (data0[ix][0][2]<EPS+data1[ix][0][2]) continue;
		glMaterialfv(GL_FRONT,GL_EMISSION,emis0[ix][0]);
		glVertex3fv(data0[ix][0]);
		glMaterialfv(GL_FRONT,GL_EMISSION,emis1[ix][0]);
		glVertex3fv(data1[ix][0]);
	}
	glEnd();
	glEndList();
d752 3
a754 3
void
showTetra(int ihz,float ***data0,float ***data1,
	int nxhz,int nyhz,float ***emis0,float ***emis1) 
d756 1
a756 1
	int ix,iy;
d758 158
a915 141
	glNewList(ihz+3+nhz*2,GL_COMPILE);
	glBegin(GL_LINES);
	/**********************************************************
	Plot the three segments for each top cell
	
	      (ix,iy+1)
		 |\
		 | \
		 |  \
		 |   \
		 |____\
	      (ix,iy) (ix+1,iy)

	**********************************************************/
	for (ix=0;ix<nxhz-1;ix++) {
		for (iy=0;iy<nyhz-1;iy++) {
			glMaterialfv(GL_FRONT,GL_EMISSION,emis0[ix][iy]);
			glVertex3fv(data0[ix][iy]);
			glVertex3fv(data0[ix+1][iy]);
			glVertex3fv(data0[ix][iy]);
			glVertex3fv(data0[ix][iy+1]);
			glVertex3fv(data0[ix][iy+1]);
			glVertex3fv(data0[ix+1][iy]);
		}
	}
	/**********************************************************
	Plot rear segments on top horizon
	**********************************************************/
	for (ix=0;ix<nxhz-1;ix++) {
		glMaterialfv(GL_FRONT,GL_EMISSION,emis0[ix][nyhz-1]);
		glVertex3fv(data0[ix][nyhz-1]);
		glVertex3fv(data0[ix+1][nyhz-1]);
	}
	/**********************************************************
	Plot right segments on top horizon
	**********************************************************/
	for (iy=0;iy<nyhz-1;iy++) {
		glMaterialfv(GL_FRONT,GL_EMISSION,emis0[nxhz-1][iy]);
		glVertex3fv(data0[nxhz-1][iy]);
		glVertex3fv(data0[nxhz-1][iy+1]);
	}

	/**********************************************************
	Plot the three segments for each base cell
	**********************************************************/
	for (ix=0;ix<nxhz-1;ix++) {
		for (iy=0;iy<nyhz-1;iy++) {
			glMaterialfv(GL_FRONT,GL_EMISSION,emis1[ix][iy]);
			glVertex3fv(data1[ix][iy]);
			glVertex3fv(data1[ix+1][iy]);
			glVertex3fv(data1[ix][iy]);
			glVertex3fv(data1[ix][iy+1]);
			glVertex3fv(data1[ix][iy+1]);
			glVertex3fv(data1[ix+1][iy]);
		}
	}
	/**********************************************************
	Plot rear segments on base horizon
	**********************************************************/
	for (ix=0;ix<nxhz-1;ix++) {
		glMaterialfv(GL_FRONT,GL_EMISSION,emis1[ix][nyhz-1]);
		glVertex3fv(data1[ix][nyhz-1]);
		glVertex3fv(data1[ix+1][nyhz-1]);
	}
	/**********************************************************
	Plot right segments on base horizon
	**********************************************************/
	for (iy=0;iy<nyhz-1;iy++) {
		glMaterialfv(GL_FRONT,GL_EMISSION,emis1[nxhz-1][iy]);
		glVertex3fv(data1[nxhz-1][iy]);
		glVertex3fv(data1[nxhz-1][iy+1]);
	}

	/**********************************************************
	Plot vertical segments
	**********************************************************/
	for (ix=0;ix<nxhz-1;ix++) {
		for (iy=0;iy<nyhz-1;iy++) {

			glMaterialfv(GL_FRONT,GL_EMISSION,emis0[ix][iy]);
			glVertex3fv(data0[ix][iy]);
			glMaterialfv(GL_FRONT,GL_EMISSION,emis1[ix][iy]);
			glVertex3fv(data1[ix][iy]);

			glMaterialfv(GL_FRONT,GL_EMISSION,emis0[ix][iy]);
			glVertex3fv(data0[ix][iy]);
			glMaterialfv(GL_FRONT,GL_EMISSION,emis1[ix][iy]);
			glVertex3fv(data1[ix][iy+1]);

			glMaterialfv(GL_FRONT,GL_EMISSION,emis0[ix+1][iy]);
			glVertex3fv(data0[ix+1][iy]);
			glMaterialfv(GL_FRONT,GL_EMISSION,emis1[ix][iy+1]);
			glVertex3fv(data1[ix][iy+1]);

			glMaterialfv(GL_FRONT,GL_EMISSION,emis0[ix][iy]);
			glVertex3fv(data0[ix][iy]);
			glMaterialfv(GL_FRONT,GL_EMISSION,emis1[ix][iy+1]);
			glVertex3fv(data1[ix][iy+1]);

			glMaterialfv(GL_FRONT,GL_EMISSION,emis0[ix+1][iy]);
			glVertex3fv(data0[ix+1][iy]);
			glMaterialfv(GL_FRONT,GL_EMISSION,emis1[ix][iy]);
			glVertex3fv(data1[ix][iy]);

		}
	}
	/***********************************************************
	Last two segments at the right corner
	***********************************************************/
	for (ix=0;ix<nxhz-1;ix++) {

		glMaterialfv(GL_FRONT,GL_EMISSION,emis0[ix][nyhz-1]);
		glVertex3fv(data0[ix][nyhz-1]);
		glMaterialfv(GL_FRONT,GL_EMISSION,emis1[ix][nyhz-1]);
		glVertex3fv(data1[ix][nyhz-1]);

		glMaterialfv(GL_FRONT,GL_EMISSION,emis0[ix+1][nyhz-1]);
		glVertex3fv(data0[ix+1][nyhz-1]);
		glMaterialfv(GL_FRONT,GL_EMISSION,emis1[ix][nyhz-1]);
		glVertex3fv(data1[ix][nyhz-1]);

	}

	for (iy=0;iy<nyhz-1;iy++) {

		glMaterialfv(GL_FRONT,GL_EMISSION,emis0[nxhz-1][iy]);
		glVertex3fv(data0[nxhz-1][iy]);
		glMaterialfv(GL_FRONT,GL_EMISSION,emis1[nxhz-1][iy]);
		glVertex3fv(data1[nxhz-1][iy]);

		glMaterialfv(GL_FRONT,GL_EMISSION,emis0[nxhz-1][iy]);
		glVertex3fv(data0[nxhz-1][iy]);
		glMaterialfv(GL_FRONT,GL_EMISSION,emis1[nxhz-1][iy+1]);
		glVertex3fv(data1[nxhz-1][iy+1]);

	}

	glMaterialfv(GL_FRONT,GL_EMISSION,emis0[nxhz-1][nyhz-1]);
	glVertex3fv(data0[nxhz-1][nyhz-1]);
	glMaterialfv(GL_FRONT,GL_EMISSION,emis1[nxhz-1][nyhz-1]);
	glVertex3fv(data1[nxhz-1][nyhz-1]);
d917 2
a918 2
	glEnd();
	glEndList();
d923 1
a923 1
	int nxhz,int nyhz,float ***emis) 
d925 4
a928 1
	int ix,iy;
d930 2
a931 32
	glNewList(ihz+3+nhz*3,GL_COMPILE);
	glBegin(GL_LINES);
	/**********************************************************
	Plot the three segments for each top cell
	**********************************************************/
	for (ix=0;ix<nxhz-1;ix++) {
		for (iy=0;iy<nyhz-1;iy++) {
			glMaterialfv(GL_FRONT,GL_EMISSION,emis[ix][iy]);
			glVertex3fv(data[ix][iy]);
			glVertex3fv(data[ix+1][iy]);
			glVertex3fv(data[ix][iy]);
			glVertex3fv(data[ix][iy+1]);
			glVertex3fv(data[ix][iy+1]);
			glVertex3fv(data[ix+1][iy]);
		}
	}
	/**********************************************************
	Plot rear segments on top horizon
	**********************************************************/
	for (ix=0;ix<nxhz-1;ix++) {
		glMaterialfv(GL_FRONT,GL_EMISSION,emis[ix][nyhz-1]);
		glVertex3fv(data[ix][nyhz-1]);
		glVertex3fv(data[ix+1][nyhz-1]);
	}
	/**********************************************************
	Plot right segments on top horizon
	**********************************************************/
	for (iy=0;iy<nyhz-1;iy++) {
		glMaterialfv(GL_FRONT,GL_EMISSION,emis[nxhz-1][iy]);
		glVertex3fv(data[nxhz-1][iy]);
		glVertex3fv(data[nxhz-1][iy+1]);
	}
d933 50
a982 2
	glEnd();
	glEndList();
d988 1
a988 1
	GLfloat m[4][4];		/*the matrix*/
d990 2
a991 2
	glPopMatrix();
	glPushMatrix();
d993 4
a996 4
	build_rotmatrix(m, curquat);
	glMultMatrixf(&m[0][0]);
	glScalef(glb_scalefactor, glb_scalefactor, glb_scalefactor);
	glb_newmodel=0;
d1005 12
a1016 12
	glPushMatrix();
	glDisable(GL_LIGHTING);
	glTranslatef(x, y, z);
	glScalef(.01, .01, .01);
	/* To rotate 90 degrees counterclockwise aroubd (0,0,1)*/
	glRotatef(90.0, 0.0, 0.0, 1.0);
	while (*message) {
		glutStrokeCharacter(GLUT_STROKE_ROMAN, *message);
		message++;
	}
	glEnable(GL_LIGHTING);
	glPopMatrix();
d1025 35
a1059 23
	int ihz;
	if (glb_newmodel) recalcModelView();
	glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

	for (ihz=0;ihz<nhz;ihz++) {
		if (hlt==LAYER && glb_on_or_off[ihz]==ON)
			glCallList(ihz+3);
		else if (hlt==HORZ && glb_on_or_off[ihz]==ON)
			glCallList(nhz+ihz+3);
		else if (hlt==TETRA && glb_on_or_off[ihz]==ON)
			glCallList(ihz+2*nhz+3);
		else if (hlt==TRI && glb_on_or_off[ihz]==ON)
			glCallList(ihz+3*nhz+3);
	}

	if (glb_plot_rays==PLOT_RAYS)
		glCallList(nhz*4+3);

	if (glb_plot_wf==PLOT_WF)
                glCallList(nhz*4+4);
	glFlush();
	/*showMessage(0, 0, 0, "x direction");*/
	glutSwapBuffers();
d1069 3
a1071 3
	glViewport(0, 0, w, h);
	glb_W=w;
	glb_H=h;
d1081 15
a1095 15
	if (button==GLUT_LEFT_BUTTON && state==GLUT_DOWN) {
		glb_spinning=0;
		glutIdleFunc(NULL);
		glb_moving=1;
		glb_beginx=x;
		glb_beginy=y;
		if(glutGetModifiers() & GLUT_ACTIVE_SHIFT) 
			glb_scaling=1;
		else 
			glb_scaling=0;
	}	
	if (button==GLUT_LEFT_BUTTON && state==GLUT_UP) {
		glb_moving=0;
		glb_spinning=0;
	}
d1104 3
a1106 3
	add_quats(lastquat, curquat, curquat);
	glb_newmodel=1;
	glutPostRedisplay();
d1115 27
a1141 25
	if (glb_scaling) {
		glb_scalefactor=glb_scalefactor*
			(1.0+(((float)(glb_beginy-y))/glb_H));
		glb_beginx=x;
		glb_beginy=y;
		glb_newmodel=1;
		glutPostRedisplay();
		return;
	}

	if (glb_moving) {
		trackball(lastquat,
			(2.0*glb_beginx-glb_W)/glb_W,
			(glb_H-2.0*glb_beginy)/glb_H,
			(2.0*x-glb_W)/glb_W,
			(glb_H-2.0*y)/glb_H,tbs);

		fprintf(stderr,"q=%f,%f,%f,%f\n",curquat[0],curquat[1],
			curquat[2],curquat[3]);

		glb_beginx=x;
		glb_beginy=y;
		glb_spinning=1;
		glutIdleFunc(animate);
	}
d1150 55
a1204 37
	switch (value) {
		case 1:
			glutFullScreen();
			break;
		case 2:
			exit(0);
			break;
		case 3:
			if (hlt==HORZ)
				hlt=TRI;
			else if (hlt==TRI)
				hlt=TETRA;
			else if (hlt==TETRA)
				hlt=LAYER;
			else 
				hlt=HORZ;	
			break;
		default:
			if (value==nhz+4) {
				if (glb_plot_rays==DO_NOT_PLOT_RAYS)
					glb_plot_rays=PLOT_RAYS;
				else
					glb_plot_rays=DO_NOT_PLOT_RAYS;
			} else if (value==nhz+5) {
                                if (glb_plot_wf==DO_NOT_PLOT_WF)
                                        glb_plot_wf=PLOT_WF;
                                else
                                        glb_plot_wf=DO_NOT_PLOT_WF;
			} else {
				if (glb_on_or_off[value-4]==ON)
					glb_on_or_off[value-4]=OFF;
				else
					glb_on_or_off[value-4]=ON;
			}
			break;	
	}
	glutPostRedisplay();
d1214 7
a1220 7
	if (visible==GLUT_VISIBLE) {
		if (glb_spinning)
			glutIdleFunc(animate);
	} else {
		if (glb_spinning)
			glutIdleFunc(NULL);
	}
d1227 36
a1262 2
zmEmission(float v,float vmin,float vmax,
	float *emission)
d1264 5
a1268 13
	float color;
	color=(v-vmin)/(vmax-vmin);
	color=MAX(0.0,MIN(1.0,color));
	if (glb_hue==1) {
		emission[0]=0.5;
		emission[1]=color;
		emission[2]=0.3;
	} else {
		emission[0]=color;
		emission[1]=color;
		emission[2]=color;
	}
	emission[3]=glb_alpha;
@


1.4
log
@Zhaobo Meng's updates.
@
text
@d1 1
a1 1
/* VIEWER3: $Revision: x.x $ ; $Date: 1996/09/02  $	*/
d5 3
a7 1
#include "GL/trackball.h"
a45 23

typedef struct {
	int **ixgh;	/*triangle positions in x*/
	int **iygh;     /*triangle positions in y*/
	float **xhz;	/*nonuniform grid for x on horizon, varying from hz to hz*/
	float **yhz;	/*nonuniform grid for y on horizon, varying from hz to hz*/
	float **zhz;      /*nonuniform grid for z on horizon, varying from hz to hz*/
	float **vhz;  	/*velocity on the nonuniform horizon*/
	float **dvdzhz; 	/*velocity z-gradient*/
	float *rixr;  	/*real index for source before and receiver after called*/
	float *riyr;    /*real index for source before and receiver after called*/
	float *rizr;    /*real index for source before and receiver after called*/ 
	float *temt;  	/*traveltime table for upper/lower face before/after called*/
	float **n1llhz;	/*1_normals to the lower left cell horizon face*/
	float **n2llhz;	/*2_normals to the lower left cell horizon face*/
	float **n3llhz;	/*3_normals to the lower left cell horizon face*/
        float **n1urhz;   /*1_normals to the upper right  cell horizon face*/
        float **n2urhz;   /*2_normals to the upper right cell horizon face*/
        float **n3urhz;   /*3_normals to the upper right cell horizon face*/

	int nd;	/*number of samples in delta*/
	int np;	/*number of samples in azimuth psi*/
} Horizon;
@


1.3
log
@Zhaobo's latest version 9 May 1997
@
text
@a0 3
/* Copyright (c) Colorado School of Mines, 1996.*/
/* All rights reserved.			 */

d14 7
a20 7
" hue=1				=1 for hue =0 for black/white		",
" q=-0.6,0.06,-0.06,0.8		define the quaternion		   	",
" tbs=0.8 	the larger the trackball size, the slower image rotates ",
" verbose=0     		=1 print some useful information	",
" rayfile=NULL			ray path file to be read		",
" wffile=NULL			wavefront file to be read		",
" dvdzhzfile=NULL		dvdz file				",
@


1.2
log
@current version.
@
text
@d1 4
a4 1
/* VIEWER3: $Revision: 1.1 $ ; $Date: 1997/03/19 22:20:12 $	*/
d7 2
a8 2
#include "viewer3.h"

d17 7
a23 8
" alpha=1.0	opacity (0.0<=alpha<1.0) 0.0 for completely transparent ",
" hue=1		=1 for hue =0 for black/white				",
" q=-0.6,0.06,-0.06,0.8 define the quaternion			   	",
" tbs=0.8 	the lager the trackball size is, the slower it rotates  ",
" verbose=0     =1 print some useful information			",
" rayfile=NULL	ray path file to read in 				",
" wffile=NULL	wavefront file to read in				",
" dvdzhzfile=NULL dvdz file						",
d33 1
a33 1
" generated by wcrayt3d (wavefront construction ray tracing for 3D), 	",
d44 43
a86 18
GLfloat angle=-150; /* in degrees */
#define FACTOR 10 
#define CONS (FACTOR*0.6)
#define EPS 0
int spinning=0; 	/*flag: set when spinning*/
int moving=0;		/*flag: set when moving*/
int beginx; 		/*the last point (beginx,beginy)*/
int beginy;
int W=60;		/*window width in pixels*/ 
int H=60;		/*window height in pixels*/
float curquat[4];	/*current quaternion*/
float lastquat[4];	/*last quaternion*/
int newModel=1;		/*flag: set when the model is updated*/
int scaling;		/*flag: set when scaling*/
float scalefactor=1.0;
float alpha;
int hue;
float tbs;
d100 1
a100 1
enum On_or_Off *on_or_off;
d103 2
a104 2
enum Plot_Rays plot_rays=DO_NOT_PLOT_RAYS;
enum Plot_Wf plot_wf=DO_NOT_PLOT_WF;
a105 1
int nhz;   		
d107 1
d166 2
d192 1
a192 1
	char names[]="Layer	";
d230 2
a231 6
	if (!getparfloat("tbs",&tbs)) 		tbs=0.8;

	if (!getparfloat("alpha",&alpha))	alpha=1.0;
	if (!getparint("hue",&hue))		hue=1; /*1 for hue*/

	alpha=MAX(0.0,MIN(1.0,alpha));	
d236 2
a237 2
	on_or_off=(enum On_or_Off *)ealloc1int(3*nhz+6);
	for (ihz=0;ihz<nhz;ihz++) on_or_off[ihz]=ON;
d241 4
d246 2
a247 1
	glutInitDisplayMode(GLUT_RGB | GLUT_DOUBLE | GLUT_DEPTH);
d250 1
d253 4
a256 1
		q0[0]=-0.6; q0[1]=0.05;q0[2]=-0.06;q0[3]=0.8;
d275 1
a275 2
		names[6]=3*16+ihz+1;
		names[7]='\0';
d282 1
a282 1
	glEnable(GL_CULL_FACE);
d286 1
d288 13
a300 7
	gluPerspective( 40.0, 1.0, 1.0, 50.0);
	glMatrixMode(GL_MODELVIEW);
	gluLookAt(
		0.0, 0.0, 35.0, /*important to set where you look at*/
		0.0, 0.0, 0.0,
		0.0, 1.0, 0.0);
	glPushMatrix(); 
d371 1
a371 1
					(xmax-xmin)-0.5)*FACTOR;
d374 1
a374 1
					(ymax-ymin)-0.5)*FACTOR;
d377 1
a377 1
					(zmax-zmin)-0.5)*FACTOR;
d387 1
a387 1
					/(xmax-xmin)-0.5)*FACTOR;
d390 1
a390 1
					/(ymax-ymin)-0.5)*FACTOR;	
d393 1
a393 1
					/(zmax-zmin)-0.5)*FACTOR;
d454 3
a456 3
		xs=((xs-xmin)/(xmax-xmin)-0.5)*FACTOR;
		ys=((ys-ymin)/(ymax-ymin)-0.5)*FACTOR;
		zs=((zs-zmin)/(zmax-zmin)-0.5)*FACTOR;
d460 1
a460 1
					(xmax-xmin)-0.5)*FACTOR;
d462 1
a462 1
					(ymax-ymin)-0.5)*FACTOR;
d464 1
a464 1
					(zmax-zmin)-0.5)*FACTOR;
d499 1
a499 1
					(xmax-xmin)-0.5)*FACTOR;
d501 1
a501 1
					(ymax-ymin)-0.5)*FACTOR;
d503 1
a503 1
					(zmax-zmin)-0.5)*FACTOR;
d566 3
a568 3
		if (fabs(rixs[0][iray])<0.6*FACTOR &&
		    fabs(riys[0][iray])<0.6*FACTOR &&
		    fabs(rizs[0][iray])<0.6*FACTOR ) {
d573 3
a575 3
			if (fabs(rixs[it][iray])<0.6*FACTOR &&
			    fabs(riys[it][iray])<0.6*FACTOR &&
			    fabs(rizs[it][iray])<0.6*FACTOR ) {
d602 9
a610 9
		if (fabs(wfx[itri][0])<CONS &&
		    fabs(wfy[itri][0])<CONS &&
		    fabs(wfz[itri][0])<CONS && 
		    fabs(wfx[itri][1])<CONS &&
		    fabs(wfy[itri][1])<CONS &&
		    fabs(wfz[itri][1])<CONS &&
                    fabs(wfx[itri][2])<CONS &&
                    fabs(wfy[itri][2])<CONS &&
                    fabs(wfz[itri][2])<CONS) {
d888 2
a889 2
	glScalef(scalefactor, scalefactor, scalefactor);
	newModel=0;
d901 3
a903 1
	glScalef(.02, .02, .02);
d912 3
d919 1
a919 1
	if (newModel) recalcModelView();
d923 1
a923 1
		if (hlt==LAYER && on_or_off[ihz]==ON)
d925 1
a925 1
		else if (hlt==HORZ && on_or_off[ihz]==ON)
d927 1
a927 1
		else if (hlt==TETRA && on_or_off[ihz]==ON)
d929 1
a929 1
		else if (hlt==TRI && on_or_off[ihz]==ON)
d933 1
a933 1
	if (plot_rays==PLOT_RAYS)
d936 1
a936 1
	if (plot_wf==PLOT_WF)
d939 1
a939 1
	/*showMessage(2, 7.1, 4.1, "Spin the grid");*/
d943 4
d951 2
a952 2
	W=w;
	H=h;
d955 4
d963 1
a963 1
		spinning=0;
d965 3
a967 3
		moving=1;
		beginx=x;
		beginy=y;
d969 1
a969 1
			scaling=1;
d971 1
a971 1
			scaling=0;
d974 2
a975 2
		moving=0;
		spinning=0;
d979 3
d986 1
a986 1
	newModel=1;
d990 3
d996 6
a1001 5
	if (scaling) {
		scalefactor=scalefactor*(1.0+(((float)(beginy-y))/H));
		beginx=x;
		beginy=y;
		newModel=1;
d1006 1
a1006 1
	if (moving) {
d1008 4
a1011 4
			(2.0*beginx-W)/W,
			(H-2.0*beginy)/H,
			(2.0*x-W)/W,
			(H-2.0*y)/H);
d1016 3
a1018 3
		beginx=x;
		beginy=y;
		spinning=1;
d1023 3
a1025 1

d1048 2
a1049 2
				if (plot_rays==DO_NOT_PLOT_RAYS)
					plot_rays=PLOT_RAYS;
d1051 1
a1051 1
					plot_rays=DO_NOT_PLOT_RAYS;
d1053 2
a1054 2
                                if (plot_wf==DO_NOT_PLOT_WF)
                                        plot_wf=PLOT_WF;
d1056 1
a1056 1
                                        plot_wf=DO_NOT_PLOT_WF;
d1058 2
a1059 2
				if (on_or_off[value-4]==ON)
					on_or_off[value-4]=OFF;
d1061 1
a1061 1
					on_or_off[value-4]=ON;
d1068 4
d1076 1
a1076 1
		if (spinning)
d1079 1
a1079 1
		if (spinning)
d1084 3
d1094 1
a1094 1
	if (hue==1) {
d1103 1
a1103 1
	emission[3]=alpha;
@


1.1
log
@Initial revision
@
text
@d1 1
a1 2
/* Copyright (c) Colorado School of Mines, 1996.*/
/* All rights reserved.			 */
d3 1
a3 3
/* VIEWER3: $Revision: x.x $ ; $Date: 1996/09/02  $	*/

#include "/usr/local/cwp/include/par.h" /*this line must appear first*/
@
