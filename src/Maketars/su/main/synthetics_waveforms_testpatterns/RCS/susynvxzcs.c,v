head	1.17;
access;
symbols;
locks; strict;
comment	@ * @;


1.17
date	2015.06.02.20.15.23;	author john;	state Exp;
branches;
next	1.16;

1.16
date	2011.11.12.00.40.42;	author john;	state Exp;
branches;
next	1.15;

1.15
date	2008.12.11.22.14.03;	author john;	state Exp;
branches;
next	1.14;

1.14
date	2008.12.08.23.06.14;	author john;	state Exp;
branches;
next	1.13;

1.13
date	2006.11.07.22.58.42;	author john;	state Exp;
branches;
next	1.12;

1.12
date	2003.06.09.16.17.07;	author john;	state Exp;
branches;
next	1.11;

1.11
date	2000.09.22.19.10.19;	author john;	state Exp;
branches;
next	1.10;

1.10
date	96.09.13.21.49.05;	author john;	state Exp;
branches;
next	1.9;

1.9
date	96.02.21.23.39.07;	author jkc;	state Exp;
branches;
next	1.8;

1.8
date	96.02.21.22.21.52;	author jkc;	state Exp;
branches;
next	1.7;

1.7
date	96.02.20.23.05.13;	author jkc;	state Exp;
branches;
next	1.6;

1.6
date	96.02.07.15.38.24;	author jkc;	state Exp;
branches;
next	1.5;

1.5
date	95.09.27.20.24.24;	author john;	state Exp;
branches;
next	1.4;

1.4
date	95.07.11.18.44.47;	author jkc;	state Exp;
branches;
next	1.3;

1.3
date	95.05.03.12.34.07;	author john;	state Exp;
branches;
next	1.2;

1.2
date	95.03.15.12.48.58;	author john;	state Exp;
branches;
next	1.1;

1.1
date	95.03.02.10.07.46;	author john;	state Exp;
branches;
next	;


desc
@susynvxzcs - synthetic seismograms for common shot geometry in v(x,z) media
@


1.17
log
@added NINT for dt -- Ekkehart Tessmer Uni-bremen
@
text
@/* Copyright (c) Colorado School of Mines, 2011.*/
/* All rights reserved.                       */

/* SUSYNVXZCS: $Revision: 1.16 $ ; $Date: 2011/11/12 00:40:42 $	*/

#include "su.h" 
#include "segy.h" 

/*********************** self documentation **********************/
char *sdoc[] = {
" 									",
" SUSYNVXZCS - SYNthetic seismograms of common shot in V(X,Z) media via	",
" 		Kirchhoff-style modeling				",
" 									",
" susynvxzcs<vfile >outfile  nx= nz= [optional parameters]		",
" 									",
" Required Parameters:							",
" <vfile        file containing velocities v[nx][nz]			",
" >outfile      file containing seismograms of common ofset		",
" nx=           number of x samples (2nd dimension) in velocity ",
" nz=           number of z samples (1st dimension) in velocity ",
" 									",
" Optional Parameters:							",
" nt=501        	number of time samples				",
" dt=0.004      	time sampling interval (sec)			",
" ft=0.0        	first time (sec)				",
" fpeak=0.2/dt		peak frequency of symmetric Ricker wavelet (Hz)	",
" nxg=			number of receivers of input traces		",
" dxg=15		receiver sampling interval (m)			",
" fxg=0.0		first receiver (m)				",
" nxd=5         	skipped number of receivers			",
" nxs=1			number of offsets				",
" dxs=50		shot sampling interval (m)			",
" fxs=0.0		first shot (m)				",
" dx=50         	x sampling interval (m)				",
" fx=0.         	first x sample (m)				",
" dz=50         	z sampling interval (m)				",
" nxb=nx/2    	band width centered at midpoint (see note)	",
" nxc=0         hozizontal range in which velocity is changed	",
" nzc=0         vertical range in which velocity is changed	",
" pert=0        =1 calculate time correction from v_p[nx][nz]	",
" vpfile        file containing slowness perturbation array v_p[nx][nz]	",
" ref=\"1:1,2;4,2\"	reflector(s):  \"amplitude:x1,z1;x2,z2;x3,z3;...\"",
" smooth=0		=1 for smooth (piecewise cubic spline) reflectors",
" ls=0			=1 for line source; =0 for point source		",
" tmin=10.0*dt		minimum time of interest (sec)			",
" ndpfz=5		number of diffractors per Fresnel zone		",
" cable=1		roll reciever spread with shot			",
" 			=0 static reciever spread			",
" verbose=0		=1 to print some useful information		",
" 									",
" Notes:								",
" This algorithm is based on formula (58) in Geo. Pros. 34, 686-703,	",
" by N. Bleistein.							",
"									",
" Traveltime and amplitude are calculated by finite difference which	",
" is done only in one of every NXD receivers; in skipped receivers, 	",
" interpolation is used to calculate traveltime and amplitude.		", 
" For each receiver, traveltime and amplitude are calculated in the 	",
" horizontal range of (xg-nxb*dx, xg+nxb*dx). Velocity is changed by 	",
" constant extropolation in two upper trianglar corners whose width is 	",
" nxc*dx and height is nzc*dz.						",
"									",
" Eikonal equation will fail to solve if there is a polar turned ray.	",
" In this case, the program shows the related geometric information. 	",
" There are three ways to remove the turned rays: smoothing velocity, 	",
" reducing nxb, and increaing nxc and nzc (if the turned ray occurs  	",
" in shallow areas). To prevent traveltime distortion from an over-	",
" smoothed velocity, traveltime is corrected based on the slowness 	",
" perturbation.								",
"									",
" More than one ref (reflector) may be specified.			",
" Note that reflectors are encoded as quoted strings, with an optional	",
" reflector amplitude: preceding the x,z coordinates of each reflector.	",
" Default amplitude is 1.0 if amplitude: part of the string is omitted.	",
"									",
NULL};

/*
 *	Author: Zhenyue Liu, 07/20/92, Center for Wave Phenomena
 *		Many subroutines borrowed from Dave Hale's program: SUSYNLV
 *
 *		Trino Salinas, 07/30/96, fixed a bug in the geometry
 *		setting to allow the spread move with the shots.
 *
 *		Chris Liner 12/10/08  added cable option, set fldr header word
 *
 * Trace header fields set: trid, counit, ns, dt, delrt,
 *				tracl. tracr, fldr, tracf,
 *				sx, gx
 */
/**************** end self doc ***********************************/

/* global varibles for detecting error in solving eikonal equation */
int ierr=0;
float x_err, z_err, r_err;
int ia_err;


/* parameters for half-derivative filter */
#define LHD 20
#define NHD 1+2*LHD

static void makeone (float **ts, float **as, float **sgs, float **tg, 
	float **ag, float **sgg, float ex, float ez, float dx,  
	float dz, float fx, float vs0, float vg0, int ls, Wavelet *w,
	int nr, Reflector *r, int nt, float dt, float ft, float *trace);

/* additional prototypes for eikonal equation functions */
void delta_t (int na, float da, float r, float dr, 
	float uc[], float wc[], float sc[], float bc[],
	float un[], float wn[], float sn[], float bn[]);
void eiktam_pert (float xs, float zs, int nz, float dz, float fz, int nx, 
	float dx, float fx, float **vel, float **vel_p, int pert, 
	float **time, float **angle, float **sig, float **bet);

/* segy trace */
segy tr;

int
main (int argc, char **argv)
{
	int 	nr,ir,ls,smooth,ndpfz,ns,ixs,ixg,nxs,nxg,nt,
		nx,nz,nxb,nxd,ixd,i,ix,iz,nx1,nx0,nxd1,nxc,nzc,
		verbose,tracl,pert,cable,
		*nxz;
	float   tmin,temp,temp1,
		dsmax,fpeak,dx,dz,fx,ex,fx1,ex1,
		dxg,dxs,dt,fxg,fxs,ft,xs,xg,vs0,vg0,ez,
		*ar,**xr,**zr,
		**vold,**vpold=NULL,**told,**aold,**sgold,
		**ts,**as,**sgs,**tg,**ag,**sgg,**bas,**bag,
		**v,**vp=NULL,**tg1=NULL,**ag1=NULL,**sgg1=NULL;
	FILE *vfp=stdin;
	char *vpfile="";
	Reflector *r;
	Wavelet *w;

	/* hook up getpar to handle the parameters */
	initargs(argc,argv);
	requestdoc(0);

	/* get required parameters */
	if (!getparint("nx",&nx)) err("must specify nx!\n");
	if (!getparint("nz",&nz)) err("must specify nz!\n");
	
	/* get optional parameters */
	if (!getparint("nt",&nt)) nt = 501; CHECK_NT("nt",nt);
	if (!getparfloat("dt",&dt)) dt = 0.004;
	if (!getparfloat("ft",&ft)) ft = 0.0;
	if (!getparfloat("fpeak",&fpeak)) fpeak = 0.2/dt;
	if (!getparint("nxg",&nxg)) nxg = 101;
	if (!getparfloat("dxg",&dxg)) dxg = 15;
	if (!getparfloat("fxg",&fxg)) fxg = 0.0;
	if (!getparint("nxd",&nxd)) nxd = 5;
	if (!getparint("nxs",&nxs)) nxs = 1;
	if (!getparfloat("dxs",&dxs)) dxs = 50;
	if (!getparfloat("fxs",&fxs)) fxs = 0.0;
	if (!getparfloat("dx",&dx)) dx = 50;
	if (!getparfloat("fx",&fx)) fx = 0.0;
	if (!getparfloat("dz",&dz)) dz = 50;
	if (!getparint("nxb",&nxb)) nxb = nx/2;
	if (!getparint("nxc",&nxc)) nxc = 0;
	nxc = MIN(nxc,nxb);
	if (!getparint("nzc",&nzc)) nzc = 0;
	nzc = MIN(nzc,nz);
	if (!getparint("ls",&ls)) ls = 0;
	if (!getparint("pert",&pert)) pert = 0;
	if (!getparfloat("tmin",&tmin)) tmin = 10.0*dt;
	if (!getparint("ndpfz",&ndpfz)) ndpfz = 5;
	if (!getparint("smooth",&smooth)) smooth = 0;
	if (!getparint("cable",&cable)) cable = 1;
	if (!getparint("verbose",&verbose)) verbose = 0;
	
	/* check the ranges of shots and receivers */
	ex = fx+(nx-1)*dx;
	ez = (nz-1)*dz;
	for (ixs=0; ixs<nxs; ++ixs) {
		/* compute shot coordinates */
		xs = fxs+ixs*dxs;
		if (fx>xs || ex<xs) 
		err("shot %i lies outside of specified (x,z) grid\n",ixs);
	}

	for (ixs=0; ixs<2; ++ixs) {
		for (ixg=0; ixg<nxg; ++ixg) {
			/* compute receiver coordinates */
			if (cable==1) {
				xg = fxg+ixg*dxg+ixs*(nxs-1)*dxs;
			} else {
				xg = fxg+ixg*dxg;
			}
			if (fx>xg || ex<xg)
			err("receiver %i lies outside of specified (x,z) grid\n",ixs);
		}
	}


	decodeReflectors(&nr,&ar,&nxz,&xr,&zr);
	if (!smooth) breakReflectors(&nr,&ar,&nxz,&xr,&zr);

	/* allocate space */
	vold = ealloc2float(nz,nx);
	aold = ealloc2float(nz,nx);
	told = ealloc2float(nz,nx);
	bas = ealloc2float(nz,nx);
	sgold = ealloc2float(nz,nx);
	if(pert) vpold = ealloc2float(nz,nx);
	/* read velocities and slowness perturbation*/
	if(fread(vold[0],sizeof(float),nx*nz,vfp)!=nx*nz)
		err("cannot read %d velocities from file %s",nx*nz,vfp);
	if(pert) {
		/* read slowness perturbation*/
		if (!getparstring("vpfile",&vpfile)) 
			err("must specify vpfile!\n");
		if(fread(vpold[0],sizeof(float),nx*nz,fopen(vpfile,"r"))
			!=nx*nz)
		err("cannot read %d slowness perturbation from file %s"
			,nx*nz,vpfile);
		/* calculate 1/2 perturbation of slowness squares*/
		for (ix=0; ix<nx; ++ix)
			for (iz=0; iz<nz; ++iz)
				vpold[ix][iz] = vpold[ix][iz]/vold[ix][iz];
	}
	/* determine maximum reflector segment length */
	tmin = MAX(tmin,MAX(ft,dt));
	dsmax = vold[0][0]/(2*ndpfz)*sqrt(tmin/fpeak);
 	
	/* make reflectors */
	makeref(dsmax,nr,ar,nxz,xr,zr,&r);

	/* count reflector segments */
	for (ir=0,ns=0; ir<nr; ++ir)
		ns += r[ir].ns;

	/* make wavelet */
	makericker(fpeak,dt,&w);
	
	/* if requested, print information */
	if (verbose) {
		warn("\nSUSYNVXZCS:");
		warn("Total number of small reflecting segments is %d.\n",ns);
	}
	
	/* set constant segy trace header parameters */
	memset((void *) &tr, 0, sizeof(segy));
	tr.trid = 1;
	tr.counit = 1;
	tr.ns = nt;
	tr.dt = 1.0e6*dt;
	tr.delrt = 1.0e3*ft;
	tr.d2 = dxg;
	
	/* allocate space */
	nx1 = 1+2*nxb;
	ts = ealloc2float(nz,nx1);
	as = ealloc2float(nz,nx1);
	sgs = ealloc2float(nz,nx1);
	tg = ealloc2float(nz,nx1);
	ag = ealloc2float(nz,nx1);
	sgg = ealloc2float(nz,nx1);
	v = ealloc2float(nz,nx1);
	bag = ealloc2float(nz,nx1);
	if(pert) vp = ealloc2float(nz,nx1);
	if(nxd>1) {
		/* allocate space for interpolation */
		tg1 = ealloc2float(nz,nx1);
		ag1 = ealloc2float(nz,nx1);
		sgg1 = ealloc2float(nz,nx1);
  	}

	/* change velocity values within two trianglar upper corners to
 		avoid possible polar-turned rays	*/
	for(iz=0; iz<nzc; ++iz)
		for(ix=iz*nxc/nzc; ix<nxc; ++ix){
			vold[nxc-ix-1][iz] = vold[nxc-iz*nxc/nzc][iz];
			vold[nx1-nxc+ix][iz] = vold[nx1-nxc+iz*nxc/nzc-1][iz];
		}

		
	/* loop over shots */
	for (ixs=0, tracl=0; ixs<nxs; ++ixs){
	    xs = fxs+ixs*dxs;
	    /* calculate traveltimes from shot */
	    eiktam_pert(xs,0,nz,dz,0,nx,dx,fx,vold,vpold,pert,told,aold,sgold,bas);
	    if(ierr){
		/* Ekonal equation suffers from turned rays*/
		err("\tEikonal equation fails to solve at "
		    "x=%g, z=%g\n\tfrom shot xs=%g .\n",x_err+xs,z_err,xs);
		}
	    /* calculate velocity at shot 	*/
	    temp = (xs-fx)/dx;
	    ixd = temp;
	    temp = temp-ixd;
	    vs0 = (1-temp)*vold[ixd][0]+temp*vold[ixd+1][0];
	
	    /* save the skipping number */
	    nxd1 = nxd;
	    
	    /* loop over receivers */
	    for (ixg=0; ixg<nxg; ixg +=nxd1){
		if (cable==1) {
			xg = fxg+ixs*dxs+ixg*dxg;
		} else {
			xg = fxg+ixg*dxg;
		}

		/* set range for traveltimes' calculation */
		fx1 = xg-nxb*dx;
		nx0 = (fx1-fx)/dx;
		temp = (fx1-fx)/dx-nx0;
	       	for(ix=0;ix<nx1;++ix){
		    if(ix<-nx0) 
			for(iz=0;iz<nz;++iz)
				v[ix][iz] = vold[0][iz];
		    else if(ix+nx0>nx-2)
			for(iz=0;iz<nz;++iz)
				v[ix][iz]=vold[nx-1][iz];
		    else	
			for(iz=0;iz<nz;++iz){
				v[ix][iz] = vold[ix+nx0][iz]*(1.0-temp)
					+temp*vold[ix+nx0+1][iz];
				ts[ix][iz] = told[ix+nx0][iz]*(1.0-temp)
					+temp*told[ix+nx0+1][iz];
				as[ix][iz] = aold[ix+nx0][iz]*(1.0-temp)
					+temp*aold[ix+nx0+1][iz];
				sgs[ix][iz] = sgold[ix+nx0][iz]*(1.0-temp)
					+temp*sgold[ix+nx0+1][iz];
				}
		}

		if(pert){
		    for(ix=0;ix<nx1;++ix)
			for(iz=0;iz<nz;++iz){
			    if(ix<-nx0) 
				vp[ix][iz] = vpold[0][iz];
			    else if(ix+nx0>nx-2) 
				vp[ix][iz]=vpold[nx-1][iz];
			    else
				vp[ix][iz] = vpold[ix+nx0][iz]*(1.0-temp)
					+temp*vpold[ix+nx0+1][iz];
			    }
		}
			
		if(ixg==0 || nxd1==1){
		/* No interpolation */
	
		/* compute traveltimes, prop angles, sigmas from receiver */
		eiktam_pert(xg,0.,nz,dz,0.,nx1,dx,fx1,v,vp,pert,tg,ag,sgg,bag);
		if(ierr){
			/* Ekonal equation fails to solve */
			warn("\tEikonal equation fails to solve at "
			     "x=%g, z=%g\n\tfrom receiver xg=%g .",
			     x_err+xg,z_err,xg);
			break;
		}
			/* calculate velocity at receiver 	*/
			vg0 = (1-temp)*vold[nx0+nxb][0]
				+temp*vold[nx0+nxb+1][0];

			/* make one trace */
			ex1 = MIN(ex,xg+nxb*dx);
			makeone(ts,as,sgs,tg,ag,sgg,ex1,ez,dx,dz,fx1,vs0,vg0,
				ls,w,nr,r,nt,dt,ft,tr.data);
			/* set segy trace header parameters */
			tr.tracl = tr.tracr = ++tracl;
			tr.fldr = ixs+1;
			tr.tracf = ixg+1;	
			tr.sx = NINT(xs);
			tr.gx = NINT(xg);
			/* write trace */
			puttr(&tr);
		}
		else {
			/* Linear interpolation */
			
		eiktam_pert(xg,0,nz,dz,0,nx1,dx,fx1,v,vp,pert,tg1,ag1,sgg1,bag);
		if(ierr){
			/* Ekonal equation fails to solve */
			warn("\tEikonal equation fails to solve at "
			     "x=%g, z=%g\n\tfrom receiver xg=%g .",
			     x_err+xg,z_err,xg);
			break;
		}

		/* calculate velocity at receiver 	*/
		vg0 = (1-temp)*vold[nx0+nxb][0]+temp*vold[nx0+nxb+1][0];
			
			/* interpolate quantities between two midpoints	*/
		    	xg -= nxd1*dxg;
		    for(i=1; i<=nxd1; ++i) {
		    	xg += dxg;
			fx1 = xg-nxb*dx;	
			ex1 = xg+nxb*dx;
			temp = nxd1-i;
			temp1 = 1.0/(nxd1-i+1);
			for(ix=0;ix<nx1;++ix)
			    for(iz=0;iz<nz;++iz){
			    if(i==nxd1){
			   	tg[ix][iz] = tg1[ix][iz];
			   	ag[ix][iz] = ag1[ix][iz];
			   	sgg[ix][iz] = sgg1[ix][iz];
				}
			    else{
			   	tg[ix][iz] = (temp*tg[ix][iz]
					+tg1[ix][iz])*temp1;
			   	ag[ix][iz] = (temp*ag[ix][iz]
					+ag1[ix][iz])*temp1;
			   	sgg[ix][iz] = (temp*sgg[ix][iz]
					+sgg1[ix][iz])*temp1;
				}
			}

			/* calculate quantities at shot 	*/
	    		nx0 = (fx1-fx)/dx;
	    		temp = (fx1-fx)/dx-nx0;
	   		for(ix=MAX(0,-nx0); ix<MIN(nx1,nx-1-nx0); ++ix){
			    for(iz=0;iz<nz;++iz){
			   	ts[ix][iz] = told[ix+nx0][iz]*(1.0-temp)
					+temp*told[ix+nx0+1][iz];
			    	sgs[ix][iz] = sgold[ix+nx0][iz]*(1.0-temp)
					+temp*sgold[ix+nx0+1][iz];
			        as[ix][iz] = aold[ix+nx0][iz]*(1.0-temp)
					+temp*aold[ix+nx0+1][iz];
		   		 }
			}
				
			/* make one trace */
			ex1 = MIN(ex,xg+nxb*dx);
			makeone(ts,as,sgs,tg,ag,sgg,ex1,ez,dx,dz,fx1,vs0,vg0,
				ls,w,nr,r,nt,dt,ft,tr.data);
			/* set segy trace header parameters */
			tr.tracl = tr.tracr = ++tracl;
			tr.fldr = ixs+1;
			tr.tracf = ixg+1;	
			tr.sx = NINT(xs);
			tr.gx = NINT(xg);
			/* write trace */
			puttr(&tr);
		    }
		}
		/* recount the skipping number for the last midpoint */
		    if(ixg<nxg-1 && ixg>nxg-1-nxd1) nxd1 = nxg-1-ixg;

	    }
	    warn("\t finish shot %f",xs);
	}

	free2float(vold);
	free2float(aold);
	free2float(told);
	free2float(sgold);
	free2float(ts);
	free2float(as);
	free2float(sgs);
	free2float(bas);
	free2float(v);
	free2float(tg);
	free2float(bag);
	free2float(sgg);
	free2float(ag);
	if(pert) {
		free2float(vp);
		free2float(vpold);
	}
	if(nxd>1) {
		free2float(sgg1);
		free2float(tg1);
		free2float(ag1);
  	}
	return(CWP_Exit());
}

static void makeone (float **ts, float **as, float **sgs, 
	float **tg, float **ag, float **sgg, float ex, float ez, float dx, 
	float dz, float fx, float vs0, float vg0, int ls, Wavelet *w,
	int nr, Reflector *r, int nt, float dt, float ft, float *trace)
/*****************************************************************************
Make one synthetic seismogram 
******************************************************************************
Input:
**ts		array[nx][nz] containing traveltimes from shot
**as		array[nx][nz] containing propagation angles from shot 
**sgs		array[nx][nz] containing sigmas from shot
**tg		array[nx][nz] containing traveltimes from receiver
**ag		array[nx][nz] containing propagation angles from receiver 
**sgg		array[nx][nz] containing sigmas from receiver
nz		number of z samples
dz		z sampling interval
nx		number of x samples
dx		x sampling interval
fx		first x sample
ex		last x sample
ez		last z sample
ls		=1 for line source amplitudes; =0 for point source
w		wavelet to convolve with trace
xs		x coordinate of source
xg		x coordinate of receiver group
nr		number of reflectors
r		array[nr] of reflectors
nt		number of time samples
dt		time sampling interval
ft		first time sample

Output:
trace		array[nt] containing synthetic seismogram
*****************************************************************************/
{
	int it,ir,is,ns,ix,iz;
	float ar,ds,xd,zd,cd,sd,xi,zi,ci,cr,time,amp,sx,sz,
		tsd,asd,sgsd,tgd,agd,sggd,
		*temp;
	ReflectorSegment *rs;
	int lhd=LHD,nhd=NHD;
	static float hd[NHD];
	static int madehd=0;

	/* if half-derivative filter not yet made, make it */
	if (!madehd) {
		mkhdiff(dt,lhd,hd);
		madehd = 1;
	}
 
	/* zero trace */
	for (it=0; it<nt; ++it)
		trace[it] = 0.0;
	
	/* loop over reflectors */
	for (ir=0; ir<nr; ++ir) {

		/* amplitude, number of segments, segment length */
		ar = r[ir].a;
		ns = r[ir].ns;
		ds = r[ir].ds;
		rs = r[ir].rs;
	
		/* loop over diffracting segments */
		for (is=0; is<ns; ++is) {
		
			/* diffractor midpoint, unit-normal, and length */
			xd = rs[is].x;
			zd = rs[is].z;
			cd = rs[is].c;
			sd = rs[is].s;
			
			/* check range of reflector */
			if(xd<fx || xd>=ex || zd>=ez)
				continue;
			/* determine sample indices */
			xi = (xd-fx)/dx;
			ix = xi;
			zi = zd/dz;
			iz = zi;
			/* bilinear interpolation */
			sx = xi-ix;
			sz = zi-iz;
			tsd = (1.0-sz)*((1.0-sx)*ts[ix][iz] + 
						sx*ts[ix+1][iz]) +
					sz*((1.0-sx)*ts[ix][iz+1] +
						sx*ts[ix+1][iz+1]);
			asd = (1.0-sz)*((1.0-sx)*as[ix][iz] + 
						sx*as[ix+1][iz]) +
					sz*((1.0-sx)*as[ix][iz+1] +
						sx*as[ix+1][iz+1]);
			sgsd = (1.0-sz)*((1.0-sx)*sgs[ix][iz] + 
						sx*sgs[ix+1][iz]) +
					sz*((1.0-sx)*sgs[ix][iz+1] +
						sx*sgs[ix+1][iz+1]);
			tgd = (1.0-sz)*((1.0-sx)*tg[ix][iz] + 
						sx*tg[ix+1][iz]) +
					sz*((1.0-sx)*tg[ix][iz+1] +
						sx*tg[ix+1][iz+1]);
			agd = (1.0-sz)*((1.0-sx)*ag[ix][iz] + 
						sx*ag[ix+1][iz]) +
					sz*((1.0-sx)*ag[ix][iz+1] +
						sx*ag[ix+1][iz+1]);
			sggd = (1.0-sz)*((1.0-sx)*sgg[ix][iz] + 
						sx*sgg[ix+1][iz]) +
					sz*((1.0-sx)*sgg[ix][iz+1] +
						sx*sgg[ix+1][iz+1]);
			
			/* cosines of incidence and reflection angles */
			ci = cd*cos(asd)+sd*sin(asd);
			cr = cd*cos(agd)+sd*sin(agd);

			/* two-way time and amplitude */
			time = tsd+tgd;

			if (ls)
			     amp = sqrt(vs0*vg0/(sgsd*sggd));
			else
			     amp = sqrt(vs0*vg0/(sgsd*sggd*(sgsd+sggd)));
					   
			amp *= ABS(ci+cr)*ar*ds;
		
			/* add sinc wavelet to trace */
			addsinc(time,amp,nt,dt,ft,trace);
		}
	}
	
	/* allocate workspace */
	temp = ealloc1float(nt);
	
	/* apply half-derivative filter to trace */
	convolve_cwp(nhd,-lhd,hd,nt,0,trace,nt,0,temp);

	/* convolve wavelet with trace */
	convolve_cwp(w->lw,w->iw,w->wv,nt,0,temp,nt,0,trace);
	
	/* free workspace */
	free1float(temp);
}

void delta_t (int na, float da, float r, float dr, 
	float uc[], float wc[], float sc[], float bc[],
	float un[], float wn[], float sn[], float bn[])
/*****************************************************************************
difference equation extrapolation of "delta t" in polar coordinates
******************************************************************************
Input:
na		number of a samples
da		a sampling interval
r		current radial distance r
dr		radial distance to extrapolate
uc		array[na] of dt/dr at current r
un		array[na] of dt/dr at next r
wc		array[na] of dt/da at current r
wn		array[na] of dt/da at next r
sc		array[na] of dt/dv at current r

Output:
sn		array[na] of dt/dv at next r 
******************************************************************************

This function implements the Crank-Nicolson finite-difference method with
boundary conditions sn[1]=sn[0] and sn[na-1]=sn[na-2].
******************************************************************************
Author:  Zhenyue Liu, Colorado School of Mines, 07/8/92
******************************************************************************/
{
	int i;
	float r1,*d,*b,*c,*e;
	
	/* allocate workspace */
	d = alloc1float(na-2);
	b = alloc1float(na-2);
	c = alloc1float(na-2);
	e = alloc1float(na-2);
	
	r1 = r+dr;
 	
	/* Crank-Nicolson */
 	for (i=0; i<na-2; ++i) {
		d[i] = (uc[i+1]+un[i+1])/(2.0*dr);
		e[i] = (wn[i+1]/(r1*r1)+wc[i+1]/(r*r))/(8.0*da);
		b[i] = (bc[i+1]+bn[i+1])*0.5-(sc[i+2]-sc[i])*e[i]
			+d[i]*sc[i+1];
		c[i] = -e[i];
	} 
	d[0] += c[0];
	d[na-3] += e[na-3]; 
	
	tripp(na-2,d,e,c,b);
	for(i=0;i<na-2; ++i) sn[i+1]=b[i];
	sn[0] = sn[1];
	sn[na-1] = sn[na-2];
	
	
	/* free workspace */
	free1float(d);
	free1float(c);
	free1float(e);
	free1float(b);
}

/* functions defined and used internally */
void eiktam_pert (float xs, float zs, int nz, float dz, float fz, int nx, 
	float dx, float fx, float **vel, float **vel_p, int pert,
	float **time, float **angle, float **sig, float **bet)
/*****************************************************************************
Compute traveltimes t(x,z) and  propagation angle a(x,z) via eikonal equation,
 and sigma sig(x,z), incident angle bet(x,z) via Crank-Nicolson Method
******************************************************************************
Input:
xs		x coordinate of source (must be within x samples)
zs		z coordinate of source (must be within z samples)
nz		number of z samples
dz		z sampling interval
fz		first z sample
nx		number of x samples
dx		x sampling interval
fx		first x sample
vel		array[nx][nz] containing velocities
vel_p		array[nx][nz] containing velocity perturbations

Output:
time		array[nx][nz] containing first-arrival times
angle		array[nx][nz] containing propagation angles
sig  		array[nx][nz] containing sigmas
bet		array[nx][nz] containing betas
******************************************************************************
Notes:
The actual computation of times and sigmas is done in polar coordinates,
with bilinear interpolation used to map to/from rectangular coordinates.

This version takes into account a perturbation in velocity.
******************************************************************************
Revisor:  Zhenyue Liu, Colorado School of Mines, 7/8/92
******************************************************************************/
{
	int ix,iz,ia,ir,na,nr;
	float ss,a,r,da,dr,fa,fr,ex,ez,ea,rmax,rmaxs,
		**s,**sp,**tp,**up,**wp,**ap,**time_p;

	/* shift coordinates so source is at (x=0,z=0) */
	fx -= xs;
	fz -= zs;
	ex = fx+(nx-1)*dx;
	ez = fz+(nz-1)*dz;
	
	/* determine polar coordinate sampling */
	rmaxs = fx*fx+fz*fz;
	rmaxs = MAX(rmaxs,fx*fx+ez*ez);
	rmaxs = MAX(rmaxs,ex*ex+ez*ez);
	rmaxs = MAX(rmaxs,ex*ex+fz*fz);
	rmax = sqrt(rmaxs);
	dr = MIN(ABS(dx),ABS(dz));
	nr = 1+NINT(rmax/dr);
	dr = rmax/(nr-1);
	fr = 0.0;
	if (fx==0.0 && fz==0.0) {
		fa = 0.0;  ea = PI/2.0;
	} else if (fx<0.0 && fz==0.0) {
		fa = -PI/2.0;  ea = PI/2.0;
	} else if (fx==0.0 && fz<0.0) {
		fa = 0.0;  ea = PI;
	} else {
		fa = -PI;  ea = PI;
	}
	da = dr/rmax;
	na = 1+NINT((ea-fa)/da);
	da = (ea-fa)/(na-1);
	if (fa==-PI && ea==PI)
		na = na-1;
	
	/* allocate space */
	time_p = alloc2float(nz,nx);
	s = alloc2float(nz,nx);
	sp = alloc2float(na,nr);
	tp = alloc2float(na,nr);
	up = alloc2float(na,nr);
	wp = alloc2float(na,nr);
	ap = alloc2float(na,nr);
	
	/* compute slownesses */
	for (ix=0; ix<nx; ++ix)
		for (iz=0; iz<nz; ++iz)
			s[ix][iz] = 1.0/vel[ix][iz];
	
	/* convert from rectangular to polar coordinates */
	recttopolar(nz,dz,fz,nx,dx,fx,s,na,da,fa,nr,dr,fr,sp);
	
	/* average the slownesses in source region */
	for (ir=0,ss=0.0; ir<2; ++ir)
		for (ia=0; ia<na; ++ia)
			ss += sp[ir][ia];
	ss /= 2*na;

	/* compute traveltimes and derivatives in source region */
	for (ir=0,r=0; ir<2; ++ir,r+=dr) {
		for (ia=0; ia<na; ++ia) {
			up[ir][ia] = ss;
			wp[ir][ia] = 0.0;
			tp[ir][ia] = r*ss;
		}
	}

/* 	tt=cpusec();   */
	/* solve eikonal equation for remaining times and derivatives */
	for (ir=1,r=dr; ir<nr-1; ++ir,r+=dr) {
		eikpex(na,da,r,dr,
			sp[ir],up[ir],wp[ir],tp[ir],
			sp[ir+1],up[ir+1],wp[ir+1],tp[ir+1]);
		if(ierr) {
			x_err = r_err*sin(ia_err*da+fa);
			z_err = r_err*cos(ia_err*da+fa);
			return;
		}
	}
	
	/* convert times from polar to rectangular coordinates */
	polartorect(na,da,fa,nr,dr,fr,tp,nz,dz,fz,nx,dx,fx,time);

/*  	fprintf(stderr,"\t CPU time for traveltimes= %f \n",cpusec()-tt); 
 	tt=cpusec();   */
	
	/* compute propagation angles in polar and convert */
	for (ia=0,a=fa; ia<na; ++ia,a+=da)
		ap[0][ia] = a;
	for (ir=1,r=fr+dr; ir<nr; ++ir,r+=dr)
		for (ia=0,a=fa; ia<na; ++ia,a+=da){
		    ap[ir][ia] = a+asin(wp[ir][ia]/(sp[ir][ia]*r));
		}
	polartorect(na,da,fa,nr,dr,fr,ap,nz,dz,fz,nx,dx,fx,angle);
/*  	fprintf(stderr,"\t CPU time for propagation angles= %f\n", 	
		cpusec()-tt); 
	tt=cpusec();   */
	
	/* compute sigmas  for initial values */
	for (ir=0,r=0; ir<2; ++ir,r+=dr) 
		for (ia=0; ia<na; ++ia) tp[ir][ia] = r/ss;

	/* solve diffrence equation for remaining sigmas */
	for (ir=1,r=dr; ir<nr-1; ++ir,r+=dr) 
 		ray_theoretic_sigma(na,da,r,dr,up[ir],wp[ir],tp[ir],
			up[ir+1],wp[ir+1],tp[ir+1]);  
	polartorect(na,da,fa,nr,dr,fr,tp,nz,dz,fz,nx,dx,fx,sig);

/* 	fprintf(stderr,"\t CPU time for sigmas= %f \n",cpusec()-tt); 
	tt=cpusec(); */
	
	/* compute betas for initial values */
	for (ir=0; ir<2; ++ir) 
		for (ia=0,a=fa; ia<na; ++ia,a+=da) tp[ir][ia] = a;

	/* solve diffrence equation for remaining betas */
	for (ir=1,r=dr; ir<nr-1; ++ir,r+=dr) 
 		ray_theoretic_beta(na,da,r,dr,up[ir],wp[ir],tp[ir],
			up[ir+1],wp[ir+1],tp[ir+1]);  
	polartorect(na,da,fa,nr,dr,fr,tp,nz,dz,fz,nx,dx,fx,bet);
	
	if(pert){
	    /* compute time perturbation by Crank-Nicolson scheme */

	    recttopolar(nz,dz,fz,nx,dx,fx,vel_p,na,da,fa,nr,dr,fr,sp);
	    /* initial values */
	    for (ir=0,r=0; ir<2; ++ir,r+=dr) 
		for (ia=0; ia<na; ++ia) 
			tp[ir][ia] = r/ss*sp[ir][ia];
	    /* solve difference equation for remaining perturbed time */
	    for (ir=1,r=dr; ir<nr-1; ++ir,r+=dr) 
 		delta_t(na,da,r,dr,up[ir],wp[ir],tp[ir],sp[ir],
			up[ir+1],wp[ir+1],tp[ir+1],sp[ir+1]);  

	    polartorect(na,da,fa,nr,dr,fr,tp,nz,dz,fz,nx,dx,fx,time_p);
	    /* sum the total time */
	    for (ix=0; ix<nx; ++ix)
		for (iz=0; iz<nz; ++iz)
			time[ix][iz] += time_p[ix][iz];
	}
/* 	fprintf(stderr,"\t CPU time for incident angles= %f \n",
		cpusec()-tt); */
	
	/* free space */
	free2float(s);
	free2float(time_p);
	free2float(sp);
	free2float(tp);
	free2float(up);
	free2float(wp);
	free2float(ap);
}
@


1.16
log
@copyright
@
text
@d4 1
a4 4
/* Copyright (c) Colorado School of Mines, 2007.*/
/* All rights reserved.                       */

/* SUSYNVXZCS: $Revision: 1.15 $ ; $Date: 2008/12/11 22:14:03 $	*/
d605 1
a605 1
	conv(nhd,-lhd,hd,nt,0,trace,nt,0,temp);
d608 1
a608 1
	conv(w->lw,w->iw,w->wv,nt,0,temp,nt,0,trace);
@


1.15
log
@sets fldr and tracf header values
@
text
@d1 3
d7 1
a7 1
/* SUSYNVXZCS: $Revision: 1.13 $ ; $Date: 2006/11/07 22:58:42 $	*/
@


1.14
log
@slightly modified version of susynvxzcs that allows the
user to define the receivers relative to the shot position (the
original method) or to have the receivers be 'static' (not moving
with the shot).  I found it useful in modeling some OBC data.
--Chris Liner, U of Houston
@
text
@d86 2
d331 13
a343 12
	if(pert){
	    for(ix=0;ix<nx1;++ix)
		for(iz=0;iz<nz;++iz){
		    if(ix<-nx0) 
			vp[ix][iz] = vpold[0][iz];
		    else if(ix+nx0>nx-2) 
			vp[ix][iz]=vpold[nx-1][iz];
		    else
			vp[ix][iz] = vpold[ix+nx0][iz]*(1.0-temp)
				+temp*vpold[ix+nx0+1][iz];
		    }
	}
d348 1
a348 2
			/* compute traveltimes, propagation angles, sigmas 
	  		 from receiver */
d367 2
d434 2
@


1.13
log
@changed    memset( .., (int) '\0',...) to memset( .., 0,..) as per suggestion of Marion Zhu and Reg Beardsley
@
text
@d1 4
a4 1
/* SUSYNVXZCS: $Revision: 1.12 $ ; $Date: 2003/06/09 16:17:07 $	*/
d48 2
d123 1
a123 1
		verbose,tracl,pert,
d170 1
d180 1
a180 1
		err("shot lies outside of specified (x,z) grid\n");
d186 5
a190 1
			xg = fxg+ixg*dxg+ixs*(nxs-1)*dxs;
d192 1
a192 1
			err("receiver lies outside of specified (x,z) grid\n");
d300 5
a304 1
		xg = fxg+ixs*dxs+ixg*dxg;
@


1.12
log
@9 June 2003
@
text
@d1 1
a1 1
/* SUSYNVXZCS: $Revision: 1.11 $ ; $Date: 2000/09/22 19:10:19 $	*/
d234 1
a234 1
	memset((void *) &tr, (int) '\0', sizeof(tr));
@


1.11
log
@cleaned up extraneous defines
@
text
@d1 1
a1 1
/* SUSYNVXZCS: $Revision: 1.10 $ ; $Date: 1996/09/13 21:49:05 $	*/
d451 1
a451 1
	return EXIT_SUCCESS;
@


1.10
log
@silenced -Wall messages
@
text
@d1 1
a1 1
/* SUSYNVXZCS: $Revision: 1.9 $ ; $Date: 1996/02/21 23:39:07 $	*/
a102 9
void eikpex (int na, float da, float r, float dr, 
	float sc[], float uc[], float wc[], float tc[],
	float sn[], float un[], float wn[], float tn[]);
void sigma (int na, float da, float r, float dr, 
	float uc[], float wc[], float sc[],
	float un[], float wn[], float sn[]);
void beta (int na, float da, float r, float dr, 
	float uc[], float wc[], float bc[],
	float un[], float wn[], float bn[]);
d106 1
a106 2
void tripp (int n, float *d, float *e, float *c, float *b);
void eiktam (float xs, float zs, int nz, float dz, float fz, int nx, 
d273 1
a273 1
	    eiktam(xs,0,nz,dz,0,nx,dx,fx,vold,vpold,pert,told,aold,sgold,bas);
d333 1
a333 1
		eiktam(xg,0.,nz,dz,0.,nx1,dx,fx1,v,vp,pert,tg,ag,sgg,bag);
d359 1
a359 1
		eiktam(xg,0,nz,dz,0,nx1,dx,fx1,v,vp,pert,tg1,ag1,sgg1,bag);
a593 292

#define TINY 1.0e-3	/* avoid divide by zero */
#define CFL 0.98	/* Courant/Friedrichs/Lewy stability factor */

void eikpex (int na, float da, float r, float dr, 
	float sc[], float uc[], float wc[], float tc[],
	float sn[], float un[], float wn[], float tn[])
/*****************************************************************************
Eikonal equation extrapolation of times and derivatives in polar coordinates
******************************************************************************
Input:
na		number of a samples
da		a sampling interval
r		current radial distance r
dr		radial distance to extrapolate
sc		array[na] of slownesses at current r
uc		array[na] of dt/dr at current r
wc		array[na] of dt/da at current r
tc		array[na] of times t at current r
sn		array[na] of slownesses at next r

Output:
un		array[na] of dt/dr at next r (may be equivalenced to uc)
wn		array[na] of dt/da at next r (may be equivalenced to wc)
tn		array[na] of times t at next r (may be equivalenced to tc)
******************************************************************************
Notes:
If na*da==2*PI, then the angular coordinate is wrapped around (periodic). 

This function implements the finite-difference method described by Bill
Symes (Rice University) and Jos van Trier (Stanford University) in a
(1990) preprint of a paper submitted to Geophysics.
******************************************************************************
Author:  Dave Hale, Colorado School of Mines, 07/16/90
******************************************************************************/
{
	int i,wrap;
	float drleft,drorig,frac,cmax,umaxl,uminr,uminm,umaxm,
		uu,unew,uold,ueol,ueor,wor,or,*wtemp,*s;
	
	/* allocate workspace */
	wtemp = alloc1float(na);
	s = alloc1float(na);
	
	/* remember the step size */
	drleft = drorig = dr;
	
	/* initialize slownesses to values at current r */
	for (i=0; i<na; ++i)
		s[i] = sc[i];
	
	/* copy inputs to output */
	for (i=0; i<na; ++i) {
		un[i] = uc[i];
		wn[i] = wc[i];
		tn[i] = tc[i];
	}
	
	/* determine if angular coordinate wraps around */
	wrap = ABS(na*da-2.0*PI)<0.01*ABS(da);
	
	/* loop over intermediate steps with adaptive stepsize */
	while (drleft>0.0) {
		
		/* determine adaptive step size according to CFL condition */
		for (i=0,cmax=TINY; i<na; ++i) {
			if (r*ABS(un[i])<TINY*ABS(wn[i]))
				cmax = 1.0/TINY;
			else
				cmax = MAX(cmax,ABS(wn[i]/(r*un[i])));
		}
		dr = MIN(drleft,CFL/cmax*r*da);
		
		/* if angles wrap around */
		if (wrap) {
			umaxl = (wn[na-1]>0.0 ? un[na-1] : s[0]);
			if (wn[0]>0.0) {
				uminm = s[0];
				umaxm = un[0];
			} else {
				uminm = un[0];
				umaxm = s[0];
			}
			uminr = (wn[1]>0.0 ? s[0] : un[1]);
			ueol = uminm+umaxl;
			ueor = uminr+umaxm;
			wtemp[0] = wn[0]+dr*(ueor-ueol)/da;
			umaxl = (wn[na-2]>0.0 ? un[na-2] : s[na-1]);
			if (wn[na-1]>0.0) {
				uminm = s[na-1];
				umaxm = un[na-1];
			} else {
				uminm = un[na-1];
				umaxm = s[na-1];
			}
			uminr = (wn[0]>0.0 ? s[na-1] : un[0]);
			ueol = uminm+umaxl;
			ueor = uminr+umaxm;
			wtemp[na-1] = wn[na-1]+dr*(ueor-ueol)/da;
		
		/* else, if angles do not wrap around */
		} else {
			if (wn[0]<=0.0)
				wtemp[0] = wn[0] + 
					dr*(un[1]-un[0])/da; 
			else
				wtemp[0] = 0.0;
			if (wn[na-1]>=0.0) 
				wtemp[na-1] = wn[na-1] +
					dr*(un[na-1]-un[na-2])/da;
			else
				wtemp[na-1] = 0.0;
		}
		
		/* update interior w values via Enquist/Osher scheme */
		for (i=1; i<na-1; ++i) {
			umaxl = (wn[i-1]>0.0 ? un[i-1] : s[i]);
			if (wn[i]>0.0) {
				uminm = s[i];
				umaxm = un[i];
			} else {
				uminm = un[i];
				umaxm = s[i];
			}
			uminr = (wn[i+1]>0.0 ? s[i] : un[i+1]);
			ueol = uminm+umaxl;
			ueor = uminr+umaxm;
			wtemp[i] = wn[i]+dr*(ueor-ueol)/da;
		}
		
		/* decrement the size of step left to do */
		drleft -= dr;
		
		/* update radial coordinate and its inverse */
		r += dr;
		or = 1.0/r;
		
		/* linearly interpolate slowness for new r */
		frac = drleft/drorig;
		for (i=0; i<na; ++i)
			s[i] = frac*sc[i]+(1.0-frac)*sn[i];
		
		/* update w and u; integrate u to get t */
		for (i=0; i<na; i++) {
			wn[i] = wtemp[i];
			wor = wn[i]*or;
			uu = (s[i]-wor)*(s[i]+wor);
			if(uu<=0) {
				ierr = 1;
				ia_err = i;
				r_err = r;
				return;
			}
 			unew = sqrt(uu); 
			uold = un[i];
			un[i] = unew;
			tn[i] += 0.5*dr*(unew+uold);
		}
	}
	
	/* free workspace */
	free1float(wtemp);
	free1float(s);
}

void sigma (int na, float da, float r, float dr, 
	float uc[], float wc[], float sc[],
	float un[], float wn[], float sn[])
/*****************************************************************************
difference equation extrapolation of "sigma" in polar coordinates
******************************************************************************
Input:
na		number of a samples
da		a sampling interval
r		current radial distance r
dr		radial distance to extrapolate
uc		array[na] of dt/dr at current r
wc		array[na] of dt/da at current r
sc		array[na] of sigma  at current r
un		array[na] of dt/dr at next r
wn		array[na] of dt/da at next r

Output:
sn		array[na] of sigma at next r 
******************************************************************************

This function implements the Crank-Nicolson finite-difference method with
boundary conditions dsigma/da=0. 

Author:  Zhenyue Liu, Center for Wave Phenomena, 07/8/92
******************************************************************************/
{
	int i;
	float r1,*d,*b,*c,*e;
	
	/* allocate workspace */
	d = alloc1float(na-2);
	b = alloc1float(na-2);
	c = alloc1float(na-2);
	e = alloc1float(na-2);
	
	r1 = r+dr;
 	
	/* Crank-Nicolson */
 	for (i=0; i<na-2; ++i) {
		d[i] = (uc[i+1]+un[i+1])/(2.0*dr);
		e[i] = (wn[i+1]/(r1*r1)+wc[i+1]/(r*r))/(8.0*da);
		b[i] = 1.0-(sc[i+2]-sc[i])*e[i]
			+d[i]*sc[i+1];
		c[i] = -e[i];
	} 
	d[0] += c[0];
	d[na-3] += e[na-3]; 
	
	tripp(na-2,d,e,c,b);
	for(i=0;i<na-2; ++i) sn[i+1]=b[i];
	sn[0] = sn[1];
	sn[na-1] = sn[na-2];
	
	
	/* free workspace */
	free1float(d);
	free1float(c);
	free1float(e);
	free1float(b);
}


void beta (int na, float da, float r, float dr, 
	float uc[], float wc[], float bc[],
	float un[], float wn[], float bn[])
/*****************************************************************************
difference equation extrapolation of "beta" in polar coordinates
******************************************************************************
Input:
na		number of a samples
da		a sampling interval
r		current radial distance r
dr		radial distance to extrapolate
uc		array[na] of dt/dr at current r
wc		array[na] of dt/da at current r
bc		array[na] of beta  at current r
un		array[na] of dt/dr at next r
wn		array[na] of dt/da at next r

Output:
bn		array[na] of beta at next r 
******************************************************************************

This function implements the Crank-Nicolson finite-difference method, with 
boundary conditions dbeta/da=1. 

author:  Zhenyue Liu, Center for Wave Phenomena, 07/8/92
******************************************************************************/
{
	int i;
	float r1,*d,*b,*c,*e;
	
	/* allocate workspace */
	d = alloc1float(na-2);
	b = alloc1float(na-2);
	c = alloc1float(na-2);
	e = alloc1float(na-2);
	
	r1 = r+dr;
	/* Crank-Nicolson */
   	for (i=0; i<na-2; ++i) {
		d[i] = uc[i+1]*r*r+un[i+1]*r1*r1;
		e[i] = (wn[i+1]+wc[i+1])*dr/(4.0*da);
		b[i] = -(bc[i+2]-bc[i])*e[i]
			+d[i]*bc[i+1];
		c[i] = -e[i];
	}   
	d[0] += c[0];
	d[na-3] += e[na-3]; 
	b[0] += da*c[0];
	b[na-3] -= da*e[na-3];
	
	tripp(na-2,d,e,c,b);
	for(i=0;i<na-2; ++i) bn[i+1]=b[i];
	bn[0] = bn[1]-da;
	bn[na-1] = bn[na-2]+da;
	
	
	/* free workspace */
	free1float(d);
	free1float(c);
	free1float(e);
	free1float(b);
}


a655 55

static void exch(float x, float y);
static void exch(float x, float y)
{    
	float t;
	t=x; x=y; y=t;
}
void tripp(int n, float *d, float *e, float *c, float *b)
/*******************************************************************
Solve an unsymmetric tridiagonal system that uses Gaussian elimination 
with partial pivoting
********************************************************************
Input:
d	diagonal vector of matrix
e       upper-diagonal vector of matrix
c       lower-diagonal vector of matrix
b       right-hand vector
n       dimension of matrix

Output:
b       solution vector
*******************************************************************
Author: Zhenyue Liu, Colorado School of Mines, 7/06/92
*********************************************************************/
{
	int k;
	float temp;

	
/*      elimination   */
	for(k=0; k<n-1; ++k){
	    c[k] = 0;
 	    if(ABS(d[k])<ABS(c[k+1])){
	        exch(d[k],c[k+1]);
		exch(e[k],d[k+1]);
		exch(c[k],e[k+1]);
		exch(b[k],b[k+1]);
		} 
		
	    if(d[k]==0 ) err("coefficient matrix is singular!\n");
	    temp = c[k+1]/d[k];  
	    d[k+1] -= temp*e[k];
	    e[k+1] -= temp*c[k];
	    b[k+1] -= temp*b[k];
        } 
	 
/*      substitution      */
	if(d[n-1]==0 ) err("coefficient matrix is singular!\n");
	b[n-1] = b[n-1]/d[n-1];
	b[n-2] = (b[n-2] - b[n-1]*e[n-2])/d[n-2];		
	for(k=n-3; k>=0; --k)
	    b[k] = (b[k] - b[k+1]*e[k] - b[k+2]*c[k])/d[k];
	    
}	

d657 1
a657 1
void eiktam (float xs, float zs, int nz, float dz, float fz, int nx, 
d685 2
d795 1
a795 1
 		sigma(na,da,r,dr,up[ir],wp[ir],tp[ir],
d808 1
a808 1
 		beta(na,da,r,dr,up[ir],wp[ir],tp[ir],
@


1.9
log
@Using two argument CHECK_NT macro to check the relevant time sample
quantity.
@
text
@d1 1
a1 1
/* SUSYNVXZCS: $Revision: 1.8 $ ; $Date: 1996/02/21 22:21:52 $	*/
d75 1
a75 1
 *	Author:  Zhenyue Liu, 07/20/92, Center for Wave Phenomena
d78 3
d134 1
a134 1
		**vold,**vpold,**told,**aold,**sgold,
d136 1
a136 1
		**v,**vp,**tg1,**ag1,**sgg1;
d185 12
a196 9
	} 
	for (ixg=0; ixg<nxg; ++ixg) {
		/* compute receiver coordinates */
		xg = fxg+ixg*dxg;
		if (fx>xg || ex<xg) 
		err("receiver lies outside of specified (x,z) grid\n");
	} 
		
	
d300 2
a301 1
		xg = fxg+ixg*dxg;
@


1.8
log
@Using CHECK_NT macro.
Removed numerous unused variables (per -Wall).
@
text
@d1 1
a1 1
/* SUSYNVXZCS: $Revision: 1.7 $ ; $Date: 1996/02/20 23:05:13 $	*/
d148 1
a148 1
	if (!getparint("nt",&nt)) nt = 501; CHECK_NT(nt);
@


1.7
log
@Protect against nt >SU_NFLTS.
@
text
@d1 1
a1 1
/* SUSYNVXZCS: $Revision: 1.6 $ ; $Date: 1996/02/07 15:38:24 $	*/
d120 1
d123 1
a123 1
	int 	nr,ir,ixz,ls,smooth,ndpfz,ns,ixs,ixg,nxs,nxg,nt,
d128 1
a128 1
		x,z,t,dsmax,fpeak,dx,dz,fx,ex,fx1,ex1,
d130 1
a130 1
		*trace,*ar,**xr,**zr,
d148 1
a148 2
	if (!getparint("nt",&nt)) nt = 501;
	if (nt > SU_NFLTS) err("Cannot have nt=%d > SU_NFLTS=%d",nt,SU_NFLTS);
d493 1
a493 1
	float ar,ds,xd,zd,cd,sd,vd,cg,sg,xi,zi,ci,cr,time,amp,sx,sz,
d635 1
a635 1
		uu,uumin,unew,uold,ueol,ueor,wor,or,*wtemp,*s;
d853 1
a853 1
	float r1,*d,*b,*c,*e,t;
d1040 1
a1040 1
	float ss,a,r,da,dr,fa,fr,ex,ez,ea,rmax,rmaxs,tt,
@


1.6
log
@Deal with header fields accessed/modified down to sudoc.
@
text
@d1 1
a1 1
/* SUSYNVXZCS: $Revision: 1.5 $ ; $Date: 1995/09/27 20:24:24 $	*/
d148 1
@


1.5
log
@added return EXIT_SUCCESS at the end of main
@
text
@d1 1
a1 1
/* SUSYNVXZCS: $Revision: 1.4 $ ; $Date: 1995/07/11 18:44:47 $	*/
d77 4
d289 2
a290 1
	    nxd1 = nxd;				    				
d373 1
a373 1
			/* interpolate quantities between two midpoints	*/			
d910 2
a911 1
boundary conditions sn[1]=sn[0] and sn[na-1]=sn[na-2]. ******************************************************************************
@


1.4
log
@Changed default to verbose=0.
Changed fprint's to warn's and eliminated wrapped lines the ANSI way.
Fixed program name in verbose block from SYNLVXZ to SUSYNVXZCS.
@
text
@d1 1
a1 1
/* SUSYNVXZCS: $Revision: 1.3 $ ; $Date: 1995/05/03 12:34:07 $	*/
d448 1
@


1.3
log
@changed bzero to memset
@
text
@d1 1
a1 1
/* SUSYNVXZCS: $Revision: 1.2 $ ; $Date: 95/03/15 12:48:58 $	*/
d45 1
a45 1
" verbose=1		=1 to print some useful information		",
d167 1
a167 1
	if (!getparint("verbose",&verbose)) verbose = 1;
d228 2
a229 5
		fprintf(stderr,"\nSUSYNVXZCS:\n");
		fprintf(stderr,
			"Total number of small reflecting\n"
			"segments is %d.\n",ns);
		fprintf(stderr,"\n");
d275 2
a276 1
		err("\tEkonal equation fails to solve at x=%g, z=%g\n\tfrom shot xs=%g .\n",x_err+xs,z_err,xs);
d333 3
a335 1
			fprintf(stderr,"\tEkonal equation fails to solve at x=%g, z=%g\n\tfrom receiver xg=%g .\n",x_err+xg,z_err,xg);
d359 3
a361 1
			fprintf(stderr,"\tEkonal equation fails to solve at x=%g, z=%g\n\tfrom receiver xg=%g .\n",x_err+xg,z_err,xg);
d423 1
a423 1
	    fprintf(stderr,"\t finish shot %f\n",xs);
@


1.2
log
@removed extraneous recttopolar and polartorect routines
@
text
@d1 1
a1 1
/* SUSYNVXZCS: $Revision: 1.1 $ ; $Date: 95/03/02 10:07:46 $	*/
d236 1
a236 1
	bzero(&tr,sizeof(tr));
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/* SUSYNVXZCS: $Revision: 1.2 $ ; $Date: 94/2/19 15:35:57 $	*/
a996 7
static void recttopolar (
	int nx, float dx, float fx, int ny, float dy, float fy, float **p,
	int na, float da, float fa, int nr, float dr, float fr, float **q);
static void polartorect (
	int na, float da, float fa, int nr, float dr, float fr, float **q,
	int nx, float dx, float fx, int ny, float dy, float fy, float **p);

a1180 135

static void recttopolar (
	int nx, float dx, float fx, int ny, float dy, float fy, float **p,
	int na, float da, float fa, int nr, float dr, float fr, float **q)
/*****************************************************************************
Convert a function of p(x,y) to q(a,r), where x = r*cos(a) and y = r*sin(a)
******************************************************************************
Input:
nx		number of x samples
dx		x sampling interval
fx		first x sample
ny		number of y samples
dy		y sampling interval
fy		first y sample
p		array[ny][nx] containing samples of p(x,y)
na		number of a samples
da		a sampling interval
fa		first a sample
nr		number of r samples
dr		r sampling interval
fr		first r sample

Output:
q		array[nr][na] containing samples of q(a,r)
******************************************************************************
Notes:
The polar angle a is measured in radians.

Linear extrapolation is used to determine the value of p(x,y) for
x and y coordinates not in the range corresponding to nx, dx, ....
******************************************************************************
Author:  Dave Hale, Colorado School of Mines, 06/15/90
******************************************************************************/
{
	int ia,ir,ix,iy;
	float a,r,x,y,xi,yi,sx,sy;
	
	/* for all r */
	for (ir=0,r=fr; ir<nr; ++ir,r+=dr) {
	
		/* for all a */
		for (ia=0,a=fa; ia<na; ++ia,a+=da) {
		
			/* determine x and y */
			x = r*cos(a);
			y = r*sin(a);
			
			/* determine sample indices */
			xi = (x-fx)/dx;
			ix = xi;
			if (ix<0 ) xi = ix = 0; 
			if (ix>nx-2) {ix = nx-2; xi = nx-1;}
			yi = (y-fy)/dy;
			iy = yi;
			if (iy<0) yi = iy = 0;
			if (iy>ny-2) {iy = ny-2; yi = ny-1;}
			
			/* bilinear interpolation */
			sx = xi-ix;
			sy = yi-iy;
			q[ir][ia] = (1.0-sy)*((1.0-sx)*p[iy][ix] + 
						sx*p[iy][ix+1]) +
					sy*((1.0-sx)*p[iy+1][ix] +
						sx*p[iy+1][ix+1]);
		}
	}
}

static void polartorect (
	int na, float da, float fa, int nr, float dr, float fr, float **q,
	int nx, float dx, float fx, int ny, float dy, float fy, float **p)
/*****************************************************************************
Convert a function of q(a,r) to p(x,y), where x = r*cos(a) and y = r*sin(a)
******************************************************************************
Input:
na		number of a samples
da		a sampling interval
fa		first a sample
nr		number of r samples
dr		r sampling interval
fr		first r sample
nx		number of x samples
dx		x sampling interval
fx		first x sample
ny		number of y samples
dy		y sampling interval
fy		first y sample
q		array[nr][na] containing samples of q(a,r)

Output:
p		array[ny][nx] containing samples of p(x,y)
******************************************************************************
Notes:
The polar angle a is measured in radians.

Linear extrapolation is used to determine the value of q(a,r) for
a and r coordinates not in the range corresponding to na, da, ....
******************************************************************************
Author:  Dave Hale, Colorado School of Mines, 06/15/90
******************************************************************************/
{
	int ix,iy,ia,ir;
	float x,y,a,r,ai,ri,sa,sr;
	
	/* for all y */
	for (iy=0,y=fy; iy<ny; ++iy,y+=dy) {
	
		/* for all x */
		for (ix=0,x=fx; ix<nx; ++ix,x+=dx) {
		
			/* determine a and r */
			a = atan2(y,x);
			r = sqrt(x*x+y*y);
			
			/* determine sample indices */
			ai = (a-fa)/da;
			ia = ai;
			if (ia<0) ai = ia = 0;
			if (ia>na-2) {ai = na-1; ia = na-2;}
			ri = (r-fr)/dr;
			ir = ri;
			if (ir<0) ri = ir = 0;
			if (ir>nr-2) {ri = nr-1; ir = nr-2;}
			
			/* bilinear interpolation */
			sa = ai-ia;
			sr = ri-ir;
			p[iy][ix] = (1.0-sr)*((1.0-sa)*q[ir][ia] + 
						sa*q[ir][ia+1]) +
					sr*((1.0-sa)*q[ir+1][ia] +
						sa*q[ir+1][ia+1]);
		}
	}
}

@
