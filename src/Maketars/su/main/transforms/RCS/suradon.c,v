head	1.21;
access;
symbols;
locks; strict;
comment	@ * @;


1.21
date	2015.08.07.22.26.35;	author john;	state Exp;
branches;
next	1.20;

1.20
date	2011.11.16.23.35.04;	author john;	state Exp;
branches;
next	1.19;

1.19
date	2011.11.12.00.42.19;	author john;	state Exp;
branches;
next	1.18;

1.18
date	2010.12.08.17.35.01;	author john;	state Exp;
branches;
next	1.17;

1.17
date	2008.05.05.20.50.21;	author john;	state Exp;
branches;
next	1.16;

1.16
date	2005.12.07.17.11.15;	author john;	state Exp;
branches;
next	1.15;

1.15
date	2003.06.09.16.17.07;	author john;	state Exp;
branches;
next	1.14;

1.14
date	97.07.28.22.36.46;	author john;	state Exp;
branches;
next	1.13;

1.13
date	96.09.13.21.49.05;	author john;	state Exp;
branches;
next	1.12;

1.12
date	96.02.07.23.37.07;	author jkc;	state Exp;
branches;
next	1.11;

1.11
date	96.02.05.16.44.23;	author jkc;	state Exp;
branches;
next	1.10;

1.10
date	95.08.02.21.20.22;	author jkc;	state Exp;
branches;
next	1.9;

1.9
date	95.04.10.10.48.06;	author john;	state Exp;
branches;
next	1.8;

1.8
date	94.10.18.12.56.19;	author john;	state Exp;
branches;
next	1.7;

1.7
date	94.09.23.10.52.51;	author john;	state Exp;
branches;
next	1.6;

1.6
date	94.09.06.10.21.36;	author jkc;	state Exp;
branches;
next	1.5;

1.5
date	94.07.27.13.31.40;	author john;	state Exp;
branches;
next	1.4;

1.4
date	94.06.23.14.55.38;	author jkc;	state Exp;
branches;
next	1.3;

1.3
date	94.06.15.11.00.58;	author john;	state Exp;
branches;
next	1.2;

1.2
date	93.06.16.15.34.32;	author john;	state Exp;
branches;
next	1.1;

1.1
date	93.06.09.14.40.37;	author john;	state Exp;
branches;
next	;


desc
@suradon --- radon transform seismic data
@


1.21
log
@ Klaus Bolding Rasmussen  patched an source of instability
@
text
@/* Copyright (c) Colorado School of Mines, 2011.*/
/* All rights reserved.                       */

/* SURADON: $Revision: 1.20 $ ; $Date: 2011/11/16 23:35:04 $	*/

#include "su.h"
#include "segy.h"
#include "header.h"
#include "VND.h"

/*********************** self documentation **********************/
char *sdoc[] = {
"									",
" SURADON - compute forward or reverse Radon transform or remove multiples",
"           by using the parabolic Radon transform to estimate multiples",
"           and subtract.						",
"									",
"     suradon <stdin >stdout [Optional Parameters]			",
"									",
" Optional Parameters:							",
" choose=0    0  Forward Radon transform				",
"             1  Compute data minus multiples				",
"             2  Compute estimate of multiples				",
"             3  Compute forward and reverse transform			",
"             4  Compute inverse Radon transform			",
" igopt=1     1  parabolic transform: g(x) = offset**2			",
"             2  Foster/Mosher psuedo hyperbolic transform		",
"                   g(x) = sqrt(depth**2 + offset**2)			",
"             3  Linear tau-p: g(x) = offset				",
"             4  abs linear tau-p: g(x) = abs(offset)			",
" offref=2000.    reference maximum offset to which maximum and minimum	",
"                 moveout times are associated				",
" interoff=0.     intercept offset to which tau-p times are associated	",
" pmin=-200       minimum moveout in ms on reference offset		",
" pmax=400        maximum moveout in ms on reference offset		",
" dp=16           moveout increment in ms on reference offset		",
" pmula=80        moveout in ms on reference offset where multiples begin",
"                     at maximum time					",
" pmulb=200       moveout in ms on reference offset where multiples begin",
"                     at zero time					",
" depthref=500.   Reference depth for Foster/Mosher hyperbolic transform",
" nwin=1          number of windows to use through the mute zone	",
" f1=60.          High-end frequency before taper off			",
" f2=80.          High-end frequency					",
" prewhite=0.1    Prewhitening factor in percent.			",
" cdpkey=cdp      name of header word for defining ensemble		",
" offkey=offset   name of header word with spatial information		",
" nxmax=240       maximum number of input traces per ensemble		",
" ltaper=7	  taper (integer) for mute tapering function		",
"									",
" Optimizing Parameters:						",
" The following parameters are occasionally used to avoid spatial aliasing",
" problems on the linear tau-p transform.  Not recommended for other	",
" transforms...								",
" ninterp=0      number of traces to interpolate between each input trace",
"                   prior to computing transform			",
" freq1=4.0      low-end frequency in Hz for picking (good default: 3 Hz)",
"                (Known bug: freq1 cannot be zero) ",
" freq2=20.0     high-end frequency in Hz for picking (good default: 20 Hz)",
" lagc=400       length of AGC operator for picking (good default: 400 ms)",
" lent=5         length of time smoother in samples for picker		",
"                     (good default: 5 samples)				",
" lenx=7         length of space smoother in samples for picker		",
"                     (good default: 1 sample)				",
" xopt=1         1 = use differences for spatial derivative		",
"                        (works with irregular spacing)			",
"                0 = use FFT derivative for spatial derivatives		",
"                      (more accurate but requires regular spacing and	",
"                      at least 16 input tracs--will switch to differences",
"                      automatically if have less than 16 input traces)	",
"									",
NULL};

/* Credits:
 *	CWP: John Anderson (visitor to CSM from Mobil) Spring 1993
 *
 * Multiple removal notes:
 *	Usually the input data are NMO corrected CMP gathers.  The
 *	first pass is to compute a parabolic Radon transform and
 * 	identify the multiples in the transform domain.  Then, the
 * 	module is run on all the data using "choose=1" to estimate
 * 	and subtract the multiples.  See the May, 1993 CWP Project
 *	Review for more extensive documentation.
 *
 * NWIN notes:
 *	The parabolic transform runs with higher resolution if the
 * 	mute zone is honored.  When "nwin" is specified larger than
 *   	one (say 6), then multiple windows are used through the mute
 * 	zone.  It is assumed in this case that the input data are
 * 	sorted by the offkey header item from small offset to large
 * 	offset.  This causes the code to run 6 times longer.  The
 *      mute time is taken from the "muts" header word.
 *      You may have to manually set this header field yourself, if
 *      it is not already set.
 *
 * References:
 * Anderson, J. E., 1993, Parabolic and linear 2-D, tau-p transforms
 *       using the generalized radon tranform, in May 11-14, 1993
 *       Project Review, Consortium Project on Seismic Inverse methods
 *       for Complex Structures, CWP-137, Center for Wave Phenomena
 *       internal report.
 * Other References cited in above paper:
 * Beylkin, G,.1987, The discrete Radon transform: IEEE Transactions
 *       of Acoustics, Speech, and Signal Processing, 35, 162-712.
 * Chapman, C.H.,1981, Generalized Radon transforms and slant stacks:
 *       Geophysical Journal of the Royal Astronomical Society, 66,
 *       445-453.
 * Foster, D. J. and Mosher, C. C., 1990, Multiple supression
 *       using curvilinear Radon transforms: SEG Expanded Abstracts 1990,
 *       1647-1650.
 * Foster, D. J. and Mosher, C. C., 1992, Suppression of multiples
 *       using the Radon transform: Geophysics, 57, No. 3, 386-395.
 * Gulunay, N., 1990, F-X domain least-squares Tau-P and Tau-Q: SEG
 *       Expanded Abstracts 1990, 1607-1610.
 * Hampson, D., 1986, Inverse velocity stacking for multiple elimination:
 *       J. Can. Soc. Expl. Geophs., 22, 44-55.
 * Hampson, D., 1987, The discrete Radon transform: a new tool for image
 *       enhancement and noise suppression: SEG Expanded Abstracts 1978,
 *       141-143.
 * Johnston, D.E., 1990, Which multiple suppression method should I use?
 *       SEG Expanded Abstracts 1990, 1750-1752.
 *
 * Trace header words accessed: ns, dt, cdpkey, offkey, muts
 */
/**************** end self doc ********************************/

static void forward_p_transform(VND *vnda,VND *vndb,int nx, int nt, float *g,
	float dt, int ntfft, int np, float pmin, float dp,
	float *mutetime, float *offset, int nk,float f1,
	float f2,float prewhite);

static void inverse_p_transform(VND *vnda,int nx, float *g,
	float dt, int ntfft, int np, float pmin, float dp, int ip1,
	float f1,float f2);
static void compute_r(float w, int nx, float *g, int np, float dp, complex *r);
static void compute_rhs(float w, int nx, float *g, complex *data, int np,
		float pmin, float dp, complex *rhs);
static int ctoep(int n, complex *r, complex *a, complex *b,
		complex *f, complex *wrk);
static int ctoephcg(int niter, int n, complex *r, complex *a, complex *b,
		complex *wrk1, complex *wrk2, complex *wrk3, complex *wrk4 );
static float rcdot(int n, complex *a, complex *b);
static void htmul(int n, complex *a, complex *x, complex *y);
static float freqweight(int j, float df, float f1, float f2);
static float gofx(int igopt, float offset, float intercept_off,
		  float refdepth);
static void taupmute(int ip,int ipa,int ipb,int nt, int ltap, float *rt);
static void jea_xinterpolate(VND *vndorig, VND *vndinterp, int ninterp,
		int nt, int nx, float freq1, float freq2, int lagc,
		int lent, int lenx, int xopt, float dt, int iopt);
static void runav(int n,int len,float *a,float *b);

segy tr;
segy tro;
int main(int argc, char **argv)
{
	char *cdpkey=NULL;	/* key denoting the ensemble */
	char *offkey=NULL;	/* key denoting trace labeling in an ensemble */
	char *headerfile=NULL;	/* temporary file containing trace headers */
	char *fname=NULL;
	int j;
	int it;
	int icount;
	int oldcmp;
	int icmp;
	int nxmax;
	int nx;
	int nxinterp;
	int nxout=0;
	int np;
	int ipa;
	int ipb;
	int ix;
	int ninterp;
	int k;
	int nt;
	int lent;
	int lenx;
	int lagc;
	int xopt=0;
	int ntfft;
	int nxm;
	int nmax;
	int choose;
	int nk;
	int igopt;
	int ltaper;
	int cdpindex;
	int offindex;
	int iend;
	int ieod;
	float offref;
	float depthref;
	float intercept_off;
	float pmin;
	float pmax;
	float pmula;
	float pmulb;
	float dp;
	float dt;
	float freq1;
	float freq2;
	float f1;
	float f2;
	float prewhite;
	float fac;
	float d;
	float *rt=NULL;
	float *xin=NULL;
	float *offset=NULL;
	float *mutetime=NULL;
	float *g=NULL;
	float *gg=NULL;
	float *trace=NULL;
	Value hdrwd;
	FILE *headerfp=NULL;
	VND *vndorig=NULL;
	VND *vndinterp=NULL;
	VND *vndresult=NULL;

	initargs(argc, argv);
	requestdoc(1);

	if (!getparint("xopt",&xopt))	xopt=1;
	if (!getparstring("cdpkey",&cdpkey)) cdpkey="cdp";
	if (!getparstring("offkey",&offkey)) offkey="offset";
	if (!getparint("choose",&choose)) choose=0;
	if (!getparint("ninterp",&ninterp)) ninterp=0;
	if (!getparint("nwin",&nk)) nk=1;
	if (!getparint("igopt",&igopt)) igopt=1;
	if (!getparint("nxmax",&nxmax)) nxmax=240;
	if (!getparint("ninterp",&ninterp)) ninterp=1;
	if (!getparint("lagc",&lagc))lagc=400;
	if (!getparint("lent",&lent)) lent=5;
	if (!getparint("lenx",&lenx)) lenx=7;
	if (!getparfloat("freq1",&freq1)) freq1=4.;
	if (!getparfloat("freq2",&freq2)) freq2=20.;
	if (!getparfloat("offref",&offref)) offref=2000.;
	if (!getparfloat("f1",&f1)) f1=60.;
	if (!getparfloat("f2",&f2)) f2=80.;
	if (!getparfloat("pmin",&pmin)) pmin=-200.;
	if (!getparfloat("pmax",&pmax)) pmax=400.;
	if (!getparfloat("dp",&dp)) dp=16.;
	if (!getparfloat("pmula",&pmula)) pmula=80.;
	if (!getparfloat("pmulb",&pmulb)) pmulb=200.;
	if (!getparfloat("depthref",&depthref)) depthref=500.;
	if (!getparfloat("interoff",&intercept_off)) intercept_off=0.;
	if (!getparfloat("prewhite",&prewhite)) prewhite=0.1;
	if (!getparint("ltaper",&ltaper)) ltaper=7;


        checkpars();

	cdpindex=getindex(cdpkey);
	offindex=getindex(offkey);
	if(nk<0) nk=1;
	fac=1000.*gofx(igopt,offref,intercept_off,depthref);
	pmin/=fac;
	pmax/=fac;
	dp/=fac;
	pmula/=fac;
	pmulb/=fac;
	ipa=( pmula -  pmin)/ dp;
	ipb=( pmulb -  pmin)/ dp;
	np=1+( pmax -  pmin)/ dp;
	if(np<1)err("Range of PMIN and PMAX invalid");
	if(choose==0) ipa=0;
	if(choose==3) ipa=0;
	if(choose==4) ipa=0;
	if(ipa<0) ipa=0;

	if(!gettr(&tr)) err("Can't get first trace \n");
	nt=tr.ns;
	dt = ((double) tr.dt)/1000000.0;
	gethval(&tr,cdpindex,&hdrwd);
	oldcmp=hdrwd.i;

	ntfft=npfar(nt);
	nxinterp = (1+ ninterp)*(nxmax-1)+1;
	nmax=MAX(nxinterp, np);
	nmax=MAX(nmax, ntfft+4);

	offset   = (float *)VNDemalloc(nxmax*sizeof(float),
				       "suradon_main: offset");
	rt       = (float *)VNDemalloc(nmax*sizeof(float),
				       "suradon_main: rt");
	trace    = (float *)VNDemalloc(nt*sizeof(float),
				       "suradon_main: trace");
	xin      = (float *)VNDemalloc(nxmax*sizeof(float),
				       "suradon_main: xin");
	g        = (float *)VNDemalloc(nxmax*sizeof(float),
				       "suradon_main: g");
	gg       = (float *)VNDemalloc(nxinterp*sizeof(float),
				       "suradon_main: gg");
	mutetime = (float *)VNDemalloc(nxmax*sizeof(float),
				       "suradon_main: mutetime");

	headerfile=VNDtempname("radontmp");
	if( (headerfp = fopen(headerfile,"w+"))==NULL)
		err("couldn't open temp file for trace headers");
	fname = VNDtempname("radontmp");
	vndorig = V2Dop(2,1000000,sizeof(float),fname,nt, nxmax);
	VNDfree(fname,"suradon_main: fname 1");
	fname = VNDtempname("radontmp");
	vndinterp = V2Dop(2,2000000,sizeof(float),fname,nt, nxinterp);
	VNDfree(fname,"suradon_main: fname 2");
	fname = VNDtempname("radontmp");
	nmax=MAX( nxinterp, np);
	vndresult = V2Dop(2,1000000,sizeof(float),fname,ntfft+2, nmax);
	VNDfree(fname,"suradon_main: fname 3");

	icount=0;
	icmp=0;
	nx=0;
	iend=0;
	ieod=0;
	do {
		gethval(&tr,cdpindex,&hdrwd);
		if(hdrwd.i!=oldcmp || ieod) { /* process this ensemble */
		   icmp++;
		   nxm= nx-1;
		   if( nx>1) {
			nxinterp=1 + nxm*(ninterp+1);
			if( choose==4) { /* count number of original offsets */
				k=1;
				for(j=1;j<nx;j++) {
					if(fabs(offset[j]-offset[j-1])>0.001)k++;
				}
				np=nx;
				nx=k;
			{ /* Jonathan Raven's fix */
		            int i1 = vndorig->N[0];      /* No. of samples read */
            		    int i2 = vndresult->N[0];   /* No. of samples written */
           		    for(j=0;j< np;j++){
                                V2Dr0(vndorig,j,(char *)rt,1001);
                		for (it=i1; it<i2; it++) rt[it] = 0.0;
                		V2Dw0(vndresult,j,(char *)rt,1002);
            			}
			}


/*	for(j=0;j< np;j++){					
		V2Dr0(vndorig,j,(char *)rt,1001);
		V2Dw0(vndresult,j,(char *)rt,1002);
	}
*/
			}else{
				jea_xinterpolate( vndorig, vndinterp,
					 ninterp, nt, nx,
					 freq1, freq2, lagc,
					 lent, lenx, xopt, dt,0);
				d=1./(1.+ ninterp);
				for(j=0;j<nxinterp;j++) rt[j]=j*d;
				for(j=0;j<nx;j++) xin[j]=j;
				intlin(nx,xin,offset,offset[0],
					 offset[ nxm],nxinterp,rt,gg);
				for(j=0;j<nxinterp;j++)
					 gg[j]=gofx(igopt,gg[j],
						 intercept_off,depthref);
				forward_p_transform( vndinterp,
					 vndresult, nxinterp,nt,gg,dt,
					 ntfft,np,pmin,dp,mutetime,
					 offset,nk,f1,f2,prewhite);
				nxout= np;
			}
			if(choose>=1) {
				if( choose==1){
					/* do tau-p mute here */
					for(j=0;j< ipb;j++) {
						V2Dr0( vndresult,j,
						      (char *) rt,1003);
						taupmute(j,ipa,ipb,
							 ntfft,ltaper,rt);
						V2Dw0( vndresult,j,
						      (char *) rt,1004);
					}
				}
				inverse_p_transform( vndresult, nx,
					 g, dt, ntfft, np,
					 pmin, dp, ipa, f1, f2);
				if(choose==1){
				    for(ix=0;ix< nx;ix++) {
					V2Dr0( vndorig,ix,(char *)trace,1005);
					V2Dr0( vndresult,ix,(char *) rt,1006);
					for(it=0;it< nt;it++)
						 rt[it]=trace[it]- rt[it];
					V2Dw0( vndresult,ix,(char *) rt,1007);
				    }
				}
				nxout= nx;
			}
						VNDmemchk(rt,"rt 01 e");
			erewind(headerfp);
			for(ix=0;ix<nxout;ix++) {
				if(ix<nx) efread(&tro,HDRBYTES,1,headerfp);
				V2Dr0(vndresult,ix,(char *)rt,1008);
				for(j=0;j< nt;j++) tro.data[j]=rt[j];
				icount++;
				tro.tracl = icount;
				tro.tracr = ix+1;
				if( choose==0) {
					tro.f2=1000.*( pmin+ ix* dp)*
						gofx( igopt, offref,
						     intercept_off, depthref);
					tro.d2=1000.*dp*gofx( igopt, offref,
							     intercept_off,
							     depthref);
				}
				puttr(&tro);
			}
		   }else{  /* pass input data unmodified */
			erewind(headerfp);
			efread(&tro,HDRBYTES,1,headerfp);
			V2Dr0(vndorig,0,(char *)rt,1009);
			for(j=0;j< nt;j++) tro.data[j]=rt[j];
			icount++;
			tro.tracl = icount;
			tro.tracr = 1;
			puttr(&tro);
		   }
		   oldcmp=hdrwd.i;
		   erewind(headerfp);
		   nx=0;
		}
		/* save trace and header */
		efwrite(&tr,HDRBYTES,1,headerfp);
		gethval(&tr,offindex,&hdrwd);
		offset[nx]=hdrwd.i;
		g[nx]=gofx(igopt,offset[nx],intercept_off,depthref);
		mutetime[nx]=tr.muts;
		V2Dw0(vndorig,nx,(char *)tr.data,1010);
		nx++;
		if(ieod) {
			iend++;
		}else{
			if(gettr(&tr)) {
				iend=0;
			}else{
				iend=1;
				ieod=1;
			}
		}
	}while(iend<2);

/* free memory and temporary file space */
    	VNDfree(offset,"suradon_main: offset");
	VNDfree(rt,"suradon_main: rt");
	VNDfree(trace,"suradon_main: trace");
	VNDfree(xin,"suradon_main: xin");
	VNDfree(g,"suradon_main: g");
	VNDfree(gg,"suradon_main: gg");
	VNDfree(mutetime,"suradon_main: mutetime");
	fclose(headerfp);
	remove(headerfile);
	VNDfree(headerfile,"suradon_main: headerfile");
	VNDcl(vndorig,1);
	VNDcl(vndinterp,1);
	VNDcl(vndresult,1);
	if(VNDtotalmem()!=0) {
		fprintf(stderr,"Warning, not all of the VND memory \n");
		fprintf(stderr,"has been freed and checked for overruns\n");
		fprintf(stderr,"Total VND memory at end of job = %ld\n",
		VNDtotalmem());
	}
	return(CWP_Exit());
}

static void forward_p_transform(VND *vnda,VND *vndb,int nx, int nt, float *g,
	float dt, int ntfft, int np, float pmin, float dp,
	float *mutetime, float *offset, int nk,float f1, float f2,
	float prewhite)
/*******************************************************************
do forward generalized radon transform

******************************************************************
Function parameters:

VND *vnda	input data in time-space domain
VND *vndb	output data in tau-p domain
int nx		number of input traces
int nt		number of intput time samples
float *g	g[ix]=offset**2 for parabolic transform
float dt	sample rate in seconds
int ntfft	length of time fft and output tau-p data in samples
int np		number of generalized ray parameters
float pmin	minimum generalized ray parameter
float dp	generalized ray parameter increment
float *mutetime array of mute times in ms
float *offset   array of offsets (ignored)
int nk          number of offset ranges to transform separately
		through the mute zone
float f1        max freq without taper
float f2        max non-zero freq component
prewhite	0.01 means prewhiten 1 percent

key assumption: offsets are sorted to increase with index
*******************************************************************
Author: John Anderson (visitor to CSM from Mobil) Spring 1993
*******************************************************************/
{
	int ix,ip,it,iw,j,ntfftny,k,nxx,nxxinc,ik,ik2;
	size_t nmax;
	float *rt=NULL,*rrt=NULL,*kindex=NULL,*tindex=NULL,w,dw,rsum,fac,wa,wb,rk[2],rit[2],df;
	complex czero,*crt=NULL,*ccrt=NULL,*r=NULL,*rhs=NULL,*wrk1=NULL,*wrk2=NULL,*wrk3=NULL,*wrk4=NULL;
	VND *vndc=NULL;
	char *fname=NULL;

	fac=1./ntfft;
	ntfftny=1+ntfft/2;
	df=1./(ntfft*dt);
	dw=2.*PI*df;
	nmax=MAX(vndb->N[0],vndb->N[1]);
	nxxinc=1+(nx-1)/nk;
	czero.r=czero.i=0.;

	if(nk>1) {
/* allocate file space and build a set of (mute time, group index) pairs */
		fname=VNDtempname("radontmp");
		vndc = V2Dop(2,1000000,sizeof(complex),fname,
				ntfftny,np*nk);
		VNDfree(fname,"forward_p_transform: fname");
		kindex = offset; /* dummy assignment */
		kindex=(float *)VNDemalloc(nk*sizeof(float),
			"forward_p_transform:kindex");
		tindex=(float *)VNDemalloc(nk*sizeof(float),
			"forward_p_transform:tindex");
		for(k=0;k<nk;k++) {
			kindex[k]=k;
			nxx=MIN(nx,(k+0.75)*nxxinc);
			tindex[k]=0.001*mutetime[nxx]/dt;
		}
	}else{
		vndc = vndb;
	}

	crt=(complex *)VNDemalloc(nmax*sizeof(complex),
		"forward_transform:crt");
	rt=(float *)crt;
	ccrt=(complex *)VNDemalloc(MAX((nk+1)*np,vndb->N[1])*sizeof(complex),
		"forward_transform:ccrt");
	rrt=(float *)ccrt;
	r=(complex *)VNDemalloc(np*sizeof(complex),
		"forward_p_transform:r");
	rhs=(complex *)VNDemalloc(np*sizeof(complex),
		"forward_p_transform:rhs");
	wrk1=(complex *)VNDemalloc(np*sizeof(complex),
		"forward_p_transform:wrk1");
	wrk2=(complex *)VNDemalloc(np*sizeof(complex),
		"forward_p_transform:wrk2");
	wrk3=(complex *)VNDemalloc(np*sizeof(complex),
		"forward_p_transform:wrk3");
	wrk4=(complex *)VNDemalloc(np*sizeof(complex),
		"forward_p_transform:wrk4");


/* do forward time to frequency fft */
	for(ix=0;ix<nx;ix++) {
		V2Dr0(vnda,ix,(char *)rt,201);
		for(it=0;it<nt;it++) rt[it]*=fac;
		for(j=nt;j<ntfft;j++) rt[j]=0.;
		pfarc(1,ntfft,rt,crt);
		V2Dw0(vndb,ix,(char *)crt,202);
	}
	VNDr2c(vndb);

/* do radon transform, frequency by frequency, for multiple spatial windows */
	for(iw=0;iw<ntfftny;iw++) {
		wa=freqweight(iw,df,f1,f2);
		if(wa>0.) {
		    w=iw*dw;
		    V2Dr1(vndb,iw,(char *)crt,203);
		    if(wa<1.) {
		    	for(ix=0;ix<nx;ix++) crt[ix]=crmul(crt[ix],wa);
		    }
		    for(k=0;k<nk;k++) {
			nxx=MIN(nx,(k+1)*nxxinc);
			compute_rhs(w,nxx,g,crt,np,pmin,dp,rhs);
			compute_r(w,nxx,g,np,dp,r);
			r[0].r *= (1.+prewhite);
			for(rsum=0.,j=1;j<np;j++)
				rsum +=sqrt(r[j].r*r[j].r + r[j].i*r[j].i);
			rsum=rsum/r[0].r;
			if (rsum>1.+np/5) {
				j=ctoephcg(np/7,np,r,&ccrt[k*np],rhs,
					wrk1,wrk2,wrk3,wrk4);
			}else{
				j=ctoep(np,r,&ccrt[k*np],rhs,wrk1,wrk2);
			}
		    }
		}else{
		    for(ip=0;ip<np*nk;ip++) ccrt[ip]=czero;
		}
		V2Dw1(vndc,iw,(char *)ccrt,204);
	}

/* do fourier transform from frequency to tau */
	for(ip=0;ip<np*nk;ip++) {
		V2Dr0(vndc,ip,(char *)crt,205);
		pfacr(-1,ntfft,crt,rt);
		V2Dw0(vndc,ip,(char *)rt,206);
	}
	VNDc2r(vndc);

/* merge appropriate tau-p transform for each window using mute zone
   information */
	if(nk>1) {
		VNDc2r(vndb);
		for(it=0;it<ntfft;it++) {
			rit[0]=it;
			intlin(nk,tindex,kindex,kindex[0],kindex[nk-1],1,rit,rk);
			ik=rk[0];
			ik2=MIN(ik+1,nk-1);
			wb=rk[0]-ik;
			wa=1-wb;
			V2Dr1(vndc,it,(char *)rrt,207);
			for(ip=0;ip<np;ip++) {
				rt[ip]=wa*rrt[ik*np+ip]+ wb*rrt[ik2*np+ip];
			}
			V2Dw1(vndb,it,(char *)rt,208);
		}
		VNDcl(vndc,1);
		VNDfree(tindex,"forward_p_transform: tindex");
		VNDfree(kindex,"forward_p_transform: kindex");
	}
	VNDfree(crt,"forward_p_transform: crt");
	VNDfree(ccrt,"forward_p_transform: ccrt");
	VNDfree(r,"forward_p_transform: r");
	VNDfree(rhs,"forward_p_transform: rhs");
	VNDfree(wrk1,"forward_p_transform: wrk1");
	VNDfree(wrk2,"forward_p_transform: wrk2");
	VNDfree(wrk3,"forward_p_transform: wrk3");
	VNDfree(wrk4,"forward_p_transform: wrk4");
	return;
}
static float gofx(int igopt, float offset, float intercept_off,float refdepth)
/*******************************************************************
return g(x) for various options
******************************************************************
Function parameters:

int igopt		1 = parabolic transform
			2 = Foster/Mosher pseudo hyperbolic option
			3 = linear tau-p
			4 = linear tau-p using absolute value of
				offset
float offset		offset in m
float intercept_off	offset corresponding to intercept time
float refdepth		reference depth in m for igopt=2
*******************************************************************
Author: John Anderson (visitor to CSM from Mobil) Spring 1993
*******************************************************************/
{
	offset=offset-intercept_off;
	if(igopt==1) {
		return(offset*offset);
	}
	if(igopt==2) {
		return( sqrt(refdepth*refdepth + offset*offset) );
	}
	if(igopt==3) {
		return(offset);
	}
	if(igopt==4) {
		return(fabs(offset));
	}
	return(offset);
}
static float freqweight(int j, float df, float f1, float f2)
/*******************************************************************
return weight for each frequency
******************************************************************
Function parameters:

int j		freq index
float df	freq increment
float f1	taper off freq
float f2	freq beyond which all components are zero
*******************************************************************
Author: John Anderson (visitor to CSM from Mobil) Spring 1993
*******************************************************************/
{
	float w;
	float f=j*df;
	if(f<=f1) return (1.);
	if(f>=f2) return (0.);
	w = (f2-f)/(f2-f1);
	return (w);
}

static void taupmute(int ip,int ipa,int ipb,int nt, int ltap, float *rt)
/*******************************************************************
do simple tau-p mute to elliminate multiples
******************************************************************
Function parameters:

int ip		current ray parameter index
int ipa		max ray parameter primary  pick at maximum time
int ipb		max ray parmater primary pick at minimum time
int nt		number of time samples
int ltap	length of mute taper in samples
float rt[nt]	tau-p data for all tau values

*******************************************************************
Author: John Anderson (visitor to CSM from Mobil) Spring 1993
*******************************************************************/

{
	int j,k;
	float w;
	if(ip>=ipb) return;
	if(ip<=ipa) {
		for(k=0;k<nt;k++) rt[k]=0;
		return;
	}
	w=MAX(ipb-ipa,1);
	w=(ipb-ip)/w;
	j=w*nt;
	for(k=0;k<j;k++) rt[k]=0.;
	for(k=j;k<MIN(nt,j+ltap);k++) rt[k]*=(k-j)/ltap;
}

static void inverse_p_transform(VND *vnda,int nx, float *g, float dt,
	int ntfft, int np, float pmin, float dp, int ip1,
	float f1, float f2)
/*******************************************************************
do inverse generalized radon transform

******************************************************************
Function parameters:

VND *vnda	output data in tau-p domain and data in time-space domain
int nx		number of output traces
int nt		number of output time samples
float *g	g[ix]=offset**2 for parabolic transform
float dt	sample rate in seconds
int ntfft	length of time fft and input tau-p data in samples
int np		number of generalized ray parameters
float pmin	minimum generalized ray parameter
float dp	generalized ray parameter increment
int ip1		starting generalized ray parameter index to compute
		(use as 0 for full inversion, positive integer to
		just invert multiples)
float f1        max freq without taper
float f2        max non-zero freq component
*******************************************************************
Author: John Anderson (visitor to CSM from Mobil) Spring 1993
*******************************************************************/
{
	int ip,iw,ntfftny,ix,it;
	size_t nmax;
	float w,dw,p,rsum,isum,dr,di,tr,ti,fac,wa,df;
	float *rt=NULL;
	complex *crt=NULL, *ctemp=NULL,czero;

	ntfftny=1+ntfft/2;
	df=1./(ntfft*dt);
	dw=2.*PI*df;
	czero.r=czero.i=0.;

	nmax=MAX(vnda->N[0],2*vnda->N[1])*vnda->NumBytesPerNode;
	nmax=MAX(nmax,nx*sizeof(complex));

	crt=(complex *)VNDemalloc(nmax,
		"inverse_p_transform:crt");
	rt=(float *)crt;
	ctemp=(complex *)VNDemalloc(np*sizeof(complex),
		"inverse_p_transform:ctemp");

	fac=1./ntfft;
	ntfftny=ntfft/2+1;
	for(ip=0;ip<np;ip++) {
		V2Dr0(vnda,ip,(char *)rt,301);
		for(it=0;it<ntfft;it++) rt[it]*=fac;
		pfarc(1,ntfft,rt,crt);
		V2Dw0(vnda,ip,(char *)crt,302);
	}
	VNDr2c(vnda);

	fac=1./np;
	for(iw=0;iw<ntfftny;iw++) {
		wa=freqweight(iw,df,f1,f2);
		if(wa>0.) {
			w=iw*dw;
			V2Dr1(vnda,iw,(char *)crt,303);
			if(wa<1.) {
				for(ip=0;ip<np;ip++) crt[ip]=crmul(crt[ip],wa);
			}
			for(ip=0;ip<np;ip++) ctemp[ip]=crt[ip];
			for(ix=0;ix<nx;ix++) {
			    rsum = isum = 0.;
			    for(ip=ip1;ip<np;ip++) {
				p = pmin + ip*dp;
				tr = cos(w*p*g[ix]);
				ti = sin(w*p*g[ix]);
				dr = ctemp[ip].r;
				di = ctemp[ip].i;
				rsum += tr*dr - ti*di;
				isum += tr*di + ti*dr;
			    }
			    crt[ix].r   = fac*rsum;
			    crt[ix].i   = fac*isum;
			}
		}else{
			for(ix=0;ix<nx;ix++) crt[ix]=czero;
		}
		V2Dw1(vnda,iw,(char *)crt,304);
	}
	for(ix=0;ix<nx;ix++) {
		V2Dr0(vnda,ix,(char *)crt,305);
		pfacr(-1,ntfft,crt,rt);
		V2Dw0(vnda,ix,(char *)rt,306);
	}
	VNDc2r(vnda);
	VNDfree(crt,"inverse_p_transform: crt");
	VNDfree(ctemp,"inverse_p_transform: ctemp");
	return;
}

static void compute_r( float w, int nx, float *g, int np, float dp, complex *r)
/*******************************************************************
Compute the top row of the Hermitian Toeplitz Matrix
			+
		  R = B B

		  i w p g(x)
where B = (1/np) e	    for equal increments in p as

     +           -i w p g(x)
and B = (1/nx) e

as used for the Discrete Radon Transform computation for
linear or parabolic tau-p.


		 nx-1	i w j dp g(x )
r[j] = 1/(nx*np) Sum	e	    k
		 k=0
						  2
g(x ) is initialized to  x  for linear tau-p or x   for the parabolic transform
   k		          k		         k
prior to calling this routine.  The use of g is intended to emphasize that the
spatial locations do not have to be equally spaced for either method.
In general, this routine can be called for g specified as any function
of spatial position only.  For a more general function of x, dp will
not correspond to an increment in slowness or slowness squared but
rather to a more general parameter.

******************************************************************
Function parameters:

float w	input as angular frequency component of interest
int   nx      number of spatial positions stored in g
float g[]     spatial function for this Radon Transform
int   np      number of slowness (or slowness squared) components
float dp      increment in slownes (or slowness squared)
float r[]     output vector of { real r0, imaginary r0, real r1,
	      imaginary r1, ...}
******************************************************************
Author: John Anderson (visitor to CSM from Mobil) Spring 1993
******************************************************************/
{
	int j,k;
	float rsum, isum, fac;
	fac= 1./(nx*np);
	for(j=0;j<np;j++) {
		rsum=0.;
		isum=0.;
		for(k=0;k<nx;k++) {
			rsum = rsum+cos( w*j*dp*g[k] );
			isum = isum+sin( w*j*dp*g[k] );
		}
		r[j].r    = fac*rsum;
		r[j].i    = fac*isum;
	}
}

static void compute_rhs( float w, int nx, float *g, complex *data, int np,
		float pmin, float dp, complex *rhs)
/*********************************************************************
				     +
Compute the right-hand-side vector  B  data(x)

	+	    -i w p g(x)
where B   = (1/nx) e	        for equal increments in p as
used for the Discrete Radon Transform computation for
linear or parabolic tau-p.

Function parameters:

float w	input angular frequency of interest
int   nx	number of spatial positions ( defines length of g and data )
float g[]      spatial function corresponding to spatial locations of data
complex data[] data as a function of spatial position for a single
		angular frequency w as complex values
int   np	number of output slownesses p (may be slowness squared
		or a more general function)
float pmin     starting value of output p
float dp	increment in output p
complex rhs[]  np complex values for the result
*********************************************************************
Author: John Anderson (visitor to CSM from Mobil) Spring 1993
*********************************************************************/

{
	int ip, ix;
	float p, rsum, isum, dr, di, tr, ti, fac;
	fac=1./nx;
	for(ip=0;ip<np;ip++) {
		p = pmin + ip*dp;
		rsum = isum = 0.;
		for(ix=0;ix<nx;ix++) {
			tr = cos(w*p*g[ix]);
			ti = -sin(w*p*g[ix]);
			dr = data[ix].r;
			di = data[ix].i;
			rsum += tr*dr - ti*di;
			isum += tr*di + ti*dr;
		}
		rhs[ip].r   = fac*rsum;
		rhs[ip].i   = fac*isum;
	}
}

static int ctoep( int n, complex *r, complex *a, complex *b,
		 complex *f, complex *g )
/***********************************************************************
Complex Hermitian Toeplitz Solver for

N-1
Sum  R	     A  = B      for i=0,1,2,...,N-1
j=0   (i-j)   j    i

where R is Hermitian Toeplitz and A and B are complex.  For
an example 4 x 4 system,  A returns as the solution of


   R0  R1  R2  R3	A0	     B0

     *
   R1  R0  R1  R2	A1	     B1
				=
     *   *
   R2  R1  R0  R1	A2	     B2

     *   *   *
   R3  R2  R1  R0	A3	     B3

and


   R0  R1  R2  R3	F0	     1

     *
   R1  R0  R1  R2	F1	     0
				=
     *   *
   R2  R1  R0  R1	F2	     0

     *   *   *
   R3  R2  R1  R0	F3	     0


***********************************************************************
where the function parameters are defined by

n     dimension of system
*r    provides the top row of the Hermitian Toeplitz matrix R
*a    returns the complex solution vector A
*b    input as complex vector B (not changed during call)
*f    returns the complex spiking filter F
      (may be needed later for Simpson's sideways recursion
      if do search for optimum filter lag)
*g    work space of length n complex values

The function value returns as the number of successfully
computed complex filter coefficients (up to n) if successful or
0 if no coefficients could be computed.
***********************************************************************
Author: John Anderson (visitor to CSM from Mobil) Spring 1993
***********************************************************************/

{
	float er, ei, vr, vi, cr, ci, vsq;
	int j;	  	/*  for the jth iteration, j=0,n-1 	*/
	int k;			/*  for the kth component, k=0,j-1 	*/
	int jmk;		/*  j-k 				*/
	if (r[0].r==0.) return 0;

	f[0].r = 1.0/r[0].r;
	f[0].i = 0.;
	a[0].r = b[0].r/r[0].r;
	a[0].i = b[0].i/r[0].r;
	vr=1.;
	vi=0.;
	vsq=1.;

	for(j=1;j<n;j++) {     	/* iteration loop for iteration j	*/
	/*  	Compute spiking filter that outputs {v,0,0,...}
		for this iteration step j			*/
		f[j].r=0.;
		f[j].i=0.;
		er=ei=0.;
		for(k=0;k<j;k++) {
			jmk=j-k;
			er+=r[jmk].r*f[k].r+r[jmk].i*f[k].i;
			ei+=r[jmk].r*f[k].i-r[jmk].i*f[k].r;
		}
		cr  = (er*vr - ei*vi)/vsq;
		ci  = (er*vi + ei*vr)/vsq;
		vr  = vr - (cr*er+ci*ei);
		vi  = vi + (cr*ei-ci*er);
		vsq =  vr*vr + vi*vi;
		if (vsq <= 0.) break;
		for(k=0;k<=j;k++) {
			jmk=j-k;
			g[k].r = f[k].r - cr*f[jmk].r - ci*f[jmk].i;
			g[k].i = f[k].i + cr*f[jmk].i - ci*f[jmk].r;
		}
		for(k=0;k<=j;k++) {
			f[k]=g[k];
		}

		/*  Compute shaping filter for this iteration */
		a[j].r=0.;
		a[j].i=0.;
		er=ei=0.;
		for(k=0;k<j;k++) {
			jmk=j-k;
			er+=r[jmk].r*a[k].r+r[jmk].i*a[k].i;
			ei+=r[jmk].r*a[k].i-r[jmk].i*a[k].r;
		}
		er  = er-b[j].r;
		ei  = ei-b[j].i;
		cr  = (er*vr - ei*vi)/vsq;
		ci  = (er*vi + ei*vr)/vsq;
		for(k=0;k<=j;k++) {
			jmk=j-k;
			a[k].r += - cr*f[jmk].r - ci*f[jmk].i;
			a[k].i += + cr*f[jmk].i - ci*f[jmk].r;
		}
	}

	/* Properly normalize the spiking filter so that R F = {1,0,0,...} */
	/* instead of {v,0,0,...}.  To be accurate, recompute vr,vi,vsq */
	vr=vi=0.;
	for(k=0;k<j;k++) {
		vr+=r[k].r*f[k].r-r[k].i*f[k].i;
		vi+=r[k].r*f[k].i+r[k].i*f[k].r;
	}

	vsq = vr*vr + vi*vi;

	/*  Compute (er,ei) = 1./(vr,vi)   */
	er = vr/vsq;
	ei = -vi/vsq;
	for(k=0;k<j;k++) {
		f[k].r = er*f[k].r - ei*f[k].i;
		f[k].i = er*f[k].i + ei*f[k].r;
	}
	return (j);
}

static int ctoephcg( int niter, int n, complex *a, complex *x, complex *y,
	complex *s, complex *ss, complex *g, complex *rr)

/*********************************************************************

Hestenes and Stiefel conjugate gradient algorithm
specialized for solving Hermitian Toeplitz
system.  a[] is input as a vector defining the only the
top row of A.  x[] is the solution vector returned.
y[] is input.  niter is the maximum number of conjugate
gradient steps to compute.  The function returns as
the number of steps actually computed.  The other
vectors provide workspace.

Complex Hermitian Toeplitz Solver for

N-1
Sum  A	     x  = y      for i=0,1,2,...,N-1
j=0   (i-j)   j    i

where A is Hermitian Toeplitz and x and y are complex.  For
an example 4 x 4 system,  x returns as the solution of


   A0  A1  A2  A3	x0	     y0

     *
   A1  A0  A1  A2	x1	     y1
				=
     *   *
   A2  A1  A0  A1	x2	     y2

     *   *   *
   A3  A2  A1  A0	x3	     y3

********************************************************************
Author: John Anderson (visitor to CSM from Mobil) Spring 1993
*********************************************************************/
{
	int j, iter;
	complex czero;
	float alpha, beta, gamma, gammam, rsq, rp, test;
	float eps=1.0e-6;
	/* fix for */
/* suradon.c:1135: warning: 'rcdot' defined but not used */
/* 	float rcdot(int n, complex *a, complex *b); */
	rp   = rcdot(n,y,y);
	test = n*eps*eps*rp;
	czero.r=czero.i=0.;

	for(j=0;j<n;j++) {
		x[j]=czero;
		rr[j]=y[j];
	}
	htmul(n,a,rr,g);	   /*  adjoint matrix multiply */

	for(j=0;j<n;j++) s[j]=g[j];
	gammam=rcdot(n,g,g);

	for(iter=0;iter<niter;iter++) { /* forward matrix multiply  */
		htmul(n,a,s,ss);
		alpha  = gammam/rcdot(n,ss,ss);
		for(j=0;j<n;j++) {
			x[j] =cadd(x[j],crmul(s[j],alpha));
			rr[j]=csub(rr[j],crmul(ss[j],alpha));
		}
		rsq = rcdot(n,rr,rr);
		if ( iter>0 && ( rsq==rp || rsq<test ) ) return(iter-1);
		rp = rsq;

		htmul(n,a,rr,g);   /*  adjoint matrix multiply  */
		gamma  = rcdot(n,g,g);
		if (gamma<eps) break;
		beta   = gamma/gammam;
		gammam = gamma;

		for(j=0;j<n;j++) {
			s[j] =cadd(g[j],crmul(s[j],beta));
		}
	}
return(iter);
}

/* suradon.c:1135: warning: 'rcdot' defined but not used */
static float rcdot(int n, complex *a, complex *b)
/********************************************************************
return the real part of a complex dot product where
    the first vector is the one complex conjugated
*********************************************************************
Author: John Anderson (visitor to CSM from Mobil) Spring 1993
*********************************************************************/
{
	int j;
	float sum=0.;
	for(j=0;j<n;j++) sum += a[j].r * b[j].r + a[j].i * b[j].i;
	return(sum);
}

static void htmul(int n, complex *a, complex *x, complex *y)

/*******************************************************************
   Hermitian Toeplitz matrix multiply

     solve for y = A x   where A is Hermitian Toeplitz

     and defined by the vector a giving the top row of A.
     x is input.  y is output.
*******************************************************************
Author: John Anderson (visitor to CSM from Mobil) Spring 1993
*******************************************************************/
{
	int j,irow;
	complex czero;
	czero.r=czero.i=0.;

	for(irow=0;irow<n;irow++) {
		y[irow]=czero;
		for(j=0;j<irow;j++)
			y[irow] = cadd(cmul(conjg(a[irow-j]),x[j]),y[irow]);
		for(j=irow;j<n;j++)
			y[irow] = cadd(cmul(a[j-irow],x[j]),y[irow]);
	}
}

static void jea_xinterpolate(VND *vndorig, VND *vndinterp, int ninterp,
		int nt, int nx, float freq1, float freq2, int lagc,
		int lent, int lenx, int xopt, float dt, int iopt)
/*******************************************************************
interpolate input data in space placing "ninterp" synthetic traces
between each pair of original input traces
******************************************************************
Function parameters:

VND *vndorig		VND file with input data
VND *vndinterp		VND file with output original plus interpolated data
int ninterp		number of traces to interpolate between each input
			trace
int nt			number of time samples
int nx			number of input traces
float freq1		low-end frequency in Hz for picking
						(good default: 3 Hz)
float freq2		high-end frequency in Hz for picking
						(good default: 20 Hz)
int lagc		length of AGC operator for picking
						(good default: 400 ms)
int lent		length of time smoother in samples for picker
                        (good default: 5 samples)
int lenx		length of space smoother in samples for picker
                        (good default: 1 sample)
int xopt		1 = use differences for spatial derivative
                            (works with irregular spacing)
                        0 = use FFT derivative for spatial derivatives
                            (more accurate but requires regular spacing and
                            at least 16 input tracs--will switch to differences
                            automatically if have less than 16 input traces)
float dt		sample rate in sec
int iopt		0 = interpolate: output 1+(nx-1)*(1+ninterp) traces
                            with ninterp traces between each pair of
			    input traces
			1 = compute low-pass model: output nx traces
                            on original trace locations -- This is typically
                            used for Quality Control if the interpolator
                            is failing for any reason
			2 = compute dip picks in units of samples/trace:
                            output nx traces on original trace locations

This routine outputs 'ninterp' interpolated traces between each pair of
input traces.  The values for lagc, freq1, and freq2 are only used for
event tracking. The output data will be full bandwidth with no agc.  The
suggested default parameters typically will do a satisfactory job of
interpolation for dips up to about 12 ms/trace.  Using a larger value for
freq2 causes the algorithm to do a better job on the shallow dips, but to
fail on the steep dips.  Only one dip is assumed at each time sample between
each pair of input traces.  The original input traces are passed through
this routine without modification.

The key assumption used here is that the low frequency data are unaliased
and can be used for event tracking.  Those dip picks are used to interpolate
the original full-bandwidth data, giving some measure of interpolation
at higher frequencies which otherwise would be aliased.  Using iopt equal
to 1 allows you to visually check whether the low-pass picking model
is aliased.
If you can't visually pick dips correctly on the low-pass picking
model, this computer routine will fail.

The place this code is most likely to fail is on the first breaks.

This routine assumes that the input and output files hav been allocated in
the calling routine as

char *fname;
fname=VNDtempname("main_prog");
vndorig = V2Dop(2,1000000,sizeof(float),fname,nt,nxmax);
VNDfree(fname,"jea_xinterpolate: fname");
fname=VNDtempname("main_prog");
vndinterp = V2Dop(2,1000000,sizeof(float),fname,
			nt,1+(nxmax-1)*(ninterp+1));
VNDfree(fname,"main: fname");

where nxmax is the maximum number of input traces and nt is the number
of time samples.
*******************************************************************
Author: John Anderson (visitor to CSM from Mobil) Spring 1993
*******************************************************************/
{
	int	ntfft,ntfftny,nxfft,nxfftny,j,k,ix,it,ixm;
	float	df,dff,wa,wb,dxx,eps=1e-30,f,fcl,fch;
	float 	*rt=NULL,*rrt=NULL,*a=NULL,*b=NULL,*p=NULL,*time=NULL,*aa=NULL,*bb=NULL,*save=NULL;
	complex	*crt=NULL,*ccrt=NULL;
	VND	*vnda=NULL,*vndb=NULL;
	char 	*fname=NULL;

	lent=1+2*(lent/2);
	lenx=1+2*(lenx/2);
	lagc=1 + lagc*0.001/dt;

	ntfft=npfar(nt);
	ntfftny=1+ntfft/2;
	nxfft=npfar(nx);
	nxfftny=1+nxfft/2;

	df=1./(ntfft*dt);

	crt = (complex *)VNDemalloc( MAX(ntfftny,nxfftny)*sizeof(complex),
		"jea_xinterpolate:allocating crt" );
	rt = (float *)crt;

	if(nx<2 || (iopt==0 && ninterp==0) ) {
	    	for(ix=0;ix<nx;ix++) {
			V2Dr0(vndorig,ix,(char *)rt,101);
			V2Dw0(vndinterp,ix,(char *)rt,102);
		}
		VNDfree(crt,"crt");
		return;
	}

	ccrt = (complex *)VNDemalloc( ntfftny*sizeof(complex),
		"jea_xinterpolate:allocating ccrt" );
	rrt = (float *)ccrt;
	a =  (float *)VNDemalloc( MAX(nx,nt)*sizeof(float),
		"jea_xinterpolate:allocating a" );
	b =  (float *)VNDemalloc( MAX(nx,nt)*sizeof(float),
		"jea_xinterpolate:allocating b" );
	p =  (float *)VNDemalloc( nt*sizeof(float),
		"jea_xinterpolate:allocating p" );
	time =  (float *)VNDemalloc( nt*sizeof(float),
		"jea_xinterpolate:allocating time" );
	aa =  (float *)VNDemalloc( MAX(nx,nt)*sizeof(float),
		"jea_xinterpolate:allocating aa" );
	bb =  (float *)VNDemalloc( MAX(nx,nt)*sizeof(float),
		"jea_xinterpolate:allocating bb" );

	fname = VNDtempname("jea_xinterpolate");
	vnda  = V2Dop(2,500000,sizeof(float),fname,nt,nx);
	VNDfree(fname,"jea_xinterpolate: fname");
	fname = VNDtempname("jea_xinterpolate");
	vndb  = V2Dop(2,500000,sizeof(float),fname,nt,nx);
	VNDfree(fname,"jea_xinterpolate: fname");

	eps = 0;
	for(ix=0;ix<nx;ix++) {
		V2Dr0(vndorig,ix,(char *)rt,203);
		for(j=0;j<nt;j++) eps = MAX(eps, fabs(rt[j]));
	}
	eps = MAX(1e-2*eps, 1e-30);

	/* loop computing filtered data for picking purposes in vnda */
	/* compute time derivative of filtered data in vndb */
	dff=2.*PI/ntfft;
	for(ix=0;ix<nx;ix++) {
		V2Dr0(vndorig,ix,(char *)rt,103);
		for(j=0;j<nt;j++) a[j]=fabs(rt[j]);
		runav(nt,lagc,a,b);
		runav(nt,lagc,b,a);
		for(j=0;j<nt;j++) rt[j]=rt[j]/(a[j]+ eps);
		for(j=nt;j<ntfft;j++) rt[j]=0.;
		pfarc(1,ntfft,rt,crt);
		if(freq1>0.){
			for(j=0;j<ntfftny;j++){
				f=j*df;
				fcl=(f/freq1);
				fcl=fcl*fcl*fcl*fcl;
				fch=(f/freq2);
				fch=fch*fch*fch*fch;
				f=fcl/( (1.+fcl)*(1.+fch) );
				crt[j]=crmul(crt[j],f);
				ccrt[j]=cmul(crt[j],cmplx(0.,-j*dff));
			}
		}else{
			for(j=0;j<ntfftny;j++){
				f=j*df;
				fch=(f/freq2);
				f=1./(1.+fch*fch*fch*fch);
				crt[j]=crmul(crt[j],f);
				ccrt[j]=cmul(crt[j],cmplx(0.,-j*dff));
			}
		}
		pfacr(-1,ntfft,crt,rt);
		V2Dw0(vnda,ix,(char *)rt,104);
		pfacr(-1,ntfft,ccrt,rrt);
		V2Dw0(vndb,ix,(char *)rrt,105);
	}

	if(iopt==1){
		for(ix=0;ix<nx;ix++){
			V2Dr0(vnda,ix,(char *)rt,104);
			V2Dw0(vndinterp,ix,(char *)rt,104);
		}
		VNDcl(vnda,1);
		VNDcl(vndb,1);
		VNDfree(crt,"jea_xinterpolate: crt");
		VNDfree(ccrt,"jea_xinterpolate: ccrt");
		VNDfree(a,"jea_xinterpolate: a");
		VNDfree(b,"jea_xinterpolate: b");
		VNDfree(p,"jea_xinterpolate: p");
		VNDfree(time,"jea_xinterpolate: time");
		VNDfree(aa,"jea_xinterpolate: aa");
		VNDfree(bb,"jea_xinterpolate: bb");
		return;
	}

	/* loop computing spatial derivative of data for picking purposes*/
	nxfft=npfar(nx);
	nxfftny=1+nxfft/2;
	dxx=2.*PI/(nxfft*nxfft);
	if(nx<16) xopt=1;
	for(it=0;it<nt;it++) {
		V2Dr1(vnda,it,(char *)rt,106);
		if(xopt) {
			for(j=0;j<nx-1;j++) rt[j]=rt[j+1]-rt[j];
			rt[nx-1]=rt[nx-2];
		}else{
			for(j=nx;j<nxfft;j++) rt[j]=0.;
			pfarc(1,nxfft,rt,crt);
			for(j=0;j<nxfftny;j++){
				crt[j]=cmul(crt[j],cmplx(0.,-j*dxx));
			}
			pfacr(-1,nxfft,crt,rt);
		}
		V2Dw1(vnda,it,(char *)rt,107);
	}

	/* compute dot products and smooth over time */
	for(ix=0;ix<nx;ix++) {
		V2Dr0(vnda,ix,(char *)a,108);
		V2Dr0(vndb,ix,(char *)b,109);
		for(it=0;it<nt;it++) {
			aa[it]=a[it]*b[it];
			bb[it]=b[it]*b[it];
		}
		runav(nt,lent,aa,a);
		runav(nt,lent,a,aa);
		runav(nt,lent,bb,b);
		runav(nt,lent,b,bb);
		V2Dw0(vnda,ix,(char *)aa,110);
		V2Dw0(vndb,ix,(char *)bb,111);
	}

	/* smooth dot products in x */
	if(lenx>1){
	    for(it=0;it<nt;it++) {
		V2Dr1(vnda,it,(char *)a,112);
		V2Dr1(vndb,it,(char *)b,113);
		runav(nx,lenx,a,aa);
		runav(nx,lenx,aa,a);
		runav(nx,lenx,b,bb);
		runav(nx,lenx,bb,b);
		V2Dw1(vnda,it,(char *)a,114);
		V2Dw1(vndb,it,(char *)b,115);
	    }
	}

	eps = 0;
	for(ix=0;ix<nx;ix++) {
		V2Dr0(vndb,ix,(char *)bb,218);
		for(it=0;it<nt;it++) eps = MAX(eps, bb[it]);
	}
	eps = MAX(1e-5*eps, 1e-30);

	/* loop computing p, interpolating, and outputting results */
	V2Dr0(vndorig,0,(char *)a,116);
	for(ix=1;ix<nx;ix++) {
		ixm=ix-1;
		V2Dr0(vnda,ixm,(char *)aa,117);
		V2Dr0(vndb,ixm,(char *)bb,118);
		for(it=0;it<nt;it++) {
			p[it] = - aa[it]/( bb[it] + eps );
		}
		V2Dr0(vndorig,ix,(char *)b,119);
		if(iopt==2) {
			V2Dw0(vndinterp,ixm,(char *)p,120);
			/* don't output dip picks except on original traces */
		}else{
			V2Dw0(vndinterp,ixm*(ninterp+1),(char *)a,120);
			for(k=0;k<ninterp;k++){
				wa=(1.+k)/(1+ninterp);
				wb=1.-wa;
				for(it=0;it<nt;it++) time[it] = it - p[it]*wa;
				ints8r(nt,1.0,0.,a,0.0,0.0,nt,time,aa);
				for(it=0;it<nt;it++) time[it] = it + p[it]*wb;
				ints8r(nt,1.0,0.,b,0.0,0.0,nt,time,bb);
				for(it=0;it<nt;it++)
					aa[it]=wb*aa[it]+wa*bb[it];
				V2Dw0(vndinterp,k+1+ixm*(ninterp+1),
				      (char *)aa,121);
			}
		}
		save=a;
		a=b;
		b=save;
	}
	if(iopt==2) {
		V2Dw0(vndinterp,nx-1,(char *)p,122);
	}else{
		V2Dw0(vndinterp,(nx-1)*(ninterp+1),(char *)a,122);
	}


/* close files, free temporary memory, and return results in file vndinterp */
	VNDcl(vnda,1);
	VNDcl(vndb,1);
	VNDfree(crt,"jea_xinterpolate: crt");
	VNDfree(ccrt,"jea_xinterpolate: ccrt");
	VNDfree(a,"jea_xinterpolate: a");
	VNDfree(b,"jea_xinterpolate: b");
	VNDfree(p,"jea_xinterpolate: p");
	VNDfree(time,"jea_xinterpolate: time");
	VNDfree(aa,"jea_xinterpolate: aa");
	VNDfree(bb,"jea_xinterpolate: bb");

	return;
}
static void runav(int n,int len,float *a,float *b)
/******************************************************************
compute a boxcar running average filter
*******************************************************************
int n   	number of samples in a[] and b[]
int len 	length of running average in samples
float a[n]	input array
float b[n]	output array
*******************************************************************
Author: John Anderson (visitor to CSM from Mobil) Spring 1993
*******************************************************************/
{
	float sum=0.;
	int j,lenh=len/2;
	if(len<=1) {
		for(j=0;j<n;j++) b[j]=a[j];
		return;
	}
	for(j=0;j<MIN(len,n);j++) sum+=a[j];
	for(j=0;j<MIN(lenh+1,n);j++) b[j]=sum;
	for(j=lenh+1;j<n-lenh;j++) {
		sum=sum+a[j+lenh]-a[j-lenh-1];
		b[j]=sum;
	}
	for(j=MAX(0,n-lenh);j<n;j++) b[j]=sum;
	sum=1./len;
	for(j=0;j<n;j++) b[j]*=sum;
	return;
}
@


1.20
log
@added Reg Beardsley's checkpar()
@
text
@d4 1
a4 1
/* SURADON: $Revision: 1.18 $ ; $Date: 2010/12/08 17:35:01 $	*/
d48 1
a48 1
" nxmax=120       maximum number of input traces per ensemble		",
d57 1
a57 1
" freq1=3.0      low-end frequency in Hz for picking (good default: 3 Hz)",
d63 1
a63 1
" lenx=1         length of space smoother in samples for picker		",
d157 4
a160 4
	char *cdpkey;		/* key denoting the ensemble */
	char *offkey;		/* key denoting trace labeling in an ensemble */
	char *headerfile;	/* temporary file containing trace headers */
	char *fname;
d208 7
a214 7
	float *rt;
	float *xin;
	float *offset;
	float *mutetime;
	float *g;
	float *gg;
	float *trace;
d216 4
a219 4
	FILE *headerfp;
	VND *vndorig;
	VND *vndinterp;
	VND *vndresult;
d224 1
d235 1
a235 1
	if (!getparint("lenx",&lenx)) lenx=1;
d503 4
a506 4
	float *rt,*rrt,*kindex=NULL,*tindex=NULL,w,dw,rsum,fac,wa,wb,rk[2],rit[2],df;
	complex czero,*crt,*ccrt,*r,*rhs,*wrk1,*wrk2,*wrk3,*wrk4;
	VND *vndc;
	char *fname;
d752 2
a753 2
	float *rt;
	complex *crt, *ctemp,czero;
d1269 5
a1273 5
	float	df,dff,wa,wb,dxx,eps=1.0e-30,f,fcl,fch;
	float 	*rt,*rrt,*a,*b,*p,*time,*aa,*bb,*save;
	complex	*crt,*ccrt;
	VND	*vnda,*vndb;
	char 	*fname;
d1322 7
d1337 1
a1337 1
		for(j=0;j<nt;j++) rt[j]=rt[j]/(a[j]+eps);
d1435 7
@


1.19
log
@copyright
@
text
@d250 3
@


1.18
log
@Jonathan Raven's fix
@
text
@d1 4
a4 1
/* SURADON: $Revision: 1.17 $ ; $Date: 2008/05/05 20:50:21 $	*/
@


1.17
log
@cosmetic
@
text
@d1 1
a1 1
/* SURADON: $Revision: 1.16 $ ; $Date: 2005/12/07 17:11:15 $	*/
d324 16
a339 4
				for(j=0;j< np;j++){
					V2Dr0(vndorig,j,(char *)rt,1001);
					V2Dw0(vndresult,j,(char *)rt,1002);
				}
@


1.16
log
@7 Dec 2005 version
@
text
@d1 1
a1 1
/* SURADON: $Revision: 1.15 $ ; $Date: 2003/06/09 16:17:07 $	*/
d4 1
a4 1
#include "segy.h" 
d79 1
a79 1
 * 	and subtract the multiples.  See the May, 1993 CWP Project 
d89 1
a89 1
 *      mute time is taken from the "muts" header word. 
d133 1
a133 1
static void compute_rhs(float w, int nx, float *g, complex *data, int np, 
d145 2
a146 2
static void jea_xinterpolate(VND *vndorig, VND *vndinterp, int ninterp, 
		int nt, int nx, float freq1, float freq2, int lagc, 
d157 1
a157 1
	char *fname;	
d292 1
a292 1
	if( (headerfp = fopen(headerfile,"w+"))==NULL) 
d341 1
a341 1
				forward_p_transform( vndinterp,		
d343 2
a344 2
					 ntfft,np,pmin,dp,mutetime, 
					 offset,nk,f1,f2,prewhite);  
d346 1
a346 1
			} 
d366 1
a366 1
					for(it=0;it< nt;it++) 
d427 1
a427 1
    	VNDfree(offset,"suradon_main: offset"); 
d429 1
a429 1
	VNDfree(trace,"suradon_main: trace");  
d488 1
a488 1
	
d512 1
a512 1
		}	
d561 1
a561 1
			for(rsum=0.,j=1;j<np;j++) 
d563 2
a564 2
			rsum=rsum/r[0].r;  
			if (rsum>1.+np/5) { 
d572 1
a572 1
		    for(ip=0;ip<np*nk;ip++) ccrt[ip]=czero;		
d600 1
a600 1
			V2Dw1(vndb,it,(char *)rt,208);		
d613 1
a613 1
	VNDfree(wrk4,"forward_p_transform: wrk4");	
d625 1
a625 1
			4 = linear tau-p using absolute value of 
d703 2
a704 2
static void inverse_p_transform(VND *vnda,int nx, float *g, float dt, 
	int ntfft, int np, float pmin, float dp, int ip1, 
d735 1
a735 1
	
d810 1
a810 1
and B = (1/nx) e 
d837 1
a837 1
float r[]     output vector of { real r0, imaginary r0, real r1, 
d851 1
a851 1
			isum = isum+sin( w*j*dp*g[k] );	
d858 1
a858 1
static void compute_rhs( float w, int nx, float *g, complex *data, int np, 
d875 1
a875 1
		angular frequency w as complex values 
d880 1
a880 1
complex rhs[]  np complex values for the result 
d907 1
a907 1
/***********************************************************************	
d922 1
a922 1
				=    
d936 1
a936 1
				=    
d944 1
a944 1
***********************************************************************	
d948 1
a948 1
*r    provides the top row of the Hermitian Toeplitz matrix R 
d959 1
a959 1
***********************************************************************	
d979 1
a979 1
	/*  	Compute spiking filter that outputs {v,0,0,...} 
d998 1
a998 1
			g[k].i = f[k].i + cr*f[jmk].i - ci*f[jmk].r;		
d1020 2
a1021 2
			a[k].i += + cr*f[jmk].i - ci*f[jmk].r;		
		}	
d1025 1
a1025 1
	/* instead of {v,0,0,...}.  To be accurate, recompute vr,vi,vsq */ 
d1039 1
a1039 1
		f[k].i = er*f[k].i + ei*f[k].r;	
d1044 1
a1044 1
static int ctoephcg( int niter, int n, complex *a, complex *x, complex *y, 
d1049 1
a1049 1
Hestenes and Stiefel conjugate gradient algorithm 
d1053 1
a1053 1
y[] is input.  niter is the maximum number of conjugate 
d1055 1
a1055 1
the number of steps actually computed.  The other 
d1072 1
a1072 1
				=    
d1087 3
a1089 1
	float rcdot(int n, complex *a, complex *b);
d1104 1
a1104 1
		htmul(n,a,s,ss);  
d1118 1
a1118 1
		gammam = gamma;			
d1122 1
a1122 1
		}	
d1127 1
d1129 1
a1129 1
/********************************************************************  
d1150 1
a1150 1
     x is input.  y is output. 
d1168 2
a1169 2
static void jea_xinterpolate(VND *vndorig, VND *vndinterp, int ninterp, 
		int nt, int nx, float freq1, float freq2, int lagc, 
d1172 1
a1172 1
interpolate input data in space placing "ninterp" synthetic traces 
d1207 1
a1207 1
			2 = compute dip picks in units of samples/trace: 
d1210 1
a1210 1
This routine outputs 'ninterp' interpolated traces between each pair of 
d1212 5
a1216 5
event tracking. The output data will be full bandwidth with no agc.  The 
suggested default parameters typically will do a satisfactory job of 
interpolation for dips up to about 12 ms/trace.  Using a larger value for 
freq2 causes the algorithm to do a better job on the shallow dips, but to 
fail on the steep dips.  Only one dip is assumed at each time sample between 
d1226 1
a1226 1
If you can't visually pick dips correctly on the low-pass picking 
d1243 1
a1243 1
where nxmax is the maximum number of input traces and nt is the number 
d1273 1
a1273 1
			V2Dr0(vndorig,ix,(char *)rt,101);	
d1311 1
a1311 1
		for(j=0;j<nt;j++) rt[j]=rt[j]/(a[j]+eps);	
d1334 1
a1334 1
		pfacr(-1,ntfft,crt,rt); 
d1336 1
a1336 1
		pfacr(-1,ntfft,ccrt,rrt); 
d1338 1
a1338 1
	} 
d1374 1
a1374 1
			pfacr(-1,nxfft,crt,rt); 
d1377 1
a1377 1
	} 
d1439 2
a1440 2
		b=save;  
	} 
@


1.15
log
@9 June 2003
@
text
@d1 1
a1 1
/* SURADON: $Revision: 1.14 $ ; $Date: 1997/07/28 22:36:46 $	*/
d46 1
d89 3
a91 3
 *      mute time is taken from the "muts" header word.  Beware,
 *      the SU mute module does not set this header word as one
 *      would normally expect.  You have to manually set it yourself.
d154 4
a157 4
	char *cdpkey;
	char *offkey;
	char *headerfile;
	char *fname;
d245 1
a263 1
	ltaper=7;
@


1.14
log
@changes suggested by Stew Levin to silence SGI compiler warnings, etc
@
text
@d1 1
a1 1
/* SURADON: $Revision: 1.13 $ ; $Date: 1996/09/13 21:49:05 $	*/
d445 1
a445 1
	return EXIT_SUCCESS;
@


1.13
log
@silenced -Wall messages
@
text
@d1 1
a1 1
/* SURADON: $Revision: 1.12 $ ; $Date: 1996/02/07 23:37:07 $	*/
d469 1
a469 1
float *offset   array of offsets
d481 2
a482 1
	int ix,ip,it,iw,j,ntfftny,nmax,k,nxx,nxxinc,ik,ik2;
d502 1
d729 2
a730 1
	int ip,iw,ntfftny,ix,it,nmax;
d1245 1
a1245 1
	int	ntfft,ntfftny,nxfft,nxfftny,jlow,jhigh,j,k,ix,it,ixm;
d1248 1
a1248 1
	complex	*crt,*ccrt,czero;
a1261 3
	jlow = freq1/df;
	jhigh = freq2/df;	
	czero.r=czero.i=0.;
@


1.12
log
@Maintenance by JEA.
@
text
@d1 1
a1 1
/* SURADON: $Revision: 1.10 $ ; $Date: 1995/08/02 21:20:22 $	*/
d165 1
a165 1
	int nxout;
d176 1
a176 1
	int xopt;
d482 1
a482 1
	float *rt,*rrt,*kindex,*tindex,w,dw,rsum,fac,wa,wb,rk[2],rit[2],df;
@


1.11
log
@Deal with header words accessed/modified down to sudoc.
Cosmetics.
@
text
@d11 3
a13 3
" SURADON -- compute forward or reverse Radon transform	or remove	",
"            multiples by using the Radon transform to estimate multiples",
"            and subtract.						",
d15 1
a15 1
"       suradon <stdin >stdout [Optional Parameters]			",
d54 1
a67 2
" Trace header words accessed: ns, dt, cdpkey, offkey, muts.		",
"									",
d118 2
d319 1
a319 2
					if(fabs(offset[j]-offset[j-1])>0.001)
						k++;
d385 3
a387 3
					tro.d2=1000.*dp*
						gofx( igopt, offref,
						     intercept_off, depthref);
d582 2
a583 1
/* merge appropriate tau-p transform for each window using mute zone information */
d1172 2
a1173 1
int ninterp		number of traces to interpolate between each input trace
d1183 1
a1183 1
                        			(good default: 5 samples)
d1185 1
a1185 1
                        			(good default: 1 sample)
d1217 2
a1218 1
to 1 allows you to visually check whether the low-pass picking model is aliased.
d1310 19
a1328 9
		for(j=0;j<ntfftny;j++){
			f=j*df;
			fcl=(f/freq1);
			fcl=fcl*fcl*fcl*fcl;
			fch=(f/freq2);
			fch=fch*fch*fch*fch;
			f=fcl/( (1.+fcl)*(1.+fch) );
			crt[j]=crmul(crt[j],f);
			ccrt[j]=cmul(crt[j],cmplx(0.,-j*dff));
d1477 3
a1479 3
	for(j=0;j<MIN(lenh,n);j++) b[j]=sum;
	for(j=lenh;j<n-lenh;j++) {
		sum=sum+a[j+lenh]-a[j-lenh];
d1483 2
a1484 1
	for(j=0;j<n;j++) b[j]/=len;
@


1.10
log
@Cast the integers tr.dt and/or tr.delrt and/or clones to double before
division with floating constant (which is implicitly double
precision).  Casting is needed to make some compilers happy and if we
cast to float then there will be an extra conversion to double because
of the floating constant (casting to float and writing 1000000.0F
would save a conversion, but most people find that F yucky and
efficiency is not an issue here).
Motivated by examples from Stew Levin.

Also: added key word static in lots of places--thx again to Stew
@
text
@d1 1
a1 1
/* SURADON: $Revision: 1.9 $ ; $Date: 1995/04/10 10:48:06 $	*/
d274 14
a287 7
	offset   = (float *)VNDemalloc(nxmax*sizeof(float),"suradon_main: offset");
	rt       = (float *)VNDemalloc(nmax*sizeof(float),"suradon_main: rt");
	trace    = (float *)VNDemalloc(nt*sizeof(float),"suradon_main: trace");
	xin      = (float *)VNDemalloc(nxmax*sizeof(float),"suradon_main: xin");
	g        = (float *)VNDemalloc(nxmax*sizeof(float),"suradon_main: g");
	gg       = (float *)VNDemalloc(nxinterp*sizeof(float),"suradon_main: gg");
	mutetime = (float *)VNDemalloc(nxmax*sizeof(float),"suradon_main: mutetime");
d315 1
a315 1
			if( choose==4) {	/* count the number of original offsets */
d318 2
a319 1
					if(fabs(offset[j]-offset[j-1])>0.001)k++;
d350 7
a356 4
						V2Dr0( vndresult,j,(char *) rt,1003);
						taupmute(j,ipa,ipb,ntfft,ltaper,rt);
						V2Dw0( vndresult,j,(char *) rt,1004);
					}					
d383 5
a387 2
						gofx( igopt, offref,intercept_off, depthref);
					tro.d2=1000.*dp*gofx( igopt, offref,intercept_off, depthref);
d1174 6
a1179 3
float freq1		low-end frequency in Hz for picking (good default: 3 Hz)
float freq2		high-end frequency in Hz for picking (good default: 20 Hz)
int lagc		length of AGC operator for picking (good default: 400 ms)
d1181 1
a1181 1
                        (good default: 5 samples)
d1183 1
a1183 1
                        (good default: 1 sample)
d1192 2
a1193 1
                            with ninterp traces between each pair of input traces
d1410 1
a1410 1
				for(it=0;it<nt;it++) time[it] = it - p[it]*wa;		
d1412 1
a1412 1
				for(it=0;it<nt;it++) time[it] = it + p[it]*wb;		
d1414 4
a1417 2
				for(it=0;it<nt;it++) aa[it]=wb*aa[it]+wa*bb[it];
				V2Dw0(vndinterp,k+1+ixm*(ninterp+1),(char *)aa,121);
@


1.9
log
@added references.
@
text
@d1 1
a1 1
/* SURADON: $Revision: 1.8 $ ; $Date: 94/10/18 12:56:19 $	*/
d127 1
a127 1
void inverse_p_transform(VND *vnda,int nx, float *g,
d140 2
a141 1
static float gofx(int igopt, float offset, float intercept_off, float refdepth);
d265 1
a265 1
	dt=0.000001*tr.dt;
d434 1
a434 1
void forward_p_transform(VND *vnda,VND *vndb,int nx, int nt, float *g,
d598 1
a598 1
float gofx(int igopt, float offset, float intercept_off,float refdepth)
d631 1
a631 1
float freqweight(int j, float df, float f1, float f2)
d653 1
a653 1
void taupmute(int ip,int ipa,int ipb,int nt, int ltap, float *rt)
d685 1
a685 1
void inverse_p_transform(VND *vnda,int nx, float *g, float dt, 
d781 1
a781 1
void compute_r( float w, int nx, float *g, int np, float dp, complex *r)
d839 1
a839 1
void compute_rhs( float w, int nx, float *g, complex *data, int np, 
d886 2
a887 1
int ctoep( int n, complex *r, complex *a, complex *b, complex *f, complex *g )
d1025 1
a1025 1
int ctoephcg( int niter, int n, complex *a, complex *x, complex *y, 
d1106 1
a1106 1
float rcdot(int n, complex *a, complex *b)
d1120 1
a1120 1
void htmul(int n, complex *a, complex *x, complex *y)
d1146 1
a1146 1
void jea_xinterpolate(VND *vndorig, VND *vndinterp, int ninterp, 
d1425 1
a1425 1
void runav(int n,int len,float *a,float *b)
@


1.8
log
@added missing puttr for "one trace ensembles"
@
text
@d1 1
a1 1
/* SURADON: $Revision: 1.7 $ ; $Date: 94/09/23 10:52:51 $	*/
d92 27
@


1.7
log
@changed by John Anderson
@
text
@d1 1
a1 1
/* SURADON: $Revision: 1.6 $ ; $Date: 94/09/06 10:21:36 $	*/
d357 1
@


1.6
log
@Added include of segy.h
@
text
@d1 1
a1 1
/* SURADON: $Revision: 1.8 $ ; $Date: 94/08/25 15:01:14 $	*/
d127 1
d244 1
a244 1
	nmax=MAX(nmax, ntfft+2);
d246 7
a252 7
	offset   = ealloc1float(nxmax);
	rt       = ealloc1float(nmax);
	trace    = ealloc1float(nmax);
	xin      = ealloc1float(nxmax);
	g        = ealloc1float(nxmax);
	gg       = ealloc1float(nxinterp);
	mutetime = ealloc1float(nxmax);
d257 7
a263 2
	vndorig = V2Dop(2,1000000,sizeof(float),VNDtempname("radontmp"),nt, nxmax);
	vndinterp = V2Dop(2,2000000,sizeof(float),VNDtempname("radontmp"),nt, nxinterp);
d265 2
a266 1
	vndresult = V2Dop(2,1000000,sizeof(float),VNDtempname("radontmp"),ntfft+2, nmax);
d333 1
d383 7
a389 6
    	free1float(offset); 
	free1float(rt);
	free1float(xin);
	free1float(g);
	free1float(gg);
	free1float(mutetime);
d392 1
a392 1
	free(headerfile);
d396 6
d442 1
d454 2
a455 1
		vndc = V2Dop(2,1000000,sizeof(complex),VNDtempname("radontmp"),
d457 1
d556 2
a557 2
		free(tindex);
		free(kindex);
d559 8
a566 8
	free(crt);
	free(ccrt);
	free(r);
	free(rhs);
	free(wrk1);
	free(wrk2);
	free(wrk3);
	free(wrk4);	
d693 2
a694 2
/*	nmax=MAX(nx,np);
	nmax=MAX(nmax,ntfftny)*sizeof(complex); */
a695 2
	nmax=MAX(vnda->N[0],vnda->N[1])*vnda->NumBytesPerNode;

d747 2
a748 2
	free(crt);
	free(ctemp);
d1176 6
a1181 2
vndorig = V2Dop(2,1000000,sizeof(float),VNDtempname("suxinterp"),nt,nxmax);
vndinterp = V2Dop(2,1000000,sizeof(float),VNDtempname("suxinterp"),
d1183 1
d1196 1
d1221 1
a1221 1
		free(crt);
d1241 6
a1246 2
	vnda  = V2Dop(2,500000,sizeof(float),VNDtempname("suxinterp"),nt,nx);
	vndb  = V2Dop(2,500000,sizeof(float),VNDtempname("suxinterp"),nt,nx);
d1282 8
a1289 8
		free(crt);
		free(ccrt);
		free(a);
		free(b);
		free(p);
		free(time);
		free(aa);
		free(bb);
d1384 8
a1391 8
	free(crt);
	free(ccrt);
	free(a);
	free(b);
	free(p);
	free(time);
	free(aa);
	free(bb);
d1396 1
a1396 1
/*
d1398 1
a1398 1

@


1.5
log
@cosmetics
@
text
@d1 2
d4 1
@


1.4
log
@fccabs -> rcabs
@
text
@a0 2
/* SURADON - RADON transform of seismic data */

d2 2
a3 1
#include "header.h" 
d6 1
a6 1
char *sdoc[] = { 
d8 3
a10 1
" SURADON - forward generalized Radon transform from (x,t) -> (p,tau) space.",
d12 1
a12 1
" suradon <stdin >stdout [Optional Parameters]				",
d14 29
a42 30
" Required parameters:							",
"	none								",
" Optional parameters:							",
" dt=from header	sampling interval (if not set=.004 s)		",
" key1=cdp		trace header key defining ensemble		",
" key2=offset		key defining x coordinate for radon transform	",
" xo=from header		x0,x1,x2,x3,...,xn-1or a list specifying the",
"			x coordinate for each trace.			",
" nxmax=48		max number of traces/ensemble in the input data	",
"			(will become max(nxmax,np))			",
" fmin=.025/dt		min frequency of interest (Hz)			",
" fmax=10*fmin		max frequency of interest (Hz)			",
" pmin=-100		min generalized slowness (define as integer--	",
"			actual value used is  pmin/pscale )		",
" pmax=100		max generalized slowness			",
" dp=4			increment in generalized slowness		",
" pscale=1.0e9		to define and save pmin, pmax, and dp as integers",
"			in the SEGY headers actual generalized slownesses are",
"			the value specified divided by pscale.		",
" g=x**2			parabolic tau-p transform		",
"			=x for linear tau-p				",
" gref=0.		reference value for x, g = (x-gref)**2 or (x-gref)",
" prewhite=0.1		percent prewhitening to use for stabilizing the	",
"			complex Levinson recursion when solving for pdata",
" op=f			transform using Levinson recursion		",	
"			=c transform by matrix mult. of conjugate operator",
" verbose=0		minimal listing					",
"			=1 asks for ensemble details			",
"			=2 asks for everything in listing		",
" outpar=/dev/tty	if verbose, output messages to file outpar	",
d44 19
a62 7
" Notes:								",
" If xo is specified, all of the input data are considered to be one	",
" ensemble and key1 and key2 are ignored. The default is to use values from",
" the trace header. Note that key1 and key2 can be defined as any of the",
" 4 byte integer header items.  The possible choices are tracl,tracr,fldr,",
" tracf,ep,cdp,cdpt,triad,offset,gelev,selev,sdepth,gdel,sdel,swdep,gwdep",
" sx,sy,gx, and gy (see sukeyword for more info about key fields).	", 
d64 1
a64 7
" Trace header fields accessed on input: ns, dt, key2, key1		",
" Trace header fields modified: trace headers may not be fully		",
" preserved. The first nx output traces have the original		",
" trace headers corresponding to the first nx input traces		",
" with the updated values for ns,tracl,d1,d2,f1,f2, and gdel.		",
" On output, ns = NFFT and gdel = p (note pscale scaling).		",
" d1=dt. f1=0. d2=dp. f2=pmin.  tracl=sequential trace count.		",
d66 1
a66 6
" A second module, SUIRADON,  computes the inverse radon		",
" transform by solving B pdata = xdata  for xdata			",
" by straightforward matix multiplication.				",
"									",
NULL}; 
/**************** end self doc ********************************/
d68 2
a69 3

/*
 * Author: John Anderson (visitor from Mobil) 1993
d71 7
a77 6
 * References:
 * 1987, Gregory Beylkin, Discrete Radon Transform, IEEE
 *   Transactions on Acoustics, Speech, and Signal Processing
 * 1987, Dan Hampson, The Discrete Radon Transform: A New Tool
 *   for Image Enhancement and Noise Suppression, available in
 *   the 1987 CSEG Abstracts or 1987 SEG Expanded Abstracts
d79 10
a88 19
 * Algorithm:
 * Loop over gathers associated with a single key1:
 *   Inside Loop 1 over x
 *    (a) get an input trace
 *    (b) extract x information for computing g(x) from key2
 *	(c) do forward temporal FFT (sign on transform is +1)
 *	(d) store result in memory
 *   Inside Loop 2 over w from fmin to fmax
 *	(a) gather all x components for a given w
 *	(b) solve system  B pdata = xdata   for pdata
 *	 using a complex form of Levinson recursion
 *	 or a conjugate gradient method depending on matrix
 *   Inside Loop 3 over p
 *	(a) gather all w for a give p
 *	(b) do inverse temporal FFT (sign on transform is -1)
 *	(c) put p information in trace header location key2
 *	(c) output trace
 *						  i w p g(x)
 * where B is the matrix operator B(p,x) = (1/np) e
d90 1
d92 4
a95 2
segy tr;	/* Input trace data of length nt */
segy tro;	/* Output trace of length nfft	*/
d97 19
a115 10
/* function prototype */
void compute_transform_and_output(int nx, float *g, complex **data,
                                  int nf, float fmin, float df, 
                                  int nfft, int np, float pmin, 
                                  float dp, float pscale, float prewhite, 
                                  complex *r, complex *wrk1, complex *wrk2,
                                  complex *wrk3, complex *wrk4,
                                  complex *rhs, float *rt, complex *crt, 
				  float dt, int verbose, int conjugate,
                                  FILE *headerfp , FILE *outparfp);
d117 2
d121 62
a182 15
	int nt;		/* number of points on input trace*/
	int nfft;	/* transform length */
	int nf;		/* number of frequencies */
	int cdp;	/* trace cdp */
	int oldcdp;	/* cdp of current ensemble in memory */
	int j;		/* index */
	int k;		/* index */
	int m;		/* index */
	int nxo;	/* number of values in xo[] */
	int np;		/* number of generalized slownesses */
	int nxmax;	/* max number of traces/ensemble to allow */
	int nx=0;	/* counter for current traces in ensemble */
	int gtype;	/* 1=parabolic transform, 0=linear tau-p */
	int verbose;	/* 0 no printout; 1 ensemble printout; 	*/
			/* .... 2 trace-by-trace printout */
a183 48
	int index_key1;		/* index to ensemble key in trace header*/
	int index_key2;		/* index to x location in trace header	*/
	int conjugate;		/* 1 or true if do conjugate operator	*/
				/* 0 or false if do least squares inverse */

	Value hdrwd;		
	float *xo;		/* used for store x values if not from 	*/
	complex *crt;		/* complex trace for fft */
	float *rt;		/* real trace padded out for fft*/

	complex *r;		/* r[] is dimensioned nxmax */
	float *g;		/* g[] is dimensioned nxmax */
	complex *rhs;		/* rhs[] is dimensioned nxmax */

	complex *wrk1;		/* [] is dimensioned nxmax */
	complex *wrk2;		/* [] is dimensioned nxmax */
	complex *wrk3;		/* [] is dimensioned nxmax */
	complex *wrk4;		/* [] is dimensioned nxmax */

	complex **data;		/* data[freq index][x or p index] */

	float dt;		/* sampling interval in secs */
	float df;		/* output sample interval in Hz	*/
	float offset;		/* trace offset (or x Radon coordinate)	*/
	float pmin;		/* minimum generalized slowness (unscaled) */
	float pmax;		/* maximum generalized slowness (unscaled) */
	float dp;		/* slowness increment */
	float pscale;		/* divide pmin, pmax, and dp by pscale to get*/
				/*    true generalized slowness */
	float fmin;		/* minimum frequency component to use */
	float fmax;		/* maximum frequency component to use */
	float fnyq;		/* Nyquist frequency component */
	float prewhite;		/* percentage prewhitening for levinson */
				/* recursion */
	float gref;		/* reference value for g(x) */

	char *key1c;		/* holds string for ensemble key	*/
	char *key2c;		/* holds string for hdr value for x	*/
	char *gc;		/* holds "x" or "x**2" for type of transform */
	char *op;		/* f transform using Levinson recursion	*/
				/* c transform using only conjugate operator */

	FILE *headerfp;		/* temporary file for storing trace headers */

	char *outpar;		/* name of file holding output parfile */
	FILE *outparfp;		/* .... its file pointer */
	
	/* Initialize */
a185 3
	
	if (!getparstring("outpar",&outpar))	outpar="/dev/tty";
	outparfp = efopen(outpar,"w");
d187 24
a210 4
	if (!getparint("verbose",&verbose)) verbose=0;
	if (verbose)fprintf(outparfp,"\n..............\n");
	if (verbose)fprintf(outparfp,
			"suradon: linear or parabolic radon transform \n");
d212 18
a229 3
	/* Get info from first trace */
	if (!gettr(&tr))  err("can't get first trace");
	nt = tr.ns;
d231 5
a235 3
	if (verbose)fprintf(outparfp,"\n..............\n");
	if (verbose)fprintf(outparfp,
		"\n\nGot the first trace into suradon.  nt =%d\n",nt);
d237 4
a240 6
	/*  fudge parameter in case no x values available in trace header  */
	if ( (nxo=countparval("xo"))!=0) {
		xo = ealloc1float(nxo);
		getparfloat("xo",xo);
	}
	if (verbose) fprintf(outparfp,"nxo =%d\n",nxo);
d242 7
a248 1
	if (!getparstring("op",&op)) op="f";
d250 7
a256 3
	if	 (STREQ(op,"c"))  conjugate=1;
	else if  (STREQ(op,"f"))  conjugate=0;
	else	err("Unknown option op=\"%s\", see selfdoc",op);
d258 112
a369 9
	if (!getparstring("key1",&key1c))  key1c="cdp";
	if (!getparstring("key2",&key2c))      key2c="offset";
	index_key1=getindex(key1c);
	index_key2=getindex(key2c);
	if (verbose) fprintf(outparfp,"key1 = %s  key2 = %s  \n",key1c,key2c);
	fprintf(outparfp,"Corresponding header indices are %d and %d \n",
               index_key1,index_key2);

	if (!getparstring("g",&gc))	gc="x**2";
d371 15
a385 3
	if	(STREQ(gc,"x**2")) 	gtype=1;
	else if	(STREQ(gc,"x")) 	gtype=0;
	else	err("Unknown option op=\"%s\", see selfdoc",op);
d387 6
a392 4
	if ( !getparfloat("gref",&gref)) gref=0.;
	gethval(&tr,index_key1,&hdrwd);
	oldcdp=hdrwd.i;
	fprintf(outparfp,"The starting ensemble key is %d \n",oldcdp);
d394 2
a395 5
	if (!getparfloat("dt", &dt)) dt = (float) tr.dt/1000000.0;
	if (!dt) {
		dt = .004;
		warn("dt not set, assumed to be .004");
	}
d397 17
a413 2
	fnyq = 0.5/dt;
	nfft=npfaro(2*nt,3*nt);
d415 33
a447 4
	if (!getparfloat("fmin",&fmin)) fmin=.025/dt ;
	if (!getparfloat("fmax",&fmax)) {
		fmax=10*fmin;
		if (fmax>fnyq) fmax=fnyq;
d450 18
a467 2
	df = 1.0/(nfft*dt);
	nf = 1 + (fmax-fmin)/df;
a468 4
	if (!getparfloat("pmin",&pmin)) pmin=-100.;
	if (!getparfloat("pmax",&pmax)) pmax=100.;
	if (!getparfloat("dp",&dp)) dp=4.;
	np = 1 + (pmax-pmin)/dp;
d470 7
a476 44
	if (!getparfloat("pscale",&pscale)) pscale=1000000000.;
	if (!getparint("nxmax", &nxmax)) nxmax = np;
	if (np>nxmax) nxmax=np;
	if (!getparfloat("prewhite",&prewhite)) prewhite=0.1;

	/* Allocate memory buffers */
	crt = ealloc1complex(nfft/2+1);
	rt = ealloc1float(nfft+2);
	r = ealloc1complex(nxmax);
	wrk1 = ealloc1complex(nxmax);
	wrk2 = ealloc1complex(nxmax);
	wrk3 = ealloc1complex(nxmax);
	wrk4 = ealloc1complex(nxmax);
	g = ealloc1float(nxmax);
	rhs = ealloc1complex(nxmax);
	data = ealloc2complex(nxmax,nf);

/*  Note that the fast index in data is allocated first but that
    it will be referenced second.  
    Reference data as    data[0 to nf-1][0 to 2*nxmax-1]
*/

	if (verbose) {
		fprintf(outparfp,"Ensembles to be transformed together"
				 " are defined by key1=%s\n",key1c);
		fprintf(outparfp,"The distance information is to be take"
				 " from key2=%s\n",key2c);
		fprintf(outparfp,"The type of transform (linear or parabolic)"
				 " is defined by g=%s\n",gc);
		fprintf(outparfp,"The starting ensemble is %d \n",oldcdp);
		fprintf(outparfp,
			"The sample rate assumed for these data is %f \n",dt);
		fprintf(outparfp,"The frequency range to be processed"
				" ranges from %f Hz to %f Hz \n",fmin,fmax);
		fprintf(outparfp,"Number of frequency components to "
				 "process is %d \n",nf);
		fprintf(outparfp,"Length of Fourier transform is %d \n",nfft);
		fprintf(outparfp,"The percentage of prewhitening used for" 
				 " operator stabilizaton is %f \n",prewhite);
		fprintf(outparfp,"np = %d  pmin = %f  pmax = %f  pscale=%f \n"
				,np,pmin,pmax,pscale);
		fprintf(outparfp,"Maximum of np and nxmax=%d \n",nxmax);
		fprintf(outparfp,"Ready to begin main loop for suradon\n");
		fprintf(outparfp,"........\n");
d478 1
a478 1
	headerfp = etmpfile();
d480 26
a505 13
	/* Main loop over traces */
	do {
		efwrite(&tr,HDRBYTES,1,headerfp);
		gethval(&tr,index_key1,&hdrwd);
		cdp=hdrwd.i;
		gethval(&tr,index_key2,&hdrwd);
		offset=hdrwd.i;
		if (verbose>1) fprintf(outparfp,"From input trace header,"
					" ensemble = %d and x coord = %f \n"
					,cdp,offset);
		if (nxo>0) {
			cdp = oldcdp;
			offset = xo[nx];
d507 2
d510 7
a516 6
		if (cdp!=oldcdp) {
			if (verbose) fprintf(outparfp,
					"Encountered new ensemble = %d." 
					" Will process data for old "
					" ensemble = %d which has %d"
					" input traces.\n",cdp,oldcdp,nx);
d518 15
a532 7
			compute_transform_and_output(nx,g,data,nf,fmin,df,
						nfft,np,pmin,dp,pscale,
						prewhite,r,wrk1,wrk2,wrk3,
							wrk4,rhs,rt,crt,
						dt,verbose,conjugate,headerfp,
						outparfp);
			nx=0;
d534 19
d554 32
a585 2
		if (gtype) g[nx]=offset*offset - gref;
		else g[nx]=offset-gref;
d587 15
a601 2
		for(j=0;j<nt;j++) rt[j]=tr.data[j];
		for(j=nt;j<nfft+2;j++) rt[j]=0.;
d603 5
a607 5
		pfarc(1,nfft,rt,crt);
		m=fmin/df;
		for(k=0;k<nf;k++) data[k][nx] = crt[m+k];		
		
		nx++;
d609 6
a614 14
		if (nx>nxmax) {
			fprintf(outparfp,"\nToo many traces found for this"
					" ensemble!\n");
			fprintf(outparfp,"Currently working on trace %d \n",nx);
			fprintf(outparfp,"nxmax = %d  and the current"
				" key1 =%d \n",nxmax,oldcdp);
			fprintf(outparfp,"The data up to this point will be"
				" processed.");
			fprintf(outparfp,"After this point, no more input"
				" data will be processed.\n");
			nx=nx-1;
			break;
		}
	} while ( gettr(&tr) );
d616 3
a618 2
	if (verbose) fprintf(outparfp,"Completed input of last ensemble" 
				"in suradon. Last ensemble = %d \n",oldcdp);	
d620 13
a632 7
	compute_transform_and_output(nx,g,data,nf,fmin,df,
			nfft,np,pmin,dp,pscale,prewhite,r,wrk1,wrk2,wrk3,
			wrk4, rhs,rt,crt,dt, verbose,conjugate,headerfp,
			outparfp);

	if (verbose)fprintf(outparfp,"All done in suradon \n");
	return EXIT_SUCCESS;
d635 5
a639 7
/* function prototypes used in compute_transform_and_output */
void compute_r(float w, int nx, float *g, int np, float dp, complex *r);
void compute_rhs(float w, int nx, float *g, complex *data, int np, 
		 float pmin, float dp, complex *rhs);
int ctoep(int n, complex *r, complex *a, complex *b, complex *f, complex *wrk);
int ctoephcg(int niter, int n, complex *r, complex *a, complex *b,
	complex *wrk1, complex *wrk2, complex *wrk3, complex *wrk4 );
d641 20
a660 6
void compute_transform_and_output(int nx, float *g, complex **data,
	int nf, float fmin, float df,int nfft, int np, float pmin, 
	float dp, float pscale, float prewhite, complex *r, complex *wrk1,
	complex *wrk2, complex *wrk3, complex *wrk4,
	complex *rhs, float *rt, complex *crt, float dt, int verbose,
	int conjugate, FILE *headerfp , FILE *outparfp)
d662 9
d672 2
a673 9
	float rcabs(complex z);
	int itr=0;	/* Output trace counter	*/
	int j;
	int k;
	int m;
	float f;
	float w;
	float p;
	float rsum;
d675 1
a675 1
	for(k=0;k<nf;k++) { /*  This is inner loop 2 */
d677 5
a681 2
		f = fmin + k*df; 	/*  f = frequency in Hz */
		w = 2*PI*f;		/*  w = angular frequency */
d683 9
a691 2
		compute_rhs(w,nx,g,&data[k][0],np,pmin/pscale,dp/pscale,rhs);
		if (conjugate) {	/* output traditional tau-p */
d693 8
a700 29
			for(m=0;m<np;m++) data[k][m]=crmul(rhs[m],w);
		} else {	 /* output generalized radon result */   
			compute_r(w,nx,g,np,dp/pscale,r);
			/*  if you have huge memory, compute r once and save */

			rsum=0;
			for(j=1;j<np;j++) rsum = rsum+rcabs(r[j]);

			rsum=rsum/r[0].r;  
			if (rsum>1.+np/5) {
				j=ctoephcg(np,np,r,&data[k][0],rhs,
						wrk1,wrk2,wrk3,wrk4);
				if (verbose>2) 
					fprintf(outparfp,
						"nf = %d freq = %f inverted"
						" dominance = %f jiter=%d \n"
						,nf,f,rsum,j);
			} else {
				r[0].r *= (1.+0.01*prewhite);
				j=ctoep(np,r,&data[k][0],rhs,wrk1,wrk2);

				if (verbose>2)
					fprintf(outparfp,
					  "freq = %f niter = %d  np = %d\n"
						,f,j,np);
				if (j<np) {
					for(m=j+j+1;m<np;m++)
						data[k][m]=cmplx(0.,0.);
				}  
d702 17
a718 1

d720 1
a720 29
	} 
	erewind(headerfp); 
	for(j=0;j<np;j++) { /*  This is inner loop 3 from selfdoc */

		for(m=0;m<nfft+2;m++) crt[m]=cmplx(0.,0.);
		m=fmin/df;

		for(k=0;k<nf;k++) {
			crt[k+m]=crmul(data[k][j],1./(2.*nfft));
		}

		pfacr(-1,nfft,crt,rt);
		if (j<nx)efread(&tro,HDRBYTES,1,headerfp);
		p=pmin+j*dp;
		tro.gdel=p;
		tro.ns=nfft;
		itr++;
		tro.tracl = itr;
		tro.dt = 1000000*dt;
		tro.d1 = tro.dt;
		tro.d2 = dp;
		tro.f1 = 0.0;
		tro.f2 = pmin;
		for(m=0;m<nfft;m++) tro.data[m]=rt[m];

		if (verbose>1) fprintf(outparfp,
					"Outputting trace. Trace count = %d"
					" Generalized slowness = %f \n",itr,p); 
	 	puttr(&tro); 
d722 9
a730 1
	erewind(headerfp);
d754 1
a754 1
   k		      k		      k
d792 1
a792 1
float pmin, float dp, complex *rhs)
d797 2
a798 2
	+	  -i w p g(x)
where B = (1/nx) e	    for equal increments in p as
d843 1
a843 1
Sum  R	A  = B      for i=0,1,2,...,N-1
a975 2
/* function prototype */
void htmul(int n, complex *a, complex *x, complex *y);
d977 1
a977 1
 complex *s, complex *ss, complex *g, complex *rr)
d993 1
a993 1
Sum  A	x  = y      for i=0,1,2,...,N-1
d1095 298
@


1.3
log
@y
changed fcabs to fccabs to reflect change in libcwp.a
y
@
text
@d386 1
a386 1
	float fccabs(complex z);
d410 1
a410 1
			for(j=1;j<np;j++) rsum = rsum+fccabs(r[j]);
@


1.2
log
@cosmetic change
@
text
@d386 1
a386 1
	float fcabs(complex z);
d410 1
a410 1
			for(j=1;j<np;j++) rsum = rsum+fcabs(r[j]);
@


1.1
log
@Initial revision
@
text
@d66 2
@
