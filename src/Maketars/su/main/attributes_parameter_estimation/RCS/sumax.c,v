head	1.22;
access;
symbols;
locks
	john:1.22; strict;
comment	@ * @;


1.22
date	2015.08.07.21.54.19;	author john;	state Exp;
branches;
next	1.21;

1.21
date	2011.11.16.17.24.58;	author john;	state Exp;
branches;
next	1.20;

1.20
date	2011.11.11.23.59.15;	author john;	state Exp;
branches;
next	1.19;

1.19
date	2010.01.25.22.57.06;	author john;	state Exp;
branches;
next	1.18;

1.18
date	2007.08.22.17.18.00;	author john;	state Exp;
branches;
next	1.17;

1.17
date	2006.05.03.17.12.04;	author john;	state Exp;
branches;
next	1.16;

1.16
date	2005.12.22.00.54.17;	author john;	state Exp;
branches;
next	1.15;

1.15
date	2005.10.04.16.42.43;	author john;	state Exp;
branches;
next	1.14;

1.14
date	2005.10.04.16.35.00;	author john;	state Exp;
branches;
next	1.13;

1.13
date	2003.06.09.16.17.07;	author john;	state Exp;
branches;
next	1.12;

1.12
date	96.09.13.21.49.05;	author john;	state Exp;
branches;
next	1.11;

1.11
date	96.01.30.16.20.49;	author jkc;	state Exp;
branches;
next	1.10;

1.10
date	94.08.25.14.59.59;	author jkc;	state Exp;
branches;
next	1.9;

1.9
date	94.05.23.15.17.26;	author jkc;	state Exp;
branches;
next	1.8;

1.8
date	92.10.27.14.25.34;	author john;	state Exp;
branches;
next	1.7;

1.7
date	92.10.26.10.23.35;	author john;	state Exp;
branches;
next	1.6;

1.6
date	92.10.23.15.00.50;	author john;	state Exp;
branches;
next	1.5;

1.5
date	91.09.05.08.51.06;	author jkcohen;	state Exp;
branches;
next	1.4;

1.4
date	91.02.14.14.43.48;	author jkcohen;	state Exp;
branches;
next	1.3;

1.3
date	90.06.05.15.51.24;	author jkc;	state Exp;
branches;
next	1.2;

1.2
date	90.06.04.23.25.40;	author jkc;	state Exp;
branches;
next	1.1;

1.1
date	90.04.19.15.27.27;	author jkc;	state Exp;
branches;
next	;


desc
@Find max per data set or per trace
@


1.22
log
@Marianne Houbiers of Statoil
fixed small error
@
text
@/* Copyright (c) Colorado School of Mines, 2011.*/
/* All rights reserved.                       */

/* SUMAX: $Revision: 1.21 $ ; $Date: 2011/11/16 17:24:58 $		*/

#include "su.h"
#include "segy.h"

/*************************** self documentation **************************/
char *sdoc[] = {
"									",
" SUMAX - get trace by trace local/global maxima, minima, or absolute maximum",
"									",
" sumax <stdin >stdout [optional parameters] 			",
"									",
" Required parameters:						",
"	none								",
"									",
" Optional parameters: 						",
"	output=ascii 		write ascii data to outpar		",
"				=binary for binary floats to stdout	",
"				=segy for SEGY traces to stdout		",
"									",
"	mode=maxmin		output both minima and maxima		",
"				=max maxima only			",
"				=min minima only			",
"				=abs absolute maxima only      		",
"				=rms RMS 		      		",
"				=thd search first max above threshold	",
"									",
"	threshamp=0		threshold amplitude value		",
"	threshtime=0		tmin to start search for threshold 	",
"									",
"	verbose=0 		writes global quantities to outpar	",
"				=1 trace number, values, sample location",
"				=2 key1 & key2 instead of trace number  ",
"	key1=fldr		key for verbose=2                       ",
"	key2=ep			key for verbose=2                       ",
"									",
"	outpar=/dev/tty		output parameter file; contains output	",
"					from verbose			",
"									",
" Examples: 								",
" For global max and min values:  sumax < segy_data			",
" For local and global max and min values:  sumax < segy_data verbose=1	",
" To plot values specified by mode:					",
"    sumax < segy_data output=binary mode=modeval | xgraph n=npairs	",
" To plot seismic data with the only values nonzero being those specified",
" by mode=modeval:							",
"    sumax < segy_data output=segy mode=modeval | suxwigb		",
"  									",
" Note:	while traces are counted from 1, sample values are counted from 0.",
"	Also, if multiple min, max, or abs max values exist on a trace,	",
"       only the first one is captured.					",
"									",
" See also: suxmax, supsmax						",
NULL};

/* Credits:
 *	CWP : John Stockwell (total rewrite)
 *	Geocon : Garry Perratt (all ASCII output changed from %e to %e)
 *	                       (added mode=rms).
 *      ESCI: Reginald Beardsley (added header key option)
 *	based on an original program by:
 *	SEP: Shuki Ronen
 *	CWP: Jack K. Cohen
 *      IFM-GEOMAR: Gerald Klein (added threshold option) 
 *
 * Trace header fields accessed: ns dt & user specified keys
 */

/**************** end self doc ***********************************/


segy   tr;

int      main(int argc, char **argv)
{
   char    *outpar;		/* name of file holding output parfile  */
   FILE    *outparfp;		/* ... its file pointer                 */
   char    *output;		/* format (ascii/binary/segy) of output */
   char    *mode;		/* desired output maxmin/max/min/abs    */
   char    *key1;
   char    *key2;
   char    ident[256];          /* trace identification string */

   int      verbose;		/* flag to print extra information      */

   int      nt;			/* number of time points on trace       */
   int      ntr;		/* number of traces                     */
   float    dt;			/* time sampling interval               */

   int      itr = 0;		/* trace number -- bumped at loop top   */
   float    fitr = 0;		/* trace number (as a float)            */
   int      it = 0;		/* time point number                    */

   int      gmaxit = 0;		/* global max sample counter            */
   int      gminit = 0;		/* global min sample counter            */
   int      gabsmaxit = 0;	/* global abs max sample counter        */

   int      gmaxitr = 1;	/* global max trace counter             */
   int      gminitr = 1;	/* global min trace counter             */
   int      gabsmaxitr = 1;	/* global abs max trace counter         */

   int      maxit = 0;		/* sample number of max value           */
   int      minit = 0;		/* sample number of min value           */
   int      absmaxit = 0;	/* sample number of abs max value       */

   float    max;		/* max on a trace                       */
   float    min;		/* min on a trace                       */
   float    absmax;		/* absolute max on a trace              */

   int      trhldit = 0;	/* sample number of max after threshold */
   int      trhldfit;		/* first sample to search for threshold */
   int      trhldgit = 0;	/* sample of global max                 */
   int      trhldgitr = 0;	/* trace of global max                  */
   float    trhldstrt;		/* first time to search for threshold   */
   float    trhldamp;		/* threshold value                      */
   float    trhldmax;		/* first max value after threshold      */
   float    trhldgmax = 0.;	/* global max value after threshold     */

   float    gmax;		/* global max                           */
   float    gmin;		/* global min                           */
   float    gabsmax;		/* global absolute max                  */

   float    grms = 0.0;		/* global rms                           */
   float    grmssumsq = 0.0;	/* global sum of sample value squared   */
   float    rms = 0.0;		/* rms on a trace                       */
   float    rmssumsq = 0.0;	/* sum of sample value squared          */
   float    val;		/* temp for adding to rmssumsq          */
   int ival1=0;
   int ival2=0;
   Value tval;

   /* Initialize */
   initargs(argc, argv);
   requestdoc(1);

   /* Get optional parameters */
   if (!getparint("verbose", &verbose))
      verbose = 0;
   if (!getparstring("output", &output))
      output = "ascii";
   if (!(STREQ(output, "ascii") ||
	 STREQ(output, "binary") || STREQ(output, "segy")
       ))
      err("%s unknown output selection", output);

   if (!getparstring("key1", &key1))
      key1 = "fldr";
   if (!getparstring("key2", &key2))
      key2 = "ep";

   if (!getparstring("mode", &mode))
      mode = "maxmin";
   if (!(STREQ(mode, "maxmin") ||
	 STREQ(mode, "max") ||
	 STREQ(mode, "min") ||
	 STREQ(mode, "thd") || STREQ(mode, "abs") || STREQ(mode, "rms")
       ))
      err("%s unknown mode", mode);

   if (STREQ(mode, "rms") && STREQ(output, "segy")) {
      err("%s output incompatible with %s mode", output, mode);
   }

   if (STREQ(output, "binary") && STREQ(mode, "maxmin")) {
      mode = "max";
      warn("outputting max values");
   }

   if (!getparstring("outpar", &outpar))
      outpar = "/dev/tty";
   outparfp = efopen(outpar, "w");

   /* Get info from first trace */
   if (!gettr(&tr))
      err("can't get first trace");
   nt = tr.ns;
   if (!getparfloat("dt", &dt))
      dt = ((double) tr.dt) / 1000000.0;

   gmin = gmax = tr.data[0];
   gabsmax = ABS(tr.data[0]);

   /* Get/Set variables for threshold mode */
   if (STREQ(mode, "thd")) {
      if (!getparfloat("threshamp", &trhldamp))
	 trhldamp = 0.;
      if (!getparfloat("threshtime", &trhldstrt))
	 trhldstrt = 0.;
      trhldfit = (int) (trhldstrt / dt);

   }
   checkpars();

   /* Loop through data */
   do {
      itr++;

      /* get header values if requested */
      if( verbose == 2 ){
         gethdval(&tr ,key1 ,&tval);
         ival1 = vtoi(hdtype(key1), tval);
         gethdval(&tr ,key2 ,&tval);
         ival2 = vtoi(hdtype(key2), tval);
      }


      /* find local/global max/min values and their locations */
      min = max = tr.data[0];
      absmax = ABS(tr.data[0]);
     /* tr.data[0] = 0.0;	*/ /* Zero first data value */
     /* trhldmax = tr.data[0]; */
     trhldmax = 0.0 ;
      trhldfit = (int) (trhldstrt / dt);
      for (it = 1; it < nt; ++it) {
	 if (tr.data[it] > max) {	/* Find max */
	    max = tr.data[it];
	    maxit = it;
	 }

	 if (tr.data[it] < min) {	/* Find min */
	    min = tr.data[it];
	    minit = it;
	 }

	 if (ABS(tr.data[it]) > absmax) {	/* Find absmax */
	    absmax = ABS(tr.data[it]);
	    absmaxit = it;
	 }

	 if (it >= trhldfit) {	/* Find max after threshold */
	    if (tr.data[it] > trhldamp) {
	       if (tr.data[it] > trhldmax) {
		  trhldmax = tr.data[it];
		  trhldit = it;
	       }
	    }
	    /* else if (trhldmax > trhldamp) trhldfit = nt+1 ; */
	    /* maximum found */
	 }

	/* pick up square of first sample for rms calculation */
	 rmssumsq = tr.data[0]*tr.data[0];
	 grmssumsq = tr.data[0]*tr.data[0];
	 if (STREQ(mode, "rms")) {
	    val = tr.data[it];
	    rmssumsq += val * val;
	    grmssumsq += val * val;
	 }

	 tr.data[it] = 0.0;	/* zero data values */

      }

      if (STREQ(mode, "rms")) {
	 rms = sqrt(rmssumsq / nt);
      }
      rmssumsq = 0.0;	/* reset sum squared */

      /* prepare SEGY output */
      if (STREQ(output, "segy")) {
	 if (STREQ(mode, "maxmin")) {
	    tr.data[maxit] = max;
	    tr.data[minit] = min;
	 }
	 if (STREQ(mode, "max")) {
	    tr.data[maxit] = max;
	 }
	 if (STREQ(mode, "min")) {
	    tr.data[minit] = min;
	 }
	 if (STREQ(mode, "abs")) {
	    tr.data[absmaxit] = absmax;
	 }
	 if (STREQ(mode, "thd")) {
	    tr.data[trhldit] = trhldmax;
	 }
      }
      if (max > gmax) {	/* Find global max */
	 gmax = max;
	 gmaxitr = itr;
	 gmaxit = maxit;
      }

      if (min < gmin) {	/* Find global min */
	 gmin = min;
	 gminitr = itr;
	 gminit = minit;
      }
      if (absmax > gabsmax) {	/* Find global min */
	 gabsmax = absmax;
	 gabsmaxitr = itr;
	 gabsmaxit = absmaxit;
      }
      if (trhldmax > trhldgmax) {	/* Find global first max above
					   threshold */
	 trhldgmax = trhldmax;
	 trhldgitr = itr;
	 trhldgit = trhldit;
      }
      /* Output ASCII */
      if (STREQ(output, "ascii") && verbose) {

         if( verbose == 2){
            sprintf( ident ,"%d %d" ,ival1, ival2 );

         }else{
            sprintf( ident ,"%d" ,itr );

         }
	 /* max min */
	 if (STREQ(mode, "maxmin")) {
	    fprintf(outparfp, "%s %e at point %d time %e\n",
		    ident, max, maxit, dt * (float) maxit);
	    fprintf(outparfp, "   %e at point %d time %e\n",
		    min, minit, dt * (float) minit);
	 }
	 /* max */
	 if (STREQ(mode, "max")) {
	    fprintf(outparfp, "%s %e at point %d time %e\n",
		    ident, max, maxit, dt * (float) maxit);
	 }

	 /* min */
	 if (STREQ(mode, "min")) {
	    fprintf(outparfp, "%s %e at point %d time %e\n",
		    ident, min, minit, dt * (float) minit);
	 }

	 /* abs max */
	 if (STREQ(mode, "abs")) {
	    fprintf(outparfp, "%s %e at point %d time %e\n",
		    ident, absmax, absmaxit, dt * (float) absmaxit);
	 }

	 /* threshold */
	 if (STREQ(mode, "thd")) {
	    fprintf(outparfp, "%s %e at point %d time %e\n",
		    ident, trhldmax, trhldit, dt * (float) trhldit);
	 }

	 /* rms */
	 if (STREQ(mode, "rms")) {
	    fprintf(outparfp, "%s %e\n", ident, rms);
	 }
      }

      /* Output raw BINARY pairs to stdout */
      fitr = itr;	/* convert itr to floats, for binary output */
      if (STREQ(output, "binary")) {
	 if (STREQ(mode, "max")) {
	    efwrite(&fitr, FSIZE, 1, stdout);
	    efwrite(&max, FSIZE, 1, stdout);
	 }
	 if (STREQ(mode, "min")) {
	    efwrite(&fitr, FSIZE, 1, stdout);
	    efwrite(&min, FSIZE, 1, stdout);
	 }
	 if (STREQ(mode, "abs")) {
	    efwrite(&fitr, FSIZE, 1, stdout);
	    efwrite(&absmax, FSIZE, 1, stdout);
	 }
	 if (STREQ(mode, "thd")) {
	    efwrite(&fitr, FSIZE, 1, stdout);
	    efwrite(&trhldmax, FSIZE, 1, stdout);
	 }
	 if (STREQ(mode, "rms")) {
	    efwrite(&fitr, FSIZE, 1, stdout);
	    efwrite(&rms, FSIZE, 1, stdout);
	 }
      }
      /* Output SEGY data */
      if (STREQ(output, "segy"))
	 puttr(&tr);

   } while (gettr(&tr));

   ntr = itr;	/* Set ntr */

   /* Output global max min */
   if (STREQ(mode, "maxmin")) {
      if (verbose) {
	 fprintf(outparfp,
		 "global max = %e, at trace = %d, at sample = %d\n",
		 gmax, gmaxitr, gmaxit);
	 fprintf(outparfp,
		 "global min = %e, at trace = %d, at sample = %d\n",
		 gmin, gminitr, gminit);
      } else {
	 fprintf(outparfp, "%e %e\n", gmax, gmin);
      }
   }

   /* Output global max */
   if (STREQ(mode, "max")) {
      if (verbose) {
	 fprintf(outparfp,
		 "global max = %e, at trace = %d, at sample = %d\n",
		 gmax, gmaxitr, gmaxit);
      } else {
	 fprintf(outparfp, "%e\n", gmax);
      }
   }

   /* Output global min */
   if (STREQ(mode, "min")) {
      if (verbose) {
	 fprintf(outparfp,
		 "global min = %e, at trace = %d, at sample = %d\n",
		 gmin, gminitr, gminit);
      } else {
	 fprintf(outparfp, "%e\n", gmin);
      }
   }

   /* Output global abs max */
   if (STREQ(mode, "abs")) {
      if (verbose) {
	 fprintf(outparfp,
		 "global abs max = %e, at trace = %d, at sample = %d\n",
		 gabsmax, gabsmaxitr, gabsmaxit);
      } else {
	 fprintf(outparfp, "%e\n", gabsmax);
      }
   }

   /* Output global rms */
   if (STREQ(mode, "rms")) {
      grms = sqrt(grmssumsq / (itr * nt));
      if (verbose) {
	 fprintf(outparfp, "global rms = %e\n", grms);
      } else {
	 fprintf(outparfp, "%e\n", grms);
      }
   }

   /* Output global threshold max */
   if (STREQ(mode, "thd")) {
      if (verbose) {
	 fprintf(outparfp,
		 "global max = %e, at trace = %d, at sample = %d\n",
		 trhldgmax, trhldgitr, trhldgit);
      } else {
	 fprintf(outparfp, "%e\n", trhldgmax);
      }
   }

   /* If output=binary, print number of pairs to outpar */
   if (STREQ(output, "binary"))
      fprintf(outparfp, "npairs = %d\n", ntr);

   return (CWP_Exit());
}
@


1.21
log
@added Reg Beardsley
''s checkpar() calls
@
text
@d4 1
a4 1
/* SUMAX: $Revision: 1.19 $ ; $Date: 2010/01/25 22:57:06 $		*/
d213 3
a215 2
      tr.data[0] = 0.0;	/* Zero first data value */
      trhldmax = tr.data[0];
d244 3
@


1.20
log
@copyright
@
text
@d195 1
@


1.19
log
@cosmetic
@
text
@d1 4
a4 1
/* SUMAX: $Revision: 1.18 $ ; $Date: 2007/08/22 17:18:00 $		*/
@


1.18
log
@changed all %f to %e as per Ekkhart Tessmers observation that
amplitudes less than 1e-6 are all printed out as 0.0000
@
text
@d1 1
a1 1
/* SUMAX: $Revision: 1.17 $ ; $Date: 2006/05/03 17:12:04 $		*/
d7 1
a7 1
char    *sdoc[] = {
@


1.17
log
@added Reg's fix
@
text
@d1 1
a1 1
/* SUMAX: $Revision: 1.3 $ ; $Date: 2006/05/03 14:24:16 $		*/
d58 1
a58 1
 *	Geocon : Garry Perratt (all ASCII output changed from %e to %f)
d307 1
a307 1
	    fprintf(outparfp, "%s %e at point %d time %f\n",
d309 1
a309 1
	    fprintf(outparfp, "   %e at point %d time %f\n",
d314 1
a314 1
	    fprintf(outparfp, "%s %e at point %d time %f\n",
d320 1
a320 1
	    fprintf(outparfp, "%s %e at point %d time %f\n",
d326 1
a326 1
	    fprintf(outparfp, "%s %e at point %d time %f\n",
d332 1
a332 1
	    fprintf(outparfp, "%s %e at point %d time %f\n",
d338 1
a338 1
	    fprintf(outparfp, "%s %f\n", ident, rms);
d378 1
a378 1
		 "global max = %f, at trace = %d, at sample = %d\n",
d381 1
a381 1
		 "global min = %f, at trace = %d, at sample = %d\n",
d384 1
a384 1
	 fprintf(outparfp, "%f %f\n", gmax, gmin);
d392 1
a392 1
		 "global max = %f, at trace = %d, at sample = %d\n",
d395 1
a395 1
	 fprintf(outparfp, "%f\n", gmax);
d403 1
a403 1
		 "global min = %f, at trace = %d, at sample = %d\n",
d406 1
a406 1
	 fprintf(outparfp, "%f\n", gmin);
d414 1
a414 1
		 "global abs max = %f, at trace = %d, at sample = %d\n",
d417 1
a417 1
	 fprintf(outparfp, "%f\n", gabsmax);
d425 1
a425 1
	 fprintf(outparfp, "global rms = %f\n", grms);
d427 1
a427 1
	 fprintf(outparfp, "%f\n", grms);
@


1.16
log
@Gerald Klein modifications
@
text
@d1 1
a1 1
/* SUMAX: $Revision: 1.15 $ ; $Date: 2005/10/04 16:42:43 $			*/
d7 1
a7 1
char *sdoc[] = 	{
d11 1
a11 1
" sumax <stdin >stdout [optional parameters] 				",
d13 1
a13 1
" Required parameters:							",
d16 1
a16 1
" Optional parameters: 							",
d33 3
d60 1
d66 1
a66 1
 * Trace header fields accessed: ns dt
d68 1
d72 1
a72 1
segy tr;
d74 1
a74 2
int
main(int argc, char **argv)
d76 369
a444 334
	char *outpar;		/* name of file holding output parfile  */
	FILE *outparfp;		/* ... its file pointer			*/
	char *output;		/* format (ascii/binary/segy) of output	*/
	char *mode;		/* desired output maxmin/max/min/abs	*/
	int verbose;		/* flag to print extra information	*/

	int nt;			/* number of time points on trace	*/
	int ntr;		/* number of traces			*/
	float dt;   		/* time sampling interval 		*/

	int itr=0;		/* trace number	-- bumped at loop top 	*/
	float fitr=0;		/* trace number (as a float)		*/
	int it=0;		/* time point number			*/

	int gmaxit=0;		/* global max sample counter 		*/
	int gminit=0;		/* global min sample counter 		*/
	int gabsmaxit=0;	/* global abs max sample counter	*/

	int gmaxitr=1;		/* global max trace counter 		*/
	int gminitr=1;		/* global min trace counter 		*/
	int gabsmaxitr=1;	/* global abs max trace counter		*/

	int maxit=0;		/* sample number of max value		*/
	int minit=0;		/* sample number of min value		*/
	int absmaxit=0;		/* sample number of abs max value	*/

	float max;		/* max on a trace			*/
	float min;		/* min on a trace			*/
	float absmax;		/* absolute max on a trace		*/
	
	int trhldit=0;		/* sample number of max after threshold	*/
	int trhldfit;		/* first sample to search for threshold	*/
	int trhldgit=0;		/* sample of global max 		*/
	int trhldgitr=0;	/* trace of global max 			*/
	float trhldstrt;	/* first time to search for threshold	*/
	float trhldamp;		/* threshold value 			*/
	float trhldmax;		/* first max value after threshold	*/
	float trhldgmax=0.;	/* global max value after threshold	*/

	float gmax;		/* global max 				*/
	float gmin;		/* global min 				*/
	float gabsmax;		/* global absolute max	 		*/

	float grms=0.0;		/* global rms				*/
	float grmssumsq=0.0;	/* global sum of sample value squared	*/
	float rms=0.0;		/* rms on a trace                       */
	float rmssumsq=0.0;	/* sum of sample value squared		*/
	float val;		/* temp for adding to rmssumsq		*/


	/* Initialize */
	initargs(argc, argv);
	requestdoc(1);

	/* Get optional parameters */
	if (!getparint("verbose", &verbose)) verbose=0;
	if (!getparstring("output", &output)) output="ascii";
	if (!(	STREQ(output, "ascii") || 
		STREQ(output, "binary") || 
		STREQ(output, "segy")
	)) err("%s unknown output selection", output); 

	if (!getparstring("mode", &mode)) mode="maxmin";
	if (!(	STREQ(mode, "maxmin")|| 
		STREQ(mode, "max") || 
		STREQ(mode, "min") || 
		STREQ(mode, "thd") || 
		STREQ(mode, "abs") || 
		STREQ(mode, "rms")
	)) err("%s unknown mode", mode); 

	if (STREQ(mode, "rms") && STREQ(output, "segy")) {
		err("%s output incompatible with %s mode",output,mode);
	}

	if (STREQ(output, "binary") && STREQ(mode, "maxmin")) {
		mode="max";
		warn("outputting max values");
	}

	if (!getparstring("outpar", &outpar))  outpar = "/dev/tty" ;
	outparfp = efopen(outpar, "w");

	/* Get info from first trace */
	if (!gettr(&tr))  err("can't get first trace");
	nt = tr.ns;
	if (!getparfloat("dt", &dt)) dt = ((double) tr.dt)/1000000.0;
	
	gmin = gmax = tr.data[0];
	gabsmax = ABS(tr.data[0]);

        /* Get/Set variables for threshold mode */
	if (STREQ(mode, "thd")) {
	         if (!getparfloat("threshamp", &trhldamp)) trhldamp=0.;
		 if (!getparfloat("threshtime", &trhldstrt)) trhldstrt=0.;
		 trhldfit = (int)(trhldstrt/dt) ;
		 
	}
	
	/* Loop through data */
	do {
		itr++ ;

		/* find local/global max/min values and their locations */
		min = max = tr.data[0];
		absmax = ABS(tr.data[0]);
		tr.data[0] = 0.0; /* Zero first data value */
		trhldmax = tr.data[0]; 
		trhldfit = (int)(trhldstrt/dt) ;
		for (it = 1; it < nt; ++it) {
			if (tr.data[it] > max) { /* Find max */
				max = tr.data[it];
				maxit = it;
			}

			if (tr.data[it] < min) { /* Find min */
				min = tr.data[it];
				minit = it;
			}

			if (ABS(tr.data[it]) > absmax) {/* Find absmax */
				absmax = ABS(tr.data[it]);
				absmaxit = it;
			}

			if (it >= trhldfit) { /* Find max after threshold */
			   if (tr.data[it] > trhldamp) {
			       if (tr.data[it] > trhldmax) {
			              trhldmax = tr.data[it];
				      trhldit =  it;
			       }
			   } 
			   /*else if (trhldmax > trhldamp) trhldfit = nt+1 ;*/
			                              /* maximum found */
                        }

			if (STREQ(mode, "rms")) {
				val = tr.data[it];
				rmssumsq += val * val;
				grmssumsq += val * val;
			}

			tr.data[it] = 0.0; /* zero data values */

		}

		if (STREQ(mode, "rms")) {
			rms = sqrt(rmssumsq / nt );
		}
		rmssumsq = 0.0;	/* reset sum squared */

		/* prepare SEGY output */
		if (STREQ(output, "segy")) {
			if (STREQ(mode, "maxmin")) {
				tr.data[maxit] = max;
				tr.data[minit] = min;
			}
			if (STREQ(mode, "max")) {
				tr.data[maxit] = max;
			}
			if (STREQ(mode, "min")) {
				tr.data[minit] = min;
			}
			if (STREQ(mode, "abs")) {
				tr.data[absmaxit] = absmax;
			}
			if (STREQ(mode, "thd")) {
				tr.data[trhldit] = trhldmax;
			}
		}
		if (max > gmax) { /* Find global max */
			gmax = max;
			gmaxitr = itr;
			gmaxit  = maxit;
		}

		if (min < gmin) { /* Find global min */
			gmin = min;
			gminitr = itr;
			gminit  = minit;
		}
		if (absmax > gabsmax) { /* Find global min */
			gabsmax = absmax;
			gabsmaxitr = itr;
			gabsmaxit  = absmaxit;
		}
		if (trhldmax > trhldgmax) { /* Find global first max above threshold */
			trhldgmax = trhldmax;
			trhldgitr = itr;
			trhldgit  = trhldit;
		}
		/* Output ASCII */
		if (STREQ(output, "ascii") && verbose) { 
			/* max min */
			if (STREQ(mode, "maxmin")) {
				fprintf(outparfp, "%d %e at point %d time %f\n",
						itr, max, maxit, dt*(float)maxit); 
				fprintf(outparfp, "   %e at point %d time %f\n",
						min, minit, dt*(float)minit); 
			}
			/* max */
			if (STREQ(mode, "max")) {
				fprintf(outparfp, "%d %e at point %d time %f\n",
						itr, max, maxit, dt*(float)maxit); 
			}

			/* min */
			if (STREQ(mode, "min")) {
				fprintf(outparfp, "%d %e at point %d time %f\n",
						itr, min, minit, dt*(float)minit); 
			}

			/* abs max */
			if (STREQ(mode, "abs")) {
				fprintf(outparfp, "%d %e at point %d time %f\n",
						itr, absmax, absmaxit, dt*(float)absmaxit); 
			}

			/* threshold */
			if (STREQ(mode, "thd")) {
				fprintf(outparfp, "%d %e at point %d time %f\n",
						itr, trhldmax, trhldit, dt*(float)trhldit); 
			}		

			/* rms */
			if (STREQ(mode, "rms")) {
				fprintf(outparfp, "%d %f\n",
						itr, rms); 
			}
		}

		/* Output raw BINARY pairs to stdout */ 
		fitr = itr; /* convert itr to floats, for binary output */
		if (STREQ(output, "binary")) {
			if (STREQ(mode, "max")){
				efwrite(&fitr, FSIZE, 1, stdout);
				efwrite(&max, FSIZE, 1, stdout);
			}
			if (STREQ(mode, "min")){
				efwrite(&fitr, FSIZE, 1, stdout);
				efwrite(&min, FSIZE, 1, stdout);
			}
			if (STREQ(mode, "abs")){
				efwrite(&fitr, FSIZE, 1, stdout);
				efwrite(&absmax, FSIZE, 1, stdout);
			}
			if (STREQ(mode, "thd")){
				efwrite(&fitr, FSIZE, 1, stdout);
				efwrite(&trhldmax, FSIZE, 1, stdout);
			}
			if (STREQ(mode, "rms")){
				efwrite(&fitr, FSIZE, 1, stdout);
				efwrite(&rms, FSIZE, 1, stdout);
			}
		}
		/* Output SEGY data */
		if (STREQ(output, "segy"))  puttr (&tr);

	} while (gettr(&tr)); 

	ntr = itr ; /* Set ntr */

	/* Output global max min */
	if (STREQ(mode, "maxmin")) {
		if (verbose) { 
			fprintf(outparfp, 
			  "global max = %f, at trace = %d, at sample = %d\n",
				gmax, gmaxitr, gmaxit);
			fprintf(outparfp, 
			 "global min = %f, at trace = %d, at sample = %d\n", 
				gmin, gminitr, gminit);
		} else {
			fprintf(outparfp, "%f %f\n", gmax,gmin);
		}
	}

	/* Output global max */
	if (STREQ(mode, "max")) {
		if (verbose) { 
			fprintf(outparfp, 
			  "global max = %f, at trace = %d, at sample = %d\n",
				gmax, gmaxitr, gmaxit);
		} else {
			fprintf(outparfp, "%f\n", gmax);
		}
	}

	/* Output global min */
	if (STREQ(mode, "min")) {
		if (verbose) { 
			fprintf(outparfp, 
			  "global min = %f, at trace = %d, at sample = %d\n",
				gmin, gminitr, gminit);
		} else {
			fprintf(outparfp, "%f\n", gmin);
		}
	}

	/* Output global abs max */
	if (STREQ(mode, "abs")) {
		if (verbose) { 
			fprintf(outparfp, 
			 "global abs max = %f, at trace = %d, at sample = %d\n",
				gabsmax, gabsmaxitr, gabsmaxit);
		} else {
				fprintf(outparfp, "%f\n", gabsmax);
		}
	}

	/* Output global rms */
	if (STREQ(mode, "rms")) {
		grms = sqrt(grmssumsq / (itr*nt));
		if (verbose) { 
			fprintf(outparfp, 
			 "global rms = %f\n",grms);
		} else {
				fprintf(outparfp, "%f\n", grms);
		}
	}

	/* Output global threshold max */
	if (STREQ(mode, "thd")) {
		if (verbose) { 
			fprintf(outparfp, 
			 "global max = %e, at trace = %d, at sample = %d\n",
				trhldgmax, trhldgitr, trhldgit);
		} else {
				fprintf(outparfp, "%e\n", trhldgmax);
		}
	}

	/* If output=binary, print number of pairs to outpar */
	if (STREQ(output, "binary"))
		fprintf(outparfp, "npairs = %d\n", ntr);
d446 1
a446 1
	return(CWP_Exit());
@


1.15
log
@4 Oct 2005
@
text
@d1 1
a1 1
/* SUMAX: $Revision: 1.14 $ ; $Date: 2005/10/04 16:35:00 $			*/
d26 4
d60 1
d62 1
a62 1
 * Trace header fields accessed: ns
d80 1
d101 9
d138 1
d158 2
d163 8
d179 2
d197 11
d238 3
d258 5
d267 4
a270 4
				fprintf(outparfp, "%d %f at point %d\n",
						itr, max, maxit); 
				fprintf(outparfp, "   %f at point %d\n",
						min, minit); 
d274 2
a275 2
				fprintf(outparfp, "%d %f at point %d\n",
						itr, max, maxit); 
d280 2
a281 2
				fprintf(outparfp, "%d %f at point %d\n",
						itr, min, minit); 
d286 2
a287 2
				fprintf(outparfp, "%d %f at point %d\n",
						itr, absmax, absmaxit); 
d290 6
d318 4
d392 11
@


1.14
log
@a
Garry Parrat's changes of %e to %f and the rms output
@
text
@d1 340
a340 340
/* SUMAX: $Revision: 1.13 $ ; $Date: 2003/06/09 16:17:07 $			*/

#include "su.h"
#include "segy.h"

/*************************** self documentation **************************/
char *sdoc[] = 	{
"									",
" SUMAX - get trace by trace local/global maxima, minima, or absolute maximum",
"									",
" sumax <stdin >stdout [optional parameters] 				",
"									",
" Required parameters:							",
"	none								",
"									",
" Optional parameters: 							",
"	output=ascii 		write ascii data to outpar		",
"				=binary for binary floats to stdout	",
"				=segy for SEGY traces to stdout		",
"									",
"	mode=maxmin		output both minima and maxima		",
"				=max maxima only			",
"				=min minima only			",
"				=abs absolute maxima only      		",
"				=rms RMS 		      		",
"									",
"	verbose=0 		writes global quantities to outpar	",
"				=1 trace number, values, sample location",
"									",
"	outpar=/dev/tty		output parameter file; contains output	",
"					from verbose			",
"									",
" Examples: 								",
" For global max and min values:  sumax < segy_data			",
" For local and global max and min values:  sumax < segy_data verbose=1	",
" To plot values specified by mode:					",
"    sumax < segy_data output=binary mode=modeval | xgraph n=npairs	",
" To plot seismic data with the only values nonzero being those specified",
" by mode=modeval:							",
"    sumax < segy_data output=segy mode=modeval | suxwigb		",
"  									",
" Note:	while traces are counted from 1, sample values are counted from 0.",
"	Also, if multiple min, max, or abs max values exist on a trace,	",
"       only the first one is captured.					",
"									",
" See also: suxmax, supsmax						",
NULL};

/* Credits:
 *	CWP : John Stockwell (total rewrite)
 *	Geocon : Garry Perratt (all ASCII output changed from %e to %f)
 *	                       (added mode=rms).
 *	based on an original program by:
 *	SEP: Shuki Ronen
 *	CWP: Jack K. Cohen
 *
 * Trace header fields accessed: ns
 */
/**************** end self doc ***********************************/


segy tr;

int
main(int argc, char **argv)
{
	char *outpar;		/* name of file holding output parfile  */
	FILE *outparfp;		/* ... its file pointer			*/
	char *output;		/* format (ascii/binary/segy) of output	*/
	char *mode;		/* desired output maxmin/max/min/abs	*/
	int verbose;		/* flag to print extra information	*/

	int nt;			/* number of time points on trace	*/
	int ntr;		/* number of traces			*/

	int itr=0;		/* trace number	-- bumped at loop top 	*/
	float fitr=0;		/* trace number (as a float)		*/
	int it=0;		/* time point number			*/

	int gmaxit=0;		/* global max sample counter 		*/
	int gminit=0;		/* global min sample counter 		*/
	int gabsmaxit=0;	/* global abs max sample counter	*/

	int gmaxitr=1;		/* global max trace counter 		*/
	int gminitr=1;		/* global min trace counter 		*/
	int gabsmaxitr=1;	/* global abs max trace counter		*/

	int maxit=0;		/* sample number of max value		*/
	int minit=0;		/* sample number of min value		*/
	int absmaxit=0;		/* sample number of abs max value	*/

	float max;		/* max on a trace			*/
	float min;		/* min on a trace			*/
	float absmax;		/* absolute max on a trace		*/

	float gmax;		/* global max 				*/
	float gmin;		/* global min 				*/
	float gabsmax;		/* global absolute max	 		*/

	float grms=0.0;		/* global rms				*/
	float grmssumsq=0.0;	/* global sum of sample value squared	*/
	float rms=0.0;		/* rms on a trace                       */
	float rmssumsq=0.0;	/* sum of sample value squared		*/
	float val;		/* temp for adding to rmssumsq		*/


	/* Initialize */
	initargs(argc, argv);
	requestdoc(1);

	/* Get optional parameters */
	if (!getparint("verbose", &verbose)) verbose=0;
	if (!getparstring("output", &output)) output="ascii";
	if (!(	STREQ(output, "ascii") || 
		STREQ(output, "binary") || 
		STREQ(output, "segy")
	)) err("%s unknown output selection", output); 

	if (!getparstring("mode", &mode)) mode="maxmin";
	if (!(	STREQ(mode, "maxmin")|| 
		STREQ(mode, "max") || 
		STREQ(mode, "min") || 
		STREQ(mode, "abs") || 
		STREQ(mode, "rms")
	)) err("%s unknown mode", mode); 

	if (STREQ(mode, "rms") && STREQ(output, "segy")) {
		err("%s output incompatible with %s mode",output,mode);
	}

	if (STREQ(output, "binary") && STREQ(mode, "maxmin")) {
		mode="max";
		warn("outputting max values");
	}

	if (!getparstring("outpar", &outpar))  outpar = "/dev/tty" ;
	outparfp = efopen(outpar, "w");

	/* Get info from first trace */
	if (!gettr(&tr))  err("can't get first trace");
	nt = tr.ns;
	gmin = gmax = tr.data[0];
	gabsmax = ABS(tr.data[0]);

	/* Loop through data */
	do {
		itr++ ;

		/* find local/global max/min values and their locations */
		min = max = tr.data[0];
		absmax = ABS(tr.data[0]);
		tr.data[0] = 0.0; /* Zero first data value */
		for (it = 1; it < nt; ++it) {
			if (tr.data[it] > max) { /* Find max */
				max = tr.data[it];
				maxit = it;
			}

			if (tr.data[it] < min) { /* Find min */
				min = tr.data[it];
				minit = it;
			}

			if (ABS(tr.data[it]) > absmax) {/* Find absmax */
				absmax = ABS(tr.data[it]);
				absmaxit = it;
			}

			if (STREQ(mode, "rms")) {
				val = tr.data[it];
				rmssumsq += val * val;
				grmssumsq += val * val;
			}

			tr.data[it] = 0.0; /* zero data values */

		}

		if (STREQ(mode, "rms")) {
			rms = sqrt(rmssumsq / nt );
		}
		rmssumsq = 0.0;	/* reset sum squared */

		/* prepare SEGY output */
		if (STREQ(output, "segy")) {
			if (STREQ(mode, "maxmin")) {
				tr.data[maxit] = max;
				tr.data[minit] = min;
			}
			if (STREQ(mode, "max")) {
				tr.data[maxit] = max;
			}
			if (STREQ(mode, "min")) {
				tr.data[minit] = min;
			}
			if (STREQ(mode, "abs")) {
				tr.data[absmaxit] = absmax;
			}
		}
		if (max > gmax) { /* Find global max */
			gmax = max;
			gmaxitr = itr;
			gmaxit  = maxit;
		}

		if (min < gmin) { /* Find global min */
			gmin = min;
			gminitr = itr;
			gminit  = minit;
		}
		if (absmax > gabsmax) { /* Find global min */
			gabsmax = absmax;
			gabsmaxitr = itr;
			gabsmaxit  = absmaxit;
		}
		/* Output ASCII */
		if (STREQ(output, "ascii") && verbose) { 
			/* max min */
			if (STREQ(mode, "maxmin")) {
				fprintf(outparfp, "%d %f at point %d\n",
						itr, max, maxit); 
				fprintf(outparfp, "   %f at point %d\n",
						min, minit); 
			}
			/* max */
			if (STREQ(mode, "max")) {
				fprintf(outparfp, "%d %f at point %d\n",
						itr, max, maxit); 
			}

			/* min */
			if (STREQ(mode, "min")) {
				fprintf(outparfp, "%d %f at point %d\n",
						itr, min, minit); 
			}

			/* abs max */
			if (STREQ(mode, "abs")) {
				fprintf(outparfp, "%d %f at point %d\n",
						itr, absmax, absmaxit); 
			}

			/* rms */
			if (STREQ(mode, "rms")) {
				fprintf(outparfp, "%d %f\n",
						itr, rms); 
			}
		}

		/* Output raw BINARY pairs to stdout */ 
		fitr = itr; /* convert itr to floats, for binary output */
		if (STREQ(output, "binary")) {
			if (STREQ(mode, "max")){
				efwrite(&fitr, FSIZE, 1, stdout);
				efwrite(&max, FSIZE, 1, stdout);
			}
			if (STREQ(mode, "min")){
				efwrite(&fitr, FSIZE, 1, stdout);
				efwrite(&min, FSIZE, 1, stdout);
			}
			if (STREQ(mode, "abs")){
				efwrite(&fitr, FSIZE, 1, stdout);
				efwrite(&absmax, FSIZE, 1, stdout);
			}
			if (STREQ(mode, "rms")){
				efwrite(&fitr, FSIZE, 1, stdout);
				efwrite(&rms, FSIZE, 1, stdout);
			}
		}
		/* Output SEGY data */
		if (STREQ(output, "segy"))  puttr (&tr);

	} while (gettr(&tr)); 

	ntr = itr ; /* Set ntr */

	/* Output global max min */
	if (STREQ(mode, "maxmin")) {
		if (verbose) { 
			fprintf(outparfp, 
			  "global max = %f, at trace = %d, at sample = %d\n",
				gmax, gmaxitr, gmaxit);
			fprintf(outparfp, 
			 "global min = %f, at trace = %d, at sample = %d\n", 
				gmin, gminitr, gminit);
		} else {
			fprintf(outparfp, "%f %f\n", gmax,gmin);
		}
	}

	/* Output global max */
	if (STREQ(mode, "max")) {
		if (verbose) { 
			fprintf(outparfp, 
			  "global max = %f, at trace = %d, at sample = %d\n",
				gmax, gmaxitr, gmaxit);
		} else {
			fprintf(outparfp, "%f\n", gmax);
		}
	}

	/* Output global min */
	if (STREQ(mode, "min")) {
		if (verbose) { 
			fprintf(outparfp, 
			  "global min = %f, at trace = %d, at sample = %d\n",
				gmin, gminitr, gminit);
		} else {
			fprintf(outparfp, "%f\n", gmin);
		}
	}

	/* Output global abs max */
	if (STREQ(mode, "abs")) {
		if (verbose) { 
			fprintf(outparfp, 
			 "global abs max = %f, at trace = %d, at sample = %d\n",
				gabsmax, gabsmaxitr, gabsmaxit);
		} else {
				fprintf(outparfp, "%f\n", gabsmax);
		}
	}

	/* Output global rms */
	if (STREQ(mode, "rms")) {
		grms = sqrt(grmssumsq / (itr*nt));
		if (verbose) { 
			fprintf(outparfp, 
			 "global rms = %f\n",grms);
		} else {
				fprintf(outparfp, "%f\n", grms);
		}
	}

	/* If output=binary, print number of pairs to outpar */
	if (STREQ(output, "binary"))
		fprintf(outparfp, "npairs = %d\n", ntr);

	return(CWP_Exit());
}
@


1.13
log
@9 June 2003
@
text
@d1 340
a340 292
/* SUMAX: $Revision: 1.12 $ ; $Date: 1996/09/13 21:49:05 $			*/

#include "su.h"
#include "segy.h"

/*************************** self documentation **************************/
char *sdoc[] = 	{
"									",
" SUMAX - get trace by trace local/global maxima, minima, or absolute maximum",
"									",
" sumax <stdin >stdout [optional parameters] 				",
"									",
" Required parameters:							",
"	none								",
"									",
" Optional parameters: 							",
"	output=ascii 		write ascii data to outpar		",
"				=binary for binary floats to stdout	",
"				=segy for SEGY traces to stdout		",
"									",
"	mode=maxmin		output both minima and maxima		",
"				=max maxima only			",
"				=min minima only			",
"				=abs absolute maxima only      		",
"									",
"	verbose=0 		writes global quantities to outpar	",
"				=1 trace number, values, sample location",
"									",
"	outpar=/dev/tty		output parameter file; contains output	",
"					from verbose			",
"									",
" Examples: 								",
" For global max and min values:  sumax < segy_data			",
" For local and global max and min values:  sumax < segy_data verbose=1	",
" To plot values specified by mode:					",
"    sumax < segy_data output=binary mode=modeval | xgraph n=npairs	",
" To plot seismic data with the only values nonzero being those specified",
" by mode=modeval:							",
"    sumax < segy_data output=segy mode=modeval | suxwigb		",
"  									",
" Note:	while traces are counted from 1, sample values are counted from 0.",
"	Also, if multiple min, max, or abs max values exist on a trace,	",
"       only the first one is captured.					",
"									",
" See also: suxmax, supsmax						",
NULL};

/* Credits:
 *	CWP : John Stockwell (total rewrite)
 *	based on an original program by:
 *	SEP: Shuki Ronen
 *	CWP: Jack K. Cohen
 *
 * Trace header fields accessed: ns
 */
/**************** end self doc ***********************************/


segy tr;

int
main(int argc, char **argv)
{
	char *outpar;		/* name of file holding output parfile  */
	FILE *outparfp;		/* ... its file pointer			*/
	char *output;		/* format (ascii/binary/segy) of output	*/
	char *mode;		/* desired output maxmin/max/min/abs	*/
	int verbose;		/* flag to print extra information	*/

	int nt;			/* number of time points on trace	*/
	int ntr;		/* number of traces			*/

	int itr=0;		/* trace number	-- bumped at loop top 	*/
	float fitr=0;		/* trace number (as a float)		*/
	int it=0;		/* time point number			*/

	int gmaxit=0;		/* global max sample counter 		*/
	int gminit=0;		/* global min sample counter 		*/
	int gabsmaxit=0;	/* global abs max sample counter	*/

	int gmaxitr=1;		/* global max trace counter 		*/
	int gminitr=1;		/* global min trace counter 		*/
	int gabsmaxitr=1;	/* global abs max trace counter		*/

	int maxit=0;		/* sample number of max value		*/
	int minit=0;		/* sample number of min value		*/
	int absmaxit=0;		/* sample number of abs max value	*/

	float max;		/* max on a trace			*/
	float min;		/* min on a trace			*/
	float absmax;		/* absolute max on a trace		*/

	float gmax;		/* global max 				*/
	float gmin;		/* global min 				*/
	float gabsmax;		/* global absolute max	 		*/

	/* Initialize */
	initargs(argc, argv);
	requestdoc(1);

	/* Get optional parameters */
	if (!getparint("verbose", &verbose)) verbose=0;
	if (!getparstring("output", &output)) output="ascii";
	if (!(	STREQ(output, "ascii") || 
		STREQ(output, "binary") || 
		STREQ(output, "segy")
	)) err("%s unknown output selection", output); 

	if (!getparstring("mode", &mode)) mode="maxmin";
	if (!(	STREQ(mode, "maxmin")|| 
		STREQ(mode, "max") || 
		STREQ(mode, "min") || 
		STREQ(mode, "abs")
	)) err("%s unknown mode", mode); 

	if (STREQ(output, "binary") && STREQ(mode, "maxmin")) {
		mode="max";
		warn("outputting max values");
	}

	if (!getparstring("outpar", &outpar))  outpar = "/dev/tty" ;
	outparfp = efopen(outpar, "w");

	/* Get info from first trace */
	if (!gettr(&tr))  err("can't get first trace");
	nt = tr.ns;
	gmin = gmax = tr.data[0];
	gabsmax = ABS(tr.data[0]);

	/* Loop through data */
	do {
		itr++ ;

		/* find local/global max/min values and their locations */
		min = max = tr.data[0];
		absmax = ABS(tr.data[0]);
		tr.data[0] = 0.0; /* Zero first data value */
		for (it = 1; it < nt; ++it) {
			if (tr.data[it] > max) { /* Find max */
				max = tr.data[it];
				maxit = it;
			}

			if (tr.data[it] < min) { /* Find min */
				min = tr.data[it];
				minit = it;
			}

			if (ABS(tr.data[it]) > absmax) {/* Find absmax */
				absmax = ABS(tr.data[it]);
				absmaxit = it;
			}

			tr.data[it] = 0.0; /* zero data values */

		}
		/* prepare SEGY output */
		if (STREQ(output, "segy")) {
			if (STREQ(mode, "maxmin")) {
				tr.data[maxit] = max;
				tr.data[minit] = min;
			}
			if (STREQ(mode, "max")) {
				tr.data[maxit] = max;
			}
			if (STREQ(mode, "min")) {
				tr.data[minit] = min;
			}
			if (STREQ(mode, "abs")) {
				tr.data[absmaxit] = absmax;
			}
		}
		if (max > gmax) { /* Find global max */
			gmax = max;
			gmaxitr = itr;
			gmaxit  = maxit;
		}

		if (min < gmin) { /* Find global min */
			gmin = min;
			gminitr = itr;
			gminit  = minit;
		}
		if (absmax > gabsmax) { /* Find global min */
			gabsmax = absmax;
			gabsmaxitr = itr;
			gabsmaxit  = absmaxit;
		}
		/* Output ASCII */
		if (STREQ(output, "ascii") && verbose) { 
			/* max min */
			if (STREQ(mode, "maxmin")) {
				fprintf(outparfp, "%d %e at point %d\n",
						itr, max, maxit); 
				fprintf(outparfp, "   %e at point %d\n",
						min, minit); 
			}
			/* max */
			if (STREQ(mode, "max")) {
				fprintf(outparfp, "%d %e at point %d\n",
						itr, max, maxit); 
			}

			/* min */
			if (STREQ(mode, "min")) {
				fprintf(outparfp, "%d %e at point %d\n",
						itr, min, minit); 
			}

			/* abs max */
			if (STREQ(mode, "abs")) {
				fprintf(outparfp, "%d %e at point %d\n",
						itr, absmax, absmaxit); 
			}
		}

		/* Output raw BINARY pairs to stdout */ 
		fitr = itr; /* convert itr to floats, for binary output */
		if (STREQ(output, "binary")) {
			if (STREQ(mode, "max")){
				efwrite(&fitr, FSIZE, 1, stdout);
				efwrite(&max, FSIZE, 1, stdout);
			}
			if (STREQ(mode, "min")){
				efwrite(&fitr, FSIZE, 1, stdout);
				efwrite(&min, FSIZE, 1, stdout);
			}
			if (STREQ(mode, "abs")){
				efwrite(&fitr, FSIZE, 1, stdout);
				efwrite(&absmax, FSIZE, 1, stdout);
			}
		}
		/* Output SEGY data */
		if (STREQ(output, "segy"))  puttr (&tr);

	} while (gettr(&tr)); 

	ntr = itr ; /* Set ntr */

	/* Output global max min */
	if (STREQ(mode, "maxmin")) {
		if (verbose) { 
			fprintf(outparfp, 
			  "global max = %e, at trace = %d, at sample = %d\n",
				gmax, gmaxitr, gmaxit);
			fprintf(outparfp, 
			 "global min = %e, at trace = %d, at sample = %d\n", 
				gmin, gminitr, gminit);
		} else {
			fprintf(outparfp, "%e %e\n", gmax,gmin);
		}
	}

	/* Output global max */
	if (STREQ(mode, "max")) {
		if (verbose) { 
			fprintf(outparfp, 
			  "global max = %e, at trace = %d, at sample = %d\n",
				gmax, gmaxitr, gmaxit);
		} else {
			fprintf(outparfp, "%e\n", gmax);
		}
	}

	/* Output global min */
	if (STREQ(mode, "min")) {
		if (verbose) { 
			fprintf(outparfp, 
			  "global min = %e, at trace = %d, at sample = %d\n",
				gmin, gminitr, gminit);
		} else {
			fprintf(outparfp, "%e\n", gmin);
		}
	}

	/* Output global abs max */
	if (STREQ(mode, "abs")) {
		if (verbose) { 
			fprintf(outparfp, 
			 "global abs max = %e, at trace = %d, at sample = %d\n",
				gabsmax, gabsmaxitr, gabsmaxit);
		} else {
				fprintf(outparfp, "%e\n", gabsmax);
		}
	}

	/* If output=binary, print number of pairs to outpar */
	if (STREQ(output, "binary"))
		fprintf(outparfp, "npairs = %d\n", ntr);

	return(CWP_Exit());
}
@


1.12
log
@silenced -Wall messages
@
text
@d1 1
a1 1
/* SUMAX: $Revision: 1.11 $ ; $Date: 1996/01/30 16:20:49 $			*/
d291 1
a291 1
	return EXIT_SUCCESS;
@


1.11
log
@Deal with header fields accessed/modified in sudoc.
@
text
@d1 1
a1 1
/* SUMAX: $Revision: 1.10 $ ; $Date: 1994/08/25 14:59:59 $			*/
d61 1
@


1.10
log
@Removed copyright statement from codes that had it.
Moved self-doc line for sudoc.
@
text
@d1 1
a1 1
/* SUMAX: $Revision: 1.9 $ ; $Date: 94/05/23 15:17:26 $			*/
d36 1
a36 1
"    sumax < segy_data output=binary mode=modeval | psgraph n=npairs |..",
d39 1
a39 1
"    sumax < segy_data output=segy mode=modeval | supswigb | ...	",
d42 2
a43 1
"	Also, if multiple min, max, or abs max values exist on a trace.	",
d45 1
d53 2
@


1.9
log
@Attempt to fix bug on data of all one sign (e.g. strictly >0).
Avoided initializations that assumed 0 was lower limit.
Initialize trace counters to 1 instead of 0.
Pulled if verbose out of a nest of ifs.
Not throughly tested.
@
text
@d1 1
a1 1
/* SUMAX: $Revision: 1.8 $ ; $Date: 92/10/27 14:25:34 $			*/
a2 13
/*----------------------------------------------------------------------
 * Copyright (c) Colorado School of Mines, 1990.
 * All rights reserved.
 *
 * This code is part of SU.  SU stands for Seismic Unix, a processing line
 * developed at the Colorado School of Mines, partially based on Stanford
 * Exploration Project (SEP) software.  Inquiries should be addressed to:
 *
 *  Jack K. Cohen, Center for Wave Phenomena, Colorado School of Mines,
 *  Golden, CO 80401  (jkc@@dix.mines.colorado.edu)
 *----------------------------------------------------------------------
 */

a44 1
/**************** end self doc ***********************************/
d52 1
@


1.8
log
@cosmetic change to selfdoc
@
text
@d1 1
a1 1
/* SUMAX: $Revision: 1.7 $ ; $Date: 92/10/26 10:23:35 $			*/
d81 3
a83 3
	int itr = 0;		/* trace number				*/
	float fitr = 0;		/* trace number (as a float)		*/
	int it = 0;		/* time point number			*/
d85 1
a85 1
	int gmaxit=0;		/* global max sample  counter 		*/
d89 3
a91 3
	int gmaxitr=0;		/* global max trace counter 		*/
	int gminitr=0;		/* global min trace counter 		*/
	int gabsmaxitr=0;	/* global abs max trace counter		*/
d93 3
a95 3
	int maxit=1;		/* sample number of max value		*/
	int minit=1;		/* sample number of min value		*/
	int absmaxit=1;		/* sample number of abs max value	*/
d99 1
a99 1
	float absmax=0.;	/* absolute max on a trace		*/
d101 3
a103 3
	float gmax=0.;		/* global max 				*/
	float gmin=0.;		/* global min 				*/
	float gabsmax=0.;	/* global absolute max	 		*/
d135 2
d198 1
a198 1
		if (STREQ(output, "ascii")) { 
d201 1
a201 2
				if (verbose) { 
					fprintf(outparfp, "%d %e at point %d\n",
d203 1
a203 1
					fprintf(outparfp, "   %e at point %d\n",
a204 1
				}
d208 1
a208 2
				if (verbose) { 
					fprintf(outparfp, "%d %e at point %d\n",
a209 1
				}
d214 1
a214 2
				if (verbose) { 
					fprintf(outparfp, "%d %e at point %d\n",
a215 1
				}
d220 1
a220 2
				if (verbose) { 
					fprintf(outparfp, "%d %e at point %d\n",
a221 1
				}
d224 1
@


1.7
log
@added Notes and Examples to selfdoc.
@
text
@d1 1
a1 1
/* SUMAX: $Revision: 1.6 $ ; $Date: 92/10/23 15:00:50 $			*/
d46 2
a47 2
" For global max and min values:  sumax < data				",
" For local and global max and min values:  sumax < data verbose=1	",
d49 1
a49 1
"    sumax < data output=binary mode=modeval | psgraph n=npairs |...	", 
d52 1
a52 1
"    sumax < sudata output=segy mode=modeval | supswigb | ...		",
d54 3
a56 5
" Note:	while traces are counted from 1, sample values are counted from 0",
"	in output=ascii, verbose=1 case. Also, if multiple min, max, or	", 
"	abs max values exist on a trace, then only the one occurring at	",
"	the earliest time will be output.				",
"  									",
@


1.6
log
@total rewrite
@
text
@d1 1
a1 1
/* SUMAX: $Revision: 1.5 $ ; $Date: 91/09/05 08:51:06 $			*/
d45 14
a58 6
"Note: output=binary  mode must= max,min,or abs, output is suitable	",
"      to be piped into xgraph/psgraph					",
" 									",
" For output=segy  outputs SEGY traces with all values nulled except  	",
" those specified by \"mode\".						",
"									",
d140 1
a140 1
		itr++;
d252 3
a254 2
	
	
d302 3
@


1.5
log
@string -> String and so forth
@
text
@d1 1
a1 1
/* SUMAX: $Revision: 1.4 $ ; $Date: 91/02/14 14:43:48 $			*/
d20 32
a51 29
String sdoc = "\
									\n\
SUMAX - get trace by trace absolute maxima and global maximum magnitude	\n\
	and their indices 						\n\
									\n\
sumax <stdin >stdout [optional parameters]				\n\
									\n\
Required parameters:							\n\
	none								\n\
						        		\n\
Optional parameters: 							\n\
	output=ascii 							\n\
	      =binary	(for binary floats)				\n\
									\n\
	verbose=0 (applies only to the output=ascii option)		\n\
									\n\
		Under the ascii option, verbose=1, prints the trace	\n\
		number and maximum value on each trace.	 In addition,	\n\
		a message is printed giving the global maximum and its	\n\
		location.  With the default, verbose=0, only the global	\n\
		maximum is printed.		 			\n\
									\n\
		Under the binary option, the max on each trace is	\n\
		written as a float.					\n\
									\n\
NOTE: Under the verbose option, the sample locations are reported	\n\
      zero-based (i.e. first sample is sample 0).			\n\
									\n\
";
d55 4
a58 3
 *	SEP: Shuki
 *	CWP: Jack
 *
d66 4
a69 1
	String output;		/* format (ascii/binary) of output	*/
d71 1
d73 2
d76 2
a77 5
	int gitr;		/* trace with global max 		*/
	int git;		/* zero-based index of global max	*/
	float gmax= -1.0;	/* global absolute maximum		*/
	float absmax;		/* absolute max on a trace		*/
	int absmaxloc;		/* zero-based index of absmax		*/
d79 3
d83 16
d101 1
a101 1
	askdoc(1);
d103 7
a109 1
	verbose = 0;	getparint("verbose", &verbose);
d111 10
a120 5
	/* Set and check output disposition (ascii or binary) */
	output = "ascii";	getparstring("output", &output);
	if ((!STREQ(output, "ascii")) && (!STREQ(output, "binary"))) {
	    err("output parameter=%s, must be \"ascii\" or \"binary\"",
								output);
d123 2
a124 2
	while (gettr(&tr)) {
		register int i;
d126 3
a128 1
		nt = tr.ns;
d130 12
a141 5
		absmax = ABS(tr.data[0]); absmaxloc = 0;
		for (i = 1; i < nt; ++i) {
			if (ABS(tr.data[i]) > absmax) {
				absmax = ABS(tr.data[i]);
				absmaxloc = i;
d143 13
d157 5
a161 7
		if (STREQ(output, "ascii")) {
			if (verbose) printf("%d %e at point %d\n",
						++itr, absmax, absmaxloc);
			if (absmax > gmax) {
				gmax = absmax;
				gitr = itr;
				git  = absmaxloc;
d163 92
d256 1
a256 1
		    efwrite((char *) &absmax, FSIZE, 1, stdout);
d260 9
a268 5
	if (STREQ(output, "ascii")) {
		if (verbose) printf("global max = ");
		printf("%e", gmax);
		if (verbose) printf(" at trace %d, point %d", gitr, git);
		printf("\n");
d270 23
a292 1
	
@


1.4
log
@UGH!  Typoed i into initialization of absmax--should be 0.
@
text
@d1 1
a1 1
/* SUMAX: $Revision: 1.3 $ ; $Date: 90/06/05 15:51:24 $			*/
d20 1
a20 1
string sdoc = "\
d62 1
a62 1
	string output;		/* format (ascii/binary) of output	*/
d77 1
a77 1
	verbose = 0;	igetpar("verbose", &verbose);
d80 1
a80 1
	output = "ascii";	sgetpar("output", &output);
@


1.3
log
@Eliminated veclib routines.
@
text
@d1 1
a1 1
/* SUMAX: $Revision: 1.2 $ ; $Date: 90/06/04 23:25:40 $			*/
d91 1
a91 1
		absmax = ABS(tr.data[i]); absmaxloc = 0;
@


1.2
log
@ANSI C, etc
@
text
@d1 1
a1 1
/* SUMAX: $Revision: 1.1 $ ; $Date: 90/04/19 15:27:27 $			*/
a17 1
#include "fconst.h"
d87 2
d90 8
a97 1
		maxmgv(tr.data, ONE, &absmax, &absmaxloc, &nt);
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/* SUMAX: $Revision: 2.10 $ ; $Date: 89/09/22 11:00:53 $			*/
d12 1
a12 1
 *  Golden, CO 80401  (isis!csm9a!jkcohen)
d32 2
a33 2
	output = ascii 							\n\
	       = binary	(for binary floats)				\n\
d35 1
a35 1
	verbose = 0 (applies only to the output=ascii option)		\n\
a55 1
 *
a57 5
/* Embed Revision Control System identifier strings */
static string progid =
	"   $Source: /src/su/src/RCS/sumax.c,v $";
static string revid =
	"   $Revision: 2.10 $ ; $Date: 89/09/22 11:00:53 $";
a58 2


d61 1
a61 2
main(argc, argv)
int argc; char **argv;
a75 5
	if (!igetpar("ID", &ID)) ID = 0;
	if (ID) {
		(void) fprintf(stderr, "%s\n", progid);
		(void) fprintf(stderr, "%s\n", revid);
	}
@
