head	1.35;
access;
symbols;
locks; strict;
comment	@ * @;


1.35
date	2016.05.09.16.43.24;	author john;	state Exp;
branches;
next	1.34;

1.34
date	2013.08.20.22.24.04;	author john;	state Exp;
branches;
next	1.33;

1.33
date	2011.12.20.17.51.06;	author john;	state Exp;
branches;
next	1.32;

1.32
date	2011.12.01.18.50.34;	author john;	state Exp;
branches;
next	1.31;

1.31
date	2011.11.16.17.24.58;	author john;	state Exp;
branches;
next	1.30;

1.30
date	2011.11.11.23.59.15;	author john;	state Exp;
branches;
next	1.29;

1.29
date	2011.09.09.22.29.07;	author john;	state Exp;
branches;
next	1.28;

1.28
date	2010.11.18.19.19.35;	author john;	state Exp;
branches;
next	1.27;

1.27
date	2005.03.09.17.29.26;	author john;	state Exp;
branches;
next	1.26;

1.26
date	2004.12.23.23.42.30;	author john;	state Exp;
branches;
next	1.25;

1.25
date	2003.06.09.16.17.07;	author john;	state Exp;
branches;
next	1.24;

1.24
date	98.01.08.18.42.05;	author john;	state Exp;
branches;
next	1.23;

1.23
date	97.08.28.15.59.55;	author john;	state Exp;
branches;
next	1.22;

1.22
date	97.07.28.22.36.46;	author john;	state Exp;
branches;
next	1.21;

1.21
date	96.09.05.19.13.24;	author jkc;	state Exp;
branches;
next	1.20;

1.20
date	96.01.24.18.18.21;	author jkc;	state Exp;
branches;
next	1.19;

1.19
date	95.10.04.16.42.20;	author john;	state Exp;
branches;
next	1.18;

1.18
date	95.08.02.19.37.43;	author jkc;	state Exp;
branches;
next	1.17;

1.17
date	94.08.25.14.59.13;	author jkc;	state Exp;
branches;
next	1.16;

1.16
date	94.03.31.15.04.57;	author john;	state Exp;
branches;
next	1.15;

1.15
date	94.03.31.14.23.07;	author john;	state Exp;
branches;
next	1.14;

1.14
date	94.03.31.13.11.52;	author john;	state Exp;
branches;
next	1.13;

1.13
date	94.03.31.12.43.52;	author john;	state Exp;
branches;
next	1.12;

1.12
date	94.03.30.13.46.02;	author john;	state Exp;
branches;
next	1.11;

1.11
date	94.03.28.14.29.46;	author jkc;	state Exp;
branches;
next	1.10;

1.10
date	93.12.14.13.41.36;	author jkc;	state Exp;
branches;
next	1.9;

1.9
date	93.08.09.15.19.29;	author john;	state Exp;
branches;
next	1.8;

1.8
date	92.10.26.12.59.25;	author john;	state Exp;
branches;
next	1.7;

1.7
date	91.09.05.08.50.15;	author jkcohen;	state Exp;
branches;
next	1.6;

1.6
date	90.12.18.20.44.58;	author jkc;	state Exp;
branches;
next	1.5;

1.5
date	90.09.03.09.39.58;	author jkc;	state Exp;
branches;
next	1.4;

1.4
date	90.09.01.21.11.51;	author jkc;	state Exp;
branches;
next	1.3;

1.3
date	90.06.11.15.25.04;	author jkc;	state Exp;
branches;
next	1.2;

1.2
date	90.05.25.19.25.42;	author jkc;	state Exp;
branches;
next	1.1;

1.1
date	90.04.17.12.23.16;	author jkc;	state Exp;
branches;
next	;


desc
@Complex envelope and phase traces
@


1.35
log
@Kylee Brown and Steven Rennolet updates
@
text
@/* Copyright (c) Colorado School of Mines, 2011.*/
/* All rights reserved.                       */


/* SUATTRIBUTES:  $Revision: 1.28 $ ; $Date: 2010/11/18 19:19:35 $	*/


#include "su.h"
#include "segy.h"

/*********************** self documentation **********************/
char *sdoc[] = {
" 									",
" SUATTRIBUTES - instantaneous trace ATTRIBUTES 			",
" 									",
" suattributes <stdin >stdout mode=amp					",
" 									",
" Required parameters:							",
" 	none								",
" 									",
" Optional parameter:							",
" 	mode=amp	output flag 					",
" 	       		=amp envelope traces				",
" 	       		=phase phase traces				",
" 	       		=uphase unwrapped phase traces			",
" 	       		=freq frequency traces				",
"			=freqw Frequency Weighted Envelope		",
"			=thin  Thin-Bed (inst. freq - average freq)	",
"			=bandwith Instantaneous bandwidth		",
"			=normamp Normalized Phase (Cosine Phase)	",
" 	       		=fdenv 1st envelope traces derivative		",
" 	       		=sdenv 2nd envelope traces derivative		",
" 	       		=q Ins. Q Factor				",
"	unwrap=		default unwrap=0 for mode=phase			",
" 			default unwrap=1 for freq, uphase, freqw, Q	",
" 			dphase_min=PI/unwrap				",
"	wint=		windowing for freqw				",
"			windowing for thin				",
"			default=1 					",
" 			o--------o--------o				",
" 			data-1	data	data+1				",
" 									",
" Notes:								",
" This program performs complex trace attribute analysis. The first three",
" attributes, amp,phase,freq are the classical Taner, Kohler, and	",
" Sheriff, 1979.							",
" 									",
" 									",
" The unwrap parameter is active only for mode=freq and mode=phase. The	",
" quantity dphase_min is the minimum change in the phase angle taken to be",
" the result of phase wrapping, rather than natural phase variation in the",
" data. Setting unwrap=0 turns off phase-unwrapping altogether. Choosing",
" unwrap > 1 makes the unwrapping function more sensitive to phase changes.",
" Setting unwrap > 1 may be necessary to resolve higher frequencies in	",
" data (or sample data more finely). The phase unwrapping is crude. The ",
" differentiation needed to compute the instantaneous frequency		",
" freq(t)= d(phase)/dt is a simple centered difference.			",
"	 					       			",
" The mode=uphase generates uwrapped phase traces by integrating the	",
" instantaneous amplitude traces.		       			",
"	 					       			",
" Examples:								",
" suvibro f1=10 f2=50 t1=0 t2=0 tv=1 | suattributes2 mode=amp | ...	",
" suvibro f1=10 f2=50 t1=0 t2=0 tv=1 | suattributes2 mode=phase | ...	",
" suvibro f1=10 f2=50 t1=0 t2=0 tv=1 | suattributes2 mode=freq | ...	",
" suplane | suattributes mode=... | supswigb |...       		",

NULL};

/* Credits:
 *	CWP: Jack Cohen
 *      CWP: John Stockwell (added freq and unwrap features)
 *	UGM (Geophysics Students): Agung Wiyono
 *           email:aakanjas@@gmail.com (others)
 *	CSM: Kylee Brown and Steven Rennolet, Senior Design,
 *	     updates to instanteous phase, instantaneous frequency,
 *	     first time derivative of the envelope, second time derivative
 *	     of the envelope, instantaneous quality factor, and thin bed
 *	     indicator
 *					
 *
 * Algorithm:
 *	c(t) = hilbert_tranform_kernel(t) convolved with data(t)  
 *
 *  amp(t) = sqrt( c.re^2(t) + c.im^2(t))
 *  phase(t) = arctan( c.im(t)/c.re(t))
 *  freq(t) = d(phase)/dt
 *
 * Reference: 
 *  Taner, M. T., Koehler, A. F., and  Sheriff R. E.   "Complex seismic trace 
 *      analysis", Geophysics,  vol.44, p. 1041-1063, 1979
 *  Chopra, S. and K.  Marfurt, 2005, A historical perspective, Geophysics,
 *      vol. 70, no. 5, p.3SO-295SO, Society of Exploration Geophysicists.
 *  Barnes, A. E, 1992, The calculation of instantaneous frequency and 
 *      instantaneous bandwidth, Geophysics, vol. 57, no. 11, p. 1520-1524,
 *      Society of Exploration Geophysicists.
 *
 * Trace header fields accessed: ns, trid
 * Trace header fields modified: d1, trid

 */
/**************** end self doc ********************************/

#define	AMP		 1
#define	ARG		 2
#define	FREQ		 3
#define BANDWIDTH	 4
#define NORMAMP		 5
#define FREQW		 6
#define THIN		 7
#define FENV		 8
#define SENV		 9
#define Q		 10
#define UPHASE		 11

/* function prototype of functions used internally */
void unwrap_phase(int n, float unwrap, float *phase);
void differentate1d(int n, float h, float *f);
void twindow(int nt, int wtime, float *data);

segy tr;

int
main(int argc, char **argv)
{
	cwp_String mode;	/* display: real, imag, amp, arg	*/
	int imode=AMP;		/* integer abbrev. for mode in switch	*/
	register complex *ct;	/* complex trace			*/
	int nt;			/* number of points on input trace	*/
	float dt;		/* sample spacing			*/
	float *data;		/* array of data from each trace	*/
	float *hdata;		/* array of Hilbert transformed data	*/
	float unwrap;		/* PI/unwrap=min dphase assumed to by wrap*/
	int wint;		/* n time sampling to window */
	cwp_Bool seismic;	/* is this seismic data?		*/
	int ntout;
	/* Initialize */
	initargs(argc, argv);
	requestdoc(1);
	

	/* Get info from first trace */
	if (!gettr(&tr)) err("can't get first trace");
	nt = tr.ns;
	dt = ((double) tr.dt)/1000000.0;
	ntout = nt + nt -1;

	/* check to see if data type is seismic */
	seismic = ISSEISMIC(tr.trid);

	if (!seismic)
		warn("input is not seismic data, trid=%d", tr.trid);

	/* Get mode; note that imode is initialized to AMP */
	if (!getparstring("mode", &mode))	mode = "amp";

	if      (STREQ(mode, "phase"))  imode = ARG;
	else if (STREQ(mode, "freq"))	imode = FREQ;
	else if (STREQ(mode, "uphase"))  imode = UPHASE;
	else if (STREQ(mode, "bandwidth")) imode = BANDWIDTH;
	else if (STREQ(mode, "normamp")) imode = NORMAMP;
	else if (STREQ(mode, "freqw")) imode = FREQW;
	else if (STREQ(mode, "thin")) imode = THIN;
	else if (STREQ(mode, "fdenv")) imode = FENV;
	else if (STREQ(mode, "sdenv")) imode = SENV;
	else if (STREQ(mode, "q")) imode = Q;
	else if (!STREQ(mode, "amp"))
		err("unknown mode=\"%s\", see self-doc", mode);

	/* getpar value of unwrap */
	switch(imode) {
	case FREQ:
		if (!getparfloat("unwrap", &unwrap))	unwrap=1;
	break;
	case UPHASE:
		if (!getparfloat("unwrap", &unwrap))	unwrap=1;
	break;
	case Q:
		if (!getparfloat("unwrap", &unwrap))	unwrap=1;
	break;
	case FREQW:
		if (!getparfloat("unwrap", &unwrap))	unwrap=1;
		if (!getparint("wint", &wint))	wint=3; 
	break;
	case THIN:
		if (!getparfloat("unwrap", &unwrap))	unwrap=1;
		if (!getparint("wint", &wint))	wint=3;
	break;
	case ARG:
		if (!getparfloat("unwrap", &unwrap))	unwrap=0;
	break;
	}

	/* allocate space for data and hilbert transformed data, cmplx trace */
	data = ealloc1float(nt);
	hdata = ealloc1float(nt);
	ct = ealloc1complex(nt);


	/* Loop over traces */
	do {
		register int i;

		/* Get data from trace */
		for (i = 0; i < nt; ++i)  data[i] = tr.data[i];

		
		/* construct quadrature trace with hilbert transform */
		hilbert(nt, data, hdata);

		/* build the complex trace */
		for (i = 0; i < nt; ++i)  ct[i] = cmplx(data[i],hdata[i]);

		/* Form absolute value, phase, or frequency */
		switch(imode) {
		case AMP:
			for (i = 0; i < nt; ++i) {
				float re = ct[i].r;
				float im = ct[i].i;
				tr.data[i] = sqrt(re*re + im*im);
			}
			
			/* set trace id */
			tr.trid = ENVELOPE;
		break;
		case ARG:
		{
			float *phase = ealloc1float(nt);

			for (i = 0; i < nt; ++i) {
				float re = ct[i].r;
				float im = ct[i].i;
				if (re*re+im*im)  phase[i] = atan2(im, re);
				else              phase[i] = 0.0;
			}

			/* phase unwrapping */
			/* default unwrap=0 for this mode */
			if (unwrap!=0) unwrap_phase(nt, unwrap, phase);
			
			/* write phase values to tr.data */
			for (i = 0; i < nt; ++i) tr.data[i] = phase[i];
			
			/* set trace id */
			tr.trid = INSTPHASE;
		}
		break;
		case FREQ:
		{
			float *phase = ealloc1float(nt);
			float	fnyq = 0.5 / dt;

			for (i = 0; i < nt; ++i) {
				float re = ct[i].r;
				float im = ct[i].i;
				if (re*re+im*im) {
					phase[i] = atan2(im, re);
				} else {
					phase[i] = 0.0;
				}
				
			}

			/* unwrap the phase */
			if (unwrap!=0) unwrap_phase(nt, unwrap, phase);

			/* compute freq(t)=dphase/dt */
			differentate1d(nt, 2.0*PI*dt, phase);
			
			/* correct values greater nyquist frequency */
			for (i=0 ; i < nt; ++i)	{
				if (phase[i] > fnyq)
					phase[i] = 2 * fnyq - phase[i];
			}
                                        
			/* write freq(t) values to tr.data */
			for (i=0 ; i < nt; ++i) tr.data[i] = phase[i];

			/* set trace id */
			tr.trid = INSTFREQ;
		}
		break;
		case UPHASE:
		{
			float *phase = ealloc1float(nt);
			float	fnyq = 0.5 / dt;

			for (i = 0; i < nt; ++i) {
				float re = ct[i].r;
				float im = ct[i].i;
				if (re*re+im*im) {
					phase[i] = atan2(im, re);
				} else {
					phase[i] = 0.0;
				}
				
			}

			/* unwrap the phase */
			if (unwrap!=0) unwrap_phase(nt, unwrap, phase);

			/* compute freq(t)=dphase/dt */
			differentate1d(nt, 2.0*PI*dt, phase);
			
			/* correct values greater nyquist frequency */
			for (i=0 ; i < nt; ++i)	{
				if (phase[i] > fnyq)
					phase[i] = 2 * fnyq - phase[i];
			}
			/* integrate instantaneous frequency values */
			/* and write unwrapped phase values to tr.data */
			for (i = 1; i < nt; ++i) {
				tr.data[0] = phase[0];
                                tr.data[i] += phase[i-1];
                        }

			/* set trace id */
			tr.trid = INSTPHASE;
		}
		break;
		case FREQW:
		{
			float	fnyq = 0.5 / dt;
			float *freqw = ealloc1float(nt);
			float *phase = ealloc1float(nt);
			float *envelop = ealloc1float(nt);
			float *envelop2 = ealloc1float(nt);
			for (i = 0; i < nt; ++i) {
				float re = ct[i].r;
				float im = ct[i].i;
				if (re*re+im*im) {
					phase[i] = atan2(im, re);
					} else {
						phase[i] = 0.0;
						}
				envelop[i] = sqrt(re*re + im*im);
			}

			/* unwrap the phase */
			if (unwrap!=0) unwrap_phase(nt, unwrap, phase);

			/* compute freq(t)=dphase/dt */
			differentate1d(nt, 2.0*PI*dt, phase);
			
			/* correct values greater nyquist frequency */
			for (i=0 ; i < nt; ++i)	{
				if (phase[i] > fnyq)
					phase[i] = 2 * fnyq - phase[i];
			envelop2[i]=envelop[i]*phase[i];
			}
			twindow(nt, wint, envelop);
			twindow(nt, wint, envelop2);
			/* correct values greater nyquist frequency */
			for (i=0 ; i < nt; ++i) {
			freqw[i] = (envelop[i] == 0.0) ? 0.0 :envelop2[i]/envelop[i];
			}
			/* write freq(t) values to tr.data */
			for (i=0 ; i < nt; ++i) tr.data[i] = freqw[i];
			
			/* set trace id */
			tr.trid = INSTFREQ;
		}
		break;
		case THIN:
		{
			float	fnyq = 0.5 / dt;
			float *phase = ealloc1float(nt);
			float *freqw = ealloc1float(nt);
			float *phase2 = ealloc1float(nt);



			for (i = 0; i < nt; ++i) {
				float re = ct[i].r;
				float im = ct[i].i;

				if (re*re+im*im) {
					phase[i] = atan2(im, re);
				} else {
					phase[i] = 0.0;
				}
			}

			/* unwrap the phase */
			if (unwrap!=0) unwrap_phase(nt, unwrap, phase);

			/* compute freq(t)=dphase/dt */
			differentate1d(nt, 2.0*PI*dt, phase);

			/* correct values greater nyquist frequency */
			for (i=0 ; i < nt; ++i)	{
				if (phase[i] > fnyq)
					phase[i] = 2 * fnyq - phase[i];
					phase2[i]= 2 * fnyq - phase[i];
			}
			/* Do windowing for Average Ins . Freq over wint*/
			twindow(nt, wint, phase2);

			for (i=0 ; i < nt; ++i)	{
				freqw[i] = phase[i] - phase2[i];
			/*	if (abs(freqw[i]) > fnyq)
				freqw[i] = 2 * fnyq - freqw[i];
			*/
			/* write Thin-Bed(t) values to tr.data */
				tr.data[i] = freqw[i];
				}
			/* set trace id */
			tr.trid = INSTFREQ;
		}
		break;
		case BANDWIDTH:
		{
			float *envelop = ealloc1float(nt);
			float *envelop2 = ealloc1float(nt);

		/* Bandwidth (Barnes 1992)

		          |d(envelope)/dt|
		band =abs |--------------|
		          |2 PI envelope |
	 	*/

			for (i = 0; i < nt; ++i) {
				float er = ct[i].r;
				float em = ct[i].i;
				envelop[i] = sqrt(er*er + em*em);
				envelop2[i]=sqrt(er*er + em*em);

			}
				differentate1d(nt, dt, envelop);

				for (i = 0; i < ntout; ++i) {
				   if (2.0*PI*envelop2[i]!=0.0) {
					tr.data[i] = ABS(envelop[i]/(2.0*PI*envelop2[i]));
				   } else {
				        tr.data[i]=0.0;
				   }
				}
				tr.trid = ENVELOPE;
		}
		break;
		case NORMAMP:
		{
			float phase;
			float *na = ealloc1float(nt);
			for (i = 0; i < nt; ++i) {
				float re = ct[i].r;
				float im = ct[i].i;
				if (re*re+im*im)  phase = atan2(im, re);
				else              phase = 0.0;
				na[i] = cos(phase);
			}
			for (i=0 ; i < nt; ++i) tr.data[i] = na[i];
			
			/* set trace id */
			tr.trid = INSTPHASE;
			}
		break;
		case FENV:
		{
			float *amp = ealloc1float(nt);
			for (i = 0; i < nt; ++i) {
				float re = ct[i].r;
				float im = ct[i].i;
				amp[i] = sqrt(re*re + im*im);
			}
		/*conv(nt, 0, envelop, nt, 0, time, ntout, 0, ouput);*/

		differentate1d(nt, 2.0*PI*dt, amp);
		for (i=0 ; i < nt; ++i) tr.data[i] = amp[i];
			/* set trace id */
			tr.trid = ENVELOPE;
		}
		break;
		case SENV:
		{
			float *amp = ealloc1float(nt);
			for (i = 0; i < nt; ++i) {
				float re = ct[i].r;
				float im = ct[i].i;
				amp[i] = sqrt(re*re + im*im);
			}

		differentate1d(nt, 2.0*PI*dt, amp);
		differentate1d(nt, 2.0*PI*dt, amp);
		for (i=0 ; i < nt; ++i) tr.data[i] = amp[i];
			/* set trace id */
			tr.trid = ENVELOPE;
		}
		break;

		case Q:
		{
			float *envelop = ealloc1float(nt);
			float *envelop2 = ealloc1float(nt);
			float *phase = ealloc1float(nt);
			float	fnyq = 0.5 / dt;

		/* Banswith (Barnes 1992)

		        -PI Freq(t) d(envelope)/dt
		band =  --------------------------
		                 envelope(t)
	 	*/

			for (i = 0; i < nt; ++i) {
				float re = ct[i].r;
				float im = ct[i].i;
				envelop[i] = sqrt(re*re + im*im);
				envelop2[i]=sqrt(re*re + im*im);
				if (re*re+im*im) {
					phase[i] = atan2(im, re);
				} else {
					phase[i] = 0.0;
				}

			}
			/* get envelope diff */
			differentate1d(nt, dt, envelop);
			/* unwrap the phase */
			if (unwrap!=0) unwrap_phase(nt, unwrap, phase);
			/* compute freq(t)=dphase/dt */
			differentate1d(nt, 2.0*PI*dt, phase);

			for (i=0 ; i < nt; ++i)	{
				if (phase[i] > fnyq)
					phase[i] = 2 * fnyq - phase[i];
			}

			for (i = 0; i < ntout; ++i) {
				if (envelop[i]!=0.0)
				tr.data[i] = -1*PI*phase[i]*envelop2[i]/envelop[i];
				else
				tr.data[i]=0.0;
				}
				tr.trid = INSTFREQ;
		}
		break;
		default:
			err("%s: mysterious mode=\"%s\"", __LINE__, mode);
		}


		tr.d1 = dt;   /* for graphics */
		puttr(&tr);

	} while (gettr(&tr));


	return(CWP_Exit());
}


void differentate1d(int n, float h, float *f)
/************************************************************************
differentate1d - compute the 1st derivative of a function f[]
************************************************************************
Input:
n		number of samples
h		sample rate
f		array[n] of input values

Output:
f		array[n], the derivative of f
************************************************************************
Notes:
This is a simple 2 point centered-difference differentiator.
The derivatives at the endpoints are computed via 2 point leading and
lagging differences. 
************************************************************************
Author: John Stockwell, CWP, 1994
************************************************************************/
{
	int i;	
	float *temp;
	float h2=2*h;

	/* allocate space in temporary vector */
	temp = ealloc1float(n);

	/* do first as a leading difference */
	temp[0] = (f[1] - f[0])/h;

	/* do the middle values as a centered difference */
	for (i=1; i<n-1; ++i) temp[i] = (f[i+1] - f[i-1])/h2;

	/* do last value as a lagging difference */
	temp[n-1] = (f[n-1] - f[n-2])/h;

	for (i=0 ; i < n ; ++i) f[i] = temp[i];

	free1float(temp);
}

void unwrap_phase(int n, float w, float *phase)
/************************************************************************
unwrap_phase - unwrap the phase
*************************************************************************
Input:
n		number of samples
w		unwrapping flag; returns an error if w=0
phase		array[n] of input phase values

Output:
phase		array[n] of output phase values
*************************************************************************
Notes:
The phase is assumed to be continuously increasing. The strategy is
to look at the change in phase (dphase) with each time step. If it is larger
than PI/w, then use the previous value of dphase. No attempt is
made at smoothing the dphase curve.
*************************************************************************
Author: John Stockwell, CWP, 1994
************************************************************************/
{
	int i;
	float pibyw=0.0;
	float *dphase;
	float *temp;

	/* prevent division by zero in PI/w */
	if (w==0)  err("wrapping parameter is zero");
	else       pibyw = PI/w;

	/* allocate space */
	dphase = ealloc1float(n);
	temp = ealloc1float(n);

	/* initialize */
	temp[0]=phase[0];
	dphase[0]=0.0;

	/* compute unwrapped phase at each time step */
	for (i = 1; i < n; ++i) {

		/* compute jump in phase */
		dphase[i] = ABS(phase[i] - phase[i-1]);

		/* if dphase >= PI/w, use previous dphase value */
		if (ABS(dphase[i] - dphase[i-1]) >= pibyw )
			dphase[i] = dphase[i-1];

		/* sum up values in temporary vector */
		temp[i] = temp[i-1] + dphase[i];
	}

	/* assign values of temporary vector to phase[i] */
	for (i=0; i<n; ++i) phase[i] = temp[i];

	/* free space */
	free1float(temp);
	free1float(dphase);
}

void twindow(int nt, int wtime, float *data)
/************************************************************
twindow - simple time gating
*************************************************************
Input:
nt	number of time samples
wtime	= n*dt   where n are integer ex=1,2,3,4,5,...
          wtime=3 as default
 used for Frequency Weighted and Thin-bed attributes
*************************************************************
Author:	UGM (Geophysics Students): Agung Wiyono, 2005
************************************************************/
{
	float val;
	float *temp;
	int i;
	float sum;
	int nwin;
	
	nwin=2*wtime+1;
	temp = ealloc1float(nt);
	sum=0.0;
	for (i = 0; i< wtime+1; ++i) {
		val = data[i];
		sum +=val;
	}
	/* weighted */
	temp[0] = sum/nwin;
	
	/* dt<wtime */
	for (i = 1; i < wtime; ++i) {
		val = data[i+wtime];
		sum+=val;
		++nwin;
		temp[i] = sum/nwin;
		}
	/*wtime<dt<dt-wtime */
	for (i = wtime ; i < nt-wtime; ++i) {
		val = data[i+wtime];
		sum += val;
		val = data[i-wtime];
		sum -=val;
		temp[i] = sum/nwin;
	}

	/*dt-wtime<dt*/
	for (i = nt - wtime; i < nt; ++i) {
		val = data[i-wtime];
		sum -= val;
		--nwin;
		temp[i] = sum/nwin;
	}
	
	
	for (i=0; i<nt; ++i) data[i] = temp[i];

	/* Memori free */
	free1float(temp);
}



@


1.34
log
@corrected the thin bed attribute
@
text
@d2 4
a5 1
/* All rights reserved.		       */
a6 1
/* SUATTRIBUTES:  $Revision: 1.33 $ ; $Date: 2011/12/20 17:51:06 $	*/
d25 1
d27 2
a33 1
" ... unwrapping related options ....					",
a36 5
"       trend=0		=1 remove the linear trend of the inst. phase	",
" 	zeromean=0	=1 assume instantaneous phase is zero mean	",
" 									",
"			=freqw Frequency Weighted Envelope		",
"			=thin  Thin-Bed (inst. freq - average freq)	",
a46 3
"  									",
" The unwrapping algorithm is the \"simple\" unwrapping algorithm that	",
" searches for jumps in phase.						",
d48 6
a53 5
" The quantity dphase_min is the minimum change in the phase angle taken",
" to be the result of phase wrapping, rather than natural phase	 ",
" variation in the data. Setting unwrap=0 turns off phase-unwrapping	",
" alltogether. Choosing  unwrap > 1 makes the unwrapping function more	",
" sensitive to instantaneous phase changes.				",
d55 6
a60 1
" data (or sample data more finely).					",
d67 1
a67 1
"	 					       			",
d71 1
a71 1
 *	CWP: Jack K. Cohen
d74 6
a79 1
 *	   email:aakanjas@@gmail.com (others) added more attributes
d89 8
a96 2
 * Reference: Taner, M. T., Koehler, A. F., and  Sheriff R. E.
 * "Complex seismic trace analysis", Geophysics,  vol.44, p. 1041-1063, 1979
d117 1
d128 1
a128 1
	register complex *ct=NULL;	/* complex trace		*/
d131 2
a132 2
	float *data=NULL;	/* array of data from each trace	*/
	float *hdata=NULL;	/* array of Hilbert transformed data	*/
a136 3
	int trend=0;		/* =1 remove trend from instantaneous phase */
	int zeromean=0;		/* =1 assume zero mean inst. phase func. */

d140 1
a155 1
	if (!getparint("trend", &trend))	trend=0;
a193 2
	checkpars();

d199 1
a229 2
			/* capture real and imaginary parts of the data */
			/* calculate unwrapped phase			*/
d233 2
a234 5
				if (re*re+im*im){
					phase[i] = atan2(im, re);
				} else {
					phase[i] = 0.0;
					}
d236 4
a239 4
			    
			/* unwrap the phase */
			if (unwrap!=0) 
			simple_unwrap_phase(nt, trend, zeromean, unwrap, phase);
d250 1
a250 5
			float *freq = ealloc1float(nt);
			float *u = ealloc1float(nt);
			float *uprime = ealloc1float(nt);
			float *v = ealloc1float(nt);
			float *vprime = ealloc1float(nt);
d254 4
a257 23
				u[i] = ct[i].r;
				uprime[i] = ct[i].r;
				v[i] = ct[i].i;
				vprime[i] = ct[i].i;
			}

			/* compute inst. frequency by computing the	*/
			/* derivative of the instantaneous phase.	*/
			/* Note that: 					*/
			/* freq(t) = d/dt[ phase[t] ] 			*/ 
			/*  = d/dt ( arctan (v/u) )			*/
			/*   = [ 1/ (1 +(v/u)^2) ] ( v'/u - vu'/u^2 )	*/
			/*   = ( v'u - vu' )/(u^2 +v^2)			*/

			differentate1d(nt, 2.0*PI*dt,uprime );
			differentate1d(nt, 2.0*PI*dt,vprime );

			for (i=0; i < nt ; ++i){
				float num = (vprime[i]*u[i] - v[i]*uprime[i]);
				float den = (u[i]*u[i] + v[i]*v[i]);
			
				if (ABS(den)>FLT_EPSILON){
					freq[i] = num/den;
d259 1
a259 1
					freq[i] = 0.0;
d261 8
d270 4
a273 8
				/* correct values greater nyquist frequency */
				if (freq[i] > fnyq)
					freq[i] = 2 * fnyq - freq[i];
				if (freq[i] < 0 )
					freq[i] = ABS(freq[i]);

				/* write freq(t) values to tr.data */
				tr.data[i] = freq[i];
d275 3
a277 1
					
d286 1
d300 1
a300 1
			simple_unwrap_phase(nt, trend, zeromean, unwrap, phase);
d302 14
a315 2
			/* write phase values into the trace*/
			for (i=0 ; i < nt; ++i) tr.data[i] = phase[i];
d324 2
a325 5
			float *u = ealloc1float(nt);
			float *uprime = ealloc1float(nt);
			float *v = ealloc1float(nt);
			float *vprime = ealloc1float(nt);
			float *freq = ealloc1float(nt);
d328 10
d339 2
a340 23
			for (i = 0; i < nt; ++i) {
				u[i] = ct[i].r;
				uprime[i] = ct[i].r;
				v[i] = ct[i].i;
				vprime[i] = ct[i].i;
			}

			/* compute inst. frequency by computing the	*/
			/* derivative of the instantaneous phase.	*/
			/* Note that: 					*/
			/* freq(t) = d/dt[ phase[t] ] 			*/ 
			/*  = d/dt ( arctan (v/u) )			*/
			/*   = [ 1/ (1 +(v/u)^2) ] ( v'/u - vu'/u^2 )	*/
			/*   = ( v'u - vu' )/(u^2 +v^2)			*/

			differentate1d(nt, 2.0*PI*dt,uprime );
			differentate1d(nt, 2.0*PI*dt,vprime );


			for (i=0; i < nt ; ++i){
				float num = (vprime[i]*u[i] - v[i]*uprime[i]);
				float den = (u[i]*u[i] + v[i]*v[i]);
			
d342 2
a343 5
				if (ABS(den)>FLT_EPSILON){
					freq[i] = num/den;
				} else {
					freq[i] = 0.0;
				}
d345 5
a349 10
				/* correct values greater nyquist frequency */
				if (freq[i] > fnyq)
					freq[i] = 2 * fnyq - freq[i];
				if (freq[i] < 0 )
					freq[i] = ABS(freq[i]);
			
				envelop[i] = sqrt(den);

				envelop2[i]=envelop[i]*freq[i];

a350 1
			
a352 1

d355 1
a355 1
			freq[i] = (envelop[i] == 0.0) ? 0.0 :envelop2[i]/envelop[i];
a356 1

d358 1
a358 1
			for (i=0 ; i < nt; ++i) tr.data[i] = freq[i];
a369 1
			
d371 2
a372 1
			/* calculate the unwrapped phase */
d385 1
a385 1
			simple_unwrap_phase(nt, trend, zeromean, unwrap, phase);
d394 1
a394 1
				phase2[i]=phase[i];
d418 1
a418 1
			  |d(envelope)/dt|
d420 1
a420 1
			  |2 PI envelope |
d436 1
a436 1
					tr.data[i]=0.0;
d450 1
a450 1
				else	      phase = 0.0;
d469 2
a470 4
			differentate1d(nt, 2.0*PI*dt, amp);

			for (i=0 ; i < nt; ++i) tr.data[i] = amp[i];

d499 1
a499 1
		/* Bandwidth (Barnes 1992)
d501 1
a501 1
			-PI Freq(t) d(envelope)/dt
d503 1
a503 1
				 envelope(t)
a519 1

d521 1
a521 2
			simple_unwrap_phase(nt, trend, zeromean, unwrap, phase);

d595 60
d662 1
a662 1
	  wtime=3 as default
d711 1
a711 1
	/* Memory free */
@


1.33
log
@better phase unwrapping in instantaneous phase and freq calculations
@
text
@d4 1
a4 1
/* SUATTRIBUTES:  $Revision: 1.32 $ ; $Date: 2011/12/01 18:50:34 $	*/
d418 1
a418 1
					phase2[i]= 2 * fnyq - phase[i];
@


1.32
log
@put in average of dphase as new dphase
@
text
@d2 1
a2 1
/* All rights reserved.                       */
d4 1
a4 1
/* SUATTRIBUTES:  $Revision: 1.31 $ ; $Date: 2011/11/16 17:24:58 $	*/
a22 1
" 	       		=uphase unwrapped phase traces			",
a23 2
"			=freqw Frequency Weighted Envelope		",
"			=thin  Thin-Bed (inst. freq - average freq)	",
d29 1
d33 5
d48 3
d52 5
a56 6
" 									",
" The unwrap parameter is active only for mode=freq and mode=phase. The	",
" quantity dphase_min is the minimum change in the phase angle taken to be",
" the result of phase wrapping, rather than natural phase variation in the",
" data. Setting unwrap=0 turns off phase-unwrapping altogether. Choosing",
" unwrap > 1 makes the unwrapping function more sensitive to phase changes.",
d58 1
a58 6
" data (or sample data more finely). The phase unwrapping is crude. The ",
" differentiation needed to compute the instantaneous frequency		",
" freq(t)= d(phase)/dt is a simple centered difference.			",
"	 					       			",
" The mode=uphase generates uwrapped phase traces by integrating the	",
" instantaneous amplitude traces.		       			",
d65 1
a65 1

d69 1
a69 1
 *	CWP: Jack Cohen
d72 1
a72 1
 *           email:aakanjas@@gmail.com (others)
a103 1
void unwrap_phase(int n, float unwrap, float *phase);
d114 1
a114 1
	register complex *ct;	/* complex trace			*/
d117 2
a118 2
	float *data;		/* array of data from each trace	*/
	float *hdata;		/* array of Hilbert transformed data	*/
d123 3
a128 1
	
d144 1
d182 2
a183 1
        checkpars();
a189 1

d220 2
d225 5
a229 2
				if (re*re+im*im)  phase[i] = atan2(im, re);
				else              phase[i] = 0.0;
d231 4
a234 4

			/* phase unwrapping */
			/* default unwrap=0 for this mode */
			if (unwrap!=0) unwrap_phase(nt, unwrap, phase);
d245 5
a249 1
			float *phase = ealloc1float(nt);
d253 23
a275 4
				float re = ct[i].r;
				float im = ct[i].i;
				if (re*re+im*im) {
					phase[i] = atan2(im, re);
d277 1
a277 1
					phase[i] = 0.0;
d279 6
a284 2
				
			}
d286 2
a287 10
			/* unwrap the phase */
			if (unwrap!=0) unwrap_phase(nt, unwrap, phase);

			/* compute freq(t)=dphase/dt */
			differentate1d(nt, 2.0*PI*dt, phase);
			
			/* correct values greater nyquist frequency */
			for (i=0 ; i < nt; ++i)	{
				if (phase[i] > fnyq)
					phase[i] = 2 * fnyq - phase[i];
d289 1
a289 3
                                        
			/* write freq(t) values to tr.data */
			for (i=0 ; i < nt; ++i) tr.data[i] = phase[i];
a297 1
			float	fnyq = 0.5 / dt;
d311 1
a311 1
			if (unwrap!=0) unwrap_phase(nt, unwrap, phase);
d313 2
a314 14
			/* compute freq(t)=dphase/dt */
			differentate1d(nt, 2.0*PI*dt, phase);
			
			/* correct values greater nyquist frequency */
			for (i=0 ; i < nt; ++i)	{
				if (phase[i] > fnyq)
					phase[i] = 2 * fnyq - phase[i];
			}
			/* integrate instantaneous frequency values */
			/* and write unwrapped phase values to tr.data */
			for (i = 1; i < nt; ++i) {
				tr.data[0] = phase[0];
                                tr.data[i] += phase[i-1];
                        }
d323 5
a327 2
			float *freqw = ealloc1float(nt);
			float *phase = ealloc1float(nt);
d330 1
d332 36
a367 9
				float re = ct[i].r;
				float im = ct[i].i;
				if (re*re+im*im) {
					phase[i] = atan2(im, re);
					} else {
						phase[i] = 0.0;
						}
				envelop[i] = sqrt(re*re + im*im);
			}
d369 1
a369 2
			/* unwrap the phase */
			if (unwrap!=0) unwrap_phase(nt, unwrap, phase);
d371 1
a371 2
			/* compute freq(t)=dphase/dt */
			differentate1d(nt, 2.0*PI*dt, phase);
a372 6
			/* correct values greater nyquist frequency */
			for (i=0 ; i < nt; ++i)	{
				if (phase[i] > fnyq)
					phase[i] = 2 * fnyq - phase[i];
			envelop2[i]=envelop[i]*phase[i];
			}
d375 1
d378 1
a378 1
			freqw[i] = (envelop[i] == 0.0) ? 0.0 :envelop2[i]/envelop[i];
d380 1
d382 1
a382 1
			for (i=0 ; i < nt; ++i) tr.data[i] = freqw[i];
d394 1
d396 1
a396 2


d409 1
a409 1
			if (unwrap!=0) unwrap_phase(nt, unwrap, phase);
d442 1
a442 1
		          |d(envelope)/dt|
d444 1
a444 1
		          |2 PI envelope |
d460 1
a460 1
				        tr.data[i]=0.0;
d474 1
a474 1
				else              phase = 0.0;
d493 4
a496 2
		differentate1d(nt, 2.0*PI*dt, amp);
		for (i=0 ; i < nt; ++i) tr.data[i] = amp[i];
d525 1
a525 1
		/* Banswith (Barnes 1992)
d527 1
a527 1
		        -PI Freq(t) d(envelope)/dt
d529 1
a529 1
		                 envelope(t)
d546 1
d548 2
a549 1
			if (unwrap!=0) unwrap_phase(nt, unwrap, phase);
a622 64
void unwrap_phase(int n, float w, float *phase)
/************************************************************************
unwrap_phase - unwrap the phase
*************************************************************************
Input:
n		number of samples
w		unwrapping flag; returns an error if w=0
phase		array[n] of input phase values

Output:
phase		array[n] of output phase values
*************************************************************************
Notes:
The phase is assumed to be continuously increasing. The strategy is
to look at the change in phase (dphase) with each time step. If it is larger
than PI/w, then use the previous value of dphase. No attempt is
made at smoothing the dphase curve.
*************************************************************************
Author: John Stockwell, CWP, 1994
************************************************************************/
{
	int i;
	float pibyw=0.0;
	float *dphase;
	float *temp;

	/* prevent division by zero in PI/w */
	if (w==0)  err("wrapping parameter is zero");
	else       pibyw = PI/w;

	/* allocate space */
	dphase = ealloc1float(n);
	temp = ealloc1float(n);

	/* initialize */
	temp[0]=phase[0];
	dphase[0]=0.0;

	/* compute unwrapped phase at each time step */
	for (i = 1; i < n; ++i) {

		/* compute jump in phase */
		dphase[i] = phase[i] - phase[i-1];
		if (i< n-1){ 
			dphase[i+1] = phase[i+1] - phase[i];
		}

		/* if dphase >= PI/w, use average of previous and next dphase */
		if (ABS(dphase[i] - dphase[i-1]) >= pibyw ) {
			dphase[i] = ( dphase[i+1] + dphase[i-1])/2.0;
		}

		/* sum up values in temporary vector */
		temp[i] = temp[i-1] + dphase[i];
	}

	/* assign values of temporary vector to phase[i] */
	for (i=0; i<n; ++i) phase[i] = temp[i];

	/* free space */
	free1float(temp);
	free1float(dphase);
}

d630 1
a630 1
          wtime=3 as default
d679 1
a679 1
	/* Memori free */
@


1.31
log
@added Reg Beardsley
''s checkpar() calls
@
text
@d4 1
a4 1
/* SUATTRIBUTES:  $Revision: 1.29 $ ; $Date: 2011/09/09 22:29:07 $	*/
d625 4
a628 1
		dphase[i] = ABS(phase[i] - phase[i-1]);
d630 4
a633 3
		/* if dphase >= PI/w, use previous dphase value */
		if (ABS(dphase[i] - dphase[i-1]) >= pibyw )
			dphase[i] = dphase[i-1];
@


1.30
log
@copyright
@
text
@d180 1
@


1.29
log
@*** empty log message ***
@
text
@d1 4
a4 1
/* SUATTRIBUTES:  $Revision: 1.28 $ ; $Date: 2010/11/18 19:19:35 $	*/
@


1.28
log
@added uphase (unwrapped phase parameter)
@
text
@d1 1
a1 1
/* SUATTRIBUTES:  $Revision: 1.27 $ ; $Date: 2005/03/09 17:29:26 $	*/
d102 1
a102 1
void differentiate(int n, float h, float *f);
d252 1
a252 1
			differentiate(nt, 2.0*PI*dt, phase);
d287 1
a287 1
			differentiate(nt, 2.0*PI*dt, phase);
d327 1
a327 1
			differentiate(nt, 2.0*PI*dt, phase);
d372 1
a372 1
			differentiate(nt, 2.0*PI*dt, phase);
d414 1
a414 1
				differentiate(nt, dt, envelop);
d453 1
a453 1
		differentiate(nt, 2.0*PI*dt, amp);
d468 2
a469 2
		differentiate(nt, 2.0*PI*dt, amp);
		differentiate(nt, 2.0*PI*dt, amp);
d503 1
a503 1
			differentiate(nt, dt, envelop);
d507 1
a507 1
			differentiate(nt, 2.0*PI*dt, phase);
d538 1
a538 1
void differentiate(int n, float h, float *f)
d540 1
a540 1
differentiate - compute the 1st derivative of a function f[]
@


1.27
log
@new version
@
text
@d1 1
a1 1
/* SUATTRIBUTES:  $Revision: 1.25 $ ; $Date: 2004/08/17 16:17:07 $	*/
a9 1
" 		 							",
d20 1
d30 1
a30 1
" 			default unwrap=1 for mode=freq			",
d54 3
d98 1
d143 1
d159 3
d267 38
@


1.26
log
@changed "err" to "warn" for nonseismic data. Added normalize option
to normalize output by instantaneous amplitude.
@
text
@d1 1
a1 1
/* SUATTRIBUTES:  $Revision: 1.25 $ ; $Date: 2003/06/09 16:17:07 $	*/
d9 2
a10 2
" SUATTRIBUTES - trace ATTRIBUTES instantanteous amplitude, phase,	",
" 		 or frequency						",
d22 7
d32 6
a37 2
"	normalize=0		=1 normalize by instantaneous amplitude	 	",
"	verbose=0	silent =1 chatty				",
d39 3
a42 2
" This program performs complex trace attribute analysis, a la Taner,	",
" Kohler, and Sheriff, 1979.						",
d55 3
a57 3
" suvibro f1=10 f2=50 t1=0 t2=0 tv=1 | suattributes mode=amp | ...	",
" suvibro f1=10 f2=50 t1=0 t2=0 tv=1 | suattributes mode=phase | ...	",
" suvibro f1=10 f2=50 t1=0 t2=0 tv=1 | suattributes mode=freq | ...	",
d59 1
a59 1
"	 					       			",
d65 3
d81 1
a82 1

d88 7
a94 1

d99 1
a109 2
	int normalize;		/* normalize				*/
	int verbose;		/* verbose				*/
d114 1
d116 1
a116 1
	
d120 1
d126 1
d139 7
d152 12
a163 1
		if (!getparfloat("unwrap", &unwrap))	unwrap=1; 
d166 1
a166 1
		if (!getparfloat("unwrap", &unwrap))	unwrap=0; 
a169 4
	/* getpar values of other optional parameters  */
	if (!getparint("normalize",&normalize))	normalize=0;
	if (!getparint("verbose",&verbose))	verbose=0;

d198 1
a198 1

d216 1
a216 1

d218 2
a219 13
			for (i = 0; i < nt; ++i) {
				if (normalize) {
					float re = ct[i].r;
					float im = ct[i].i;
					float amp = sqrt(re*re + im*im);

					if(!amp) amp = 1.0;

					tr.data[i] = phase[i]/amp;
				} else {
					tr.data[i] = phase[i];
				}
			}
a221 1
			
d248 1
a248 1
				if (phase[i] > fnyq)	
d251 1
a251 1
                                         
d253 13
d267 9
a275 4
				if (normalize) {
					float re = ct[i].r;
					float im = ct[i].i;
					float amp = sqrt(re*re + im*im);
d277 2
a278 1
					if(!amp) amp = 1.0;
d280 37
a316 1
					tr.data[i] = phase[i]/amp;
d318 1
a318 1
					tr.data[i] = phase[i];
d321 71
d394 81
a474 1
			tr.trid = INSTFREQ;
d569 1
d591 64
a654 1
}		
@


1.25
log
@9 June 2003
@
text
@d1 1
a1 1
/* SUATTRIBUTES:  $Revision: 1.24 $ ; $Date: 1998/01/08 18:42:05 $	*/
d25 3
a28 1
" Notes:								",
d88 2
d109 1
a109 1
		err("input is not seismic data, trid=%d", tr.trid);
d129 4
d181 13
a193 2
			for (i = 0; i < nt; ++i) tr.data[i] = phase[i];
			
d196 1
d228 13
a240 1
			for (i=0 ; i < nt; ++i) tr.data[i] = phase[i];
@


1.24
log
@new fixes to prevent phase-unwrapping problems if the calculated
instantaneous frequency is larger than nyquist.
@
text
@d1 1
a1 1
/* SUATTRIBUTES:  $Revision: 1.23 $ ; $Date: 1997/08/28 15:59:55 $	*/
d225 1
a225 1
	return EXIT_SUCCESS;
@


1.23
log
@added toralf's fix of dphase computation in unwrap_phase subroutine.
@
text
@d1 1
a1 1
/* SUATTRIBUTES:  $Revision: 1.22 $ ; $Date: 1997/07/28 22:36:46 $	*/
d182 1
d200 6
a327 1

@


1.22
log
@changes suggested by Stew Levin to silence SGI compiler warnings, etc
@
text
@d1 1
a1 1
/* SUATTRIBUTES:  $Revision: 1.21 $ ; $Date: 1996/09/05 19:13:24 $	*/
d307 2
a308 2
		if (i>1 && ABS(dphase[i] - dphase[i-1]) >= pibyw )
					dphase[i] = dphase[i-1];
@


1.21
log
@Fixed -Wall complaints.
@
text
@d1 1
a1 1
/* SUATTRIBUTES:  $Revision: 1.20 $ ; $Date: 1996/01/24 18:18:21 $	*/
a89 1
	complex czero;		/* complex zero				*/
a129 1
	czero = cmplx(0.0, 0.0);
@


1.20
log
@Handle header fields accessed/modified for sudoc.
Cosmetics: combine initializations with declarations in the case
           define dt since used twice and it improves readability
@
text
@d1 1
a1 1
/* SUATTRIBUTES:  $Revision: 1.19 $ ; $Date: 1995/10/04 16:42:20 $	*/
d79 1
d83 1
a83 1
	int imode;		/* integer abbrev. for mode in switch	*/
d108 1
a108 1
	/* Get mode */
d111 1
a111 2
	if (STREQ(mode, "amp"))		imode = AMP;
	else if (STREQ(mode, "phase"))	imode = ARG;
d113 2
a114 1
	else err("unknown mode=\"%s\"", mode);
d203 1
a203 1
			for (i=0 ; i < nt; i++) tr.data[i] = phase[i];
d255 1
a255 1
	for (i=1; i<n-1; i++) temp[i] = (f[i+1] - f[i-1])/h2;
d260 1
a260 1
	for (i=0 ; i < n ; i++) f[i] = temp[i];
d287 1
a287 2
	float shift=0;
	float pibyw;
d292 2
a293 5
	if (w==0) {
		err("wrapping parameter is zero");
	} else {
		pibyw = PI/w;
	}
d303 1
a303 1
	for (i = 1; i < n; i++) {
d317 1
a317 1
	for (i=0; i<n; i++) phase[i] = temp[i];
@


1.19
log
@name change from suenv to suattributes, and corresponding cosmetics
@
text
@d1 1
a1 1
/* SUATTRIBUTES:  $Revision: 1.18 $ ; $Date: 1995/08/02 19:37:43 $	*/
d62 2
d73 1
a73 1
/* function prototype of function used internally */
d85 1
d99 1
d160 1
a160 3
			float *phase;

			phase = ealloc1float(nt);
d182 1
a182 3
			float *phase;

			phase = ealloc1float(nt);
d199 1
a199 3
			differentiate(nt,
				      2.0*PI*((double) tr.dt)/1000000.0,
				      phase);
d213 1
a213 1
		tr.d1 = (float) tr.dt / 1000000.0;   /* for graphics */
@


1.18
log
@Cast the integers tr.dt and/or tr.delrt and/or clones to double before
division with floating constant (which is implicitly double
precision).  Casting is needed to make some compilers happy and if we
cast to float then there will be an extra conversion to double because
of the floating constant (casting to float and writing 1000000.0F
would save a conversion, but most people find that F yucky and
efficiency is not an issue here).
Motivated by examples from Stew Levin.
@
text
@d1 1
a1 1
/* SUENV:  $Revision: 1.17 $ ; $Date: 1994/08/25 14:59:13 $	*/
d9 2
a10 1
" SUENV - Complex envelope, phase, or frequency time traces		",
d12 1
a12 1
" suenv <stdin >stdout mode=amp						",
d29 1
d41 4
a44 4
" suvibro f1=10 f2=50 t1=0 t2=0 tv=1 | suenv mode=amp | supsgraph |...	",
" suvibro f1=10 f2=50 t1=0 t2=0 tv=1 | suenv mode=phase | supsgraph |...",
" suvibro f1=10 f2=50 t1=0 t2=0 tv=1 | suenv mode=freq | supsgraph |...	",
" suplane | suenv mode=... | supswigb |...       			",
@


1.17
log
@Removed copyright statement from codes that had it.
Moved self-doc line for sudoc.
@
text
@d1 1
a1 1
/* SUENV:  $Revision: 1.16 $ ; $Date: 94/03/31 15:04:57 $	*/
d197 4
a200 2
			differentiate(nt, 2*PI*tr.dt/1000000.0, phase);
			
@


1.16
log
@put some free1float(temp) sorts of things in the subroutines.
@
text
@d1 1
a1 14
/* SUENV:  $Revision: 1.15 $ ; $Date: 94/03/31 14:23:07 $	*/

/*----------------------------------------------------------------------
 * Copyright (c) Colorado School of Mines, 1990.
 * All rights reserved.
 *
 * This code is part of SU.  SU stands for Seismic Unix, a processing line
 * developed at the Colorado School of Mines, partially based on Stanford
 * Exploration Project (SEP) software.  Inquiries should be addressed to:
 *
 *  Jack K. Cohen, Center for Wave Phenomena, Colorado School of Mines,
 *  Golden, CO 80401  (jkc@@dix.mines.colorado)
 *----------------------------------------------------------------------
 */
@


1.15
log
@removed extraneous defines, fixed a bug in the differentiator, cleaned
up selfdoc.
@
text
@d1 1
a1 1
/* SUENV:  $Revision: 1.14 $ ; $Date: 94/03/31 13:11:52 $	*/
d271 2
d333 3
@


1.14
log
@cosmetic.
@
text
@d1 1
a1 1
/* SUENV:  $Revision: 1.13 $ ; $Date: 94/03/31 12:43:52 $	*/
d47 3
a49 3
" data properly. The phase unwrapping is crude. The differentiation needed",
" to compute the instantaneous frequency freq(t)= d(phase)/dt is a simple",
" centered difference.				       			",
d64 1
a64 1
 *	c(t) = CABS( [INVFFT{ 2 * STEP(omega)*FFT(f) }] )
a80 2
#define LOOKFAC	2	/* Look ahead factor for npfao	  */
#define PFA_MAX	720720	/* Largest allowed nfft	          */
d143 1
a143 1
		/* Load traces into ct (zero-padded) */
d153 1
a153 1
		/* Form absolute value or phase value */
d268 1
a268 1
	temp[n-1] = (f[n-1] - f[n-2])/2;
@


1.13
log
@replaced hilbert transforming routines with Dave's hilbert transform 
hilbert() in cwp/lib.
@
text
@d1 1
a1 1
/* SUENV:  $Revision: 1.12 $ ; $Date: 94/03/30 13:46:02 $	*/
d39 1
a39 1
" This program performs complex trace attribute analysis, a la, Taner,	",
@


1.12
log
@inst frequency and phase unwrapping options added
@
text
@d1 1
a1 1
/* SUENV:  $Revision: 1.11 $ ; $Date: 94/03/28 14:29:46 $	*/
d21 20
a40 17
" 								",
" SUENV - Complex envelope, phase, or frequency time traces	",
" 								",
" suenv <stdin >stdout mode=amp					",
" 								",
" Required parameters:						",
" 	none							",
" 								",
" Optional parameter:						",
" 	mode=amp	output flag 				",
" 	       		=amp envelope traces			",
" 	       		=phase phase traces			",
" 	       		=freq frequency traces			",
"	unwrap=		default unwrap=0 for mode=phase		",
" 			default unwrap=1 for mode=freq		",
" 			dphase_min=PI/unwrap			",
" Notes:							",
d46 4
a49 3
" The phase unwrapping is crude, and the differentiation needed to compute",
" the instantaneous frequency freq(t)= d(phase)/dt is a simple centered	",
" difference.					       			",
d55 1
d96 2
a97 5
	int nfft;		/* number of points on output trace	*/
	int nfby2;		/* nfft/2				*/
	int nfby2p1;		/* nfft/2 + 1				*/
	float onfft;		/* 1.0 / nfft				*/
	float onfby2;		/* 2.0 / nfft				*/
d134 4
a137 4
	/* Set up for fft */
	nfft = npfao(nt, LOOKFAC * nt);
	if (nfft >= MIN(SU_NFLTS, PFA_MAX))
		err("Padded nt=%d -- too big", nfft);
a138 4
	nfby2 = nfft/2;
	nfby2p1 = nfby2 + 1;
	onfft = 1.0 / (float) nfft;
	onfby2 = 2.0 * onfft;
a140 3
	/* Allocate fft array */
	ct = ealloc1complex(nfft);

d146 1
a146 2
		for (i = 0; i < nt; ++i)  ct[i] = cmplx(tr.data[i], 0.0);
		for (i = nt; i < nfft; ++i)  ct[i] = czero;
d148 3
a150 2
		/* Fft */
		pfacc(1, nfft, ct);
d152 2
a153 5
		/* Apply 2*step and scale for inverse fft */
		ct[0] = crmul(ct[0], onfft);	/* only scale at dc and Nyq */
		for (i = 1; i <= nfby2; ++i)  ct[i] = crmul(ct[i], onfby2);
		if (!ISODD(nfft)) ct[nfby2] = crmul(ct[nfby2], onfft);
		for (i = nfby2p1; i < nfft; ++i)  ct[i] = czero;
a154 3
		/* Invert */
		pfacc(-1, nfft, ct);

d171 1
a171 1
			phase = alloc1float(nt);
d195 1
a195 1
			phase = alloc1float(nt);
d261 1
a261 1
	temp = alloc1float(n);
d270 1
a270 1
	temp[n] = (f[n] - f[n-1])/2;
d310 2
a311 2
	dphase=alloc1float(n);
	temp=alloc1float(n);
@


1.11
log
@Now sets tr.d1, so that the graphics programs will do the right thing.
@
text
@d1 1
a1 1
/* SUENV:  $Revision: 1.10 $ ; $Date: 93/12/14 13:41:36 $	*/
d19 1
a19 1
/*************** self documentation **************/
d21 31
a51 13
" 						",
" SUENV - Complex envelope or phase time trace	",
" 						",
" suenv <stdin >stdout mode=amp			",
" 						",
" Required parameters:				",
" 	none					",
" 						",
" Optional parameter:				",
" 	mode=amp	output flag 		",
" 	       		amp = envelope traces	",
" 	       		phase = phase traces	",
" 					       	",
a52 1
/**************** end self doc *******************/
d55 2
a56 1
 *	CWP: Jack
d61 3
d65 3
a67 3
 * Caveat:
 *	No phase unwrapping precautions are taken in the mode=phase
 *	branch.
d70 1
d74 1
d79 3
a84 1

d96 1
a98 1

a103 2


d107 4
a110 2
	seismic = (tr.trid == 0 || tr.trid == TREAL ||
		   tr.trid == TDEAD || tr.trid == TDUMMY);
d117 3
a119 2
	if (STREQ(mode, "amp"))        imode = AMP;
	else if (STREQ(mode, "phase")) imode = ARG;
d122 10
a142 1

a145 1

d174 2
d179 5
d187 2
a188 2
				if (re*re+im*im)  tr.data[i] = atan2(im, re);
				else              tr.data[i] = 0.0;
d190 9
d200 1
d202 30
d245 101
@


1.10
log
@Enlarged notion of seismic trace to include DEAD, etc.
@
text
@d1 1
a1 1
/* SUENV:  $Revision: 1.9 $ ; $Date: 93/08/09 15:19:29 $	*/
d156 1
@


1.9
log
@changed String to cwp_String
@
text
@d1 1
a1 1
/* SUENV:  $Revision: 1.8 $ ; $Date: 92/10/26 12:59:25 $	*/
d62 1
a62 1
	cwp_String mode;		/* display: real, imag, amp, arg	*/
d72 1
a79 3
	if (tr.trid && tr.trid != TREAL) {
		err("input is not seismic data, trid=%d", tr.trid);
	}
d84 4
@


1.8
log
@new selfdoc installed
@
text
@d1 1
a1 1
/* SUENV:  $Revision: 1.7 $ ; $Date: 91/09/05 08:50:15 $	*/
d62 1
a62 1
	String mode;		/* display: real, imag, amp, arg	*/
@


1.7
log
@string -> String and so forth
@
text
@d1 1
a1 1
/* SUENV:  $Revision: 1.6 $ ; $Date: 90/12/18 20:44:58 $	*/
d20 15
a34 15
String sdoc =
" 						\n"
" SUENV - Complex envelope or phase time trace	\n"
" 						\n"
" suenv <stdin >stdout mode=amp			\n"
" 						\n"
" Required parameters:				\n"
" 	none					\n"
" 						\n"
" Optional parameter:				\n"
" 	mode=amp	output flag 		\n"
" 	       		amp = envelope traces	\n"
" 	       		phase = phase traces	\n"
" 					       	\n"
;
d76 1
a76 1
	askdoc(1);
@


1.6
log
@Bringing up to current coding style.
@
text
@d1 1
a1 1
/* SUENV:  $Revision: 1.5 $ ; $Date: 90/09/03 09:39:58 $	*/
d20 1
a20 1
string sdoc =
d62 1
a62 1
	string mode;		/* display: real, imag, amp, arg	*/
@


1.5
log
@Tweak comment.
@
text
@d1 1
a1 1
/* SUENV:  $Revision: 1.4 $ ; $Date: 90/09/01 21:11:51 $	*/
d20 15
a34 15
string sdoc = "\
						\n\
SUENV - Complex envelope or phase time trace	\n\
						\n\
suenv <stdin >stdout mode=amp			\n\
						\n\
Required parameters:				\n\
	none					\n\
						\n\
Optional parameter:				\n\
	mode=amp	output flag 		\n\
	       		amp = envelope traces	\n\
	       		phase = phase traces	\n\
					       	\n\
";
a71 1
	register int i;		/* counter				*/
d88 1
a88 1
	if (!sgetpar("mode", &mode))	mode = "amp";
d112 2
d131 6
a136 13
		for (i = 0; i < nt; ++i) {
			switch(imode) {
			case AMP:
				tr.data[i] = fcabs(ct[i]);
				tr.trid = ENVELOPE;
			break;
			case ARG:
				tr.data[i] = atan2(ct[i].i, ct[i].r);
				tr.trid = INSTPHASE;
			break;
			default:
				err("%s: mysterious mode=\"%s\"",
							__LINE__, mode);
d138 14
a152 1
		}
@


1.4
log
@Fixed it up at Nyquist.
@
text
@d1 1
a1 1
/* SUENV:  $Revision: 1.3 $ ; $Date: 90/06/11 15:25:04 $	*/
d121 1
a121 1
		ct[0] = crmul(ct[0], onfft);	/* half at dc and Nyq */
@


1.3
log
@Using pfa routines.
@
text
@d1 1
a1 1
/* SUENV:  $Revision: 1.2 $ ; $Date: 90/05/25 19:25:42 $	*/
d71 1
d104 1
d115 1
a115 1
		for (i = nt; i < nfft; ++i)  ct[i] = cmplx(0.0, 0.0);
d121 1
a121 1
		ct[0] = crmul(ct[0], onfft);
d123 2
a124 1
		for (i = nfby2p1; i < nfft; ++i)  ct[i] = cmplx(0.0, 0.0);
@


1.2
log
@vec --> ealloc1float, etc.
@
text
@d1 1
a1 1
/* SUENV:  $Revision: 1.1 $ ; $Date: 90/04/17 12:23:16 $	*/
d12 1
a12 1
 *  Golden, CO 80401  (isis!csm9a!jkcohen)
a49 1
#define	FACMAX		12		/* For FFTPACK	*/
d53 4
d64 1
a64 9
	float *hcos;		/* hold cosines for fft			*/
	float *hsin;		/* hold sines for fft			*/
	register float *xr;	/* real part of trace			*/
	register float *xi;	/* imaginary part of trace		*/
	float xri;		/* temporary for xr[i]			*/
	float xii;		/* temporary for xi[i]			*/
	float xrtmp;		/* temporary for xr[nfby2]		*/
	float *wr;		/* work area for fft			*/
	float *wi;		/* work area for fft			*/
a65 1
	int ntsize;		/* nt in bytes				*/
a66 1
	int nfftsize;		/* nfft in bytes			*/
d68 1
a70 3
	int nfac;		/* number of factors of nfft		*/
	int facs[FACMAX];	/* contains factors of nfft		*/
	int nzeros;		/* number of padded zeroes in bytes	*/
d95 2
a96 2
	fftfac(&nt, &nfft, &nfac, facs);
	if (nfft > SU_NFLTS) {
d98 3
a100 2
	}
	nfby2 = nfft / 2;
a102 3
	ntsize = nt * FSIZE;
	nfftsize = nfft * FSIZE;
	nzeros = nfftsize - ntsize;
a103 4
	/* Allocate fft arrays */
	hcos = ealloc1float(nfft);	hsin = ealloc1float(nfft);
	xr   = ealloc1float(nfft);	xi   = ealloc1float(nfft);
	wr   = ealloc1float(nfft);	wi   = ealloc1float(nfft);
d105 2
a106 2
	/* Set up tables */
	ffttab(&nfft, hcos, hsin);
d111 3
a113 4
		/* Load traces into xr, xi (zero-padded) */
		bcopy(tr.data, xr, ntsize);
		bzero(xr + nt, nzeros);
		bzero(xi, nfftsize);
d116 1
a116 1
		fft(xr, xi, wr, wi, &nfft, facs, &nfac, hcos, hsin);
d118 4
a121 12
		/* Apply 2*step, conjugate and scale for inverse fft */
		xr[0] *= onfft;  /* use 1*step at zero frequency */
		xi[0] *= onfft;
		xrtmp = xr[nfby2]; /* save for n even case */
		for (i = 1; i <= nfby2; ++i) {
			xr[i] *=  onfby2; /* equivalent to *= (2/nfft) */
			xi[i] *= -onfby2;
			xr[nfft - i] = xi[nfft - i] = 0.0;
		}
		if (!ISODD(nfft)) { /* n/2 wiped above to correctly do n odd */
			xr[nfby2] = xrtmp * onfby2;/* xi[nfby2] = 0 is right */
		}
d124 1
a124 1
		fft(xr, xi, wr, wi, &nfft, facs, &nfac, hcos, hsin);
a127 2
			xri =  xr[i];
			xii = -xi[i]; /* minus for inverse fft */
d130 1
a130 1
				tr.data[i] = sqrt(xri*xri + xii*xii);
d134 1
a134 1
				tr.data[i] = atan2(xii, xri);
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/* SUENV:  $Revision: 2.11 $ ; $Date: 89/09/20 19:35:18 $	*/
d30 1
a30 1
	mode = amp	output flag 		\n\
a46 1
 *
a48 5
/* Embed Revision Control System identifier strings */
static string progid =
	"   $Source: /src/su/src/RCS/suenv.c,v $";
static string revid =
	"   $Revision: 2.11 $ ; $Date: 89/09/20 19:35:18 $";
a49 2


d57 1
a57 2
main(argc, argv)
int argc; char **argv;
d83 1
a83 1
	/* Initialize SU */
a84 5
	if (!igetpar("ID", &ID))	ID = 0;
	if (ID) {
		(void) fprintf(stderr, "%s\n", progid);
		(void) fprintf(stderr, "%s\n", revid);
	}
d116 3
a118 3
	hcos = vec(nfft);	hsin = vec(nfft);
	xr   = vec(nfft);	xi   = vec(nfft);
	wr   = vec(nfft);	wi   = vec(nfft);
d175 1
a175 1
	return SUCCEED;
@
