head	1.76;
access;
symbols;
locks; strict;
comment	@ * @;


1.76
date	2019.06.26.18.58.47;	author john;	state Exp;
branches;
next	1.75;

1.75
date	2015.08.07.21.59.07;	author john;	state Exp;
branches;
next	1.74;

1.74
date	2013.09.12.00.32.35;	author john;	state Exp;
branches;
next	1.73;

1.73
date	2012.12.05.22.55.30;	author john;	state Exp;
branches;
next	1.72;

1.72
date	2012.10.31.22.55.22;	author john;	state Exp;
branches;
next	1.71;

1.71
date	2012.10.31.22.27.39;	author john;	state Exp;
branches;
next	1.70;

1.70
date	2012.10.31.22.15.13;	author john;	state Exp;
branches;
next	1.69;

1.69
date	2011.12.21.23.21.07;	author john;	state Exp;
branches;
next	1.68;

1.68
date	2010.11.04.18.40.58;	author john;	state Exp;
branches;
next	1.67;

1.67
date	2008.06.27.15.09.58;	author john;	state Exp;
branches;
next	1.66;

1.66
date	2007.09.20.21.25.20;	author john;	state Exp;
branches;
next	1.65;

1.65
date	2007.09.20.21.15.14;	author john;	state Exp;
branches;
next	1.64;

1.64
date	2007.04.26.23.48.09;	author john;	state Exp;
branches;
next	1.63;

1.63
date	2006.10.31.22.25.37;	author john;	state Exp;
branches;
next	1.62;

1.62
date	2005.12.19.23.21.15;	author john;	state Exp;
branches;
next	1.61;

1.61
date	2005.12.07.17.11.15;	author john;	state Exp;
branches;
next	1.60;

1.60
date	2004.03.02.18.36.37;	author john;	state Exp;
branches;
next	1.59;

1.59
date	2004.03.01.18.01.10;	author john;	state Exp;
branches;
next	1.58;

1.58
date	2003.06.09.16.17.07;	author john;	state Exp;
branches;
next	1.57;

1.57
date	2001.10.24.18.18.45;	author john;	state Exp;
branches;
next	1.56;

1.56
date	2000.09.22.17.49.46;	author john;	state Exp;
branches;
next	1.55;

1.55
date	98.08.28.21.52.19;	author john;	state Exp;
branches;
next	1.54;

1.54
date	97.07.28.22.36.46;	author john;	state Exp;
branches;
next	1.53;

1.53
date	97.06.02.15.58.25;	author john;	state Exp;
branches;
next	1.52;

1.52
date	97.05.05.17.34.14;	author john;	state Exp;
branches;
next	1.51;

1.51
date	97.03.21.16.38.42;	author john;	state Exp;
branches;
next	1.50;

1.50
date	97.01.09.16.38.56;	author john;	state Exp;
branches;
next	1.49;

1.49
date	96.09.09.16.30.31;	author john;	state Exp;
branches;
next	1.48;

1.48
date	96.09.03.21.34.44;	author jkc;	state Exp;
branches;
next	1.47;

1.47
date	96.08.20.21.32.00;	author jkc;	state Exp;
branches;
next	1.46;

1.46
date	96.02.22.21.52.42;	author jkc;	state Exp;
branches;
next	1.45;

1.45
date	95.10.18.15.36.44;	author jkc;	state Exp;
branches;
next	1.44;

1.44
date	95.09.27.16.48.28;	author john;	state Exp;
branches;
next	1.43;

1.43
date	95.09.18.13.38.32;	author jkc;	state Exp;
branches;
next	1.42;

1.42
date	95.08.28.20.35.18;	author jkc;	state Exp;
branches;
next	1.41;

1.41
date	95.08.28.20.23.51;	author jkc;	state Exp;
branches;
next	1.40;

1.40
date	95.08.28.20.00.28;	author jkc;	state Exp;
branches;
next	1.39;

1.39
date	95.08.23.19.49.13;	author jkc;	state Exp;
branches;
next	1.38;

1.38
date	95.04.26.14.03.39;	author john;	state Exp;
branches;
next	1.37;

1.37
date	95.01.19.11.42.35;	author john;	state Exp;
branches;
next	1.36;

1.36
date	94.10.10.10.48.14;	author john;	state Exp;
branches;
next	1.35;

1.35
date	94.10.07.09.55.00;	author john;	state Exp;
branches;
next	1.34;

1.34
date	94.09.06.10.02.23;	author jkc;	state Exp;
branches;
next	1.33;

1.33
date	94.09.06.09.59.22;	author jkc;	state Exp;
branches;
next	1.32;

1.32
date	94.08.25.14.58.19;	author jkc;	state Exp;
branches;
next	1.31;

1.31
date	94.08.18.13.59.00;	author jkc;	state Exp;
branches;
next	1.30;

1.30
date	94.08.02.14.40.25;	author jkc;	state Exp;
branches;
next	1.29;

1.29
date	94.07.15.13.59.33;	author john;	state Exp;
branches;
next	1.28;

1.28
date	94.07.12.17.11.26;	author john;	state Exp;
branches;
next	1.27;

1.27
date	94.06.15.10.24.39;	author john;	state Exp;
branches;
next	1.26;

1.26
date	94.04.18.08.36.54;	author john;	state Exp;
branches;
next	1.25;

1.25
date	94.03.25.09.56.39;	author john;	state Exp;
branches;
next	1.24;

1.24
date	94.03.10.14.39.45;	author john;	state Exp;
branches;
next	1.23;

1.23
date	93.11.12.15.51.24;	author john;	state Exp;
branches;
next	1.22;

1.22
date	93.08.26.20.04.08;	author jkc;	state Exp;
branches;
next	1.21;

1.21
date	93.08.13.10.27.23;	author john;	state Exp;
branches;
next	1.20;

1.20
date	93.07.27.09.45.16;	author john;	state Exp;
branches;
next	1.19;

1.19
date	93.07.13.09.28.56;	author john;	state Exp;
branches;
next	1.18;

1.18
date	93.07.13.09.26.43;	author john;	state Exp;
branches;
next	1.17;

1.17
date	93.05.27.10.44.46;	author john;	state Exp;
branches;
next	1.16;

1.16
date	93.05.26.12.54.18;	author john;	state Exp;
branches;
next	1.15;

1.15
date	93.01.22.11.59.05;	author john;	state Exp;
branches;
next	1.14;

1.14
date	92.12.11.10.30.12;	author john;	state Exp;
branches;
next	1.13;

1.13
date	92.11.17.10.32.15;	author jkc;	state Exp;
branches;
next	1.12;

1.12
date	92.11.06.08.29.46;	author john;	state Exp;
branches;
next	1.11;

1.11
date	92.10.22.15.51.19;	author john;	state Exp;
branches;
next	1.10;

1.10
date	92.06.15.13.04.31;	author jkc;	state Exp;
branches;
next	1.9;

1.9
date	92.06.12.13.41.08;	author jkc;	state Exp;
branches;
next	1.8;

1.8
date	91.09.05.08.49.13;	author jkcohen;	state Exp;
branches;
next	1.7;

1.7
date	91.06.02.21.31.42;	author jkcohen;	state Exp;
branches;
next	1.6;

1.6
date	90.11.30.11.53.30;	author jkc;	state Exp;
branches;
next	1.5;

1.5
date	90.11.26.16.36.25;	author jkc;	state Exp;
branches;
next	1.4;

1.4
date	90.11.25.18.43.28;	author jkc;	state Exp;
branches;
next	1.3;

1.3
date	90.10.23.12.31.13;	author jkc;	state Exp;
branches;
next	1.2;

1.2
date	90.09.03.09.42.33;	author jkc;	state Exp;
branches;
next	1.1;

1.1
date	90.04.15.16.49.23;	author jkc;	state Exp;
branches;
next	;


desc
@Read a segy format tape
@


1.76
log
@small change to allow user to control number of extended headers read
@
text
@/* SEGYREAD: $Revision: 1.75 $ ; $Date: 2015/08/07 21:59:07 $     */

#define _XOPEN_SOURCE
#include <unistd.h>
#include "su.h"
#include "segy.h"
#include "tapesegy.h"
#include "tapebhdr.h"
#include "bheader.h"
#include "header.h"

/*********************** self documentation **********************/
char *sdoc[] = {
"									",
" SEGYREAD - read an SEG-Y tape						",
"									",
"   segyread > stdout tape=						",
"									",
"   or									",
"									",
"   SEG-Y data stream ... | segyread tape=-  > stdout			",
"									",
" Required parameter:							",
" tape=		input tape device or seg-y filename (see notes)		",
"									",
" Optional parameters:							",
" buff=1	for buffered device (9-track reel tape drive)		",
"		=0 possibly useful for 8mm EXABYTE drives		",
" verbose=0	silent operation					",
"		=1 ; echo every 'vblock' traces				",
" vblock=50	echo every 'vblock' traces under verbose option		",
" hfile=header	file to store ebcdic block (as ascii)			",
" bfile=binary	file to store binary block				",
" xfile=xhdrs	file to store extended text block			",
" over=0	quit if bhed format not equal 1, 2, 3, 5, or 8		",
"		= 1 ; override and attempt conversion			",
" format=bh.format	if over=1 try to convert assuming format value  ",
" conv=1	convert data to native format				",
"			= 0 ; assume data is in native format		",
" ebcdic=1	perform ebcdic to ascii conversion on 3200 byte textural",
"               header. =0 do not perform conversion			",
" ns=bh.hns	number of samples (use if bhed ns wrong)		",
" trcwt=1	apply trace weighting factor (bytes 169-170)		",
"		=0, do not apply.  (Default is 0 for formats 1 and 5)	",
" trmin=1		first trace to read				",
" trmax=INT_MAX	last trace to read					",
" endian=(autodetected) =1 for big-endian,  =0 for little-endian byte order",
" swapbhed=endian	swap binary reel header?			",
" swaphdrs=endian	swap trace headers?				",
" swapdata=endian	swap data?					",
" nextended=(set from binary header) number of extended text headers	",
" errmax=0	allowable number of consecutive tape IO errors		",
" remap=...,...	remap key(s) 						",
" byte=...,...	formats to use for header remapping 			",
" 									",
" Notes:								",
" Traditionally tape=/dev/rmt0.	 However, in the modern world tape device",
" names are much less uniform.  The magic name can often be deduced by	",
" \"ls /dev\".  Likely man pages with the names of the tape devices are:",
" \"mt\", \"sd\" \"st\".  Also try \"man -k scsi\", \" man mt\", etc.	",
" Sometimes \"mt status\" will tell the device name.			",
" 									",
" For a SEG-Y diskfile use tape=filename.				",
" 									",
" The xfile argument will only be used if the file contains extended	",
" text headers.								",
" 									",
" Remark: a SEG-Y file is not the same as an su file. A SEG-Y file	",
" consists of three parts: an ebcdic header, a binary reel header, and	",
" the traces.  The traces are (usually) in 32 bit IBM floating point	",
" format.  An SU file consists only of the trace portion written in the ",
" native binary floats.							",
"									",
" Formats supported:							",
" 1: IBM floating point, 4 byte (32 bits)				",
" 2: two's complement integer, 4 byte (32 bits)				",
" 3: two's complement integer, 2 byte (16 bits)				",
" 5: IEEE floating point, 4 byte (32 bits)				",
" 8: two's complement integer, 1 byte (8 bits)				",
"									",
" tape=-   read from standard input. Caveat, under Solaris, you will	",
" need to use the buff=1 option, as well.				",
"									",
" Header remap:								",
" The value of header word remap is mapped from the values of byte	",
"									",
" Map a float at location 221 to sample spacing d1:			",
"	segyread <data >outdata remap=d1 byte=221f			",
"									",
" Map a long at location 225 to source location sx:			",
"	segyread <data >outdata remap=sx byte=225l			",
"									",
" Map a short at location 229 to gain constant igc:			",
"	segyread <data >outdata remap=igc byte=229s			",
"									",
" Or all combined: 							",
"	segyread <data >outdata remap=d1,sx,igc byte=221f,225l,229s	",
"									",
" Segy header words are accessed as Xt where X denotes the byte number	",
" starting at 1 in correspondance with the SEGY standard (1975)		",
" Known types include:	f	float (4 bytes)				",
" 			l	long int (4 bytes)			",
" 			s	short int (2 bytes)			",
" 			b	byte (1 bytes)				",
"									",
"	  type:	  sudoc segyread   for further information		",
"									",
NULL};

/*
 * Note:
 *      If you have a tape with multiple sequences of ebcdic header,
 *	binary header,traces, use the device that
 *	invokes the no-rewind option and issue multiple segyread
 *	commands (making an appropriate shell script if you
 *	want to save all the headers).	Consider using >> if
 *	you want a single trace file in the end.  Similar
 *	considerations apply for multiple reels of tapes,
 *	but use the standard rewind on end of file.
 *
 * Note: For buff=1 (default) tape is accessed with 'read', for buff=0
 *	tape is accessed with fread. We suggest that you try buff=1
 *	even with EXABYTE tapes.
 * Caveat: may be slow on an 8mm streaming (EXABYTE) tapedrive
 * Warning: segyread or segywrite to 8mm tape is fragile. Allow sufficient
 *	time between successive reads and writes.
 * Warning: may return the error message "efclose: fclose failed"
 *	intermittently when segyreading/segywriting to 8mm (EXABYTE) tape
 *	even if actual segyread/segywrite is successful. However, this
 *	error message may be returned if your tape drive has a fixed
 *	block size set.
 * Caution: When reading or writing SEG-Y tapes, the tape
 *	drive should be set to be able to read variable block length
 *	tape files.
 */

/* Credits:
 *	SEP: Einar Kjartansson
 *	CWP: Jack K. Cohen, Brian Sumner, Chris Liner
 *	   : John Stockwell (added 8mm tape stuff)
 * conv parameter added by:
 *	Tony Kocurko
 *	Department of Earth Sciences
 *	Memorial University of Newfoundland
 *	St. John's, Newfoundland
 * read from stdin via tape=-  added by	Tony Kocurko
 * bhed format = 2,3 conversion by:
 *	Remco Romijn (Applied Geophysics, TU Delft)
 *	J.W. de Bruijn (Applied Geophysics, TU Delft)
 * bhed format = 8 conversion by: John Stockwell
 * header remap feature added by:
 * 	Matthias Imhof, Virginia Tech
 *--------------------------
 * Additional Notes:
 *	Brian's subroutine, ibm_to_float, which converts IBM floating
 *	point to IEEE floating point is NOT portable and must be
 *	altered for non-IEEE machines.	See the subroutine notes below.
 *
 *	A direct read by dd would suck up the entire tape; hence the
 *	dancing around with buffers and files.
 *
 */
/**************** end self doc ***********************************/

#define SEGYREAD_TAPE_ERROR(which) \
	if (verbose) \
		warn("tape read error on %s", which); \
	if (++errcount > errmax) \
		err("exceeded maximum io errors"); \

#define SEGYREAD_TAPE_ERROR_TRACE(which) \
	if (verbose) \
		warn("tape read error on trace %d", which); \
	if (++errcount > errmax) \
		err("exceeded maximum io errors"); \

/* Subroutine prototypes */
static void ibm_to_float(int from[], int to[], int n, int endian, int verbose);
static void int_to_float(int from[], float to[], int n, int endian);
static void short_to_float(short from[], float to[], int n, int endian);
static void integer1_to_float(signed char from[], float to[], int n);
static void tapebhed_to_bhed(const tapebhed *tapebhptr, bhed *bhptr);
static void tapesegy_to_segy(const tapesegy *tapetrptr, segy *trptr);

static void ugethval(cwp_String type1, Value *valp1,
		     char type2, int ubyte,
		      char *tr, int endian, int conv, int verbose);

/* Globals */
tapesegy tapetr;
tapebhed tapebh;
segy tr;
bhed bh;

int
main(int argc, char **argv)
{
	char *tape;		/* name of raw tape device	*/
	char *bfile;		/* name of binary header file	*/
	char *hfile;		/* name of ascii header file	*/
	char *xfile;		/* name of extended header file	*/

	int tapefd = 0;		/* file descriptor for tape	*/

	FILE *tapefp = NULL;	/* file pointer for tape	*/
	FILE *binaryfp;		/* file pointer for bfile	*/
	FILE *headerfp;		/* file pointer for hfile	*/
	FILE *xheaderfp;	/* file pointer for xfile	*/
	FILE *pipefp;		/* file pointer for popen write */

	size_t nsegy;		/* size of whole trace in bytes		*/
	int i;			/* counter				*/
	int itr;		/* current trace number			*/
	int trmin;		/* first trace to read			*/
	int trmax;		/* last trace to read			*/
	int ns;			/* number of data samples		*/

	int over;		/* flag for bhed.float override		*/
	int format;		/* flag for to specify override format	*/
	cwp_Bool format_set = cwp_false;
				/* flag to see if new format is set	*/
	int conv;		/* flag for data conversion		*/
	int trcwt;		/* flag for trace weighting		*/
	int verbose;		/* echo every ...			*/
	int vblock;		/* ... vblock traces with verbose=1	*/
	int buff;		/* flag for buffered/unbuffered device	*/
	int endian;		/* flag for big=1 or little=0 endian	*/
	int swapdata;		/* flag for big=1 or little=0 endian	*/
	int swapbhed;		/* flag for big=1 or little=0 endian	*/
	int swaphdrs;		/* flag for big=1 or little=0 endian	*/
	int errmax;		/* max consecutive tape io errors	*/
	int errcount = 0;	/* counter for tape io errors		*/
	cwp_Bool nsflag;	/* flag for error in tr.ns		*/

	char cmdbuf[BUFSIZ];	/* dd command buffer			*/
	char ebcbuf[EBCBYTES];	/* ebcdic data buffer			*/

	int ebcdic=1;		/* ebcdic to ascii conversion flag	*/

	cwp_String key1[SU_NKEYS];	/* output key(s)		*/
	cwp_String key2[SU_NKEYS];	/* first input key(s)		*/
	cwp_String type1[SU_NKEYS];	/* array of types for key1	*/
	char type2[SU_NKEYS];		/* array of types for key2	*/
	int ubyte[SU_NKEYS];
	int nkeys;			/* number of keys to be computed*/
	int n;				/* counter of keys getparred	*/
	int ikey;			/* loop counter of keys 	*/
	int index1[SU_NKEYS];		/* array of indexes for key1 	*/
	Value val1;			/* value of key1		*/

	/* deal with number of extended text headers */
	short nextended;

	/* Initialize */
	initargs(argc, argv);
	requestdoc(0); /* stdin not used */


	/* Make sure stdout is a file or pipe */
	switch(filestat(STDOUT)) {
	case TTY:
		err("stdout can't be tty");
		break;
	case DIRECTORY:
		err("stdout must be a file, not a directory");
		break;
	case BADFILETYPE:
		err("stdout is illegal filetype");
		break;
	default: /* Others OK */
		break;
	}

	/* Set filenames */
	MUSTGETPARSTRING("tape",  &tape);
	if (!getparstring("hfile", &hfile))	hfile = "header";
	if (!getparstring("bfile", &bfile))	bfile = "binary";
	if (!getparstring("xfile", &xfile))	xfile = "xhdrs";


	/* Set parameters */
	if (!getparint("trmin", &trmin))	trmin = 1;
	if (!getparint("trmax", &trmax))	trmax = INT_MAX;
	if (!getparint("verbose", &verbose))	verbose = 0;
	if (!getparint("vblock", &vblock))	vblock = 50;
	if (!getparint("endian", &endian))      {
              union { short s; char c[2]; } testend;
                testend.s = 1;
 		endian = (testend.c[0] == '\0') ? 1 : 0;
	}
	if (!getparint("swapdata", &swapdata)) 	swapdata=endian;
	if (!getparint("swapbhed", &swapbhed)) 	swapbhed=endian;
	if (!getparint("swaphdrs", &swaphdrs)) 	swaphdrs=endian;
	
	if (!getparint("ebcdic", &ebcdic)) 	ebcdic=1;

	if (!getparint("errmax", &errmax))	errmax = 0;
	if (!getparint("buff", &buff))		buff = 1;


	/* Override binary format value */
	if (!getparint("over", &over))		over = 0;
	if (getparint("format", &format))	format_set = cwp_true;
	if (((over!=0) && (format_set))) {
		bh.format = format;
		if ( !(
			   (format == 1)
			|| (format == 2)
			|| (format == 3)
			|| (format == 5)
			|| (format == 8)
			) ) {
 	          warn("Specified format=%d not supported", format);
		  warn("Assuming IBM floating point format, instead");
		}
	}

	/* Override conversion of IBM floating point data? */
	if (!getparint("conv", &conv))		conv = 1;

	/* Get parameters */
	/* get key1's */
	if ((n = countparval("remap")) != 0){
		nkeys = n;
		getparstringarray("remap", key1);
	} else { /* set default */
		nkeys = 0;
	}

	/* get key2's */
	if ((n = countparval("byte")) != 0){
		if (n != nkeys)
			err("number of byte's and remap's must be equal!");

		getparstringarray("byte", key2);
	}

	for (ikey = 0; ikey < nkeys; ++ikey) {

		/* get types and index values */
		type1[ikey]  = hdtype(key1[ikey]);
		index1[ikey] = getindex(key1[ikey]);
		}

	for (ikey = 0; ikey < nkeys; ++ikey) {
		#if 0
		fprintf(stderr, "%s\t", key2[ikey]);
		#endif
		if (sscanf(key2[ikey],"%d%c", &ubyte[ikey], &type2[ikey]) != 2)
			err("user format XXXt");
		#if 0
		sscanf(key2[ikey],"%d%c", &ubyte[ikey], &type2[ikey]);
		fprintf(stderr, "%d\t%c\n", ubyte[ikey], type2[ikey]);
		#endif
		}

	/* Open files - first the tape */
	if (buff) {
		if ( tape[0] == '-' && tape[1] == '\0' ) tapefd = 0;
		else tapefd = eopen(tape, O_RDONLY, 0444);
	} else {
		if ( tape[0] == '-' && tape[1] == '\0' ) tapefp = stdin;
		else tapefp = efopen(tape, "r");
	}

	/* - the ebcdic header file in ascii */
	headerfp = efopen(hfile, "w");
	if (verbose) warn("header file opened successfully");

	/* - the binary data file */
	binaryfp = efopen(bfile, "w");
	if (verbose) warn("binary file opened successfully");

	/* Read the ebcdic raw bytes from the tape into the buffer */
	if (buff) {
		if (-1 == (int) read(tapefd, ebcbuf, EBCBYTES)) {
			SEGYREAD_TAPE_ERROR("ebcdic header");
		} else { /* Reset counter on successful tape IO */
			errcount = 0;
		}
	} else {
/* segyread.c:350: warning: value computed is not used */
/* 		 (int) fread(ebcbuf, 1, EBCBYTES, tapefp); */
		 fread(ebcbuf, 1, EBCBYTES, tapefp);
		 if (ferror(tapefp)) {
			SEGYREAD_TAPE_ERROR("ebcdic header");
			clearerr(tapefp);
		} else { /* Reset counter on successful tape IO */
			errcount = 0;
		}
	}

	/* Open pipe to use dd to convert  ebcdic to ascii */
#ifdef SUN
	if (ebcdic==1)  {
		sprintf(cmdbuf, "dd ibs=1 of=%s conv=ascii count=3200", hfile);
	} else {
		sprintf(cmdbuf, "dd ibs=1 of=%s count=3200", hfile);
	}
#else
	/* this command gives a file containing 3240 bytes on sun */
	/* see top of Makefile.config for versions */
	/* not sure why this breaks now; works in version 37 */
	if (ebcdic==1){
		sprintf(cmdbuf, "dd ibs=1 of=%s conv=ascii count=3200", hfile);
	} else {
		
		sprintf(cmdbuf, "dd ibs=1 of=%s count=3200", hfile);
	}
#endif
	pipefp = epopen(cmdbuf, "w");

	/* Write ebcdic stream from buffer into pipe */
	efwrite(ebcbuf, EBCBYTES, 1, pipefp);

	/* Read binary header from tape to bh structure */
	if (buff) {
		if (-1 == read(tapefd, (char *) &tapebh, BNYBYTES)) {
			SEGYREAD_TAPE_ERROR("binary header");
		} else { /* Reset counter on successful tape IO */
			errcount = 0;
		}
	} else {
		 fread((char *) &tapebh, 1, BNYBYTES, tapefp);
		 if (ferror(tapefp)) {
			 SEGYREAD_TAPE_ERROR("binary header");
			 clearerr(tapefp);
		} else { /* Reset counter on successful tape IO */
			errcount = 0;
		}
	}

	/* Convert from bytes to ints/shorts */
	tapebhed_to_bhed(&tapebh, &bh);

	/* if little endian machine, swap bytes in binary header */
	if (swapbhed == 0) for (i = 0; i < BHED_NKEYS; ++i) swapbhval(&bh, i);

	/* Override binary format value */
	if (!getparint("over", &over))		over = 0;
	if (getparint("format", &format))	format_set = cwp_true;
	if (((over!=0) && (format_set)))	bh.format = format;

	/* Override application of trace weighting factor? */
	/* Default no for floating point formats, yes for integer formats. */
	if (!getparint("trcwt",&trcwt))
		trcwt = (bh.format == 1 || bh.format == 5) ? 0 : 1;

	switch (bh.format) {
	case 1:
		if (verbose) warn("assuming IBM floating point input");
		break;
	case 2:
		if (verbose) warn("assuming 4 byte integer input");
		break;
	case 3:
		if (verbose) warn("assuming 2 byte integer input");
		break;
	case 5:
		if (verbose) warn("assuming IEEE floating point input");
		break;
	case 8:
		if (verbose) warn("assuming 1 byte integer input");
		break;
	default:
		(over) ? warn("ignoring bh.format ... continue") :
			err("format not SEGY standard (1, 2, 3, 5, or 8)");
	}

	/* Compute length of trace (can't use sizeof here!) */
	if (!getparint("ns", &ns))  ns = bh.hns; /* let user override */
	if (!ns) err("samples/trace not set in binary header");
	bh.hns = ns;
	switch (bh.format) {
	case 8:
		nsegy = ns + SEGY_HDRBYTES;
		break;
	case 3:
		nsegy = ns * 2 + SEGY_HDRBYTES;
		break;
	case 1:
	case 2:
	case 5:
	default:
		nsegy = ns * 4 + SEGY_HDRBYTES;
	}

	/* Write binary header from bhed structure to binary file */
	efwrite( (char *) &bh, 1, BNYBYTES, binaryfp);

	/* Close binary and header files now to allow pipe into segywrite */
	efclose(binaryfp);
	if (verbose) warn("binary file closed successfully");
	efclose(headerfp);
	epclose(pipefp);
	if (verbose) warn("header file closed successfully");

        checkpars();

        if (!getparshort( "nextended" ,&nextended ))
	nextended = *((short *) (((unsigned char *)&tapebh) + 304));

	if (endian == 0) swap_short_2((short *) &nextended);
	if (verbose) warn("Number of extended text headers: %d", nextended);
	if (nextended > 0) /* number of extended text headers > 0 */
	{
		/* need to deal with -1 nextended headers */
		/* so test should actually be !=0, but ... */

		/* open the extended text header file in whatever it's in */
		xheaderfp = efopen(xfile, "w");
		if (verbose)
			warn("extended text header file opened successfully");

		for (i = 0; i < nextended; i++) {
			/* cheat -- an extended text header is same size as
			 * EBCDIC header */
			/* Read the bytes from the tape for one xhdr into the
			 * buffer */
			if (buff) {
				if (-1 == (int) read(tapefd, ebcbuf, EBCBYTES)) {
					SEGYREAD_TAPE_ERROR("extended text header");
				} else { /* Reset counter on successful tape IO */
					errcount = 0;
				}
			} else {
				fread(ebcbuf, 1, EBCBYTES, tapefp);
				if (ferror(tapefp)) {
					SEGYREAD_TAPE_ERROR("extended text header");
					clearerr(tapefp);
				} else { /* Reset counter on successful tape IO */
					errcount = 0;
				}
			}
			/* Write extended header to file */
			efwrite( (char *) ebcbuf, 1, EBCBYTES, xheaderfp);
		}
		/* Close extended text header file */
		efclose(xheaderfp);
		if (verbose) warn("extended text header file closed successfully");
	}

	/* Read the traces */
	nsflag = cwp_false;
	itr = 0;
	while (itr < trmax) {
		int nread;

		if (buff) {
			if (-1 ==
			   (nread = (int) read(tapefd, (char *) &tapetr, nsegy))){

				SEGYREAD_TAPE_ERROR_TRACE(itr);
			} else { /* Reset counter on successful tape IO */
				errcount = 0;
			}
		} else {
			nread = (int) fread((char *) &tapetr, 1, nsegy, tapefp);
			if (ferror(tapefp)) {
				SEGYREAD_TAPE_ERROR_TRACE(itr);
				clearerr(tapefp);
			} else { /* Reset counter on successful tape IO */
				errcount = 0;
			}
		}

		if (!nread)   /* middle exit loop instead of mile-long while */
			break;

		/* Convert from bytes to ints/shorts */
		tapesegy_to_segy(&tapetr, &tr);

		/* If little endian machine, then swap bytes in trace header */
		if (swaphdrs == 0)
			for (i = 0; i < SEGY_NKEYS; ++i) swaphval(&tr, i);

		/* Check tr.ns field */
		if (!nsflag && ns != tr.ns) {
			warn("discrepant tr.ns = %d with tape/user ns = %d\n"
			     "\t... first noted on trace %d",
			     tr.ns, ns, itr + 1);
			nsflag = cwp_true;
		}

		/* loop over key fields and remap */
		for (ikey = 0; ikey < nkeys; ++ikey) {

			/* get header values */

			ugethval(type1[ikey], &val1,
				 type2[ikey], ubyte[ikey] - 1,
				 (char*) &tapetr, endian, conv, verbose);
			puthval(&tr, index1[ikey], &val1);
		}
		/* Are there different swapping instructions for the data */
		/* Convert and write desired traces */
		if (++itr >= trmin) {

			/* Convert IBM floats to native floats */
			if (conv) {
				switch (bh.format) {
				case 1:
			/* Convert IBM floats to native floats */
					ibm_to_float((int *) tr.data,
						     (int *) tr.data, ns,
						     swapdata,verbose);
					break;
				case 2:
			/* Convert 4 byte integers to native floats */
					int_to_float((int *) tr.data,
						      (float *) tr.data, ns,
						      swapdata);
					break;
				case 3:
			/* Convert 2 byte integers to native floats */
					short_to_float((short *) tr.data,
						       (float *) tr.data, ns,
						       swapdata);
					break;
				case 5:
			/* IEEE floats.  Byte swap if necessary. */
                                        if (swapdata == 0)
						for (i = 0; i < ns ; ++i)
							swap_float_4(&tr.data[i]);
					break;
				case 8:
			/* Convert 1 byte integers to native floats */
					integer1_to_float((signed char *)tr.data,
							  (float *) tr.data, ns);
					break;
				}

				/* Apply trace weighting. */
				if (trcwt && tr.trwf != 0) {
			  		float scale = pow(2.0, -tr.trwf);
				  	int i;
				  	for (i = 0; i < ns; ++i) {
				    		tr.data[i] *= scale;
				  	}
				}
			} else if (conv == 0) {
				/* don't convert, if not appropriate */

                                switch (bh.format) {
                                case 1: /* swapdata=0 byte swapping */
				case 5:
                                        if (swapdata == 0)
						for (i = 0; i < ns ; ++i)
							swap_float_4(&tr.data[i]);
					break;
                                case 2: /* convert longs to floats */
                                        /* SU has no provision for reading */
                                        /* data as longs */
                                        int_to_float((int *) tr.data,
                                                (float *) tr.data, ns, endian);
                                        break;
                                case 3: /* shorts are the SHORTPAC format */
					/* used by supack2 and suunpack2 */
                                        if (swapdata == 0)/* swapdata=0 byte swap */
                                           for (i = 0; i < ns ; ++i)
                                                swap_short_2((short *) &tr.data[i]);
                                        /* Set trace ID to SHORTPACK format */
                                        tr.trid = SHORTPACK;
                                        break;
                                case 8: /* convert bytes to floats */
                                        /* SU has no provision for reading */
                                        /* data as bytes */
					integer1_to_float((signed char *)tr.data,
					(float *) tr.data, ns);
                                        break;
                                }
                        }

			/* Write the trace to disk */
			tr.ns = ns;
			puttr(&tr);

			/* Echo under verbose option */
			if (verbose && itr % vblock == 0)
				warn(" %d traces from tape", itr);
		}
	}

	/* Re-iterate error in case not seen during run */
	if (nsflag) warn("discrepancy found in header and trace ns values\n"
		"the value (%d) was used to extract traces", ns);


	/* Clean up (binary & header files already closed above) */
	(buff) ? eclose(tapefd):
		 efclose(tapefp);
	if (verbose) warn("tape closed successfully");


	return(CWP_Exit());
}

static void ibm_to_float(int from[], int to[], int n, int endian, int verbose)
/***********************************************************************
ibm_to_float - convert between 32 bit IBM and IEEE floating numbers
************************************************************************
Input::
from		input vector
to		output vector, can be same as input vector
endian		byte order =0 little endian (DEC, PC's)
			    =1 other systems
*************************************************************************
Notes:
Up to 3 bits lost on IEEE -> IBM

Assumes sizeof(int) == sizeof(float) == 4

IBM -> IEEE may overflow or underflow, taken care of by
substituting large number or zero

*************************************************************************
Credits: SEP: Stewart A. Levin,  c.1995
*************************************************************************/

/* See if this fits the bill for your needs - Stew */
/* ibmflt.f -- translated by f2c (version 1995/10/25).
*/
/* Subroutine */
{
    /* Initialized data */

    static int first = 1;

    /* System generated locals */
    int i__1;
    int j,k;

    /* Local variables */
    int   *in;
    float *out;
    int eibm, i__, mhibm;
    static int m1[512];
    static float r1[512];

    unsigned int jj;
    union {
      float rrf;
      int iif;
      unsigned int uuf;
    } cvtmp;
	
    float r_infinity__;
    int et3e;

    if(endian == 0) {
      swab(from,to,n*sizeof(int));
      for(i__ = 0; i__<n; ++i__) {
        j = to[i__];
        k = j<<16;
        to[i__] = k+((j>>16)&65535);
      }
      in = to;
    } else {
      in = from;
    }
    /* Parameter adjustments */
    out = (float *) to;
    --out;
    --in;
    /* Function Body */

    if (first) {
	first = ! first;
	cvtmp.iif = 2139095039;
	r_infinity__ = cvtmp.rrf;
	for (i__ = 0; i__ <= 511; ++i__) {
	    i__1 = i__ & 255;
	    eibm = i__1 >> 1;
	    mhibm = i__ & 1;
	    et3e = (eibm << 2) - 130;
	    if (et3e > 0 && et3e <= 255) {
		i__1 = et3e ^ (i__ & 255);
		m1[i__] = i__1 << 23;
		if (mhibm == 1) {
		    r1[i__] = 0.f;
		} else {
		    i__1 = et3e | (i__ & 256);
		    cvtmp.iif = i__1 << 23;
		    r1[i__] = -(cvtmp.rrf);
		}
	    } else if (et3e <= 0) {
		m1[i__] = i__ << 23;
		r1[i__] = 0.f;
	    } else {
		m1[i__] = i__ << 23;
		if (i__ < 256) {
		    r1[i__] = r_infinity__;
		} else {
		    r1[i__] = -r_infinity__;
		}
	    }
/* L10: */
	}
    }

    for (i__ = 1; i__ <= n; ++i__) {
	cvtmp.iif = in[i__];
/* use 9 high bits for table lookup */
	jj = cvtmp.uuf>>23;
/* fix up exponent */
	cvtmp.iif = m1[jj] ^ cvtmp.iif;
/* fix up mantissa */
	out[i__] = cvtmp.rrf + r1[jj];
/* L20: */
    }
}

static void tapebhed_to_bhed(const tapebhed *tapebhptr, bhed *bhptr)
/****************************************************************************
tapebhed_to_bhed -- converts the seg-y standard 2 byte and 4 byte
	integer header fields to, respectively, the
	machine's short and int types.
*****************************************************************************
Input:
tapbhed		pointer to array of
*****************************************************************************
Notes:
The present implementation assumes that these types are actually the "right"
size (respectively 2 and 4 bytes), so this routine is only a placeholder for
the conversions that would be needed on a machine not using this convention.
*****************************************************************************
Author: CWP: Jack  K. Cohen, August 1994
****************************************************************************/

{
	register int i;
	Value val;

	/* convert binary header, field by field */
	for (i = 0; i < BHED_NKEYS; ++i) {
		gettapebhval(tapebhptr, i, &val);
		putbhval(bhptr, i, &val);
	}
}

static void tapesegy_to_segy(const tapesegy *tapetrptr, segy *trptr)
/****************************************************************************
tapesegy_to_segy -- converts the seg-y standard 2 byte and 4 byte
		    integer header fields to, respectively, the machine's
		    short and int types.
*****************************************************************************
Input:
tapetrptr	pointer to trace in "tapesegy" (SEG-Y on tape) format

Output:
trptr		pointer to trace in "segy" (SEG-Y as in	 SU) format
*****************************************************************************
Notes:
Also copies float data byte by byte.  The present implementation assumes that
the integer types are actually the "right" size (respectively 2 and 4 bytes),
so this routine is only a placeholder for the conversions that would be needed
on a machine not using this convention.	 The float data is preserved as
four byte fields and is later converted to internal floats by ibm_to_float
(which, in turn, makes additonal assumptions).
*****************************************************************************
Author: CWP:Jack K. Cohen,  August 1994
****************************************************************************/
{
	register int i;
	Value val;

	/* convert header trace header fields */
	for (i = 0; i < SEGY_NKEYS; ++i) {
		gettapehval(tapetrptr, i, &val);
		puthval(trptr, i, &val);
	}

	/* copy the optional portion */
	memcpy((char *)&(trptr->otrav) + 2, tapetrptr->unass, 60);

	/* copy data portion */
	memcpy(trptr->data, tapetrptr->data, 4 * SU_NFLTS);
}

static void int_to_float(int from[], float to[], int n, int endian)
/****************************************************************************
Author:	J.W. de Bruijn, May 1995
****************************************************************************/
{
	register int i;

	if (endian == 0) {
		for (i = 0; i < n; ++i) {
			swap_int_4(&from[i]);
			to[i] = (float) from[i];
		}
	} else {
		for (i = 0; i < n; ++i) {
			to[i] = (float) from[i];
		}
	}
}

static void short_to_float(short from[], float to[], int n, int endian)
/****************************************************************************
short_to_float - type conversion for additional SEG-Y formats
*****************************************************************************
Author: Delft: J.W. de Bruijn, May 1995
Modified by: Baltic Sea Reasearch Institute: Toralf Foerster, March 1997
****************************************************************************/
{
	register int i;

	if (endian == 0) {
		for (i = n - 1; i >= 0 ; --i) {
			swap_short_2(&from[i]);
			to[i] = (float) from[i];
		}
	} else {
		for (i = n - 1; i >= 0 ; --i)
			to[i] = (float) from[i];
	}
}

static void integer1_to_float(signed char from[], float to[], int n)
/****************************************************************************
integer1_to_float - type conversion for additional SEG-Y formats
*****************************************************************************
Author: John Stockwell,  2005
****************************************************************************/
{
  	while (n--) {
		to[n] = from[n];
	}
}

void ugethval(cwp_String type1, Value *valp1,
	      char type2, int ubyte,
	      char *ptr2, int endian, int conv, int verbose)
{	double dval1 = 0;
	char   c = 0;
	short  s = 0;
	int    l = 0;
	float  f = 0.0;
	char	*ptr1;

	#if 0
	fprintf(stderr, "start ugethval %d %c\n", ubyte, type2);
	#endif

	switch (type2) {
	case 'b':
		ptr1 = (char*) &c;
		ptr1[0] = ptr2[ubyte];
		dval1 = (double) c;
		break;
	case 's':
		ptr1 = (char*) &s;
		ptr1[0] = ptr2[ubyte];
		ptr1[1] = ptr2[ubyte+1];
		if (endian == 0)
		   swap_short_2(&s);
		dval1 = (double) s;
		break;
	case 'l':
		ptr1 = (char*) &l;
		ptr1[0] = ptr2[ubyte];
		ptr1[1] = ptr2[ubyte+1];
		ptr1[2] = ptr2[ubyte+2];
		ptr1[3] = ptr2[ubyte+3];
		if (endian == 0)
/* segyread.c:903: warning: dereferencing type-punned pointer will break strict-aliasing rules */
/* 		   swap_long_4((long *)&l); */
/* note: long is 64-bits on 64-bit machine! */
			swap_int_4((int *)&l);
		dval1 = (double) l;
		break;
	case 'f':
		ptr1 = (char*) &f;
		ptr1[0] = ptr2[ubyte];
		ptr1[1] = ptr2[ubyte+1];
		ptr1[2] = ptr2[ubyte+2];
		ptr1[3] = ptr2[ubyte+3];
		if (conv)
/* get this message twice */
/* segyread.c:913: warning: dereferencing type-punned pointer will break strict-aliasing rules */
/* 		   ibm_to_float((int*) &f, (int*) &f, 1, endian, verbose); */
		  {
			  memcpy (&l, &f, 4);
			  ibm_to_float(&l, &l, 1, endian, verbose);
		  }
		else if (conv == 0 && endian == 0)
		   swap_float_4(&f);
		dval1 = (double) f;
		break;
	default:
		err("unknown type %s", type2);
		break;
	}

	#if 0
	fprintf(stderr, "value %lf\n", dval1);
	#endif

	switch (*type1) {
	case 's':
		err("can't change char header word");
		break;
	case 'h':
		valp1->h = (short) dval1;
		break;
	case 'u':
		valp1->u = (unsigned short) dval1;
		break;
	case 'l':
		valp1->l = (long) dval1;
		break;
	case 'v':
		valp1->v = (unsigned long) dval1;
		break;
	case 'i':
		valp1->i = (int) dval1;
		break;
	case 'p':
		valp1->p = (unsigned int) dval1;
		break;
	case 'f':
		valp1->f = (float) dval1;
		break;
	case 'd':
		valp1->d = (double) dval1;
		break;
	default:
		err("unknown type %s", type1);
		break;
	}
}

#undef SEGYREAD_TAPE_ERROR
#undef SEGYREAD_TAPE_ERROR_TRACE
@


1.75
log
@fixed selfdoc
@
text
@d1 1
a1 1
/* SEGYREAD: $Revision: 1.74 $ ; $Date: 2013/09/12 00:32:35 $     */
d51 1
d405 1
a405 1
		sprintf(cmdbuf, "dd ibs=1 of=%s conv=ascii cbs=80 count=3200", hfile);
d408 1
a408 1
		sprintf(cmdbuf, "dd ibs=1 of=%s cbs=80 count=3200", hfile);
a497 1
        getparshort( "nextended" ,&nextended );
d500 1
d502 1
@


1.74
log
@Stew Levin's data IBM to IEEE and IEEE to IBM routines added.
@
text
@d1 1
a1 1
/* SEGYREAD: $Revision: 1.73 $ ; $Date: 2012/12/05 22:55:30 $     */
d47 4
a50 4
" endian=1	set =0 for little-endian machines(PC's,DEC,etc.)	",
" swapbhed=endian	swap binary reel header?			",	
" swaphdrs=endian	swap trace headers?				",	
" swapdata=endian	swap data?					",	
@


1.73
log
@changed ibs=3200 count=1   to ibs=1 count=3200 to avoid a read
failure of the text header in the data reported by Matt Johnson of Fugro
International
@
text
@d1 1
a1 1
/* SEGYREAD: $Revision: 1.72 $ ; $Date: 2012/10/31 22:55:22 $     */
d3 2
a695 35
#ifdef _HPUX_SOURCE
static void ibm_to_float(int from[], int to[], int n, int endian)
{
	/* HP version of ibm_to_float */

    register int fconv, fmant, i, t, dummy;

	dummy = endian;

    for (i = 0; i < n; ++i) {
        fconv = from[i];

        /* next lines modified (M.J.Rutty 20/9/92) */
        /* if (fconv) { */
        /* fmant = 0x00ffffff & fconv; */

        fmant = 0x00ffffff & fconv;
        if (!fmant)
          fconv = 0;
        else {
          /* end modifications */
            t = (int) ((0x7f000000 & fconv) >> 22) - 130;
            while (!(fmant & 0x00800000)) { --t; fmant <<= 1; }
            if (t > 254) fconv = (0x80000000 & fconv) | 0x7f7fffff;
            else if (t <= 0) fconv = 0;
            else fconv = (0x80000000 & fconv) | (t << 23)
			 | (0x007fffff & fmant);
        }
        to[i] = fconv;
    }
    return;
}

#else /* use the regular ibm_to_float routine */

d709 1
a709 1
Assumes sizeof(int) == 4
a713 1
Only integer shifting and masking are used.
d715 1
a715 1
Credits: CWP: Brian Sumner,  c.1985
d717 5
d723 1
a723 1
    register int fconv, fmant, i, t;
d725 1
a725 1
    for (i = 0;i < n; ++i) {
d727 20
a746 1
	fconv = from[i];
d748 35
a782 12
	/* if little endian, i.e. endian=0 do this */
	if (endian == 0) fconv = (fconv << 24) | ((fconv >> 24) & 0xff) |
		((fconv & 0xff00) << 8) | ((fconv & 0xff0000) >> 8);

	if (fconv) {
	    fmant = 0x00ffffff & fconv;
	    /* The next two lines were added by Toralf Foerster */
	    /* to trap non-IBM format data i.e. conv=0 data  */
	    if (fmant == 0) {
		if(verbose==2){ 
		 warn("mantissa is zero data may not be in IBM FLOAT Format !");
		 warn("setting fconv=0");
d784 3
a786 1
		fconv=0;
d788 8
a795 7
	    t = (int) ((0x7f000000 & fconv) >> 22) - 130;
	    while (!(fmant & 0x00800000)) { --t; fmant <<= 1; }
	    if (t > 254) fconv = (0x80000000 & fconv) | 0x7f7fffff;
	    else if (t <= 0) fconv = 0;
	    else fconv =   (0x80000000 & fconv) | (t << 23)
			 | (0x007fffff & fmant);
	  }
a796 1
	to[i] = fconv;
d798 11
a808 1
    return;
a809 1
#endif
@


1.72
log
@verbose=1 is too irritating
@
text
@d1 1
a1 1
/* SEGYREAD: $Revision: 1.71 $ ; $Date: 2012/10/31 22:27:39 $     */
d393 1
a393 1
		sprintf(cmdbuf, "dd ibs=3200 of=%s conv=ascii count=1", hfile);
d395 1
a395 1
		sprintf(cmdbuf, "dd ibs=3200 of=%s count=1", hfile);
d402 1
a402 1
		sprintf(cmdbuf, "dd ibs=3200 of=%s conv=ascii cbs=80 count=1", hfile);
d405 1
a405 1
		sprintf(cmdbuf, "dd ibs=3200 of=%s cbs=80 count=1", hfile);
@


1.71
log
@Kris Vaneste's bug fix for cases when mantissa is zero.
@
text
@d1 1
a1 1
/* SEGYREAD: $Revision: 1.70 $ ; $Date: 2012/10/31 22:15:13 $     */
d767 1
a767 1
		if(verbose){ 
@


1.70
log
@changed swap_long to swap_int to fix a problem with 4 byte integer data
@
text
@d1 1
a1 1
/* SEGYREAD: $Revision: 1.69 $ ; $Date: 2011/12/21 23:21:07 $     */
d175 1
a175 1
static void ibm_to_float(int from[], int to[], int n, int endian);
d184 1
a184 1
		      char *tr, int endian, int conv);
d588 1
a588 1
				 (char*) &tapetr, endian, conv);
d602 1
a602 1
						     swapdata);
d729 1
a729 1
static void ibm_to_float(int from[], int to[], int n, int endian)
d766 7
a772 2
	    if (fmant == 0)
		warn("mantissa is zero data may not be in IBM FLOAT Format !");
d779 1
d908 1
a908 1
	      char *ptr2, int endian, int conv)
d956 1
a956 1
/* 		   ibm_to_float((int*) &f, (int*) &f, 1, endian); */
d959 1
a959 1
			  ibm_to_float(&l, &l, 1, endian);
@


1.69
log
@swapbhed swaphdrs options added to allow byte independent byte
swapping of headers and the data so as to cope with "dos segy" format
issues
@
text
@d1 1
a1 1
/* SEGYREAD: $Revision: 1.68 $ ; $Date: 2010/11/04 18:40:58 $     */
d176 1
a176 1
static void long_to_float(long from[], float to[], int n, int endian);
d606 1
a606 1
					long_to_float((long *) tr.data,
d650 1
a650 1
                                        long_to_float((long *) tr.data,
d848 1
a848 1
static void long_to_float(long from[], float to[], int n, int endian)
d857 1
a857 1
			swap_long_4(&from[i]);
@


1.68
log
@added swapheaders feature
@
text
@d1 1
a1 1
/* SEGYREAD: $Revision: 1.67 $ ; $Date: 2008/06/27 15:09:58 $     */
d46 3
a48 1
" swapdata=endian	swap data as well as headers?			",	
d226 2
d289 2
d434 1
a434 1
	if (endian == 0) for (i = 0; i < BHED_NKEYS; ++i) swapbhval(&bh, i);
d495 3
d570 1
a570 1
		if (endian == 0)
@


1.67
log
@added flag to turno 
hh
on and off the conversion of ashhh

ex
ebcdic to ascii
@
text
@d1 1
a1 1
/* SEGYREAD: $Revision: 1.66 $ ; $Date: 2007/09/20 21:25:20 $     */
d46 1
d223 1
d284 2
d582 1
a582 1

d593 1
a593 1
						     endian);
d599 1
a599 1
						      endian);
d605 1
a605 1
						       endian);
d609 1
a609 1
                                        if (endian == 0)
d632 1
a632 1
                                case 1: /* endian=0 byte swapping */
d634 1
a634 1
                                        if (endian == 0)
d646 1
a646 1
                                        if (endian == 0)/* endian=0 byte swap */
@


1.66
log
@John Gravley's changes, including a mechanism for handling the extended text headers of segy REV 1
@
text
@d1 1
a1 1
/* SEGYREAD: $Revision: 1.63 $ ; $Date: 2006/10/31 22:25:37 $     */
d38 2
d229 2
d282 1
d380 1
a380 1
	/* Open pipe to use dd to convert ascii to ebcdic */
d382 5
a386 1
	sprintf(cmdbuf, "dd ibs=3200 of=%s conv=ascii count=1", hfile);
d391 6
a396 1
	sprintf(cmdbuf, "dd ibs=3200 of=%s conv=ascii cbs=80 count=1", hfile);
@


1.65
log
@added endian test from Stew Levin
@
text
@d32 2
a33 1
" over=0		quit if bhed format not equal 1, 2, 3, 5, or 8		",
d57 3
d112 1
a112 1
 *						
d115 1
a115 1
 *	even with EXABYTE tapes.				 
d122 1
a122 1
 *	error message may be returned if your tape drive has a fixed 
d153 1
a153 1
 * 
d157 12
d177 3
a179 3
static	void ugethval(cwp_String type1, Value *valp1, 
	       char type2, int ubyte, 
	       char *tr, int endian, int conv);
d193 1
d195 1
a195 1
	int tapefd=0;		/* file descriptor for tape	*/
d197 1
a197 1
	FILE *tapefp=NULL;	/* file pointer for tape	*/
d200 1
d223 1
a223 1
 
d238 3
d250 1
a250 1
	break;
d253 1
a253 1
	break;
d256 1
a256 1
	break;
d258 1
a258 1
	break;
d265 2
a267 1
	
d273 6
a278 5
	if (!getparint("endian", &endian))	{
                                        union { short s; char c[2]; } testend;
					testend.s = 1;
                                        endian = (testend.c[0] == '\0') ? 1 : 0;
                                       }
d289 5
a293 5
			   (format==1)
			|| (format==2) 
			|| (format==3)
			|| (format==5)
			|| (format==8)
d305 3
a307 3
	if ((n=countparval("remap"))!=0){
		nkeys=n;
		getparstringarray("remap",key1);
d309 1
a309 1
		nkeys=0;
d313 2
a314 2
	if ((n=countparval("byte"))!=0){
		if (n!=nkeys)
d317 1
a317 1
		getparstringarray("byte",key2);
d320 2
a321 2
	for (ikey=0; ikey<nkeys; ++ikey) {
			
d327 1
a327 1
	for (ikey=0; ikey<nkeys; ++ikey) {
d331 1
a331 1
		if (sscanf(key2[ikey],"%d%c",&ubyte[ikey],&type2[ikey])!=2)
d334 1
a334 1
		sscanf(key2[ikey],"%d%c",&ubyte[ikey],&type2[ikey]);
d359 1
a359 4
			if (verbose)
				warn("tape read error on ebcdic header");
			if (++errcount > errmax)
				err("exceeded maximum io errors");
d364 3
a366 1
		 (int) fread(ebcbuf, 1, EBCBYTES, tapefp);
d368 1
a368 4
			if (verbose)
				warn("tape read error on ebcdic header");
			if (++errcount > errmax)
				err("exceeded maximum io errors");
d376 6
d383 1
a388 1

d392 1
a392 4
			if (verbose)
				warn("tape read error on binary header");
			if (++errcount > errmax)
				err("exceeded maximum io errors");
d399 2
a400 5
			if (verbose)
				warn("tape read error on binary header");
			if (++errcount > errmax)
				err("exceeded maximum io errors");
			clearerr(tapefp);
d410 1
a410 1
	if (endian==0) for (i = 0; i < BHED_NKEYS; ++i) swapbhval(&bh,i);
d420 2
a421 2
		trcwt = (bh.format==1 || bh.format==5) ? 0 : 1;
  
d452 1
a452 1
		nsegy = ns*2 + SEGY_HDRBYTES;
d458 1
a458 1
		nsegy = ns*4 + SEGY_HDRBYTES;
d462 1
a462 5
#ifdef SUXDR
	efwrite( (char *) &tapebh,1, BNYBYTES, binaryfp);
#else
	efwrite( (char *) &bh,1, BNYBYTES, binaryfp);
#endif
d471 40
d519 1
a519 1
			if (-1 == 
d521 2
a522 4
				if (verbose)
				      warn("tape read error on trace %d", itr);
				if (++errcount > errmax)
				      err("exceeded maximum io errors");
d529 1
a529 4
				if (verbose)
				      warn("tape read error on trace %d", itr);
				if (++errcount > errmax)
				      err("exceeded maximum io errors");
d535 4
a538 3
			
	if (!nread) break; /* middle exit loop instead of mile-long while */
	
d541 1
a541 1
	
d543 3
a545 3
		if (endian==0)
			for (i = 0; i < SEGY_NKEYS; ++i) swaphval(&tr,i);
	
d549 2
a550 2
				"\t... first noted on trace %d",
				tr.ns, ns, itr + 1);
d555 2
a556 2
		for (ikey=0; ikey<nkeys; ++ikey) {
			
d558 3
a560 3
			
			ugethval(type1[ikey], &val1, 
				 type2[ikey], ubyte[ikey]-1, 
d569 1
a569 1
			  if (conv) {
d572 1
a572 1
			  /* Convert IBM floats to native floats */
d574 2
a575 1
						(int *) tr.data, ns, endian);
d578 1
a578 1
			  /* Convert 4 byte integers to native floats */
d580 2
a581 1
						(float *) tr.data, ns, endian);
d584 1
a584 1
			  /* Convert 2 byte integers to native floats */
d586 2
a587 1
						(float *) tr.data, ns, endian);
d590 4
a593 4
			  /* IEEE floats.  Byte swap if necessary. */
                                        if (endian==0)
                                           for (i = 0; i < ns ; ++i)
                                                swap_float_4(&tr.data[i]);
d596 1
a596 1
			  /* Convert 1 byte integers to native floats */
d598 2
a599 2
					(float *) tr.data, ns);
                                        break;
d603 2
a604 2
				if (trcwt && tr.trwf!=0) {
			  		float scale = pow(2.0,-tr.trwf);
d606 1
a606 1
				  	for (i=0; i<ns; ++i) {
d610 1
a610 1
			} else if (conv==0) {
d616 4
a619 4
                                        if (endian==0)
                                           for (i = 0; i < ns ; ++i)
                                                swap_float_4(&tr.data[i]);
                                        break;
d628 1
a628 1
                                        if (endian==0)/* endian=0 byte swap */
a652 2


d676 1
a676 1
    for (i=0;i<n;++i) {
d685 1
a685 1
          fconv=0;
d692 2
a693 1
            else fconv = (0x80000000 & fconv) |(t << 23)|(0x007fffff & fmant);
d710 2
a711 2
			    =1 other systems 
************************************************************************* 
d717 1
a717 1
IBM -> IEEE may overflow or underflow, taken care of by 
d721 1
a721 1
************************************************************************* 
d727 1
a727 1
    for (i=0;i<n;++i) {
d732 2
a733 2
	if (endian==0) fconv = (fconv<<24) | ((fconv>>24)&0xff) |
		((fconv&0xff00)<<8) | ((fconv&0xff0000)>>8);
d740 1
a740 1
		warn("mantissa is zero data may not be in IBM FLOAT Format !");	
d745 2
a746 1
	    else fconv = (0x80000000 & fconv) |(t << 23)|(0x007fffff & fmant);
d758 1
a758 1
	machine's short and int types. 
d761 1
a761 1
tapbhed		pointer to array of 
d774 1
a774 1
	
d786 1
a786 1
		    short and int types. 
d807 1
a807 1
	
d815 1
a815 1
	memcpy((char *)&(trptr->otrav)+2, tapetrptr->unass, 60);
d818 1
a818 1
	memcpy(trptr->data, tapetrptr->data, 4*SU_NFLTS);
d827 1
a827 1
  
d845 1
a845 1
Modified by: Baltic Sea Reasearch Institute: Toralf Foerster, March 1997 
d849 1
a849 1
  
d851 1
a851 1
		for (i = n-1; i >= 0 ; --i) {
d855 2
a856 2
	} else { 
		for (i = n-1; i >= 0 ; --i)
d869 1
a869 1
		to[n] =  from[n];
d873 2
a874 2
void ugethval(cwp_String type1, Value *valp1, 
	      char type2, int ubyte, 
d882 1
a882 1
	
d886 1
a886 1
	
d892 1
a892 1
	break;
d897 1
a897 1
		if (endian==0)
d900 1
a900 1
	break;
d907 5
a911 2
		if (endian==0)
		   swap_long_4((long *)&l);
d913 1
a913 1
	break;
d921 8
a928 2
		   ibm_to_float((int*) &f, (int*) &f, 1, endian);
		else if (conv==0 && endian==0)
d931 1
a931 1
	break;
d934 1
a934 1
	break;
d939 2
a940 2
	#endif	
	
d944 1
a944 1
	break;
d947 1
a947 1
	break;
d950 1
a950 1
	break;
d953 1
a953 1
	break;
d956 1
a956 1
	break;
d959 1
a959 1
	break;
d962 1
a962 1
	break;
d965 1
a965 1
	break;
d968 1
a968 1
	break;
d971 1
a971 1
	break;
d974 3
@


1.64
log
@Stew Levin's automated endian detection added.
@
text
@a53 2
" Endian: now tests for endian, and assumes endian of your machine. Set ",
" verbose=1 to see value of endian assumed.				",
d251 5
a255 12
	if (!getparint("endian", &endian))  {

		/* Stew Levin's endian test */
		union { short s; char c[2]; } endianTest;
     		endianTest.s = 1;

     		endian = ((endianTest.c[0] == '\0') ? 1 : 0);

		if (verbose) warn("Assming endian=%d",endian);

	}

d443 3
d447 1
@


1.63
log
@changed err to warn
@
text
@d1 1
a1 1
/* SEGYREAD: $Revision: 1.62 $ ; $Date: 2005/12/19 23:21:15 $     */
d54 2
d253 12
a264 1
	if (!getparint("endian", &endian))	endian = 1;
@


1.62
log
@added craig artley's fixes including support for formats 5 and 8
@
text
@d1 1
a1 1
/* SEGYREAD: $Revision: 1.61 $ ; $Date: 2005/12/07 17:11:15 $     */
d679 1
a679 1
		err(" data are not in IBM FLOAT Format !");	
@


1.61
log
@7 Dec 2005 version
@
text
@d1 1
a1 1
/* SEGYREAD: $Revision: 1.60 $ ; $Date: 2004/03/02 18:36:37 $     */
d32 1
a32 1
" over=0	quit if bhed format not equal 1, 2, 3, or 8		",
d38 2
d63 5
a67 2
" 1: ibm floating point, 2: ibm fixed point, 4 byte,			",
" 3: ibm fixed point,  2 byte						",
d157 1
a157 1
static void integer1_to_float(char from[], float to[], int n);
d197 1
d265 1
d393 5
d409 3
d417 1
a417 1
			err("format not SEGY standard (1, 2 or 3)");
d431 1
d433 1
a433 1
	case 1:
d505 1
a505 1
	        
d508 1
d527 7
d535 1
a535 1
					integer1_to_float((char *)tr.data,
d537 10
d553 1
a562 4
                                        /* endian=0 byte swapping */
                                        if (endian==0)
                                           for (i = 0; i < ns ; ++i)
                                                swap_float_4(&tr.data[i]);
a565 1
                                        
d572 6
d799 1
a799 1
static void integer1_to_float(char from[], float to[], int n)
d806 2
a807 4
	register int i;
  
	for (i = 0; i < n ; ++i) {
			to[i] =  (char) from[i];
@


1.60
log
@warn changed back to err
@
text
@d1 1
a1 1
/* SEGYREAD: $Revision: 1.59 $ ; $Date: 2004/03/01 18:01:10 $     */
d32 1
a32 1
" over=0	quit if bhed format not equal 1, 2, or 3		",
d133 1
d152 1
d255 6
a260 1
		if ( !((format==1) || (format==2) || (format==3)) ) {
d397 3
d410 3
d510 3
d763 14
a868 1

@


1.59
log
@changed fmat error check to a warning.
@
text
@d1 1
a1 1
/* SEGYREAD: $Revision: 1.58 $ ; $Date: 2003/06/09 16:17:07 $     */
d627 1
a627 1
		warn(" data may not be in IBM FLOAT Format !");	
@


1.58
log
@9 June 2003
@
text
@d1 1
a1 1
/* SEGYREAD: $Revision: 1.57 $ ; $Date: 2001/10/24 18:18:45 $     */
d627 1
a627 1
		err(" data are not in IBM FLOAT Format !");	
@


1.57
log
@24 October 2001 version
@
text
@d1 1
a1 1
/* SEGYREAD: $Revision: 1.55 $ ; $Date: 1998/08/28 21:52:19 $     */
d498 2
a499 1
			}
d501 27
a527 4
			/* handle no ibm conversion for little endian case */
			if (conv==0 && endian==0)
				for (i = 0; i < ns ; ++i)
					swap_float_4(&tr.data[i]);
d552 1
a552 1
	return EXIT_SUCCESS;
@


1.56
log
@improvement to HPUX support
@
text
@d8 1
d42 2
d67 22
d133 2
d154 4
d201 10
d262 36
d466 11
d722 94
@


1.55
log
@Updates for Craig artley, regarding minus signs, etc...
@
text
@d1 1
a1 1
/* SEGYREAD: $Revision: 1.54 $ ; $Date: 1997/07/28 22:36:46 $     */
d96 1
a96 1
 *	SEP: Einar Kjartannson
d443 34
d526 1
@


1.54
log
@changes suggested by Stew Levin to silence SGI compiler warnings, etc
@
text
@d1 1
a1 1
/* SEGYREAD: $Revision: 1.53 $ ; $Date: 1997/06/02 15:58:25 $     */
d21 1
a21 1
"	tape=		input tape device or seg-y filename (see notes)	",
d24 11
a34 10
"	buff=1		for buffered device (9-track reel tape drive)	",
"			=0 possibly useful for 8mm EXABYTE drives	",
"	verbose=0	silent operation				",
"			=1 ; echo every 'vblock' traces			",
"	vblock=50	echo every 'vblock' traces under verbose option	",
"	hfile=header	file to store ebcdic block (as ascii)		",
"	bfile=binary	file to store binary block			",
"	over=0		quit if bhed format not equal 1, 2, or 3	",
"			= 1 ; override and attempt conversion		",
"	conv=1		convert data to native format			",
d36 20
a55 5
"	ns=bh.hns	number of samples (use if bhed ns wrong)	",
"	trmin=1		first trace to read				",
"	trmax=INT_MAX	last trace to read				",
"	endian=1	set =0 for little-endian machines(PC's,DEC,etc.)",
"	errmax=0	allowable number of consecutive tape IO errors	",
d57 3
a59 6
"  Notes: Traditionally tape=/dev/rmt0.	 However, in the modern world	",
"	tape device names are much less uniform.  The magic name can	",
"	often be deduced by \"ls /dev\".  Likely man pages with the	",
"	names of the tape devices are: \"mt\", \"sd\" \"st\".  Also	",
"	try \"man -k scsi\", \" man mt\", etc.	Sometimes \"mt status\"	",
"	will tell the device name.					",
d61 2
a62 6
"	For a SEG-Y diskfile use tape=filename.				",
"	Remark: a SEG-Y file is not the same as an su file.		",
"	A SEG-Y file consists of three parts: an ebcdic header,		",
"	a binary reel header, and the traces.  The traces are (usually)	",
"	in 32 bit IBM floating point format.  An SU file consists only	",
"	of the trace portion written in the native binary floats.	",
d64 1
a64 2
"	tape=-   read from standard input. Caveat, under Solaris, you will",
"	need to use the buff=1 option, as well.				",
a65 1
"	  type:	  sudoc segyread   for further information		",
d69 2
a70 1
 * Note: If you have a tape with multiple sequences of ebcdic header,
d84 1
a84 1
 *	   time between successive reads and writes.
d97 1
a97 1
 *	CWP: Jack, Brian, Chris
d120 1
a120 1
/* subroutine prototypes */
d127 1
d153 1
d155 3
d209 8
d297 5
a304 1
		bh.format = -1;	  /* indicate that file is no longer SEG-Y */
a307 1
		bh.format = -2;	  /* indicate that file is no longer SEG-Y */
a310 1
		bh.format = -3;	  /* indicate that file is no longer SEG-Y */
d321 1
d323 1
a323 1
	case -3:
d326 2
a327 2
	case -2:
	case -1:
d394 1
a394 1
				case -1:
d399 1
a399 1
				case -2:
d404 1
a404 1
				case -3:
@


1.53
log
@added Toralf's fix to prevent non IBM-format data from converted by
ibm_to_float
@
text
@d1 1
a1 1
/* SEGYREAD: $Revision: 1.52 $ ; $Date: 1997/05/05 17:34:14 $     */
d219 1
a219 1
		if (-1 == read(tapefd, ebcbuf, EBCBYTES)) {
d228 1
a228 1
		 fread(ebcbuf, 1, EBCBYTES, tapefp);
d320 1
a320 1
	nsflag = false;
d327 1
a327 1
			   (nread = read(tapefd, (char *) &tapetr, nsegy))){
d336 1
a336 1
			nread = fread((char *) &tapetr, 1, nsegy, tapefp);
d362 1
a362 1
			nsflag = true;
@


1.52
log
@added Tony Kocurko's fix to permit segy data to be read from
a pipe via tape=-
@
text
@d1 1
a1 1
/* SEGYREAD: $Revision: 1.51 $ ; $Date: 1997/03/21 16:38:42 $     */
d454 4
a467 1

@


1.51
log
@implemented Toralf Foerster's fix of short_to_float subroutine.
@
text
@d1 1
a1 1
/* SEGYREAD: $Revision: 1.50 $ ; $Date: 1997/01/09 16:38:56 $     */
d14 5
a18 1
" segyread > stdout tape=						",
d48 3
a50 3
"	For a seg-y diskfile use tape=filename.				",
"	Remark: a seg-y file is not the same as an su file.		",
"	A seg-y file consists of three parts: an ebcdic header,		",
d55 3
d96 1
a199 1

d201 7
a207 3
	if (buff) tapefd = eopen(tape, O_RDONLY, 0444);
	else	  tapefp = efopen(tape, "r");
	if (verbose) warn("tape opened successfully");
d560 1
a560 1
        register int i;
d562 9
a570 9
        if (endian == 0) {
                for (i = n-1; i >= 0 ; --i) {
                        swap_short_2(&from[i]);
                        to[i] = (float) from[i];
                }
        } else { 
                for (i = n-1; i >= 0 ; --i)
                        to[i] = (float) from[i];
        }
@


1.50
log
@removed erroneous message in Additional Notes paragraph.
@
text
@d1 1
a1 1
/* SEGYREAD: $Revision: 1.49 $ ; $Date: 1996/09/09 16:30:31 $     */
d540 1
a540 1
  
d543 4
a546 1
Author:	J.W. de Bruijn, May 1995
d549 1
a549 15
	register int i;
	float	*buf = alloc1float((size_t) n);
  
	if (endian == 0) {
		for (i = 0; i < n; ++i) {
			swap_short_2(&from[i]);
			buf[i] = (float) from[i];
		}
	} else {
		for (i = 0; i < n; ++i) {
			buf[i] = (float) from[i];
		}
	}
	for (i = 0; i < n; ++i)
		to[i] = buf[i];
d551 9
a559 1
	free1float(buf);
@


1.49
log
@changed includes to reflect new include file tapebhdr.h
@
text
@d1 1
a1 1
/* SEGYREAD: $Revision: 1.48 $ ; $Date: 1996/09/03 21:34:44 $     */
a99 4
 * 
 *	However, if you have created a SEGY data file by a direct read
 *	of a SEGY tape to a disk file, via dd, then use conv=0 to read
 *	the resulting file.
@


1.48
log
@Did -Wall stuff.
@
text
@d1 1
a1 1
/* SEGYREAD: $Revision: 1.47 $ ; $Date: 1996/08/20 21:32:00 $     */
d6 1
@


1.47
log
@Did some -Wall stuff, but more to go and also see LINT_TORALF
@
text
@d1 1
a1 1
/* SEGYREAD: $Revision: 1.46 $ ; $Date: 1996/02/22 21:52:42 $     */
d6 1
d10 9
a18 9
"                                                                       ",
" SEGYREAD - read an SEG-Y tape                                         ",
"                                                                       ",
" segyread > stdout tape=        		                        ",
"                                                                       ",
" Required parameter:                                                   ",
"       tape=		input tape device or seg-y filename (see notes)	",
"                                                                       ",
" Optional parameters:                                                  ",
d36 1
a36 1
"  Notes: Traditionally tape=/dev/rmt0.  However, in the modern world	",
d56 7
a62 7
 *      invokes the no-rewind option and issue multiple segyread
 *      commands (making an appropriate shell script if you
 *      want to save all the headers).  Consider using >> if
 *      you want a single trace file in the end.  Similar
 *      considerations apply for multiple reels of tapes,
 *      but use the standard rewind on end of file.
 *                                              
d64 2
a65 2
 *      tape is accessed with fread. We suggest that you try buff=1
 *      even with EXABYTE tapes.                                 
d68 1
a68 1
 *         time between successive reads and writes.
d70 4
a73 4
 *      intermittently when segyreading/segywriting to 8mm (EXABYTE) tape
 *      even if actual segyread/segywrite is successful. However, this
 *      error message may be returned if your tape drive has a fixed 
 *      block size set.
d75 2
a76 2
 *      drive should be set to be able to read variable block length
 *      tape files.
d80 3
a82 3
 *      SEP: Einar Kjartannson
 *      CWP: Jack, Brian, Chris
 *         : John Stockwell (added 8mm tape stuff)
d84 4
a87 4
 *      Tony Kocurko
 *      Department of Earth Sciences
 *      Memorial University of Newfoundland
 *      St. John's, Newfoundland
d93 3
a95 3
 *      Brian's subroutine, ibm_to_float, which converts IBM floating
 *      point to IEEE floating point is NOT portable and must be
 *      altered for non-IEEE machines.  See the subroutine notes below.
d97 2
a98 2
 *      A direct read by dd would suck up the entire tape; hence the
 *      dancing around with buffers and files.
d100 3
a102 3
 *      However, if you have created a SEGY data file by a direct read
 *      of a SEGY tape to a disk file, via dd, then use conv=0 to read
 *      the resulting file.
d122 10
a131 10
        char *tape;             /* name of raw tape device      */
        char *bfile;            /* name of binary header file   */
        char *hfile;            /* name of ascii header file    */

        int tapefd;             /* file descriptor for tape     */

        FILE *tapefp;           /* file pointer for tape        */
        FILE *binaryfp;         /* file pointer for bfile       */
        FILE *headerfp;         /* file pointer for hfile       */
        FILE *pipefp;           /* file pointer for popen write */
d133 1
a133 1
        size_t nsegy;    	/* size of whole trace in bytes		*/
d135 10
a144 10
        int itr;                /* current trace number                 */
        int trmin;              /* first trace to read                  */
        int trmax;              /* last trace to read                   */
        int ns;                 /* number of data samples               */
        int over;               /* flag for bhed.float override         */
        int conv;               /* flag for data conversion		*/
        int verbose;            /* echo every ...			*/
        int vblock;		/* ... vblock traces with verbose=1	*/
        int buff;               /* flag for buffered/unbuffered device  */
        int endian;		/* flag for big=1 or little=0 endian	*/
d147 1
a147 1
        cwp_Bool nsflag;        /* flag for error in tr.ns              */
d149 3
a151 2
        char cmdbuf[BUFSIZ];    /* dd command buffer                    */
        char ebcbuf[EBCBYTES];  /* ebcdic data buffer                   */
d153 3
d157 12
a168 16
        /* Initialize */
        initargs(argc, argv);
        requestdoc(0); /* stdin not used */


        /* Make sure stdout is a file or pipe */
        switch(filestat(STDOUT)) {
        case TTY:
                err("stdout can't be tty");
        break;
        case DIRECTORY:
                err("stdout must be a file, not a directory");
        break;
        case BADFILETYPE:
                err("stdout is illegal filetype");
        break;
d171 6
a176 1
        }
d178 7
a184 12
        /* Set filenames */
        MUSTGETPARSTRING("tape",  &tape);
        if (!getparstring("hfile", &hfile))     hfile = "header";
        if (!getparstring("bfile", &bfile))     bfile = "binary";

        
        /* Set parameters */
        if (!getparint("trmin", &trmin))        trmin = 1;
        if (!getparint("trmax", &trmax))        trmax = INT_MAX;
        if (!getparint("verbose", &verbose))    verbose = 0;
        if (!getparint("vblock", &vblock))	vblock = 50;
        if (!getparint("endian", &endian))      endian = 1;
d189 2
a190 2
        /* Override binary format value */
        if (!getparint("over", &over))          over = 0;
d192 2
a193 2
        /* Override conversion of IBM floating point data? */
        if (!getparint("conv", &conv))          conv = 1;
d196 4
a199 4
        /* Open files - first the tape */
        if (buff) tapefd = eopen(tape, O_RDONLY, 0444);
        else      tapefp = efopen(tape, "r");
        if (verbose) warn("tape opened successfully");
d201 3
a203 3
        /* - the ebcdic header file in ascii */
        headerfp = efopen(hfile, "w");
        if (verbose) warn("header file opened successfully");
d205 3
a207 3
        /* - the binary data file */
        binaryfp = efopen(bfile, "w");
        if (verbose) warn("binary file opened successfully");
d209 2
a210 2
        /* Read the ebcdic raw bytes from the tape into the buffer */
        if (buff) {
d220 1
a220 1
                 fread(ebcbuf, 1, EBCBYTES, tapefp);
d232 3
a234 3
        /* Open pipe to use dd to convert ascii to ebcdic */
        sprintf(cmdbuf, "dd ibs=3200 of=%s conv=ascii cbs=80 count=1", hfile);
        pipefp = epopen(cmdbuf, "w");
d236 2
a237 2
        /* Write ebcdic stream from buffer into pipe */
        efwrite(ebcbuf, EBCBYTES, 1, pipefp);
d240 2
a241 2
        /* Read binary header from tape to bh structure */
        if (buff) {
d251 1
a251 1
                 fread((char *) &tapebh, 1, BNYBYTES, tapefp);
d269 17
a285 30
  	switch (bh.format) {
  	case 1:
  		bh.format = -1;   /* indicate that file is no longer SEG-Y */
  		if (verbose) warn("assuming IBM floating point input");
  		break;
  	case 2:
  		bh.format = -2;   /* indicate that file is no longer SEG-Y */
  		if (verbose) warn("assuming 4 byte integer input");
  		break;
  	case 3:
  		bh.format = -3;   /* indicate that file is no longer SEG-Y */
  		if (verbose) warn("assuming 2 byte integer input");
  		break;
  	default:
  		(over) ? warn("ignoring bh.format ... continue") :
  			err("format not SEGY standard (1, 2 or 3)");
  	}

        /* Compute length of trace (can't use sizeof here!) */
        if (!getparint("ns", &ns))  ns = bh.hns; /* let user override */
        if (!ns) err("samples/trace not set in binary header");
  	switch (bh.format) {
  	case -3:
  	        nsegy = ns*2 + SEGY_HDRBYTES;
  		break;
  	case -2:
  	case -1:
  	default:
  	        nsegy = ns*4 + SEGY_HDRBYTES;
  	}
d287 15
a301 2
        /* Write binary header from bhed structure to binary file */
        efwrite( (char *) &bh,1, BNYBYTES, binaryfp);
d303 1
a303 1
        /* Close binary and header files now to allow pipe into segywrite */
d305 1
a305 1
        if (verbose) warn("binary file closed successfully");
d311 5
a315 5
        /* Read the traces */
        nsflag = false;
        itr = 0;
        while (itr < trmax) {
                int nread;
d328 2
a329 2
                 	nread = fread((char *) &tapetr, 1, nsegy, tapefp);
		 	if (ferror(tapefp)) {
d338 3
a340 3
	    	}
                        
        if (!nread) break; /* middle exit loop instead of mile-long while */
d349 30
a378 30
                /* Check tr.ns field */
                if (!nsflag && ns != tr.ns) {
                        warn("discrepant tr.ns = %d with tape/user ns = %d\n"
                                "\t... first noted on trace %d",
                                tr.ns, ns, itr + 1);
                        nsflag = true;
                }

                /* Convert and write desired traces */
                if (++itr >= trmin) {
                        /* Convert IBM floats to native floats */
                          if (conv) {
  				switch (bh.format) {
  				case -1:
                          /* Convert IBM floats to native floats */
  					ibm_to_float((int *) tr.data,
  						(int *) tr.data, ns, endian);
  					break;
  				case -2:
                          /* Convert 4 byte integers to native floats */
  					long_to_float((long *) tr.data,
  						(float *) tr.data, ns, endian);
  					break;
  				case -3:
                          /* Convert 2 byte integers to native floats */
  					short_to_float((short *) tr.data,
  						(float *) tr.data, ns, endian);
  					break;
  				}
  			}
d382 2
a383 2
                        	for (i = 0; i < ns ; ++i)
                                        swap_float_4(&tr.data[i]);
d385 9
a393 3
                        /* Write the trace to disk */
                        tr.ns = ns;
                        puttr(&tr);
a394 5
                        /* Echo under verbose option */
                        if (verbose && itr % vblock == 0)
                                warn(" %d traces from tape", itr);
                }
        }
d397 3
a400 3
        /* Re-iterate error in case not seen during run */
        if (nsflag) warn("discrepancy found in header and trace ns values\n"
                "the value (%d) was used to extract traces", ns);
d402 4
a406 4
        /* Clean up (binary & header files already closed above) */
        (buff) ? eclose(tapefd):
                 efclose(tapefp);
        if (verbose) warn("tape closed successfully");
d408 1
a408 2

        return EXIT_SUCCESS;
d445 7
a451 7
            fmant = 0x00ffffff & fconv;
            t = (int) ((0x7f000000 & fconv) >> 22) - 130;
            while (!(fmant & 0x00800000)) { --t; fmant <<= 1; }
            if (t > 254) fconv = (0x80000000 & fconv) | 0x7f7fffff;
            else if (t <= 0) fconv = 0;
            else fconv = (0x80000000 & fconv) |(t << 23)|(0x007fffff & fmant);
        }
d496 1
a496 1
trptr		pointer to trace in "segy" (SEG-Y as in  SU) format
d502 1
a502 1
on a machine not using this convention.  The float data is preserved as
d530 1
a530 1
  	register int i;
d532 10
a541 10
  	if (endian == 0) {
  		for (i = 0; i < n; ++i) {
  			swap_long_4(&from[i]);
  			to[i] = (float) from[i];
  		}
  	} else {
  		for (i = 0; i < n; ++i) {
  			to[i] = (float) from[i];
  		}
  	}
d549 2
a550 2
  	register int i;
  	float	*buf = alloc1float((size_t) n);
d552 12
a563 12
  	if (endian == 0) {
  		for (i = 0; i < n; ++i) {
  			swap_short_2(&from[i]);
  			buf[i] = (float) from[i];
  		}
  	} else {
  		for (i = 0; i < n; ++i) {
  			buf[i] = (float) from[i];
  		}
  	}
  	for (i = 0; i < n; ++i)
  		to[i] = buf[i];
d565 1
a565 1
  	free1float(buf);
@


1.46
log
@Only warn on conversion type if verbose is set.
@
text
@d1 1
a1 1
/* SEGYREAD: $Revision: 1.45 $ ; $Date: 1995/10/18 15:36:44 $     */
d111 1
a111 1
static void tapesegy_to_segy(const tapesegy *tapetrptr, segy *trptr, int ns);
d118 1
d168 2
d342 1
a342 1
		tapesegy_to_segy(&tapetr, &tr, ns);
d485 1
a485 1
static void tapesegy_to_segy(const tapesegy *tapetrptr, segy *trptr, int ns)
a492 1
ns		number of samples per trace
@


1.45
log
@Handle 2 and 4 fixed byte formats courtesy of Remco Romijn and
J.W. de Bruijn, Delft.
@
text
@d1 1
a1 1
/* SEGYREAD: $Revision: 1.44 $ ; $Date: 1995/09/27 16:48:28 $     */
d268 1
a268 1
  		warn("assuming IBM floating point input");
d272 1
a272 1
  		warn("assuming 4 byte integer input");
d276 1
a276 1
  		warn("assuming 2 byte integer input");
@


1.44
log
@changed LONG_MAX to prevent truncation
@
text
@d1 1
a1 1
/* SEGYREAD: $Revision: 1.43 $ ; $Date: 1995/09/18 13:38:32 $     */
d18 4
a21 4
"       buff=1          for buffered device (9-track reel tape drive)	",
"                       =0 possibly useful for 8mm EXABYTE drives	",
"       verbose=0       silent operation                                ",
"                       =1 ; echo every 'vblock' traces			",
d23 10
a32 10
"       hfile=header    file to store ebcdic block (as ascii)           ",
"       bfile=binary    file to store binary block                      ",
"       over=0          quit if bhed format not equal 1                 ",
"                       = 1 ; override and attempt conversion           ",
"       conv=1          convert data from IBM to native format		",
"                       = 0 ; assume data is in native format		",
"       ns=bh.hns       number of samples (use if bhed ns wrong)        ",
"       trmin=1         first trace to read                             ",
"       trmax=INT_MAX  last trace to read                              ",
"	endian=1	set =0 for little-endian machines (PC's, DEC, etc.)",
d34 1
a34 1
"                                                                       ",
d37 3
a39 3
"       often be deduced by \"ls /dev\".  Likely man pages with the	",
"       names of the tape devices are: \"mt\", \"sd\" \"st\".  Also	",
"       try \"man -k scsi\", \" man mt\", etc.	Sometimes \"mt status\"	",
d41 2
a42 2
"                                                                       ",
"       For a seg-y diskfile use tape=filename.				",
d48 2
a49 2
"                                                                       ",
"         type:   sudoc segyread   for further information              ",
d84 1
a84 1
 *      Departmant of Earth Sciences
d87 3
d108 2
d264 18
a281 5
	
        if (bh.format != 1)
                (over) ? warn("ignoring bh.format ... continue") :
                         err("format not IBM floating point");
	bh.format = -1;   /* indicate that file is no longer SEG-Y */
d286 9
a294 1
        nsegy = ns*4 + SEGY_HDRBYTES;
d356 19
a374 2
                        if (conv) ibm_to_float((int *) tr.data,
						(int *) tr.data, ns, endian);
d520 43
@


1.43
log
@Preserve the optional fields in tapesegy_to_segy subroutine.
@
text
@d1 1
a1 1
/* SEGYREAD: $Revision: 1.42 $ ; $Date: 1995/08/28 20:35:18 $     */
d31 1
a31 1
"       trmax=LONG_MAX  last trace to read                              ",
d172 1
a172 1
        if (!getparint("trmax", &trmax))        trmax = LONG_MAX;
@


1.42
log
@Self-doc upgrade.
@
text
@d1 1
a1 1
/* SEGYREAD: $Revision: 1.41 $ ; $Date: 1995/08/28 20:23:51 $     */
d471 4
a474 1
	
@


1.41
log
@Tweaked self-doc per Chris and Craig.
@
text
@d1 1
a1 1
/* SEGYREAD: $Revision: 1.40 $ ; $Date: 1995/08/28 20:00:28 $     */
d14 2
a15 2
" Required parameter:                                                  ",
"       tape=		tape device to use (see notes)			",
@


1.40
log
@Had verbose getpar twice.
@
text
@d1 1
a1 1
/* SEGYREAD: $Revision: 1.39 $ ; $Date: 1995/08/23 19:49:13 $     */
d39 2
a40 1
"       try \"man -k scsi\", \" man mt\", etc.				",
d42 6
a47 1
"       For a seg-y diskfile use tape=filename.                         ",
d53 2
a54 2
 * Note: If you have a tape with multiple sequences of binary
 *      header, ebcdic header, traces, use the device that
@


1.39
log
@Made tape= a required parameter.
@
text
@d1 1
a1 1
/* SEGYREAD: $Revision: 1.38 $ ; $Date: 1995/04/26 14:03:39 $     */
a166 1
        if (!getparint("verbose", &verbose))    verbose = 0;
@


1.38
log
@fixed bug in swapping
@
text
@d1 1
a1 1
/* SEGYREAD: $Revision: 1.37 $ ; $Date: 95/01/19 11:42:35 $     */
d12 1
a12 1
" segyread > stdout [tape=RMTDEVICE]                                    ",
d14 2
a15 2
" Required parameters:                                                  ",
"       none                                                            ",
a17 1
"       tape=RMTDEVICE  tape device to use, see suport.h                ",
d35 7
a41 1
"  Notes: use  tape=filename for segy diskfile.                         ",
d48 1
a48 1
 *      header, ebcdic header, traces, use the RMTDEVICE that
d159 1
a159 1
        if (!getparstring("tape",  &tape))      tape = RMTDEVICE;
@


1.37
log
@added missing getpar
@
text
@d1 1
a1 1
/* SEGYREAD: $Revision: 1.36 $ ; $Date: 94/10/10 10:48:14 $     */
d322 5
@


1.36
log
@updated documentation in internal subroutines.
@
text
@d1 1
a1 1
/* SEGYREAD: $Revision: 1.35 $ ; $Date: 94/10/07 09:55:00 $     */
d167 1
@


1.35
log
@changed selfdoc information
@
text
@d1 1
a1 1
/* SEGYREAD: $Revision: 1.34 $ ; $Date: 94/09/06 10:02:23 $     */
d368 1
a368 1
Credits: CWP: Brian Sumner
a394 1
/* Assumes sizeof(short) == 2, sizeof(int) == 4, sizeof(float) == 4 */
d396 16
d416 1
d424 22
d450 1
d456 1
@


1.34
log
@No changes in code.  Had forgotten to document following changes
in the previous version:

Replaced declaration: unsigned int nsegy; by size_t nsegy;
The routine swap_bhed() was replaced by a loop over the binary key words.
@
text
@d1 1
a1 1
/* SEGYREAD: $Revision: 1.33 $ ; $Date: 94/09/06 09:59:22 $     */
d20 1
a20 1
"                       =0 for unbuffered device (8mm EXABYTE drive)	",
d52 2
a53 2
 *      tape is accessed with fread.
 *                                      
d359 1
a359 1
	Up to 3 bits lost on IEEE -> IBM
d361 1
a361 1
	Assumes sizeof(int) == 4
d363 2
a364 2
	IBM -> IEEE may overflow or underflow, taken care of by 
	substituting large number or zero
d366 1
a366 1
	Only integer shifting and masking are used.
a392 1

@


1.33
log
@Added the routines tapebhed_to_bhed and tapesegy_to_segy and the
include file tapesegy.h to support reading individual fields
in the trace and binary headers (both on tape and in diskfiles).  The idea
is to avoid problems like reading 8 bytes on machines that
have 8 byte ints and thus reading out two four byte ints from the tape.
This plan is not, however, carried out 100% in this version.

No longer read in optional fields!  (So don't need segyclean.)
Eliminated includes hdr.h header.h
@
text
@d1 1
a1 1
/* SEGYREAD: $Revision: 1.6 $ ; $Date: 94/09/01 14:56:44 $     */
@


1.32
log
@Removed copyright statement from codes that had it.
Moved self-doc line for sudoc.
@
text
@d1 1
a1 1
/* SEGYREAD: $Revision: 1.31 $ ; $Date: 94/08/18 13:59:00 $     */
d5 1
a5 1
#include "header.h"
d94 2
a95 1
static void swap_bhed();
d97 2
d115 1
a115 1
        unsigned int nsegy;     /* size of whole trace in bytes         */
d126 1
a126 1
        int endian;		/* flag for big=1 or little=0 endian machine */
d163 1
a164 1
        if (!getparint("buff", &buff))          buff = 1;
d168 2
a169 1
        /* Override binary format value? */
d175 1
d222 1
a222 1
		if (-1 == read(tapefd, (char *) &bh, BNYBYTES)) {
d231 1
a231 1
                 fread((char *) &bh, 1, BNYBYTES, tapefp);
d243 3
d247 2
a248 2
	if (endian==0) swap_bhed();

a251 1
                        
a253 1

d257 1
a257 1
        nsegy = ns*4 + 240;
d277 2
a278 1
			if (-1 == (nread = read(tapefd, (char *) &tr, nsegy))){
d287 1
a287 1
                 	nread = fread((char *) &tr, 1, nsegy, tapefp);
d298 1
a298 1
                       
d301 2
a302 2
		/* if little endian machine, then swap bytes in trace header */
		if (endian==0) for (i = 0; i < SU_NKEYS; ++i) swaphval(&tr,i);
d304 4
d394 4
a397 7
static void swap_bhed()
/*******************************************************************
swap_bhed - swap the bytes in the binary header
********************************************************************
********************************************************************
Author: Jens Hartmann 
********************************************************************/
d399 21
a419 27
  swap_int_4(&bh.jobid);
  swap_int_4(&bh.lino);
  swap_int_4(&bh.reno);
  swap_short_2(&bh.ntrpr);
  swap_short_2(&bh.nart);
  swap_short_2(&bh.hdt);
  swap_short_2(&bh.dto);
  swap_short_2(&bh.hns);
  swap_short_2(&bh.nso);
  swap_short_2(&bh.format);
  swap_short_2(&bh.fold);
  swap_short_2(&bh.tsort);
  swap_short_2(&bh.vscode);
  swap_short_2(&bh.hsfe);
  swap_short_2(&bh.hslen);
  swap_short_2(&bh.hstyp);
  swap_short_2(&bh.schn);
  swap_short_2(&bh.hstas);
  swap_short_2(&bh.hstae);
  swap_short_2(&bh.htatyp);
  swap_short_2(&bh.hcorr);
  swap_short_2(&bh.bgrcv);
  swap_short_2(&bh.rcvm);
  swap_short_2(&bh.mfeet);
  swap_short_2(&bh.polyt);
  swap_short_2(&bh.vpol);
} 
@


1.31
log
@Added option to let user specify how often to echo traces read/write
instead of doing it at 50.
Added option of ignoring so many consecutive read/write errors to tape.
Added caveat that buff=0 makes tapes non-portable.
@
text
@d1 1
a1 1
/* SEGYREAD: $Revision: 1.30 $ ; $Date: 94/08/02 14:40:25 $     */
@


1.30
log
@Move binary and ascii header closes up near to prepare for piping
into segywrite.  Declared a few things static.
@
text
@d1 1
a1 1
/* SEGYREAD: $Revision: 1.29 $ ; $Date: 94/07/15 13:59:33 $     */
d22 2
a23 1
"                       = 1 ; echo every 50 traces                      ",
d34 1
d120 2
a121 1
        int verbose;            /* flag for echoing traces read         */
d124 2
d160 1
d162 2
d165 1
a165 2

        /* Check if user wants to override binary format value */
d168 1
a168 2
        /* Check if user wants to override conversion of IBM floating */
        /* point data */
a170 3
	/* endian */
        if (!getparint("endian", &endian))      endian = 1;

d185 21
a205 2
        (buff) ? eread(tapefd, ebcbuf, EBCBYTES):
                 efread(ebcbuf, 1, EBCBYTES,tapefp);
d216 21
a236 2
        (buff) ? eread(tapefd, (char *) &bh, BNYBYTES):
                 efread((char *) &bh, 1, BNYBYTES,tapefp);
d268 24
a291 3
                int nread = (buff) ? eread(tapefd, (char *) &tr, nsegy) :
                         efread((char *) &tr, 1, nsegy, tapefp);
                        
d294 2
a295 2
	/* if little endian machine, then swap bytes in trace header */
	if (endian==0) for (i = 0; i < SU_NKEYS; ++i) swaphval(&tr,i);
d316 1
a316 1
                        if (verbose && itr % 50 == 0)
@


1.29
log
@cosmetic
@
text
@d1 1
a1 1
/* SEGYREAD: $Revision: 1.28 $ ; $Date: 94/07/12 17:11:26 $     */
d91 2
a92 2
void ibm_to_float(int from[], int to[], int n, int endian);
void swap_bhed();
d166 1
a166 1
        if (!getparint("endian", &endian))          endian = 1;
d215 8
d266 1
a266 1
        /* Clean up */
a270 2
        efclose(binaryfp);
        if (verbose) warn("binary file closed successfully");
a271 5
        efclose(headerfp);
        if (verbose) warn("header file closed successfully");

        epclose(pipefp);

d275 1
a275 1
void ibm_to_float(int from[], int to[], int n, int endian)
d321 1
a321 1
void swap_bhed()
@


1.28
log
@changed swap_long_4 to swap_int_4 to reflect new segy.h convention
@
text
@d1 1
a1 1
/* SEGYREAD: $Revision: 1.27 $ ; $Date: 94/06/15 10:24:39 $     */
a2 13
/*----------------------------------------------------------------------
 * Copyright (c) Colorado School of Mines, 1990.
 * All rights reserved.
 *
 * This code is part of SU.  SU stands for Seismic Unix, a processing line
 * developed at the Colorado School of Mines, partially based on Stanford
 * Exploration Project (SEP) software.  Inquiries should be addressed to:
 *
 *  Jack K. Cohen, Center for Wave Phenomena, Colorado School of Mines,
 *  Golden, CO 80401  (jkc@@dix.mines.colorado.edu)
 *----------------------------------------------------------------------
 */

d66 1
a66 1
 *      SEP: Einar
@


1.27
log
@changed fwrite to fread in documentation
@
text
@d1 1
a1 1
/* SEGYREAD: $Revision: 1.26 $ ; $Date: 94/04/18 08:36:54 $     */
d341 3
a343 3
  swap_long_4(&bh.jobid);
  swap_long_4(&bh.lino);
  swap_long_4(&bh.reno);
@


1.26
log
@moved  "swap_bhed" statement before bh.format statement.
@
text
@d1 1
a1 1
/* SEGYREAD: $Revision: 1.25 $ ; $Date: 94/03/25 09:56:39 $     */
d63 1
a63 1
 *      tape is accessed with fwrite.
@


1.25
log
@put in byte-swapping.
@
text
@d1 1
a1 1
/* SEGYREAD: $Revision: 1.23 $ ; $Date: 93/11/12 15:51:24 $     */
d210 3
a218 2
	/* if little endian machine, swap bytes in binary header */
	if (endian==0) swap_bhed();
@


1.24
log
@added comment about IBM
@
text
@d18 1
d45 1
d62 1
a62 1
 * Note: For buff=1 (default) tape is accessed with 'write', for buff=0
d75 1
a75 1
 *      tape files. On an IBM RS6000, this means blocksize=0
a92 5
 *      The subroutines bhedtape_to_bhedsu and segytape_to_segysu are
 *      only stubs and are not portable.  On machines where shorts are
 *      not 2 bytes and/or longs are not 4 bytes, routines to convert
 *      SEGY 16 bit and 32 bit integers will be required.
 *
d104 2
a105 1
void ibm_to_float(int from[], int to[], int n);
d124 1
d133 1
a157 1

a175 1

d178 2
a193 1

a197 1

a201 1

d206 1
a206 1
        /* Read binary header from tape to bhedtape structure */
d216 3
a225 1
        
d235 4
a238 1
                
d251 1
a251 1
						(int *) tr.data, ns);
d286 12
d299 1
a299 28
/* ibm_to_float - convert between 32 bit IBM and IEEE floating numbers
 *
 * Credits:
 *      CWP: Brian
 *
 * Parameters:
 *    from      - input vector
 *    to        - output vector, can be same as input vector
 *    len       - number of floats in vectors
 *    type      - conversion type
 *
 * Notes:
 *      Up to 3 bits lost on IEEE -> IBM
 *
 *      IBM -> IEEE may overflow or underflow, taken care of by
 *      substituting large number or zero
 *
 *      Only integer shifting and masking are used.
 *
 *      This routine assumes a big-endian machine.  If yours is little
 *      endian you will need to reverse the bytes in ibm_to_float
 *      with something like
 *
 *      fconv = from[i];
 *      fconv = (fconv<<24) | ((fconv>>24)&0xff) |
 *              ((fconv&0xff00)<<8) | ((fconv&0xff0000)>>8);
 *
 */
d301 7
a307 2
/* Assumes sizeof(int) == 4 */
void ibm_to_float(int from[], int to[], int n)
d312 8
a319 2
        fconv = from[i];
        if (fconv) {
d327 1
a327 1
        to[i] = fconv;
d331 36
@


1.23
log
@added additional note.
@
text
@d1 1
a1 1
/* SEGYREAD: $Revision: 1.22 $ ; $Date: 93/08/26 20:04:08 $     */
d73 1
a73 1
 *      tape files.
@


1.22
log
@Eliminated bit version attempt at inserting portability stubs.
It probably caused some error in segywrite at the least.
Some cosmetics.
@
text
@d1 1
a1 1
/* SEGYREAD: $Revision: 1.21 $ ; $Date: 93/08/13 10:27:23 $     */
d66 1
a66 1
 * Bug: may return the error message "efclose: fclose failed"
d68 6
a73 1
 *      even if actual segyread/segywrite is successful.
@


1.21
log
@changed Bool to cwp_Bool
@
text
@d1 1
a1 1
/* SEGYREAD: $Revision: 1.20 $ ; $Date: 93/07/27 09:45:16 $	*/
a17 1
#include "segytape.h"
d21 27
a47 30
" 									",
" SEGYREAD - read an SEG-Y tape						",
" 									",
" segyread > stdout [tape=RMTDEVICE] 					",
" 									",
" Required parameters:							",
" 	none								",
" 									",
" Optional parameters:							",
" 	tape=RMTDEVICE	tape device to use, see suport.h		",
"	buff=1		for buffered device (standard 9-trac reel tape drive)",
"                       =0 for unbuffered device (8mm EXABYTE tape drive)",
"	verbose=0	silent operation				",
"			= 1 ; echo every 50 traces			",
"	hfile=header	file to store ebcdic block (as ascii)		",
"	bfile=binary	file to store binary block			",
"	over=0		quit if bhed format not equal 1			",
"			= 1 ; override and attempt conversion		",
"	conv=1		convert floating point data from IBM to	native format",
"			= 0 ; assume floating point data is in native format",
"	ns=bh.hns	number of samples (use if bhed ns wrong)	",
"	trmin=1		first trace to read				",
"	trmax=LONG_MAX	last trace to read				",
" 									",
"  Notes: use  tape=filename for segy diskfile.				",
" 	       conv=1 if file is in IBM format				",
" 		   =0 if file is in native binary format		",
" 	  use  buff=0 for streaming tape drive (i.e. exabyte) (fragile)	",
" 									",
" 	  type:   sudoc segyread   for further information		",
d52 8
a59 8
 *	header, ebcdic header, traces, use the RMTDEVICE that
 *	invokes the no-rewind option and issue multiple segyread
 *	commands (making an appropriate shell script if you
 *	want to save all the headers).  Consider using >> if
 *	you want a single trace file in the end.  Similar
 *	considerations apply for multiple reels of tapes,
 *	but use the standard rewind on end of file.
 *						
d61 2
a62 2
 *	tape is accessed with fwrite.
 *					
d65 1
a65 1
 *	   time between successive reads and writes.
d67 2
a68 2
 *	intermittently when segyreading/segywriting to 8mm (EXABYTE) tape
 *	even if actual segyread/segywrite is successful.
d72 3
a74 3
 *	SEP: Einar
 *	CWP: Jack K. Cohen, Brian Sumner, Chris Liner
 *	   : John Stockwell (added 8mm tape stuff)
d76 4
a79 4
 * 	Tony Kocurko
 *	Departmant of Earth Sciences
 *	Memorial University of Newfoundland
 *	St. John's, Newfoundland
d82 3
a84 3
 *	Brian's subroutine, ibm_to_float, that converts IBM floating
 *	point to IEEE floating point is NOT portable and must be
 *	altered for non-IEEE machines.  See the subroutine notes below.
d86 4
a89 4
 *	The subroutines bhedtape_to_bhedsu and segytape_to_segysu are
 *	only stubs and are not portable.  On machines where shorts are
 *	not 2 bytes and/or longs are not 4 bytes, routines to convert
 *	SEGY 16 bit and 32 bit integers will be required.
d91 2
a92 2
 *	A direct read by dd would suck up the entire tape; hence the
 *	dancing around with buffers and files.
a102 2
void bhedtape_to_bhedsu(void *tapebhptr, void *bhptr);
void segytape_to_segysu(void *tapetrptr, void *trptr, int nsegy);
a103 2
segytape tapetr;
bhedtape tapebh;
d109 3
a111 3
	char *tape;		/* name of raw tape device	*/
	char *bfile;		/* name of binary header file	*/
	char *hfile;		/* name of ascii header file	*/
d113 1
a113 1
	int tapefd;		/* file descriptor for tape	*/
d115 4
a118 4
	FILE *tapefp;		/* file pointer for tape	*/
	FILE *binaryfp;		/* file pointer for bfile	*/
	FILE *headerfp;		/* file pointer for hfile	*/
	FILE *pipefp;		/* file pointer for popen write	*/
d120 13
a132 8
	unsigned int nsegy;	/* size of whole trace in bytes 	*/
	int itr;		/* current trace number			*/
	int trmin;		/* first trace to read			*/
	int trmax;		/* last trace to read			*/
	int ns;			/* number of data samples		*/
	int over;		/* flag for bhed.float override		*/
	int conv;		/* flag for converting floating */
				/* point trace data from IBM format*/
a133 5
	int verbose;		/* flag for echoing traces read		*/
	int buff;		/* flag for buffered/unbuffered device	*/
	cwp_Bool nsflag;		/* flag for error in tr.ns		*/
	char cmdbuf[BUFSIZ];	/* dd command buffer			*/
	char ebcbuf[EBCBYTES];	/* ebcdic data buffer			*/
d135 3
a138 3
	/* Initialize */
	initargs(argc, argv);
	requestdoc(0); /* stdin not used */
d140 12
a152 12
	/* Make sure stdout is a file or pipe */
	switch(filestat(STDOUT)) {
	case TTY:
		err("stdout can't be tty");
	break;
	case DIRECTORY:
		err("stdout must be a file, not a directory");
	break;
	case BADFILETYPE:
		err("stdout is illegal filetype");
	break;
	}
d154 4
d159 6
a164 4
	/* Set filenames */
	if (!getparstring("tape",  &tape))	tape = RMTDEVICE;
	if (!getparstring("hfile", &hfile))	hfile = "header";
	if (!getparstring("bfile", &bfile))	bfile = "binary";
a165 6
	
	/* Set parameters */
	if (!getparint("trmin", &trmin))	trmin = 1;
	if (!getparint("trmax", &trmax))	trmax = LONG_MAX;
	if (!getparint("verbose", &verbose)) 	verbose = 0;
	if (!getparint("buff", &buff)) 		buff = 1;
d167 2
d170 2
a171 2
	/* Check if user wants to override binary format value */
	if (!getparint("over", &over))		over = 0;
d173 1
a173 2
	/* Check if user wants to override conversion of IBM floating */
	/* point data */
a174 1
	if (!getparint("conv", &conv))		conv = 1;
d176 4
d181 3
a183 4
	/* Open files - first the tape */
	if (buff) tapefd = eopen(tape, O_RDONLY, 0444);
	else	  tapefp = efopen(tape, "r");
	if (verbose) warn("tape opened successfully");
d185 3
a187 3
	/* - the ebcdic header file in ascii */
	headerfp = efopen(hfile, "w");
	if (verbose) warn("header file opened successfully");
a188 3
	/* - the binary data file */
	binaryfp = efopen(bfile, "w");
	if (verbose) warn("binary file opened successfully");
d190 3
a193 3
	/* Read the ebcdic raw bytes from the tape into the buffer */
	(buff) ? eread(tapefd, ebcbuf, EBCBYTES):
		 efread(ebcbuf, 1, EBCBYTES,tapefp);
d195 3
a198 3
	/* Open pipe to use dd to convert ascii to ebcdic */
	sprintf(cmdbuf, "dd ibs=3200 of=%s conv=ascii cbs=80 count=1", hfile);
	pipefp = epopen(cmdbuf, "w");
d200 2
a202 2
	/* Write ebcdic stream from buffer into pipe */
	efwrite(ebcbuf, EBCBYTES, 1, pipefp);
d204 3
d208 4
a211 10
	/* Read binary header from tape to bhedtape structure */
	(buff) ? eread(tapefd, (char *) &tapebh, BNYBYTES):
		 efread((char *) &tapebh, 1, BNYBYTES,tapefp);

	if (tapebh.format != 1)
		(over) ? warn("ignoring bh.format ... continue") :
			 err("format not IBM floating point");
			
	/* Convert from bytes to longs/shorts */
	bhedtape_to_bhedsu(&tapebh, &bh);
d214 4
a217 4
	/* Compute length of trace (can't use sizeof here!) */
	if (!getparint("ns", &ns))  ns = bh.hns; /* let user override */
	if (!ns) err("samples/trace not set in binary header");
	nsegy = ns*4 + 240;
d219 3
a221 3
	/* Write binary header from bhed structure to binary file */
	efwrite( (char *) &bh,1, BNYBYTES, binaryfp);
	
d223 16
a238 19
	/* Read the traces */
	nsflag = false;
	itr = 0;
	while (itr < trmax) {
		int nread = (buff) ? eread(tapefd, (char *) &tr, nsegy) :
			 efread((char *) &tr, 1, nsegy, tapefp);
			
	if (!nread) break; /* middle exit loop instead of mile-long while */

		/* Convert from bytes to longs/shorts */
		segytape_to_segysu(&tr, &tr, nsegy);
		
		/* Check tr.ns field */
		if (!nsflag && ns != tr.ns) {
			warn("discrepant tr.ns = %d with tape/user ns = %d\n"
				"\t... first noted on trace %d",
				tr.ns, ns, itr + 1);
			nsflag = true;
		}
d240 5
a244 4
		/* Convert and write desired traces */
		if (++itr >= trmin) {
			/* Convert IBM floats to native floats */
			if ( conv ) ibm_to_float((int *) tr.data, (int *) tr.data, ns);
d246 3
a248 3
			/* Write the trace to disk */
			tr.ns = ns;
			puttr(&tr);
d250 5
a254 5
			/* Echo under verbose option */
			if (verbose && itr % 50 == 0)
				warn(" %d traces from tape", itr);
		}
	}
d258 3
a260 3
	/* Re-iterate error in case not seen during run */
	if (nsflag) warn("discrepancy found in header and trace ns values\n"
		"the value (%d) was used to extract traces", ns);
d263 4
a266 4
	/* Clean up */
	(buff) ? eclose(tapefd):
		 efclose(tapefp);
	if (verbose) warn("tape closed successfully");
d268 2
a269 2
	efclose(binaryfp);
	if (verbose) warn("binary file closed successfully");
d271 2
a272 2
	efclose(headerfp);
	if (verbose) warn("header file closed successfully");
d274 1
a274 1
	epclose(pipefp);
d276 1
a276 1
	return EXIT_SUCCESS;
d283 1
a283 1
 *	CWP: Brian
d286 4
a289 4
 *    from	- input vector
 *    to	- output vector, can be same as input vector
 *    len	- number of floats in vectors
 *    type	- conversion type
d292 1
a292 1
 *	Up to 3 bits lost on IEEE -> IBM
d294 2
a295 2
 *	IBM -> IEEE may overflow or underflow, taken care of by
 *	substituting large number or zero
d297 1
a297 1
 *	Only integer shifting and masking are used.
d299 3
a301 3
 *	This routine assumes a big-endian machine.  If yours is little
 *	endian you will need to reverse the bytes in ibm_to_float
 *	with something like
d303 3
a305 3
 *	fconv = from[i];
 *	fconv = (fconv<<24) | ((fconv>>24)&0xff) |
 *		((fconv&0xff00)<<8) | ((fconv&0xff0000)>>8);
d315 2
a316 2
	fconv = from[i];
	if (fconv) {
d324 1
a324 1
	to[i] = fconv;
a327 16


/* Next two routines are just stubs */

/* Assumes sizeof(short) == 2, sizeof(long) == 4 */
void bhedtape_to_bhedsu(void *tapebhptr, void *bhptr)
{
	memcpy(bhptr, tapebhptr, BNYBYTES);
}
/* Assumes sizeof(short) == 2, sizeof(long) == 4 */
void segytape_to_segysu(void *tapetrptr, void *trptr, int nsegy)
{
	memcpy(trptr, tapetrptr, nsegy);
}


@


1.20
log
@moved Notes below selfdoc
@
text
@d1 1
a1 1
/* SEGYREAD: $Revision: 1.19 $ ; $Date: 93/07/13 09:28:56 $	*/
d139 1
a139 1
	Bool nsflag;		/* flag for error in tr.ns		*/
@


1.19
log
@*** empty log message ***
@
text
@d1 1
a1 1
/* SEGYREAD: $Revision: 1.18 $ ; $Date: 93/07/13 09:26:43 $	*/
d117 3
a119 3
	String tape;		/* name of raw tape device	*/
	String bfile;		/* name of binary header file	*/
	String hfile;		/* name of ascii header file	*/
@


1.18
log
@fixed conv=0 bug
@
text
@d1 1
a1 1
/* SEGYREAD: $Revision: 1.17 $ ; $Date: 93/05/27 10:44:46 $	*/
d48 1
a48 1
" 		   =0 if file is in native binary format		", 
@


1.17
log
@cosmetic change to selfdoc
@
text
@d1 1
a1 1
/* SEGYREAD: $Revision: 1.16 $ ; $Date: 93/05/26 12:54:18 $	*/
d25 1
a25 1
" segyread >stdout [tape=RMTDEVICE] 					",
d46 4
a49 8
" Note: If you have a tape with multiple sequences of binary		",
"	header, ebcdic header, traces, use the RMTDEVICE that		",
"	invokes the no-rewind option and issue multiple segyread	",
"	commands (making an appropriate shell script if you		",
"	want to save all the headers).  Consider using >> if		",
"	you want a single trace file in the end.  Similar		",
"	considerations apply for multiple reels of tapes,		",
"	but use the standard rewind on end of file.			",
d51 1
a51 9
" Note: For buff=1 (default) tape is accessed with 'write', for buff=0	",
" 	tape is accessed with fwrite.					",
" 									",
" Caveat: may be slow on an 8mm streaming (EXABYTE) tapedrive		",
" Warning: segyread or segywrite to 8mm tape is fragile. Allow sufficient",
"	   time between successive reads and writes.			",
" Bug: may return the error message \"efclose: fclose failed\"		",
" 	intermittently when segyreading/segywriting to 8mm (EXABYTE) tape,",
"	even if actual segyread/segywrite is successful.		",
a52 1
/**************** end self doc ***********************************/
d54 21
d77 1
a77 1
 *	CWP: Jack, Brian, Chris
d79 7
a85 1
 * Notes:
d98 4
d103 1
d179 4
a182 2
	/* Check if user wants to override conversion of IBM floating point data */
	if (!getparint("conv", &conv))		conv = 0;
@


1.16
log
@Tony Kocurko's additions
@
text
@d1 1
a1 1
/* SEGYREAD: $Revision: 1.15 $ ; $Date: 93/01/22 11:59:05 $	*/
d40 1
a40 2
"	conv=1		convert floating point data from IBM to",
"			native format",
d83 1
a83 1
 *
@


1.15
log
@found a bug in a conditional.
@
text
@d1 1
a1 1
/* SEGYREAD: $Revision: 1.13 $ ; $Date: 92/11/17 10:32:15 $	*/
d34 12
a45 9
" 	verbose=0	silent operation				",
" 			= 1 ; echo every 50 traces			",
" 	hfile=header	file to store ebcdic block (as ascii)		",
" 	bfile=binary	file to store binary block			",
" 	over=0		quit if bhed format not equal 1			",
" 			= 1 ; override and attempt conversion		",
" 	ns=bh.hns	number of samples (use if bhed ns wrong)	",
" 	trmin=1		first trace to read				",
" 	trmax=LONG_MAX	last trace to read				",
d89 2
a90 2
void bhedtape_to_bhedsu(void *tapebhptr, void *bhptr); 
void segytape_to_segysu(void *tapetrptr, void *trptr, int nsegy); 
d116 3
d161 2
d164 1
d200 1
a200 1
			 
d218 3
a220 3
		int nread = (buff) ? eread(tapefd, (char *) &tapetr, nsegy) :
			 efread((char *) &tapetr, 1, nsegy, tapefp);
			 
d224 1
a224 1
		segytape_to_segysu(&tapetr, &tr, nsegy);
d229 1
a229 1
				"\t... first noted on trace %d", 
d237 1
a237 2
			ibm_to_float((int *) tr.data, 
					(int *) tr.data, ns);
d287 1
a287 1
 *	IBM -> IEEE may overflow or underflow, taken care of by 
d329 1
a329 1
} 
d334 3
a336 1
} 
@


1.14
log
@unsplit a few strings in warn() and err() changed 1 conditional to an if
@
text
@d189 1
a189 1
		if (over)  warn("ignoring bh.format ... continue") ;
d219 3
a221 3
			warn("discrepant tr.ns = %d",tr.ns);
			warn("with tape/user ns = %d\n",ns);
			warn("\t... first noted on trace %d", itr + 1);
d232 1
@


1.13
log
@Added stubs for 16-short, 32-long conversions in header.
Put buff test inside loop to avoid duplicate code.
Using conditionals for buff tests.
@
text
@d1 1
a1 1
/* SEGYREAD: $Revision: 1.12 $ ; $Date: 92/11/06 08:29:46 $	*/
d189 1
a189 1
		(over) ? warn("ignoring bh.format ... continue") :
d219 3
a221 3
			warn("discrepant tr.ns = %d with tape/user ns = %d\n"
				"\t... first noted on trace %d", 
				tr.ns, ns, itr + 1);
@


1.12
log
@added 8mm tape drive support
@
text
@d1 1
a1 1
/* SEGYREAD: $Revision: 1.11 $ ; $Date: 92/10/22 15:51:19 $	*/
d18 1
d70 1
a70 1
 *	The library subroutine, ibm_to_float, that converts IBM floating
d72 1
a72 1
 *	altered for non-IEEE machines.  See the notes in that code.
d74 5
d84 4
d89 2
d100 1
a100 1
	int fdtape;		/* file descriptor for tape	*/
d114 1
a114 1
	int buff;		/* flag for buffered or unbuffered device*/
d157 2
a158 5
	if (buff) { /* use open */
		fdtape = eopen(tape, O_RDONLY, 0444);
	} else {
		tapefp = efopen(tape, "r");
	}
d171 2
a172 5
	if (buff) { /* use read */
		eread(fdtape, ebcbuf, EBCBYTES);
	} else {
		efread(ebcbuf, 1, EBCBYTES,tapefp);
	}
d184 6
a189 8
	/* Read binary header from tape to bhed structure */
	if (buff) {
		eread(fdtape, (char *) &bh, BNYBYTES);
	} else {
		efread((char *) &bh, 1, BNYBYTES,tapefp);
	}
	if (bh.format != 1)
		(over) ? warn("ignore bh.format ... continue") :
d191 3
a195 1

d197 1
a197 1
	if (!getparint("ns", &ns))  ns = bh.hns; /* let user override bhed */
a200 1

d203 1
a204 1

d208 5
a212 2
	if (buff) {
		while (eread(fdtape, (char *) &tr, nsegy) && itr < trmax) {
d214 5
a218 2
			/* Check tr.ns field */
			if (!nsflag && ns != tr.ns) {
a222 15
			}

			/* Convert and write desired traces */
			if (++itr >= trmin) {
				/* Convert IBM floats to native floats */
				ibm_to_float((int *) tr.data, 
						(int *) tr.data, ns);

				/* Write the trace to disk */
				puttr(&tr);

				/* Echo under verbose option */
				if (verbose && itr % 50 == 0)
					warn(" %d traces from tape", itr);
			}
a223 2
	} else {
		while (efread( (char *) &tr,1, nsegy, tapefp) && itr < trmax) {
d225 5
a229 7
			/* Check tr.ns field */
			if (!nsflag && ns != tr.ns) {
			warn("discrepant tr.ns = %d with tape/user ns = %d\n"
				"\t... first noted on trace %d", 
				tr.ns, ns, itr + 1);
			nsflag = true;
			}
d231 2
a232 5
			/* Convert and write desired traces */
			if (++itr >= trmin) {
				/* Convert IBM floats to native floats */
				ibm_to_float((int *) tr.data, 
						(int *) tr.data, ns);
d234 3
a236 7
				/* Write the trace to disk */
				puttr(&tr);

				/* Echo under verbose option */
				if (verbose && itr % 50 == 0)
					warn(" %d traces from tape", itr);
			}
d241 1
d248 2
a249 5
	if (buff) {
		eclose(fdtape);
	} else {
		efclose(tapefp);
	}
d262 64
@


1.11
log
@new selfdoc installed
@
text
@d1 1
a1 1
/* SEGYREAD: $Revision: 1.10 $ ; $Date: 92/06/15 13:04:31 $	*/
d21 40
a60 29
" 								",
" SEGYREAD - read an SEG-Y tape					",
" 								",
" segyread >stdout [tape=RMTDEVICE] 				",
" 								",
" Required parameters:						",
" 	none							",
" 								",
" Optional parameters:						",
" 	tape=RMTDEVICE	tape device to use, see suport.h	",
" 	verbose=0	silent operation			",
" 			= 1 ; echo every 20 traces		",
" 	hfile=header	file to store ebcdic block (as ascii)	",
" 	bfile=binary	file to store binary block		",
" 	over=0		quit if bhed format not equal 1		",
" 			= 1 ; override and attempt conversion  	",
" 	ns=bh.hns	number of samples (use if bhed ns wrong)",
" 	trmin=1		first trace to read			",
" 	trmax=LONG_MAX	last trace to read			",
" 								",
" Note: If you have a tape with multiple sequences of binary	",
"	header, ebcdic header, traces, use the RMTDEVICE that	",
"	invokes the no-rewind option and issue multiple segyread",
"	commands (making an appropriate shell script if you	",
"	want to save all the headers).  Consider using >> if	",
"	you want a single trace file in the end.  Similar	",
"	considerations apply for multiple reels of tapes,	",
"	but use the standard rewind on end of file.		",
" 								",
d67 1
a67 1
 *
d84 3
a86 18
	String tape;	/* name of raw tape device	*/
	String bfile;	/* name of binary header file	*/
	String hfile;	/* name of ascii header file	*/
	int tfd;	/* file descriptor for tape	*/
	int bfd;	/* file descriptor for bfile	*/
	int hfd;	/* file descriptor for hfile	*/
	FILE *fp;	/* file pointer for popen write	*/
	unsigned
	 int nsegy;	/* size of whole trace in bytes */
	int itr;	/* current trace number		*/
	int trmin;	/* first trace to read		*/
	int trmax;	/* last trace to read		*/
	int ns;		/* number of data samples	*/
	int over;	/* flag for bhed.float override	*/
	int verbose;	/* flag for echoing traces read */
	Bool nsflag;	/* flag for error in tr.ns	*/
	char cmdbuf[BUFSIZ];	/* dd command buffer	*/
	char ebcbuf[EBCBYTES];	/* ebcdic data buffer	*/
d88 1
d90 18
d137 1
d145 6
a150 1
	tfd = eopen(tape, O_RDONLY, 0444);
d153 2
a154 1
	hfd = eopen(hfile, O_WRONLY | O_CREAT | O_TRUNC, 0644);
d157 2
a158 1
	bfd = eopen(bfile, O_WRONLY | O_CREAT | O_TRUNC, 0644);
d162 5
a166 1
	eread(tfd, ebcbuf, EBCBYTES);
d171 1
a171 1
	fp = epopen(cmdbuf, "w");
d175 1
a175 1
	efwrite(ebcbuf, EBCBYTES, 1, fp);
d179 5
a183 1
	eread(tfd, (char *) &bh, BNYBYTES);
d197 1
a197 1
	ewrite(bfd, (char *) &bh, BNYBYTES);
d203 2
a204 1
	while (eread(tfd, (char *) &tr, nsegy) && itr < trmax) {
d206 2
a207 2
		/* Check tr.ns field */
		if (!nsflag && ns != tr.ns) {
d209 1
a209 1
				"\t... first noted on trace %d",
d212 15
d228 2
d231 7
a237 4
		/* Convert and write desired traces */
		if (++itr >= trmin) {
			/* Convert IBM floats to native floats */
			ibm_to_float((int *) tr.data, (int *) tr.data, ns);
d239 5
a243 2
			/* Write the trace to disk */
			puttr(&tr);
d245 7
a251 3
			/* Echo under verbose option */
			if (verbose && itr % 20 == 0)
				warn(" %d traces from tape", itr);
d262 14
a275 4
	eclose(tfd);
	eclose(bfd);
	eclose(hfd);
	epclose(fp);
@


1.10
log
@Now using new ibm_to_float and float_to_ibm routines.
@
text
@d1 1
a1 1
/* SEGYREAD: $Revision: 1.9 $ ; $Date: 92/06/12 13:41:08 $	*/
d20 31
a50 31
String sdoc =
" 								\n"
" SEGYREAD - read an SEG-Y tape					\n"
" 								\n"
" segyread >stdout [tape=RMTDEVICE] 				\n"
" 								\n"
" Required parameters:						\n"
" 	none							\n"
" 								\n"
" Optional parameters:						\n"
" 	tape=RMTDEVICE	tape device to use, see suport.h	\n"
" 	verbose=0	silent operation			\n"
" 			= 1 ; echo every 20 traces		\n"
" 	hfile=header	file to store ebcdic block (as ascii)	\n"
" 	bfile=binary	file to store binary block		\n"
" 	over=0		quit if bhed format not equal 1		\n"
" 			= 1 ; override and attempt conversion  	\n"
" 	ns=bh.hns	number of samples (use if bhed ns wrong)\n"
" 	trmin=1		first trace to read			\n"
" 	trmax=LONG_MAX	last trace to read			\n"
" 								\n"
" Note: If you have a tape with multiple sequences of binary	\n"
"	header, ebcdic header, traces, use the RMTDEVICE that	\n"
"	invokes the no-rewind option and issue multiple segyread\n"
"	commands (making an appropriate shell script if you	\n"
"	want to save all the headers).  Consider using >> if	\n"
"	you want a single trace file in the end.  Similar	\n"
"	considerations apply for multiple reels of tapes,	\n"
"	but use the standard rewind on end of file.		\n"
" 								\n"
;
d95 1
a95 1
	askdoc(0); /* stdin not used */
@


1.9
log
@Added option to let user override ns value in binary header.
@
text
@d1 1
a1 1
/* SEGYREAD: $Revision: 1.8 $ ; $Date: 91/09/05 08:49:13 $	*/
d58 1
a58 1
 *	The library subroutine, conv_float, that converts IBM floating
d60 1
a60 3
 *	altered for non-IEEE machines.  However, it has been written with
 *	an eye towards making that alteration rather painless once you
 *	know the byte order for the target machine.
d185 1
a185 1
			conv_float((char *) tr.data, (char *) tr.data, ns, 1);
@


1.8
log
@string -> String and so forth
@
text
@d1 1
a1 1
/* SEGYREAD: $Revision: 1.6 $ ; $Date: 90/11/30 11:53:30 $	*/
d35 1
a35 1
" 	over=0		quit if bhed.format not equal 1		\n"
d37 1
d162 2
a163 1
	if (!(ns = bh.hns)) err("samples/trace not set in binary header");
d178 1
a178 1
			warn("discrepant tr.ns = %d with bh.ns = %d\n"
d201 1
a201 1
		"\theader value (%d) was used to extract traces", ns);
@


1.7
log
@tweak self-doc
@
text
@d20 1
a20 1
string sdoc =
d24 1
a24 1
" segyread >stdout [optional parameters]			\n"
d74 3
a76 3
	string tape;	/* name of raw tape device	*/
	string bfile;	/* name of binary header file	*/
	string hfile;	/* name of ascii header file	*/
d81 2
a82 1
	uint nsegy;	/* size of whole trace in bytes */
d89 1
a89 1
	bool nsflag;	/* flag for error in tr.ns	*/
@


1.6
log
@Added multiple file remarks in self-doc.
@
text
@d1 1
a1 1
/* SEGYREAD: $Revision: 1.5 $ ; $Date: 90/11/26 16:36:25 $	*/
d24 1
a24 1
" segyread >stdout [tape=RMTDEVICE] 				\n"
@


1.5
log
@Using popen instead of tmpnam
@
text
@d1 1
a1 1
/* SEGYREAD: $Revision: 1.4 $ ; $Date: 90/11/25 18:43:28 $	*/
d39 9
@


1.4
log
@tweaks
@
text
@d1 1
a1 1
/* SEGYREAD: $Revision: 1.3 $ ; $Date: 90/10/23 12:31:13 $	*/
d71 1
a71 2
	FILE *efp;	/* file ptr for ebcdic tmp file	*/
	int efd;	/* ... its file id		*/
a81 1
	char efile[L_tmpnam];	/* tmp file for ebcdic	*/
a121 5
	/* - the temporary file for ebcdic header */
	tmpnam(efile);
	efp = fopen(efile, "w+");
	efd = fileno(efp);

d133 3
a135 2
	/* Write the ebcdic bytes from the buffer to the tmp file */
	ewrite(efd, ebcbuf, EBCBYTES);
d138 2
a139 5
	/* Use dd to convert ebcdic to ascii version of header file */
	sprintf(cmdbuf,
		"dd if=%s ibs=3200 of=%s conv=ascii cbs=80 count=1\n",
							efile, hfile);
	system(cmdbuf);
d141 1
d196 1
a196 2
	eclose(efd);
	eunlink(efile);
@


1.3
log
@Tweak
D
@
text
@d1 1
a1 1
/* SEGYREAD: $Revision: 1.2 $ ; $Date: 90/09/03 09:42:33 $	*/
d20 21
a40 21
string sdoc = "\
								\n\
SEGYREAD - read an SEG-Y tape					\n\
								\n\
segyread >stdout [tape=RMTDEVICE] 				\n\
								\n\
Required parameters:						\n\
	none							\n\
								\n\
Optional parameters:						\n\
	tape=RMTDEVICE	tape device to use, see suport.h	\n\
	verbose=0	silent operation			\n\
			= 1 ; echo every 20 traces		\n\
	hfile=header	file to store ebcdic block (as ascii)	\n\
	bfile=binary	file to store binary block		\n\
	over=0		quit if bhed.format not equal 1		\n\
			= 1 ; override and attempt conversion  	\n\
	trmin=1		first trace to read			\n\
	trmax=LONG_MAX	last trace to read			\n\
								\n\
";
d49 2
a50 2
 *	point to Masscomp floating point is NOT portable and must be
 *	altered for other machines.  However, it has been written with
a83 2
	char *tmpnam();		/* system subroutine	*/
	void conv_float();	/* convert floats	*/
d106 3
a108 3
	if (!sgetpar("tape",  &tape))	tape = RMTDEVICE;
	if (!sgetpar("hfile", &hfile))	hfile = "header";
	if (!sgetpar("bfile", &bfile))	bfile = "binary";
d112 3
a114 3
	if (!igetpar("trmin", &trmin))		trmin = 1;
	if (!igetpar("trmax", &trmax))		trmax = LONG_MAX;
	if (!igetpar("verbose", &verbose)) 	verbose = 0;
d118 1
a118 1
	if (!igetpar("over", &over))		over   = 0;
d151 4
a154 8
	eread(tfd, &bh, BNYBYTES);
	if (bh.format != 1) {
		if (!over) {
		       err("format not IBM floating point");
		} else {
			warn("ignore bh.format ... continue");
		}
	}
d164 1
a164 1
	ewrite(bfd, &bh, BNYBYTES);
d170 1
a170 1
	while (eread(tfd, &tr, nsegy) && itr < trmax) {
d174 3
a176 3
			warn("discrepant tr.ns = %d with bh.ns = %d, \n\t%s %d",
				tr.ns, ns,
				"... first noted on trace", itr + 1);
d183 1
a183 1
			conv_float(tr.data, tr.data, ns, 1);
d189 1
a189 1
			if (verbose && itr % 20 == 0) {
a190 1
			}
d196 2
a197 3
	if (nsflag) warn("%s %d %s",
		"discrepancy found in header and trace ns values\n\t", ns,
		"= header value was used to extract traces");
@


1.2
log
@ANSI C and syscalls changes--not checked!!
@
text
@d1 1
a1 1
/* SEGYHDRS: $Revision: 1.1 $ ; $Date: 90/04/15 15:33:37 $	*/
@


1.1
log
@Initial revision
@
text
@d1 1
a2 1

d4 1
a4 1
 * Copyright (c) Colorado School of Mines, 1989.
d12 1
a12 1
 *  Golden, CO 80401  (isis!csm9a!jkcohen)
d30 2
a31 4
	tape 		the raw tape device to use, the default	\n\
			is the string RMTDEVICE defined in	\n\
			/portdefs.h			\n\
	verbose = 0	silent operation			\n\
d33 3
a35 3
	hfile = header	file to store ebcdic block (as ascii)	\n\
	bfile = binary	file to store binary block		\n\
	over = 0	quit if bhed.format not equal 1		\n\
d37 1
a37 1
	trmin = 1	first trace to read			\n\
a56 1
 *
a58 5
/* Embed Revision Control System identifier strings */
static string progid =
	"   $Source: /src/su/src/RCS/segyread.c,v $";
static string revid =
	"   $Revision: 2.9 $ ; $Date: 89/11/04 14:33:02 $";
a59 2


d63 1
a63 2
main(argc, argv)
int argc; char **argv;
d88 1
a88 1
	/* Initialize SU */
a89 5
	if (!igetpar("ID", &ID))	ID = 0;
	if (ID) {
		(void) fprintf(stderr, "%s\n", progid);
		(void) fprintf(stderr, "%s\n", revid);
	}
d94 1
a94 1
	switch(statfil(STDOUT)) {
d124 1
a124 3
	if (-1 == (tfd = open(tape, O_RDONLY))) {
		syserr("can't open %s", tape);
	}
d128 1
a128 3
	if (NULL == (efp = fopen(efile, "w+"))) {
		syserr("fopen failed on ebcdic tmp file");
	}
d132 1
a132 5
	if (-1 == (hfd =
		open(hfile, O_WRONLY | O_CREAT | O_TRUNC, 0644))) {
		syserr("can't open ascii header file, %s, for output",
								hfile);
	}
d135 1
a135 5
	if (-1 == (bfd =
		open(bfile, O_WRONLY | O_CREAT | O_TRUNC, 0644))) {
		syserr("can't open binary header file, %s, for output",
								bfile);
	}
d139 1
a139 1
	read(tfd, (char *) ebcbuf, EBCBYTES);
d143 1
a143 1
	write(efd, (char *) ebcbuf, EBCBYTES);
d153 1
a153 1
	read(tfd, (char *) &bh, BNYBYTES);
d170 1
a170 1
	write(bfd, (char *) &bh, BNYBYTES);
d176 1
a176 1
	while (read(tfd, (char *) &tr, nsegy) && itr < trmax) {
d189 1
a189 1
			conv_float((char *) tr.data, (char *) tr.data, ns, 1);
d209 5
a213 15
	if (-1 == close(tfd)) {
		syserr("close failed on tape");
	}
	if (-1 == close(bfd)) {
		syserr("close failed on binary header file");
	}
	if (-1 == close(hfd)) {
		syserr("close failed on ascii header file");
	}
	if (-1 == close(efd)) {
		syserr("close failed on ebcdic tmp file");
	}
	if (-1 == unlink(efile)) {
		syserr("unlink of ebcdic tmp file failed");
	}
d215 1
a215 2

	return SUCCEED;
@
