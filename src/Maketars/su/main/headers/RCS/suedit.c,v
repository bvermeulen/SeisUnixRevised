head	1.38;
access;
symbols;
locks; strict;
comment	@ * @;


1.38
date	2011.11.12.00.13.49;	author john;	state Exp;
branches;
next	1.37;

1.37
date	2008.05.05.20.40.10;	author john;	state Exp;
branches;
next	1.36;

1.36
date	2006.10.31.22.22.04;	author john;	state Exp;
branches;
next	1.35;

1.35
date	2006.03.28.19.09.11;	author john;	state Exp;
branches;
next	1.34;

1.34
date	2005.10.04.16.42.43;	author john;	state Exp;
branches;
next	1.33;

1.33
date	2003.08.20.18.32.49;	author john;	state Exp;
branches;
next	1.32;

1.32
date	2003.06.09.16.17.07;	author john;	state Exp;
branches;
next	1.31;

1.31
date	99.04.05.17.09.07;	author john;	state Exp;
branches;
next	1.30;

1.30
date	98.11.11.19.28.07;	author john;	state Exp;
branches;
next	1.29;

1.29
date	97.07.28.22.36.46;	author john;	state Exp;
branches;
next	1.28;

1.28
date	96.09.10.23.02.30;	author jkc;	state Exp;
branches;
next	1.27;

1.27
date	96.01.25.19.25.10;	author jkc;	state Exp;
branches;
next	1.26;

1.26
date	95.10.31.15.54.59;	author jkc;	state Exp;
branches;
next	1.25;

1.25
date	94.08.25.14.59.10;	author jkc;	state Exp;
branches;
next	1.24;

1.24
date	94.03.31.08.57.46;	author john;	state Exp;
branches;
next	1.23;

1.23
date	93.11.29.14.19.56;	author john;	state Exp;
branches;
next	1.22;

1.22
date	93.11.12.13.31.18;	author john;	state Exp;
branches;
next	1.21;

1.21
date	93.08.13.10.27.47;	author john;	state Exp;
branches;
next	1.20;

1.20
date	93.08.09.15.19.27;	author john;	state Exp;
branches;
next	1.19;

1.19
date	92.10.23.15.11.20;	author john;	state Exp;
branches;
next	1.18;

1.18
date	92.04.03.16.10.37;	author jkc;	state Exp;
branches;
next	1.17;

1.17
date	92.04.01.13.39.15;	author jkc;	state Exp;
branches;
next	1.16;

1.16
date	92.04.01.13.25.17;	author jkc;	state Exp;
branches;
next	1.15;

1.15
date	92.02.17.10.30.17;	author jkc;	state Exp;
branches;
next	1.14;

1.14
date	91.09.05.09.07.17;	author jkcohen;	state Exp;
branches;
next	1.13;

1.13
date	91.09.05.08.50.13;	author jkcohen;	state Exp;
branches;
next	1.12;

1.12
date	91.01.18.15.15.26;	author jkc;	state Exp;
branches;
next	1.11;

1.11
date	91.01.11.18.49.52;	author jkc;	state Exp;
branches;
next	1.10;

1.10
date	90.12.23.20.02.43;	author jkc;	state Exp;
branches;
next	1.9;

1.9
date	90.12.23.16.26.09;	author jkc;	state Exp;
branches;
next	1.8;

1.8
date	90.12.18.20.12.06;	author jkc;	state Exp;
branches;
next	1.7;

1.7
date	90.12.18.16.33.43;	author jkc;	state Exp;
branches;
next	1.6;

1.6
date	90.12.18.16.05.26;	author jkc;	state Exp;
branches;
next	1.5;

1.5
date	90.11.12.18.44.27;	author jkc;	state Exp;
branches;
next	1.4;

1.4
date	90.10.25.09.58.17;	author jkc;	state Exp;
branches;
next	1.3;

1.3
date	90.05.29.17.41.32;	author jkc;	state Exp;
branches;
next	1.2;

1.2
date	90.05.29.17.40.36;	author jkc;	state Exp;
branches;
next	1.1;

1.1
date	90.04.17.12.23.07;	author jkc;	state Exp;
branches;
next	;


desc
@Examine headers and data
@


1.38
log
@copyright
@
text
@/* Copyright (c) Colorado School of Mines, 2011.*/
/* All rights reserved.                       */

/* SUEDIT: $Revision: 1.37 $; $Date: 2008/05/05 20:40:10 $    */

#include "su.h"
#include "segy.h"
#include "header.h"

#include <errno.h>


/*********************** self documentation ******************************/
char *sdoc[] = {
" 									",
" SUEDIT - examine segy diskfiles and edit headers			",
" 									",
" suedit diskfile  (open for possible header modification if writable)	",
" suedit <diskfile  (open read only)					",
" 							        	",
" The following commands are recognized:				",
" number	read in that trace and print nonzero header words	",
" <CR>		go to trace one step away (step is initially -1)	",
" +		read in next trace (step is set to +1)			",
" -		read in previous trace (step is set to -1)		",
" dN		advance N traces (step is set to N)			",
" %		print some percentiles of the trace data		",
" r		print some ranks (rank[j] = jth smallest datum) 	",
" p [n1 [n2]]  	tab plot sample n1 to n2 on current trace		",
" g [tr1 tr2]  	ximage plot the trace [traces tr1 to tr2]	",
" w [tr1 tr2]  	xwigb plot the trace [traces tr1 to tr2]	",
" f [tr1 tr2]   ximage plot the amplitude spectra of the trace		",
" u [tr1 tr2]   apply user pipeline to specified traces ",
" ! key=val  	change a value in a field (e.g. ! tracr=101)		",
" ?		print help file						",
" q		quit							",
" 									",
" NOTE: sample numbers are 1-based (first sample is 1).			",
"                                                                       ",
" 'u 1000000  1000100 suwind >subset.su' will quickly extract a few     ",
" traces from the middle of a large dataset                             ",
" 									",
NULL};

/* Credits:
 * SEP: Einar Kjartansson, Shuki Ronen, Stew Levin
 * CWP: Jack K. Cohen
 * Unocal: Reg Beardsley
 * Trace header fields accessed: ns
 * Trace header fields modified: ntr (only for internal plotting)
 */
/**************** end self doc ***********************************/


segy tr;		/* a segy trace structure		*/
FILE *tty;		/* /dev/tty is used to read user input	*/
char userin[BUFSIZ];	/* buffer user requests			*/
int nt;			/* number of sample points on traces	*/
FILE *infp;		/* file pointer for trace file		*/
char tmpwig[L_tmpnam];	/* file for trace plots			*/

char *help[] = {
"					",
" n		read in trace #n	",
" <CR>		step			",
" +		next trace;   step -> +1",
" -		prev trace;   step -> -1",
" dN		adv N traces; step -> N	",
" %		percentiles		",
" r		ranks			",
" p [n1 [n2]]  	tabplot			",
" w [tr1 tr2]  	wiggle plot		",
" g [tr1 tr2]  	greyscale plot		",
" f [tr1 tr2]   amplitude spectra plot  ",
" u [tr1 tr2]   user specified pipeline ",
" ! key=val  	modify field		",
" ?		print this file		",
" q		quit			",
"					",
NULL};

char **helpptr = help ;         /* help pointer */

#define SCREENFUL	19	/* default number of points in tab plot */

/* subroutine prototypes */
void editkey(void);
void wigplot(void);
void ftwigplot(void);
int cmp_indirect();
void userwait(void);
void edxplot(int mode);
char* uptr;

int
main(int argc, char **argv)
{
	int step = -1;		/* step +1/-1 for traversing data	*/
	int itr;		/* trace number (zero based)		*/
	int ntr;		/* number of traces in data set		*/
	int *rank;		/* permuted indices for indirect sort	*/
	int i;			/* counter				*/
	int iq;			/* index of qth quantile (100qth %tile)	*/
        cwp_Bool write_ok=cwp_false;    /* is file writable?            */


	/* Initialize */
	initargs(argc, argv);
	requestdoc(1);


	if (argc > 2)  err("only one filename argument is allowed");

	tty = efopen("/dev/tty", "r");

	/* Open file and print editing warnings if appropriate */
	if (!isatty(STDIN)) {	/* stdin was redirected to file */
		infp = stdin;
		write_ok = cwp_false;
		warn("! examine only (no header editing from STDIN)\n");

	} else {  	/* file is given by argument */

		/* First try for read and write */
		if (0 == (access(argv[1], READ_OK | WRITE_OK))) {
			infp = fopen(argv[1], "r+");
			write_ok = cwp_true;

		/* Then for just read */
		} else if (0 == (access(argv[1], READ_OK))) {
			infp = fopen(argv[1], "r");
			write_ok = cwp_false;
			warn("! %s is readonly (no header editing)\n",
								argv[1]);
		/* Admit defeat */
		} else {
			err("can't open %s for reading", argv[1]);
		}
	}

	/* allow large file access */
	fseeko(infp,0,1);

	/* Get information from first trace */
	ntr = fgettra(infp, &tr, 0);
	nt = tr.ns;

	/* Set up array for indirect sort requested by 'r' and '%' keys */
	rank = ealloc1int(nt);
	for (i = 0; i < nt; ++i)  rank[i] = i;

	printf("%d traces in input file\n", ntr);

	/* Start from last trace */
	itr = ntr - 1;

	fgettra(infp, &tr, itr);
	printheader(&tr);
	printf("> ");
	efflush(stdout);

	/* Get user directives and do requested tasks */
	while (NULL != fgets(userin, BUFSIZ, tty)) {

                /* strip leading whitespace */
                uptr = &(userin[strspn( userin ," \t" )]);

		switch(*uptr) {
		case '0': /* check if digit */
		case '1': case '2': case '3': case '4':
		case '5': case '6': case '7': case '8':
		case '9': /* end check if digit */
			itr = eatoi(uptr) - 1;
			fgettra(infp, &tr, itr);
			printheader(&tr);
		break;
		case 'q':
        		return(CWP_Exit());
		case 'p':
			{ static int p1, p2;
			  /* Get user inputs (avoid running off end of data) */
			  switch(sscanf(uptr + 1, "%d %d", &p1, &p2)) {
			  case 2:	/* user specified final position */
				if (p2 < p1) {
					warn("need p1=%d < p2=%d", p1, p2);
        				return(CWP_Exit());
				}
				p2 = MIN(p2, nt);
			  break;
			  default:
				p2 = MIN(p1 + SCREENFUL, nt);
			  break;
			  }
			  if (p1 >= nt || p1 <= 0) p1 = 1;
			  tabplot(&tr, p1-1, p2-1); /* 1-base -> 0-base */
			  p1 = p2;
			}
		break;
		case 'g':
			edxplot(0);
		break;
		case 'w':
			edxplot(1);
		break;
		case 'f':
			edxplot(2);
		break;
		case 'u':
			edxplot(3);
		break;
		case '+':
			++itr;
			if (itr > ntr - 1) {
				step = -1;
				itr = ntr - 2;
				printf("\nBounced off end of data:\n\n");
			}
			fgettra(infp, &tr, itr);
			printheader(&tr);
			step = 1;
		break;
		case '-':
			itr--;
			if (itr < 0) {
				step = 1;
				itr = 2;
				printf("\nBounced off end of data:\n\n");
			}
			fgettra(infp, &tr, itr);
			printheader(&tr);
			step = -1;
		break;
		case '\n':
			itr += step;
			if (itr < 0 || itr > ntr - 1) {
				step *= -1;
				itr += 2*step;
				printf("\nBounced off end of data:\n\n");
			}
			fgettra(infp, &tr, itr);
			printheader(&tr);
		break;
		case 'r':
			/* sort: rank[] holds rank of datum in tr */
			qsort(rank, nt, FSIZE, cmp_indirect);

			/* Could make table of desired i's and loop */
			i = 0;
			printf(" rank[%d] = %8.2e", i+1, tr.data[rank[i]]);
			i = nt / 20;
			printf(" rank[%d] = %8.2e", i+1, tr.data[rank[i]]);
			i = nt/2 - i;
			printf(" rank[%d] = %8.2e", i+1, tr.data[rank[i]]);
			printf("\n");
			i = nt - 1 - i;
			printf(" rank[%d] = %8.2e", i+1, tr.data[rank[i]]);
			i = nt - 1 - nt/20;
			printf(" rank[%d] = %8.2e", i+1, tr.data[rank[i]]);
			i = nt - 1;
			printf(" rank[%d] = %8.2e", i+1, tr.data[rank[i]]);
			printf("\nmin is at sample %d,  max at %d\n",
					rank[0] + 1, rank[nt-1] + 1);
		break;
		case '%':
			/* sort: rank[] holds rank of datum in tr */
			qsort(rank, nt, FSIZE, cmp_indirect);

			/* round to qth quantile (100 qth percentile) */
			/* thus (q*nt - 1) + .5 (-1 for zero basing) */
			i = 1; iq = (int) (0.01*nt - 0.5);
			printf(" %dst percentile is %8.2e\n",
					i+1, tr.data[rank[iq]]);
			i = 5; iq = (int) (0.05*nt - 0.5);
			printf(" %dth percentile is %8.2e\n",
					i+1, tr.data[rank[iq]]);
			i = 25; iq = (int) (0.25*nt - 0.5);
			printf("%dth percentile is %8.2e\n",
					i+1, tr.data[rank[iq]]);
			i = 50; iq = (int) (0.50*nt - 0.5);
			printf("%dth percentile is %8.2e\n",
					i+1, tr.data[rank[iq]]);
			i = 75; iq = (int) (0.75*nt - 0.5);
			printf("%dth percentile is %8.2e\n",
					i+1, tr.data[rank[iq]]);
			i = 95; iq = (int) (0.95*nt - 0.5);
			printf("%dth percentile is %8.2e\n",
					i+1, tr.data[rank[iq]]);
			i = 99; iq = (int) (0.99*nt - 0.5);
			printf("%dth percentile is %8.2e\n",
					i+1, tr.data[rank[iq]]);
			printf("min at sample %d equals %8.2e\n",
					rank[0] + 1, tr.data[rank[0]]);
			printf("max at sample %d equals %8.2e\n",
					rank[nt-1] + 1, tr.data[rank[nt-1]]);
		break;
		case 'd':
			step = eatoi(uptr + 1);
			itr += step;
			if (itr < 0 || itr > ntr - 1) {
				step *= -1;
				itr += 2*step;
				printf("\nBounced off end of data:\n\n");
			}
			fgettra(infp, &tr, itr);
			printheader(&tr);
		break;
		case '!':
			if (write_ok) {
				editkey();
			} else {
				warn("file not writable");
			}
		break;
		case '?':
                        while(*helpptr) fprintf(stderr,"%s\n", *helpptr++);
                        helpptr = help;

		break;
		default:
			warn("bad key %s\n%s", uptr, help);
                        while(*helpptr) fprintf(stderr,"%s\n", *helpptr++);
                        helpptr = help;

		break;
		}
		printf("> ");
		efflush(stdout);
	}
        return(CWP_Exit());

}



/* Modify a header field value */
void editkey(void)
{
	cwp_String keyword;	/* buffer and then header key word	*/
	cwp_String keyval;	/* header key value in ascii		*/
	cwp_String ptr;	/* pointer to isolate key word		*/
	cwp_String type;	/* type of key word			*/
	int nsegy;	/* length of trace in bytes		*/
	Value val;	/* numerical value of key word		*/

	/* char userin[] is "!    keyword  = keyval" */

	/* Strip the '!' and any leading spaces from buffer */
	for (keyword = userin + 1; isspace((int)(*keyword)); keyword++);

	/* Set keyval to start of val */
 	if (NULL == (keyval = strchr(keyword, '=') + 1)) {
		printf("command error: format is \"! key=val\"\n");
		return;
	}

	/* Null terminate keyword (back up over = and any spaces) */
	for (ptr = keyval - 2; isspace((int)(*ptr)); ptr--);
	(*(ptr + 1)) = '\0';

	/* Convert ascii keyval string to numeric val value */
	type = hdtype(keyword);
	errno = 0;
	atoval(type, keyval, &val);
	if (errno) {
	    fprintf( stderr ,"failed to convert %s to numeric, field not changed",
								keyval);
	}

	/* Insert value into header */
	puthdval(&tr, keyword, &val);

	/* Write back the trace with the new value */
	nsegy = nt * FSIZE + HDRBYTES;
	fseeko(infp, -nsegy, SEEK_CUR);
	fwrite(&tr, 1, HDRBYTES, infp);

	/* Restore file pointer */
	fseeko(infp, nsegy, SEEK_CUR);

	/* Show the user the new header value */
	printheader(&tr);

	return;
}


/* Wiggle plot of selected adjacent traces */
void edxplot(int mode)
{
	int n1;			/* first trace to be plotted		*/
	int n2;			/* last trace to be plotted		*/
	int i;			/* counter				*/
	char cmd[8192];	        /* build command for system call	*/
	char user[8192];        /* user input buffer                    */
	FILE *tmpfp;		/* fp for suwig input file		*/


	/* Prepare temporary file to hold traces to be plotted */
	tmpfp = efopen(tmpnam(tmpwig), "w+");


	/* Parse request and subtract 1 for internal trace numbers */
	switch(sscanf(uptr + 1, "%d %d %[^\n]", &n1, &n2 ,user)) {
	case 1: /* user specified remote trace to plot */
		--n1;
		fgettra(infp, &tr, n1);
		fputtr(tmpfp, &tr);
	break;
	case 2: /* user specified block of traces to plot */
        case 3:
		if (n2 < n1) {
			warn("must specify n1=%d < n2=%d", n1, n2);
			return;
		}
		for (i = n1 - 1; i <= n2 - 1; ++i) {
			fgettra(infp, &tr, i);
			fputtr(tmpfp, &tr);
		}
	break;
	default: /* no numbers given by user: plot current trace */
		fputtr(tmpfp, &tr);
	break;
	}

	/* Set up system call */
	efclose(tmpfp);

        switch( mode ){

           case 0:
	      sprintf(cmd, "(suximage perc=99 <%s ;sleep 10;rm %s)&", tmpwig ,tmpwig);
              break;
           case 1:
	      sprintf(cmd, "(suxwigb <%s perc=99;sleep 10;rm %s)  &", tmpwig ,tmpwig);
              break;
           case 2:
	      sprintf(cmd, "(suspecfx <%s | suximage legend=1 cmap=hue perc=99;sleep 10;rm %s )&", tmpwig ,tmpwig);
              break;
           case 3:
              sprintf(cmd ,"(<%s %s ;sleep 10;rm %s)&" ,tmpwig ,user,tmpwig );
              break;
        }


	system(cmd);

	printheader(&tr);

	return;
}



/* Comparison function for qsort */
int cmp_indirect(int *r, int *s)
{
	float diff = tr.data[*r] - tr.data[*s];

	if      (diff > 0)	return(1);
	else if (diff < 0)	return(-1);
	else  /* diff == 0 */	return(0);
}


/* userwait - prompt and wait for user signal to continue */
void userwait(void)
{
	/* Note: leading newline helps some devices switch to ascii */
	fprintf(stderr, "\npress return key to continue\n");
	getc(tty);

	return;
}
@


1.37
log
@explicit cast put on keyword
@
text
@d1 4
a4 1
/* SUEDIT: $Revision: 1.36 $; $Date: 2006/10/31 22:22:04 $    */
@


1.36
log
@Reg Beardsley's changes
@
text
@d1 1
a1 1
/* SUEDIT: $Revision: 1.4 $; $Date: 2006/03/28 16:49:35 $    */
d11 1
a11 1
char* sdoc[] = {
d345 1
a345 1
	for (keyword = userin + 1; isspace(*keyword); keyword++);
d354 1
a354 1
	for (ptr = keyval - 2; isspace(*ptr); ptr--);
d404 1
a404 1
		fputtr(tmpfp, &tr); 
d414 1
a414 1
			fputtr(tmpfp, &tr); 
d418 1
a418 1
		fputtr(tmpfp, &tr); 
d436 1
a436 1
           case 3: 
d441 1
a441 1
        
@


1.35
log
@a reg beardelHHhhley update
@
text
@d1 1
a1 1
/* SUEDIT: $Revision: 1.34 $; $Date: 2005/10/04 16:42:43 $    */
d36 3
d90 1
d103 1
d161 5
a165 1
		switch(*userin) {
d170 1
a170 1
			itr = eatoi(userin) - 1;
d179 1
a179 1
			  switch(sscanf(userin + 1, "%d %d", &p1, &p2)) {
d294 1
a294 1
			step = eatoi(userin + 1);
d317 1
a317 1
			warn("bad key %s\n%s", userin, help);
d400 1
a400 1
	switch(sscanf(userin + 1, "%d %d %[^\n]", &n1, &n2 ,user)) {
d423 1
a423 1
	rewind(tmpfp);
d428 1
a428 1
	      sprintf(cmd, "(suximage perc=99 <%s ;rm %s)&", tmpwig ,tmpwig);
d431 1
a431 1
	      sprintf(cmd, "(suxwigb <%s perc=99;rm %s)  &", tmpwig ,tmpwig);
d434 1
a434 1
	      sprintf(cmd, "(suspecfx <%s | suximage legend=1 cmap=hue perc=99;rm %s )&", tmpwig ,tmpwig);
d437 1
a437 1
              sprintf(cmd ,"(<%s %s ;rm %s)&" ,tmpwig ,user,tmpwig );
a443 4
	/* Clean up temp file */
	efclose(tmpfp);
	eremove(tmpwig);

@


1.34
log
@4 Oct 2005
@
text
@d1 1
a1 1
/* SUEDIT: $Revision: 1.2 $; $Date: 2005/06/14 19:09:43 $	*/
d30 1
d69 1
d196 3
d381 2
a382 1
	char cmd[BUFSIZ];	/* build command for system call	*/
d391 1
a391 1
	switch(sscanf(userin + 1, "%d %d", &n1, &n2)) {
d398 1
d413 1
a413 1
	/* Set up system call to suwig */
d419 1
a419 1
	      sprintf(cmd, "suximage perc=99 <%s &", tmpwig);
d422 1
a422 1
	      sprintf(cmd, "suxwigb <%s perc=99 & ", tmpwig);
d425 4
a428 1
	      sprintf(cmd, "sufft <%s | suamp | suximage legend=1  perc=99 & ", tmpwig);
@


1.33
log
@large file support
@
text
@d1 1
a1 1
/* SUEDIT: $Revision: 36.2 $; $Date: 2003/08/04 16:27:09 $	*/
d6 1
d8 1
a8 1
extern int errno;
d11 1
a11 1
char *sdoc[] = {
d27 3
d39 3
a41 3
 *	SEP: Einar Kjartansson, Shuki Ronen, Stew Levin
 *	CWP: Jack K. Cohen
 *
d43 1
d53 1
a54 1
/* tabulate the help message as an array of strings */
d65 3
d74 1
a74 2
/* define a pointer to the help message array */
char **helpptr=help ;
d80 3
a82 1
int cmp_indirect(const void *, const void *);
d84 1
d90 2
a91 2
	off_t itr;		/* trace number (zero based)		*/
	off_t ntr;		/* number of traces in data set		*/
d95 1
a95 2
	cwp_Bool write_ok=cwp_false;/* is file writable?		*/

d108 2
a109 1
		infp = stdin;/* note that write_ok was initialized as false */
d116 1
a116 1
			infp = efopen(argv[1], "r+");
d121 1
a121 1
			infp = efopen(argv[1], "r");
d131 3
d142 1
a142 1
	printf("%ld traces in input file\n", (long) ntr);
d146 1
a159 4
			if (itr < 0 || itr > ntr - 1) {
			 	warn("no such trace");
				itr = ntr - 1;
			}
d164 1
a164 1
			return(CWP_Exit());
d172 1
a172 1
					return EXIT_FAILURE;
d185 9
d198 1
a198 1
			    	itr = ntr - 1;
d209 1
a209 1
				itr = 0;
d218 1
a218 6
			if (itr > ntr - 1) {
				step *= -1;
			    	itr = ntr - 1;
				printf("\nBounced off end of data:\n\n");
			}
			if (itr < 0) {
d220 1
a220 17
				itr = 0;
				printf("\nBounced off end of data:\n\n");
			}
			fgettra(infp, &tr, itr);
			printheader(&tr);
		break;
		case 'd':
			step = eatoi(userin + 1);
			itr += step;
			if (itr > ntr - 1) {
				step *= -1;
			    	itr = ntr - 1;
				printf("\nBounced off end of data:\n\n");
			}
			if (itr < 0) {
				step *= -1;
				itr = 0;
d279 11
d298 3
a300 2
			while (*helpptr) fprintf(stderr,"%s\n", *helpptr++);
			helpptr = help;
d303 3
a305 4
			warn("bad key %s\n", userin);
				while(*helpptr)
					fprintf(stderr,"%s\n", *helpptr++);
			helpptr = help;
d312 1
a313 1
	return(CWP_Exit());
d323 1
a323 1
	cwp_String ptr;		/* pointer to isolate key word		*/
d325 2
a326 3
	long nsegy;		/* length of trace in bytes		*/
	int databytes;		/* length of data in bytes		*/
	Value val;		/* numerical value of key word		*/
d348 2
a349 1
	    warn("failed to convert %s to numeric, field not changed", keyval);
d356 3
a358 4
	databytes = nt * FSIZE;
	nsegy = (long) (databytes + HDRBYTES);
	efseeko(infp, (off_t) (-nsegy), SEEK_CUR);
	efwrite(&tr, 1, HDRBYTES, infp);
d361 1
a361 1
	efseeko(infp, (off_t) databytes, SEEK_CUR);
d370 66
d437 1
a437 1
int cmp_indirect(const void *r, const void *s)
d439 1
a439 5
        const int *ir;
	const int *is;
	float diff;
	ir = (const int *) r; is = (const int *) s;
	diff = tr.data[*ir] - tr.data[*is];
@


1.32
log
@9 June 2003
@
text
@d1 1
a1 1
/* SUEDIT: $Revision: 1.31 $; $Date: 1999/04/05 17:09:07 $	*/
d80 2
a81 2
	int itr;		/* trace number (zero based)		*/
	int ntr;		/* number of traces in data set		*/
d129 1
a129 1
	printf("%d traces in input file\n", ntr);
@


1.31
log
@cosmetic
@
text
@d1 1
a1 1
/* SUEDIT: $Revision: 1.30 $; $Date: 1998/11/11 19:28:07 $	*/
d154 1
a154 1
			return EXIT_SUCCESS;
d304 1
a304 1
	return EXIT_SUCCESS;
d349 1
a349 1
	efseek(infp, -nsegy, SEEK_CUR);
d353 1
a353 1
	efseek(infp, databytes, SEEK_CUR);
@


1.30
log
@fixed error that caused HEADERBYTES worth of data to be destroyed
for each additional trace header field edited.
@
text
@d1 1
a1 1
/* SUEDIT: $Revision: 1.29 $; $Date: 1997/07/28 22:36:46 $	*/
d35 2
a36 2
 *	SEP: Einar, Shuki, Stew
 *	CWP: Jack
@


1.29
log
@changes suggested by Stew Levin to silence SGI compiler warnings, etc
@
text
@d1 1
a1 1
/* SUEDIT: $Revision: 1.28 $; $Date: 1996/09/10 23:02:30 $	*/
d317 1
d347 2
a348 1
	nsegy = (long) (nt * FSIZE + HDRBYTES);
d353 1
a353 1
	efseek(infp, nsegy, SEEK_CUR);
@


1.28
log
@-Wall stuff including using initialization for boolean write_ok
@
text
@d1 1
a1 1
/* SUEDIT: $Revision: 1.27 $; $Date: 1996/01/25 19:25:10 $	*/
d73 1
a73 1
int cmp_indirect();
d85 1
a85 1
	cwp_Bool write_ok=false;/* is file writable?			*/
d107 1
a107 1
			write_ok = true;
d112 1
a112 1
			write_ok = false;
d316 1
a316 1
	int nsegy;		/* length of trace in bytes		*/
d346 1
a346 1
	nsegy = nt * FSIZE + HDRBYTES;
d361 1
a361 1
int cmp_indirect(int *r, int *s)
d363 5
a367 1
	float diff = tr.data[*r] - tr.data[*s];
@


1.27
log
@Deal with specifying header fields accessed/modified in sudoc.
@
text
@d1 1
a1 1
/* SUEDIT: $Revision: 1.26 $; $Date: 1995/10/31 15:54:59 $	*/
d76 1
d85 1
a85 1
	cwp_Bool write_ok;	/* is file writable?			*/
d99 1
a99 2
		infp = stdin;
		write_ok = false;
@


1.26
log
@Cosmetics.
@
text
@d1 1
a1 1
/* SUEDIT: $Revision: 1.25 $; $Date: 1994/08/25 14:59:10 $	*/
d38 1
@


1.25
log
@Removed copyright statement from codes that had it.
Moved self-doc line for sudoc.
@
text
@d1 1
a1 1
/* SUEDIT: $Revision: 1.24 $; $Date: 94/03/31 08:57:46 $	*/
d83 1
a83 1
	cwp_Bool write_ok;		/* is file writable?			*/
d313 1
a313 1
	cwp_String ptr;	/* pointer to isolate key word		*/
d315 2
a316 2
	int nsegy;	/* length of trace in bytes		*/
	Value val;	/* numerical value of key word		*/
@


1.24
log
@changed    return   to   return EXIT_FAILURE
@
text
@d1 1
a1 1
/* SUEDIT: $Revision: 1.23 $; $Date: 93/11/29 14:19:56 $	*/
a2 13
/*----------------------------------------------------------------------
 * Copyright (c) Colorado School of Mines, 1990.
 * All rights reserved.
 *
 * This code is part of SU.  SU stands for Seismic Unix, a processing line
 * developed at the Colorado School of Mines, partially based on Stanford
 * Exploration Project (SEP) software.  Inquiries should be addressed to:
 *
 *  Jack K. Cohen, Center for Wave Phenomena, Colorado School of Mines,
 *  Golden, CO 80401  (jkc@@dix.mines.colorado.edu)
 *----------------------------------------------------------------------
 */

a33 2
/**************** end self doc ***********************************/

d39 1
@


1.23
log
@changed helpp helpptr
@
text
@d1 1
a1 1
/* SUEDIT: $Revision: 1.22 $; $Date: 93/11/12 13:31:18 $	*/
d175 1
a175 1
					return;
@


1.22
log
@changed help menu to a char * array
@
text
@d1 1
a1 1
/* SUEDIT: $Revision: 1.21 $; $Date: 93/08/13 10:27:47 $	*/
d62 1
d79 2
a80 1
char **helpp=help ;
d302 2
a303 2
			while (*helpp) fprintf(stderr,"%s\n", *helpp++);
			helpp = help;
d307 3
a309 2
				while(*helpp) fprintf(stderr,"%s\n", *helpp++);
			helpp = help;
@


1.21
log
@changed Bool to cwp_Bool
@
text
@d1 1
a1 1
/* SUEDIT: $Revision: 1.20 $; $Date: 93/08/09 15:19:27 $	*/
d46 1
d62 15
a76 15
cwp_String help =
"					\n"
" n		read in trace #n	\n"
" <CR>		step			\n"
" +		next trace;   step -> +1\n"
" -		prev trace;   step -> -1\n"
" dN		adv N traces; step -> N	\n"
" %		percentiles		\n"
" r		ranks			\n"
" p [n1 [n2]]  	tabplot			\n"
" ! key=val  	modify field		\n"
" ?		print this file		\n"
" q		quit			\n"
"					\n"
;
d78 2
d300 2
a301 1
			printf("%s\n", help);
d304 4
a307 1
			warn("bad key %s\n%s", userin, help);
@


1.20
log
@changed String to cwp_String
@
text
@d1 1
a1 1
/* SUEDIT: $Revision: 1.19 $; $Date: 92/10/23 15:11:20 $	*/
d92 1
a92 1
	Bool write_ok;		/* is file writable?			*/
@


1.19
log
@new selfdoc installed
@
text
@d1 1
a1 1
/* SUEDIT: $Revision: 1.18 $; $Date: 92/04/03 16:10:37 $	*/
d61 1
a61 1
String help =
d315 4
a318 4
	String keyword;	/* buffer and then header key word	*/
	String keyval;	/* header key value in ascii		*/
	String ptr;	/* pointer to isolate key word		*/
	String type;	/* type of key word			*/
@


1.18
log
@Better handling of situation where go off end of data.
No longer groan and die when non-existant trace is accessed.
@
text
@d1 1
a1 1
/* SUEDIT: $Revision: 1.17 $; $Date: 92/04/01 13:39:15 $	*/
d23 23
a45 23
char *sdoc =
" 									\n"
" SUEDIT - examine segy diskfiles and edit headers			\n"
" 									\n"
" suedit diskfile  (open for possible header modification if writable)	\n"
" suedit <diskfile  (open read only)					\n"
" 							        	\n"
" The following commands are recognized:				\n"
" number	read in that trace and print nonzero header words	\n"
" <CR>		go to trace one step away (step is initially -1)	\n"
" +		read in next trace (step is set to +1)			\n"
" -		read in previous trace (step is set to -1)		\n"
" dN		advance N traces (step is set to N)			\n"
" %		print some percentiles of the trace data		\n"
" r		print some ranks (rank[j] = jth smallest datum) 	\n"
" p [n1 [n2]]  	tab plot sample n1 to n2 on current trace		\n"
" ! key=val  	change a value in a field (e.g. ! tracr=101)		\n"
" ?		print help file						\n"
" q		quit							\n"
" 									\n"
" NOTE: sample numbers are 1-based (first sample is 1).			\n"
" 									\n"
;
d97 1
a97 1
	askdoc(1);
@


1.17
log
@Fixed bug with one trace when step to end of data set.
@
text
@d1 1
a1 1
/* SUEDIT: $Revision: 1.16 $; $Date: 92/04/01 13:25:17 $	*/
d154 4
d186 3
a188 6
				if (ntr == 1) itr = 0;
				else {
				    step = -1;
			    	    itr = ntr - 2;
				    printf("\nBounced off end of data:\n\n");
				}
d197 3
a199 6
				if (ntr == 1) itr = 0;
				else {
				    step = 1;
				    itr = 2;
				    printf("\nBounced off end of data:\n\n");
				}
d207 4
a210 7
			if (itr < 0 || itr > ntr - 1) {
				if (ntr == 1) itr = 0;
				else {
				    step *= -1;
				    itr += 2*step;
				    printf("\nBounced off end of data:\n\n");
				}
d212 5
d220 16
a287 11
		break;
		case 'd':
			step = eatoi(userin + 1);
			itr += step;
			if (itr < 0 || itr > ntr - 1) {
				step *= -1;
				itr += 2*step;
				printf("\nBounced off end of data:\n\n");
			}
			fgettra(infp, &tr, itr);
			printheader(&tr);
@


1.16
log
@Fixed bug that occurs when ntr=1 and one "bounces off
the end of the data" (into never-never-land).
@
text
@d1 1
a1 1
/* SUEDIT: $Revision: 1.15 $; $Date: 92/02/17 10:30:17 $	*/
d199 1
a199 1
				    itr = ntr - 1;
@


1.15
log
@Took out graphics options (g and f) because we don't HAVE a generic
graphics anymore (and certainly not suwig!).
@
text
@d1 1
a1 1
/* SUEDIT: $Revision: 1.14 $; $Date: 91/09/05 09:07:17 $	*/
d182 6
a187 3
				step = -1;
				itr = ntr - 2;
				printf("\nBounced off end of data:\n\n");
d196 6
a201 3
				step = 1;
				itr = 2;
				printf("\nBounced off end of data:\n\n");
d210 6
a215 3
				step *= -1;
				itr += 2*step;
				printf("\nBounced off end of data:\n\n");
@


1.14
log
@Need errno.h
@
text
@d1 1
a1 1
/* SUEDIT: $Revision: 1.13 $; $Date: 91/09/05 08:50:13 $	*/
d23 1
a23 1
String sdoc =
a38 2
" g [tr1 tr2]  	wiggle plot (graph) the trace [traces tr1 to tr2]	\n"
" f		wiggle plot the Fourier transform of the trace		\n"
a59 1
char tmpwig[L_tmpnam];	/* file for trace plots			*/
a70 2
" g [tr1 tr2]  	wiggle plot		\n"
" f		wig plot Fourier Transf \n"
a80 2
void wigplot(void);
void ftwigplot(void);
a178 6
		case 'g':
			wigplot();
		break;
		case 'f':
			ftwigplot();
		break;
a342 86
	printheader(&tr);

	return;
}


/* Wiggle plot of selected adjacent traces */
void wigplot(void)
{
	int n1;			/* first trace to be plotted		*/
	int n2;			/* last trace to be plotted		*/
	int i;			/* counter				*/
	char cmd[BUFSIZ];	/* build command for system call	*/
	FILE *wigfp;		/* fp for suwig input file		*/


	/* Prepare temporary file to hold traces to be plotted */
	wigfp = efopen(etmpnam(tmpwig), "w+");


	/* Parse request and subtract 1 for internal trace numbers */
	switch(sscanf(userin + 1, "%d %d", &n1, &n2)) {
	case 1: /* user specified remote trace to plot */
		--n1;
		fgettra(infp, &tr, n1);
		fputtr(wigfp, &tr); 
	break;
	case 2: /* user specified block of traces to plot */
		if (n2 < n1) {
			warn("must specify n1=%d < n2=%d", n1, n2);
			return;
		}
		for (i = n1 - 1; i <= n2 - 1; ++i) {
			fgettra(infp, &tr, i);
			fputtr(wigfp, &tr); 
		}
	break;
	default: /* no numbers given by user: plot current trace */
		fputtr(wigfp, &tr); 
	break;
	}

	/* Set up system call to suwig */
	rewind(wigfp);
	sprintf(cmd, "suwig <%s zerox=1.2 fill=0 | tube", tmpwig);
	system(cmd);

	/* Clean up temp file */
	efclose(wigfp);
	eremove(tmpwig);

	/* Prepare for next user request */
	userwait();	/* prompt and pause till user presses return  */
	sprintf(cmd, "%s/clg", CWPBIN);
	system(cmd);	/* clear screen */
	printheader(&tr);

	return;
}


/* Wiggle plot Fourier transform of current trace */
void ftwigplot()
{
	char cmd[BUFSIZ];	/* build command for system call	*/
	FILE *fftfp;		/* fp for sufft input file		*/


	/* Prepare temporary file to hold fft trace to be plotted */
	fftfp = efopen(tmpnam(tmpwig), "w+");

	fputtr(fftfp, &tr);

	/* Set up system call for suspec1 */
	rewind(fftfp);
	sprintf(cmd, "suspec1 <%s | suwig zerox=1.2 fill=0 | tube", tmpwig);
	system(cmd);

	/* Clean up temp file */
	efclose(fftfp);
	eremove(tmpwig);

	/* Prepare for next user request */
	userwait();	/* prompt and pause till user presses return  */
	sprintf(cmd, "%s/clg", CWPBIN);
	system(cmd);	/* clear screen */
@


1.13
log
@string -> String and so forth
@
text
@d1 1
a1 1
/* SUEDIT: $Revision: 1.10 $; $Date: 90/12/23 20:02:43 $	*/
d19 2
@


1.12
log
@Found way to stop ansi police complaint on the declaration
of the qsort comparison function.
@
text
@d21 1
a21 1
string sdoc =
d62 1
a62 1
string help =
d97 1
a97 1
	bool write_ok;		/* is file writable?			*/
d312 4
a315 4
	string keyword;	/* buffer and then header key word	*/
	string keyval;	/* header key value in ascii		*/
	string ptr;	/* pointer to isolate key word		*/
	string type;	/* type of key word			*/
d317 1
a317 1
	value val;	/* numerical value of key word		*/
d339 1
a339 2
	    syswarn("failed to convert %s to numeric, field not changed",
								keyval);
@


1.11
log
@Removed unnecessary casts from qsort call
@
text
@d86 1
a86 1
int cmp_indirect(int *r, int *s);
@


1.10
log
@Forgot to rewind files before system call
@
text
@d1 1
a1 1
/* SUEDIT: $Revision: 1.9 $; $Date: 90/12/23 16:26:09 $	*/
d140 1
a140 3
	for (i = 0; i < nt; ++i) {
		rank[i] = i;
	}
d224 1
a224 1
			qsort((char *) rank, (uint) nt, FSIZE, cmp_indirect);
d245 1
a245 1
			qsort((char *) rank, (uint) nt, FSIZE, cmp_indirect);
@


1.9
log
@fd -> fp and using gettra macro
@
text
@d1 1
a1 1
/* SUEDIT: $Revision: 1.8 $; $Date: 90/12/18 20:12:06 $	*/
d400 1
d422 1
a422 1
	FILE *fpfft;		/* fp for sufft input file		*/
d426 1
a426 1
	fpfft = efopen(tmpnam(tmpwig), "w+");
d428 1
a428 1
	fputtr(fpfft, &tr);
d431 1
d436 1
a436 1
	efclose(fpfft);
@


1.8
log
@Using suspec1.
@
text
@d1 1
a1 1
/* SUEDIT: $Revision: 1.7 $; $Date: 90/12/18 16:33:43 $	*/
d59 1
a59 1
int infd;		/* file descriptor of trace file	*/
d111 1
a111 1
		infd = STDIN;
d119 1
a119 1
			infd = eopen(argv[1], O_RDWR, 0666);
d124 1
a124 1
			infd = eopen(argv[1], O_RDONLY, 0666);
d135 1
a135 1
	ntr = gettra(infd, &tr, 0);
d148 1
a148 1
	gettra(infd, &tr, itr);
d151 1
a151 3
	if (-1 == fflush(stdout)) {
		err("fflush of stdout failed");
	}
d161 1
a161 1
			gettra(infd, &tr, itr);
d199 1
a199 1
			gettra(infd, &tr, itr);
d210 1
a210 1
			gettra(infd, &tr, itr);
d221 1
a221 1
			gettra(infd, &tr, itr);
d285 1
a285 1
			gettra(infd, &tr, itr);
d303 1
a303 3
		if (-1 == fflush(stdout)) {
			err("fflush of stdout failed");
		}
d350 2
a351 5
	if (-1 == lseek(infd, (long) (-nsegy), SEEK_CUR)) {
		syswarn("lseek error, field not changed");
		return;
	}
	ewrite(infd, (char *) (&tr), HDRBYTES);
d354 1
a354 4
	if (-1 == lseek(infd, (long) nsegy, SEEK_CUR)) {
		syswarn("lseek error after changing field");
		return;
	}
d370 1
a370 2
	FILE *fpwig;		/* fp for suwig input file		*/
	int fdwig;		/* ... its file id			*/
d374 1
a374 2
	fpwig = efopen(etmpnam(tmpwig), "w+");
	fdwig = fileno(fpwig);
d381 2
a382 2
		gettra(infd, &tr, n1);
		fputtr(fdwig, &tr); 
d390 2
a391 2
			gettra(infd, &tr, i);
			fputtr(fdwig, &tr); 
d395 1
a395 1
		fputtr(fdwig, &tr); 
d404 1
a404 1
	eclose(fdwig);
a421 1
	int fdfft;		/* ... its file id			*/
a425 1
	fdfft = fileno(fpfft);
d427 1
a427 1
	fputtr(fdfft, &tr);
d434 1
a434 1
	eclose(fdfft);
@


1.7
log
@Tweaks
@
text
@d1 1
a1 1
/* SUEDIT: $Revision: 1.6 $; $Date: 90/12/18 16:05:26 $	*/
d443 2
a444 3
	/* Set up system call for suamp */
	sprintf(cmd,
	    "sufft <%s | suamp | suwig zerox=1.2 fill=0 | tube", tmpwig);
@


1.6
log
@Using su/lib/tabplot instead of internal version
@
text
@d1 1
a1 1
/* SUEDIT: $Revision: 1.5 $; $Date: 90/11/12 18:44:27 $	*/
d105 1
a105 3
	if (argc > 2) {
		err("only one filename argument is allowed");
	}
d107 1
a107 1
	tty = fopen("/dev/tty", "r");
d385 1
a385 1
	fpwig = efopen(tmpnam(tmpwig), "w+");
@


1.5
log
@Cleaned up tmpnam stuff using etmpnam, eclose, etc.
@
text
@d1 1
a1 1
/* SUEDIT: $Revision: 1.4 $; $Date: 90/10/25 09:58:17 $	*/
d12 1
a12 1
 *  Golden, CO 80401  (isis!csm9a!jkcohen)
d21 25
a45 25
string sdoc = "\
									\n\
SUEDIT - examine segy diskfiles and edit headers			\n\
									\n\
suedit diskfile	  (open for possible header modification if writable)	\n\
suedit <diskfile  (open read only)					\n\
							        	\n\
The following commands are recognized:					\n\
number		read in that trace and print nonzero header words	\n\
<CR>		go to trace one step away (step is initially -1)	\n\
+		read in next trace (step is set to +1)			\n\
-		read in previous trace (step is set to -1)		\n\
dN		advance N traces (step is set to N)			\n\
%		print some percentiles of the trace data		\n\
r		print some ranks (rank[j] = jth smallest datum) 	\n\
p [n1 [n2]]  	tab plot sample n1 to n2 on current trace		\n\
g [tr1 tr2]  	wiggle plot (graph) the trace [traces tr1 to tr2]	\n\
f		wiggle plot the Fourier transform of the trace		\n\
! key=val  	change a value in a field (e.g. ! tracr=101)		\n\
?		print help file						\n\
q		quit							\n\
									\n\
NOTE: sample numbers are 1-based (first sample is 1).			\n\
									\n\
";
d62 17
a78 16
string help = "\
\n\
n		read in trace #n	\n\
<CR>		step			\n\
+		next trace;   step -> +1\n\
-		prev trace;   step -> -1\n\
dN		adv N traces; step -> N	\n\
%		percentiles		\n\
r		ranks			\n\
p [n1 [n2]]  	tabplot			\n\
g [tr1 tr2]  	wiggle plot		\n\
f		wig plot Fourier Transf \n\
! key=val  	modify field		\n\
?		print this file		\n\
q		quit			\n\
";
d80 1
a85 1
void tabplt(void);
a97 2
	void userwait();	/* PARMS()				*/
	int cmp_indirect();	/* comparison function for qsort	*/
d154 1
a154 1
		syserr("fflush of stdout failed");
d171 18
a188 1
			tabplt();
d308 1
a308 1
			syserr("fflush of stdout failed");
a461 113


#define SCREENFUL	19
#define PLOTWIDTH	29

string str[] = {
	"-----------------------------|",
	" ----------------------------|",
	"  ---------------------------|",
	"   --------------------------|",
	"    -------------------------|",
	"     ------------------------|",
	"      -----------------------|",
	"       ----------------------|",
	"        ---------------------|",
	"         --------------------|",
	"          -------------------|",
	"           ------------------|",
	"            -----------------|",
	"             ----------------|",
	"              ---------------|",
	"               --------------|",
	"                -------------|",
	"                 ------------|",
	"                  -----------|",
	"                   ----------|",
	"                    ---------|",
	"                     --------|",
	"                      -------|",
	"                       ------|",
	"                        -----|",
	"                         ----|",
	"                          ---|",
	"                           --|",
	"                            -|",
      	"                             *",
      	"                             |+",
      	"                             |++",
      	"                             |+++",
      	"                             |++++",
      	"                             |+++++",
      	"                             |++++++",
      	"                             |+++++++",
      	"                             |++++++++",
      	"                             |+++++++++",
      	"                             |++++++++++",
      	"                             |+++++++++++",
      	"                             |++++++++++++",
      	"                             |+++++++++++++",
      	"                             |++++++++++++++",
      	"                             |+++++++++++++++",
      	"                             |++++++++++++++++",
      	"                             |+++++++++++++++++",
      	"                             |++++++++++++++++++",
      	"                             |+++++++++++++++++++",
      	"                             |++++++++++++++++++++",
      	"                             |+++++++++++++++++++++",
      	"                             |++++++++++++++++++++++",
      	"                             |+++++++++++++++++++++++",
      	"                             |++++++++++++++++++++++++",
      	"                             |+++++++++++++++++++++++++",
      	"                             |++++++++++++++++++++++++++",
      	"                             |+++++++++++++++++++++++++++",
      	"                             |++++++++++++++++++++++++++++",
      	"                             |+++++++++++++++++++++++++++++",
};


void tabplt(void)
{
	static int p1;	/* Position of first sample (1-based)	*/
	static int p2;	/* Position of second sample 		*/
	float amp;	/* largest abs(datum) in window		*/
	float val;	/* temp for data value			*/
	int plt;	/* scaled data value			*/
	int i;		/* counter				*/

	/* Get user inputs (avoid running off end of data) */
	switch(sscanf(userin + 1, "%d %d", &p1, &p2)) {
	case 2:	/* user specified final position */
		if (p2 < p1) {
			warn("need p1=%d < p2=%d", p1, p2);
			return;
		}
		p2 = MIN(p2, nt);
	break;
	default:
		p2 = MIN(p1 + SCREENFUL, nt);
	break;
	}
	if (p1 >= nt || p1 <= 0) p1 = 1;

	amp = ABS(tr.data[p1-1]);
	for (i = p1; i <= p2; ++i) {
		amp = MAX(amp, ABS(tr.data[i-1]));
	}

	if (amp == 0.0) { /* data all zeroes, plot zero string */
		for (i = p1; i <= p2; ++i) {
			val = 0.0;
			printf("%5d %11.4e%s\n", i, val, str[PLOTWIDTH]);
		}
	} else { /* usual case, plot scaled data */
		for (i = p1; i <= p2; ++i) {
			val = tr.data[i-1];
			plt = PLOTWIDTH * (val/amp + 1.0);
			printf("%5d %11.4e%s\n", i, val, str[plt]);
		}
	}
	p1 = p2;
}


@


1.4
log
@Zapped declarations of system "qsort" to make ANSI C happy.
@
text
@d1 1
a1 1
/* SUEDIT: $Revision: 1.3 $; $Date: 90/05/29 17:41:32 $	*/
d60 1
a60 1
char tmpwig[L_tmpnam];	/* tmp file for input to suwig, sufft	*/
a367 1
	char *tmpnam();		/* system subroutine			*/
d371 1
a371 4
	tmpnam(tmpwig);
	if (NULL == (fpwig = fopen(tmpwig, "w+"))) {
		syserr("fopen failed on suwig tmp file");
	}
d374 1
d403 1
a403 1
	eunlink(tmpwig);
a420 1
	char *tmpnam();		/* system subroutine			*/
d422 3
a424 4
	tmpnam(tmpwig);
	if (NULL == (fpfft = fopen(tmpwig, "w+"))) {
		syserr("fopen failed on sufft tmp file");
	}
d435 2
a436 6
	if (-1 == close(fdfft)) {
		syserr("close failed on sufft tmp file");
	}
	if (-1 == unlink(tmpwig)) {
		syserr("unlink of sufft tmp file failed");
	}
@


1.3
log
@Fixed string in warn of bad key.
@
text
@d1 1
a1 1
/* SUEDIT: $Revision: 1.2 $; $Date: 90/05/29 17:40:36 $	*/
a97 1
	void qsort();		/* system sort - see qsort(3)		*/
@


1.2
log
@ANSI C and many other tweaks
@
text
@d1 1
a1 1
/* SUEDIT: $Revision: 1.1 $; $Date: 90/04/17 12:23:07 $	*/
d288 1
a288 1
			warn("bad key %s\n\%s", userin, help);
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/* SUEDIT: $Revision: 2.18 $; $Date: 89/10/25 23:30:34 $	*/
a51 1
 *
a53 5
/* Embed Revision Control System identifier strings */
static string progid =
	"   $Source: /src/su/src/RCS/suedit.c,v $";
static string revid =
	"   $Revision: 2.18 $; $Date: 89/10/25 23:30:34 $";
a54 3



d79 10
a88 2
main(argc, argv)
int argc; char **argv;
a96 4
	void tabplot();		/* PARMS()				*/
	void wigplot();		/* PARMS()				*/
	void ftwigplot();	/* PARMS()				*/
	void editkey();		/* PARMS()				*/
d102 1
a102 1
	/* Initialize SU */
a103 5
	if (!igetpar("ID", &ID))	ID = 0;
	if (ID) {
		(void) fprintf(stderr, "%s\n", progid);
		(void) fprintf(stderr, "%s\n", revid);
	}
d123 1
a123 1
			infd = open(argv[1], O_RDWR);
d128 1
a128 1
			infd = open(argv[1], O_RDONLY);
d143 1
a143 1
	rank = ivec(nt);
d166 1
a166 5
			errno = 0;
			itr = atoie(userin) - 1;
			if (errno) {
				syserr("atoie failed on %s", userin);
			}
d171 1
a171 1
			return SUCCEED;
d173 1
a173 1
			tabplot();
d267 1
a267 5
			errno = 0;
			step = atoie(userin + 1);
			if (errno) {
				syserr("atoie failed on %s", userin + 1);
			}
d297 1
a297 1
	return SUCCEED;
d303 1
a303 1
void editkey()
d361 1
a361 1
void wigplot()
d406 2
a407 6
	if (-1 == close(fdwig)) {
		syserr("close failed on suwig tmp file");
	}
	if (-1 == unlink(tmpwig)) {
		syserr("unlink of suwig tmp file failed");
	}
d411 1
a411 1
	sprintf(cmd, "%s/clg", SUBIN);
d450 1
a450 1
	sprintf(cmd, "%s/clg", SUBIN);
d524 1
a524 1
void tabplot()
d572 1
a572 2
int cmp_indirect(r, s)
int *r, *s;
d583 1
a583 1
void userwait()
@
