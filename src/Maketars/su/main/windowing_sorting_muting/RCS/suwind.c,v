head	1.55;
access;
symbols;
locks; strict;
comment	@ * @;


1.55
date	2015.03.18.17.50.30;	author john;	state Exp;
branches;
next	1.54;

1.54
date	2011.11.17.00.03.38;	author john;	state Exp;
branches;
next	1.53;

1.53
date	2011.11.12.00.44.21;	author john;	state Exp;
branches;
next	1.52;

1.52
date	2006.11.07.22.58.42;	author john;	state Exp;
branches;
next	1.51;

1.51
date	2006.08.14.20.43.36;	author john;	state Exp;
branches;
next	1.50;

1.50
date	2006.06.21.16.52.36;	author john;	state Exp;
branches;
next	1.49;

1.49
date	2006.05.16.21.27.25;	author john;	state Exp;
branches;
next	1.48;

1.48
date	2006.04.28.17.04.01;	author john;	state Exp;
branches;
next	1.47;

1.47
date	2006.04.28.16.45.16;	author john;	state Exp;
branches;
next	1.46;

1.46
date	2006.04.25.16.07.14;	author john;	state Exp;
branches;
next	1.45;

1.45
date	2006.03.15.18.14.54;	author john;	state Exp;
branches;
next	1.44;

1.44
date	2005.12.08.15.21.06;	author john;	state Exp;
branches;
next	1.43;

1.43
date	2004.12.23.23.54.24;	author john;	state Exp;
branches;
next	1.42;

1.42
date	2003.01.07.22.04.29;	author john;	state Exp;
branches;
next	1.41;

1.41
date	2003.01.07.21.57.39;	author john;	state Exp;
branches;
next	1.40;

1.40
date	98.01.26.22.04.41;	author john;	state Exp;
branches;
next	1.39;

1.39
date	97.07.28.22.36.46;	author john;	state Exp;
branches;
next	1.38;

1.38
date	96.09.13.21.49.05;	author john;	state Exp;
branches;
next	1.37;

1.37
date	96.05.02.19.46.01;	author jkc;	state Exp;
branches;
next	1.36;

1.36
date	96.03.05.20.45.19;	author john;	state Exp;
branches;
next	1.35;

1.35
date	96.01.30.23.00.25;	author jkc;	state Exp;
branches;
next	1.34;

1.34
date	95.10.05.16.30.12;	author john;	state Exp;
branches;
next	1.33;

1.33
date	95.08.04.15.53.57;	author jkc;	state Exp;
branches;
next	1.32;

1.32
date	95.03.10.11.48.16;	author john;	state Exp;
branches;
next	1.31;

1.31
date	95.03.08.14.28.55;	author jkc;	state Exp;
branches;
next	1.30;

1.30
date	95.03.08.11.08.55;	author john;	state Exp;
branches;
next	1.29;

1.29
date	95.03.08.11.04.07;	author john;	state Exp;
branches;
next	1.28;

1.28
date	95.02.28.13.46.27;	author jkc;	state Exp;
branches;
next	1.27;

1.27
date	95.02.16.15.14.09;	author jkc;	state Exp;
branches;
next	1.26;

1.26
date	94.08.25.15.01.42;	author jkc;	state Exp;
branches;
next	1.25;

1.25
date	94.06.02.15.28.20;	author jkc;	state Exp;
branches;
next	1.24;

1.24
date	94.05.06.13.30.52;	author jkc;	state Exp;
branches;
next	1.23;

1.23
date	94.03.28.13.11.35;	author jkc;	state Exp;
branches;
next	1.22;

1.22
date	94.03.25.13.14.00;	author jkc;	state Exp;
branches;
next	1.21;

1.21
date	94.03.25.13.08.08;	author john;	state Exp;
branches;
next	1.20;

1.20
date	94.03.25.11.29.28;	author john;	state Exp;
branches;
next	1.19;

1.19
date	94.01.12.10.13.13;	author jkc;	state Exp;
branches;
next	1.18;

1.18
date	94.01.11.15.02.30;	author jkc;	state Exp;
branches;
next	1.17;

1.17
date	94.01.11.14.25.53;	author jkc;	state Exp;
branches;
next	1.16;

1.16
date	93.08.13.10.28.41;	author john;	state Exp;
branches;
next	1.15;

1.15
date	93.08.09.15.20.11;	author john;	state Exp;
branches;
next	1.14;

1.14
date	92.10.23.15.23.46;	author john;	state Exp;
branches;
next	1.13;

1.13
date	92.02.18.12.38.40;	author jkc;	state Exp;
branches;
next	1.12;

1.12
date	92.02.18.12.34.12;	author jkc;	state Exp;
branches;
next	1.11;

1.11
date	91.10.08.14.52.34;	author jkc;	state Exp;
branches;
next	1.10;

1.10
date	91.10.07.08.43.12;	author jkcohen;	state Exp;
branches;
next	1.9;

1.9
date	91.10.07.08.05.58;	author jkcohen;	state Exp;
branches;
next	1.8;

1.8
date	91.09.17.13.34.01;	author jkcohen;	state Exp;
branches;
next	1.7;

1.7
date	91.09.17.13.11.18;	author jkcohen;	state Exp;
branches;
next	1.6;

1.6
date	91.09.05.08.52.31;	author jkcohen;	state Exp;
branches;
next	1.5;

1.5
date	91.05.10.15.42.52;	author jkcohen;	state Exp;
branches;
next	1.4;

1.4
date	91.05.10.14.22.07;	author jkcohen;	state Exp;
branches;
next	1.3;

1.3
date	90.09.03.09.56.48;	author jkc;	state Exp;
branches;
next	1.2;

1.2
date	90.05.30.14.09.34;	author jkc;	state Exp;
branches;
next	1.1;

1.1
date	90.05.29.19.38.19;	author jkc;	state Exp;
branches;
next	;


desc
@Eliminated maxgetpar() per new getpar routines
@


1.55
log
@altered ordered behavior, pointed out by Garry Parratt
@
text
@/* Copyright (c) Colorado School of Mines, 2011.*/
/* All rights reserved.                       */

/* SUWIND: $Revision: 1.54 $ ; $Date: 2011/11/17 00:03:38 $		*/

#include "su.h"
#include "segy.h"

/*********************** self documentation ******************************/
char *sdoc[] = {
"									",
" SUWIND - window traces by key word					",
"									",
"  suwind <stdin >stdout [options]					",
"									",
" Required Parameters:							",
"  none 								",
"									",
" Optional Parameters:							",
" verbose=0		=1 for verbose					",
" key=tracl		Key header word to window on (see segy.h)	",
" min=LONG_MIN		min value of key header word to pass		",
" max=LONG_MAX		max value of key header word to pass		",
"									",
" abs=0			=1 to take absolute value of key header word	",
" j=1			Pass every j-th trace ...			",
" s=0			... based at s  (if ((key - s)%j) == 0)		",
" skip=0		skip the initial N traces                       ",
" count=ULONG_MAX	... up to count traces				",
" reject=none		Skip traces with specified key values		",
" accept=none		Pass traces with specified key values(see notes)",
"			processing, but do no window the data		",
" ordered=0		=1 if traces sorted in increasing keyword value ",
"			=-1  if traces are sorted in a decreasing order ",
"									",
" Options for vertical windowing (time gating):				",
" dt=tr.dt (from header) time sampling interval (sec)	(seismic data)	",
" 			 =tr.d1  (nonseismic)				",
" f1=tr.delrt (from header) first sample		(seismic data)	",
" 			 =tr.f1  (nonseismic)				",
"									",
" tmin=0.0		min time to pass				",
" tmax=(from header)	max time to pass				",
" itmin=0		min time sample to pass				",
" itmax=(from header)   max time sample to pass				",
" nt=itmax-itmin+1	number of time samples to pass			",
"									",
" Notes:								",
" On large data sets, the count parameter should be set if		",
" possible.  Otherwise, every trace in the data set will be		",
" examined.  However, the count parameter overrides the accept		",
" parameter, so you can't specify count if you want true		",
" unconditional acceptance.						",
"                                                                       ",
" The skip= option allows the user to skip over traces, which helps	",
" for selecting traces far from the beginning of the dataset.		",
" Caveat: skip only works with disk input.                        	",
"                                                                       ",
" The ordered= option will speed up the process if the data are   	",
" sorted in according to the key.                                 	",
"									",
" The accept option is a bit strange--it does NOT mean accept ONLY	",
" the traces on the accept list!  It means accept these traces,   	",
" even if they would otherwise be rejected (except as noted in the	",
" previous paragraph).  To implement accept-only, you can use the 	",
" max=0 option (rejecting everything).  For example, to accept    	",
" only the tracl values 4, 5 and 6:					",
"	... | suwind max=0 accept=4,5,6 | ...		   		",
"									",
" Another example is the case of suppressing nonseismic traces in 	",
" a seismic data set. By the SEGY standard header field trace id, 	",
" trid=1 designates traces as being seismic traces. Other traces, 	",
" such as calibration traces may be designated by another value.  	",
"									",
" Example:  trid=1 seismic and trid=0 is nonseismic. To reject    	",
"       nonseismic traces						",
"       ... | suwind key=trid reject=0 | ...				",
"      									",
" On most 32 bit machines, LONG_MIN, LONG_MAX and ULONG_MAX are   	",
" about -2E9,+2E9 and 4E9, they are defined in limits.h.		",
"									",
" Selecting times beyond the maximum in the data induces		",
" zero padding (up to SU_NFLTS).					",
"									",
" The time gating here is to the nearest neighboring sample or    	",
" time value. Gating to the exact temporal value requires	 	",
" resampling if the selected times fall between samples on the    	",
" trace. Use suresamp to perform the time gating in this case.    	",
"									",
" It doesn't really make sense to specify both itmin and tmin,		",
" but specifying itmin takes precedence over specifying tmin.		",
" Similarly, itmax takes precedence over tmax and tmax over nt.		",
" If dt in header is not set, then dt is mandatory			",
"									",
NULL};

/* Credits:
 *	SEP: Einar Kjartansson
 *	CWP: Shuki Ronen, Jack Cohen, Chris Liner
 *	Warnemuende: Toralf Foerster
 *	CENPET: Werner M. Heigl (modified to include well log data)
 *
 * Trace header fields accessed: ns, dt, delrt, keyword
 * Trace header fields modified: ns, delrt, ntr
 */
/**************** end self doc *******************************************/


segy tr;

int
main(int argc, char **argv)
{
        FILE* infp=stdin;
	cwp_Bool seismic;	/* is this seismic data? */
	cwp_String key; /* header key word from segy.h		*/
	Value val;	/* value of key				*/
	int ival;	/* ... cast to int			*/
	cwp_String type;/* type of key				*/
	int indx;	/* index of key				*/
	int ordered;   /* order of key				*/
	long min;	/* smallest key value to accept		*/
	long max;	/* largest key value to accept		*/
	int j;		/* take every jth trace ...		*/
	int s;		/* ... starting at the sth trace ...	*/

	unsigned
	 long count;    /* ... up to a total of count traces    */
	Value *badptr=NULL;  /* pointer to list of traces to reject  */
	unsigned
	 int nbad;	/* number of rejected traces		*/
	Value *goodptr=NULL; /* pointer to list of traces to accept  */
	unsigned
	 int ngood;     /* number unconditionally accepted	*/
	short ab;	/* absolute value flag (1=YES, 0=NO)    */
	short verbose;  /* if 1(yes) echo parameters to stderr  */
	register int i; /* counter				*/

	float tmin=0.0;     /* minimum time to pass			*/
	float tmax;     /* maximum time to pass			*/
	float dt;	/* sampling interval:
			   from tr.dt for seismic data (sec)
			   from tr.d1 for well log data (m,ft)	*/
	float f1;	/* first sample:
			   from tr.delrt for seismic data (sec)
			   from tr.f1 for well log data (m,ft)	*/
	int itmin;	/* smallest time sample (zero-based)    */
	int itmax;	/* largest time sample (zero-based)     */
	int ntfirst;	/* number of time samples on first trace*/
	int nt;		/* number of time samples on output     */
        int ntr=0;       /* number of traces                     */
        int itr=0;      /* trace counter                        */
        int skip=0;     /* traces to skip                       */
	size_t nzeros;  /* number of zeroes to pad		*/
	char *pzeros;   /* pointer to zero pad			*/
        


	/* Initialize */
	initargs(argc, argv);
	requestdoc(1);

	/* Default parameters;  User-defined overrides */
	if (!getparstring("key", &key))		key = "tracl";
	if (!getparlong("min", &min))		min = INT_MIN;
	if (!getparlong("max", &max))		max = INT_MAX;
	if (!getparint("j", &j))		j = 1;
	if (!getparint("s", &s))		s = 0;
	if (!getparulong("count", &count))	count = ULONG_MAX;
	if (!getparshort("abs", &ab))		ab = 0;
	if (!getparshort("verbose", &verbose))	verbose = 0;
        if (!getparint("skip" ,&skip ))         skip=0;
	if (!getparint("ordered", &ordered))    ordered = 0;

	/* Evaluate time bounds from getpars and first header */

        if( skip ){
           if( !(ntr = fgettra(infp, &tr, itr) ) ){
               err("can't get first trace");
           }
           if( skip > ntr-1 ){
              err( "can't skip past last trace" );
           }else{
              itr=skip;
              fgettra(infp, &tr, itr);
           }

        }else{
           if (!gettr(&tr)) err("can't get first trace"); 
        }

	ntfirst = tr.ns;
	
	/* check for seismic or well log data */
	seismic = ISSEISMIC(tr.trid);		
	if (seismic) {
		if (verbose) warn("input is seismic data, trid=%d",tr.trid);
		if (!getparfloat("dt",&dt))	dt = ((double) tr.dt)/1000000.0;
		if (dt==0)  err("dt not set in header or not getparred");
		if (!getparfloat("f1",&f1))	f1 = ((double) tr.delrt)/1000.0;  
		if (!f1) {
			if (verbose)
			warn("delrt not set in header or not getparred");
		}
	} else {	/* is not seismic */
		if (verbose) warn("input is not seismic data, trid=%d",tr.trid);
		if (!getparfloat("dt",&dt)) {
			if (tr.d1) {
				dt = tr.d1;
			} else { 
				if  (verbose) {
					warn("d1 field not set");
					warn("using dt field");
				}

				dt = tr.dt;

				if (dt==0)
				err("d1 and dt not set in header or dt not getparred");
			}
		}
		if (!getparfloat("f1",&f1)) f1 = tr.f1;
		if (!f1) {       
			if (verbose)
				warn("f1 not set in header or not getparred");
		}
    }

	/* Time gating parameters */
	if (getparint("itmin", &itmin)) {
		tmin = itmin*dt + f1;
	} else if (getparfloat("tmin", &tmin)) {
		itmin = NINT((tmin - f1) / dt);
	} else {
		itmin = 0;
		tmin = f1;
	}
	if (getparint("itmax", &itmax)) {
		tmax = itmax*dt + f1;
		nt = itmax - itmin + 1;
	} else if (getparfloat("tmax", &tmax)) {
		itmax = NINT((tmax - f1) / dt);
		nt = itmax - itmin + 1;
	} else if (getparint("nt", &nt)) {
		itmax = itmin + nt - 1;
		tmax = itmax*dt + f1;
	} else {
		itmax = ntfirst - 1;
		tmax = itmax*dt + f1;
		nt = itmax - itmin + 1;
	}
	

	/* Check time gating values */
	if (itmin < 0)
		err("itmin=%d should be positive", itmin);
	if (nt > SU_NFLTS)
		err("nt=%d exceeds SU_NFLTS=%d", nt, SU_NFLTS);
	if (itmin > itmax)
		err("itmin=%d, itmax=%d conflict", itmin, itmax);


	/* compute number of zeros and padding */
	nzeros = (nt - ntfirst > 0) ? (nt - ntfirst) * FSIZE : 0;
	pzeros = (char *) (tr.data + ntfirst - itmin);

	type = hdtype(key);
	indx = getindex(key);


	/* Getpar the reject vector */
	if ((nbad = countparval("reject"))) {
		badptr = (Value *) ealloc1(nbad, sizeof(Value));
		getparval("reject", type, nbad, badptr);
	}


	 /* Getpar the accept vector */
	if ((ngood = countparval("accept"))) {
		goodptr = (Value *) ealloc1(ngood, sizeof(Value));
		getparval("accept", type, ngood, goodptr);
	}
        checkpars();


	/* Echo parameters */
	if (verbose) {
		warn("key = %s", key);
		warn("type = %s", type);
		warn("min = %ld", min);
		warn("max = %ld", max);
		warn("j = %d", j);
		warn("s = %d", s);
		warn("count = %lu", count);
		warn("abs = %d", ab);
		warn("ordered = %d", ordered);
		for (i = 0; i < ngood; i++) {
			(void) fprintf(stderr, "accept[%d] = ", i);
			fprintfval(stderr, type, goodptr[i]);
			putc('\n', stderr);
		}
		for (i = 0; i < nbad; i++) {
			(void) fprintf(stderr, "reject[%d] = ", i);
			fprintfval(stderr, type, badptr[i]);
			putc('\n', stderr);
		}
		
		warn("tmin=%f tmax=%f", tmin, tmax);
		warn("itmin=%d itmax=%d nt=%u", itmin, itmax, nt);
		warn("Padding %d zeroes", nzeros/FSIZE);
	}


        if( skip ){

		/* Main loop over traces */
		do {
			cwp_Bool isbad = cwp_false;  /* flag for unconditional reject */
			cwp_Bool isgood = cwp_false; /* flag for unconditional accept */
	 
			gethval(&tr, indx, &val);
			
			for (i = 0; i < nbad; i++) {
				if (!valcmp(type, val, badptr[i])) {
					isbad = cwp_true;
					break;  /* found */
				}
			}
			
			for (i = 0; i < ngood; i++) {
				if (!valcmp(type, val, goodptr[i])) {
					isgood = cwp_true;
					break;  /* found */
				}
			}
	
			if (ab) val = valtoabs(type, val);
	
			ival = vtoi(type, val);
	
			/* If trace selected, put it out */

			if (((ordered == 1 ) && (max < ival)) || ((ordered == (-1) ) && (min > ival ))) break;


			if ( isgood || 
			    ((min <= ival) && (ival <= max) &&
			     !((ival - s) % j) && !isbad ) ) {
	
				/* Perform time windowing */
				if (itmin > 0) {
					for (i = itmin; i <= itmax; i++) {
						tr.data[i-itmin] = tr.data[i];
					}
					if (seismic)
						tr.delrt = NINT((itmin*((int) tr.dt))*.001 + ((int) (tr.delrt)));
					else	tr.f1 = itmin*(tr.d1) + tr.f1;
				}
				if (nzeros) memset(pzeros, 0, nzeros);
				tr.ns = nt;
	
				/* zero ntr field to keep sugraphics from choking */
				tr.ntr = 0; 
	
				puttr(&tr);
				if (!(--count)) break; /* all done */
			}
	
	          itr++;
		} while (itr < ntr && fgettra(infp, &tr, itr));


        }else{

		/* Main loop over traces */
		do {
			cwp_Bool isbad = cwp_false;  /* flag for unconditional reject */
			cwp_Bool isgood = cwp_false; /* flag for unconditional accept */
	 
			gethval(&tr, indx, &val);
			
			for (i = 0; i < nbad; i++) {
				if (!valcmp(type, val, badptr[i])) {
					isbad = cwp_true;
					break;  /* found */
				}
			}
			
			for (i = 0; i < ngood; i++) {
				if (!valcmp(type, val, goodptr[i])) {
					isgood = cwp_true;
					break;  /* found */
				}
			}
	
			if (ab) val = valtoabs(type, val);
	
			ival = vtoi(type, val);
	
			/* If trace selected, put it out */

			if (((ordered == 1 ) && (max < ival)) || ((ordered == (-1) ) && (min > ival ))) break; 

			if ( isgood || 
			    ((min <= ival) && (ival <= max) &&
			     !((ival - s) % j) && !isbad ) ) {
	
				/* Perform time windowing */
				if (itmin > 0) {
					for (i = itmin; i <= itmax; i++) {
						tr.data[i-itmin] = tr.data[i];
					}
					if (seismic)
						tr.delrt = NINT((itmin*((int) tr.dt))*.001 + ((int) (tr.delrt)));
					else	tr.f1 = itmin*(tr.d1) + tr.f1;
				}
				if (nzeros) memset(pzeros, 0, nzeros);
				tr.ns = nt;
	
				/* zero ntr field to keep sugraphics from choking */
				tr.ntr = 0; 
	
				puttr(&tr);
				if (!(--count)) break; /* all done */
			}
	
		} while (gettr(&tr));
        }

	return(CWP_Exit());
}
@


1.54
log
@added Reg Beardsley's checkpar()
@
text
@d4 1
a4 1
/* SUWIND: $Revision: 1.52 $ ; $Date: 2006/11/07 22:58:42 $		*/
d343 2
a344 1
			if (((ordered == 1 ) && (max <= ival)) || ((ordered == (-1) ) && (min >= ival ))) break;
d402 1
a402 1
			if (((ordered == 1 ) && (max <= ival)) || ((ordered == (-1) ) && (min >= ival ))) break;
@


1.53
log
@copyright
@
text
@d283 1
@


1.52
log
@changed    memset( .., (int) '\0',...) to memset( .., 0,..) as per suggestion of Marion Zhu and Reg Beardsley
@
text
@d1 4
a4 1
/* SUWIND: $Revision: 1.51 $ ; $Date: 2006/08/14 20:43:36 $		*/
@


1.51
log
@fixed bombing for nonseismic data
@
text
@d1 1
a1 1
/* SUWIND: $Revision: 1.50 $ ; $Date: 2006/06/21 16:52:36 $		*/
d354 1
a354 1
				if (nzeros) memset(pzeros, '\0', nzeros);
d412 1
a412 1
				if (nzeros) memset(pzeros, '\0', nzeros);
@


1.50
log
@fenced off warns, initialize tmin
@
text
@d1 1
a1 1
/* SUWIND: $Revision: 1.49 $ ; $Date: 2006/05/16 21:27:25 $		*/
d21 1
d32 7
a38 2
" Options for vertical	windowing (time gating):			",
" dt=tr.dt (from header) time sampling interval (sec)			",
d138 1
a138 1
	float dt;	/* sampling rate:
d141 1
a141 1
	float samp1;	/* first sample:
d195 1
a195 1
		dt = ((double) tr.dt)/1000000.0;
d197 2
a198 2
		samp1 = ((double) tr.delrt)/1000.0;  
		if (!tmin) {
a200 1
			tmin=samp1;
d202 1
a202 2
	}
	else {	/* change to else if (iswelllog) after las.h is available */
d204 17
a220 4
		dt = tr.d1;
		if (dt==0)  err("d1 not set in header or not getparred");
		samp1 = tr.f1;
		if (!tmin) {
d222 1
a222 2
				warn("not set in header or not getparred");
			tmin=samp1;
d224 1
a224 1
        }
d228 1
a228 1
		tmin = itmin*dt + samp1;
d230 1
a230 1
		itmin = NINT((tmin - samp1) / dt);
d233 1
a233 1
		tmin = samp1;
d236 1
a236 1
		tmax = itmax*dt + samp1;
d239 1
a239 1
		itmax = NINT((tmax - samp1) / dt);
d243 1
a243 1
		tmax = itmax*dt + samp1;
d246 1
a246 1
		tmax = itmax*dt + samp1;
@


1.49
log
@added Marc Schaming's additions, some cosmetic changes.
@
text
@d1 1
a1 1
/* SUWIND: $Revision: 1.48 $ ; $Date: 2006/04/28 17:04:01 $		*/
d130 1
a130 1
	float tmin;     /* minimum time to pass			*/
d188 1
a188 1
		warn("input is seismic data, trid=%d",tr.trid);
d192 5
a196 1
		if (!tmin)  warn("delrt not set in header or not getparred");
d199 1
a199 1
		warn("input is not seismic data, trid=%d",tr.trid);
d203 5
a207 1
		if (!tmin)  warn("not set in header or not getparred");
@


1.48
log
@*** empty log message ***
@
text
@d1 1
a1 1
/* SUWIND: $Revision: 1.47 $ ; $Date: 2006/04/28 16:45:16 $		*/
d11 1
a11 1
"     suwind <stdin >stdout [options]					",
d14 1
a14 1
"	none								",
d17 11
a27 11
"	verbose=0	=1 for verbose					",
"	key=tracl	Key header word to window on (see segy.h)	",
"	min=LONG_MIN    min value of key header word to pass		",
"	max=LONG_MAX    max value of key header word to pass		",
"	abs=0	   =1 to take absolute value of key header word		",
"	j=1	     Pass every j-th trace ...				",
"	s=0	     ... based at s  (if ((key - s)%j) == 0)		",
"       skip=0          skip the initial N traces                       ",
"	count=ULONG_MAX ... up to count traces				",
"	reject=none     Skip traces with specified key values		",
"	accept=none     Pass traces with specified key values(see notes)",
d29 9
a37 7
" Options for vertical windowing (time gating):				",
"	dt=tr.dt (from header)  time sampling interval (sec)		",
"	tmin=0.0		min time to pass			",
"	tmax=(from header)	max time to pass			",
"	itmin=0		 min time sample to pass			",
"	itmax=(from header)     max time sample to pass			",
"	nt=itmax-itmin+1	number of time samples to pass		",
d40 5
a44 5
"	On large data sets, the count parameter should be set if	",
"	possible.  Otherwise, every trace in the data set will be	",
"	examined.  However, the count parameter overrides the accept    ",
"	parameter, so you can't specify count if you want true		",
"	unconditional acceptance.					",
d46 19
a64 1
"       The skip= option only works with disk input.                    ",
d66 1
a66 13
"	The accept option is a bit strange--it does NOT mean accept ONLY",
"	the traces on the accept list!  It means accept these traces,   ",
"	even if they would otherwise be rejected (except as noted in the",
"	previous paragraph).  To implement accept-only, you can use the ",
"	max=0 option (rejecting everything).  For example, to accept    ",
"	only the tracl values 4, 5 and 6:				",
"		... | suwind max=0 accept=4,5,6 | ...		   	",
"									",
"       Another example is the case of suppressing nonseismic traces in ",
"       a seismic data set. By the SEGY standard header field trace id, ",
"       trid=1 designates traces as being seismic traces. Other traces, ",
"       such as calibration traces may be designated by another value.  ",
"      	Example:  trid=1 seismic and trid=0 is nonseismic. To reject    ",
d68 1
a68 1
"	       ... | suwind key=trid reject=0 | ...			",
d70 2
a71 15
"	On most 32 bit machines, LONG_MIN, LONG_MAX and ULONG_MAX are   ",
"	about -2E9,+2E9 and 4E9, they are defined in limits.h.		",
"									",
"	Selecting times beyond the maximum in the data induces		",
"	zero padding (up to SU_NFLTS).					",
"									",
"	The time gating here is to the nearest neighboring sample or    ",
"	time value. Gating to the exact temporal value requires	 	",
"	resampling if the selected times fall between samples on the    ",
"	trace. Use suresamp to perform the time gating in this case.    ",
"									",
"	It doesn't really make sense to specify both itmin and tmin,	",
"	but specifying itmin takes precedence over specifying tmin.	",
"	Similarly, itmax takes precedence over tmax and tmax over nt.	",
"	If dt in header is not set, then dt is mandatory		",
d73 2
d76 9
d112 1
d164 1
d268 1
d314 3
d372 3
@


1.47
log
@an additional fix from Reg Beardsley
@
text
@d1 1
a1 1
/* SUWIND: $Revision: 1.3 $ ; $Date: 2006/04/28 15:25:34 $		*/
d135 1
a135 1
        int ntr;        /* number of traces                     */
@


1.46
log
@Reg Beardsley's skip parameter
@
text
@d1 1
a1 1
/* SUWIND: $Revision: 1.2 $ ; $Date: 2006/04/25 15:46:55 $		*/
d43 2
a158 1
        if( !(ntr = fgettra(infp, &tr, itr) ) ) err("can't get first trace");
d160 11
a170 2
        if( skip > ntr-1 ){
           err( "can't skip past last trace" );
d172 1
a172 2
           itr=skip;
           fgettra(infp, &tr, itr);
d182 1
a182 1
		if (dt==0)  warn("dt not set in header or not getparred");
d277 21
a297 11
	/* Main loop over traces */
	do {
		cwp_Bool isbad = cwp_false;  /* flag for unconditional reject */
		cwp_Bool isgood = cwp_false; /* flag for unconditional accept */
 
		gethval(&tr, indx, &val);
		
		for (i = 0; i < nbad; i++) {
			if (!valcmp(type, val, badptr[i])) {
				isbad = cwp_true;
				break;  /* found */
d299 27
a325 6
		}
		
		for (i = 0; i < ngood; i++) {
			if (!valcmp(type, val, goodptr[i])) {
				isgood = cwp_true;
				break;  /* found */
d327 3
a329 1
		}
a330 1
		if (ab) val = valtoabs(type, val);
d332 1
a332 1
		ival = vtoi(type, val);
d334 38
a371 9
		/* If trace selected, put it out */
		if ( isgood || 
		    ((min <= ival) && (ival <= max) &&
		     !((ival - s) % j) && !isbad ) ) {

			/* Perform time windowing */
			if (itmin > 0) {
				for (i = itmin; i <= itmax; i++) {
					tr.data[i-itmin] = tr.data[i];
d373 8
a380 3
				if (seismic)
					tr.delrt = NINT((itmin*((int) tr.dt))*.001 + ((int) (tr.delrt)));
				else	tr.f1 = itmin*(tr.d1) + tr.f1;
d382 3
a384 13
			if (nzeros) memset(pzeros, '\0', nzeros);
			tr.ns = nt;

			/* zero ntr field to keep sugraphics from choking */
			tr.ntr = 0; 

			puttr(&tr);
			if (!(--count)) break; /* all done */
		}

          itr++;
	} while (itr < ntr && fgettra(infp, &tr, itr));

@


1.45
log
@less chatty
@
text
@d1 1
a1 1
/* SUWIND: $Revision: 1.44 $ ; $Date: 2005/12/08 15:21:06 $		*/
d24 1
d97 1
d133 3
d138 1
d154 1
d157 9
a165 1
	if (!gettr(&tr)) err("can't get first trace");
d173 1
a173 1
		if (dt==0)  err("dt not set in header or not getparred");
d178 1
a178 1
		if (verbose) warn("input is not seismic data, trid=%d",tr.trid);
d180 1
a180 2
		if (dt==0 && verbose)
			err("d1 not set in header or not getparred");
d182 1
a182 2
		if (!tmin && verbose )
			warn("not set in header or not getparred");
d316 3
a318 1
	} while (gettr(&tr));
@


1.44
log
@modified by Werner Heigel
@
text
@d1 1
a1 1
/* SUWIND: $Revision: 1.43 $ ; $Date: 2004/12/23 23:54:24 $		*/
d163 1
a163 1
		warn("input is not seismic data, trid=%d",tr.trid);
d165 2
a166 1
		if (dt==0)  err("d1 not set in header or not getparred");
d168 2
a169 1
		if (!tmin)  warn("not set in header or not getparred");
@


1.43
log
@cosmetic
@
text
@d1 1
a1 1
/* SUWIND: $Revision: 1.42 $ ; $Date: 2003/01/07 22:04:29 $		*/
d83 1
d96 1
d121 6
a126 1
	float dt;	/* sampling rate (secs)			*/
d152 17
a168 2
	if (!getparfloat("dt",&dt))	 dt = ((double) tr.dt)/1000000.0;
	if (dt==0.0) err("dt not set in header or getparred.");
d172 1
a172 1
		tmin = itmin*dt + tr.delrt/1000.0;
d174 1
a174 1
		itmin = NINT((tmin - tr.delrt/1000.0) / dt);
d176 2
a177 2
		 itmin = 0;
		 tmin = tr.delrt/1000.0;
a178 1

d180 1
a180 1
		tmax = itmax*dt + tr.delrt/1000.0;
d183 1
a183 1
		itmax = NINT((tmax - tr.delrt/1000.0) / dt);
d187 1
a187 1
		tmax = itmax*dt + tr.delrt/1000.0;
d190 1
a190 1
		tmax = itmax*dt + tr.delrt/1000.0;
d194 1
d288 3
a290 1
				tr.delrt = NINT((itmin*((int) tr.dt))*.001 + ((int) (tr.delrt)));
@


1.42
log
@added nonseismic trace rejection paragraph in selfdoc
@
text
@d1 1
a1 1
/* SUWIND: $Revision: 1.41 $ ; $Date: 2003/01/07 21:57:39 $		*/
d27 1
d74 3
d104 1
@


1.41
log
@added CWP_Exit() function
@
text
@d1 1
a1 1
/* SUWIND: $Revision: 1.40 $ ; $Date: 1998/01/26 22:04:41 $		*/
d50 8
@


1.40
log
@fixed missing 'dt' bug. It was possible to try to do time gating
on data that didn't have dt set
@
text
@d1 1
a1 1
/* SUWIND: $Revision: 1.39 $ ; $Date: 1997/07/28 22:36:46 $		*/
d267 1
a267 1
	return EXIT_SUCCESS;
@


1.39
log
@changes suggested by Stew Levin to silence SGI compiler warnings, etc
@
text
@d1 1
a1 1
/* SUWIND: $Revision: 1.38 $ ; $Date: 1996/09/13 21:49:05 $                */
d10 52
a61 51
"                                                                       ",
"     suwind <stdin >stdout [options]                                   ",
"                                                                       ",
" Required Parameters:                                                  ",
"        none                                                           ",
"                                                                       ",
" Optional Parameters:                                                  ",
"       verbose=0       =1 for verbose                                  ",
"       key=tracl       Key header word to window on (see segy.h)       ",
"       min=LONG_MIN    min value of key header word to pass            ",
"       max=LONG_MAX    max value of key header word to pass            ",
"       abs=0           =1 to take absolute value of key header word    ",
"       j=1             Pass every j-th trace ...                       ",
"       s=0             ... based at s  (if ((key - s)%j) == 0)         ",
"       count=ULONG_MAX ... up to count traces                          ",
"       reject=none     Skip traces with specified key values           ",
"       accept=none     Pass traces with specified key values(see notes)",
" Options for vertical windowing (time gating):                         ",
"       tmin = 0.0              min time to pass                        ",
"       tmax = (from header)    max time to pass                        ",
"       itmin = 0               min time sample to pass                 ",
"       itmax = (from header)   max time sample to pass                 ",
"       nt = itmax-itmin+1      number of time samples to pass          ",
"                                                                       ",
" Notes:                                                                ",
"       On large data sets, the count parameter should be set if        ",
"       possible.  Otherwise, every trace in the data set will be       ",
"       examined.  However, the count parameter overrides the accept    ",
"       parameter, so you can't specify count if you want true          ",
"       unconditional acceptance.                                       ",
"                                                                       ",
"       The accept option is a bit strange--it does NOT mean accept ONLY",
"       the traces on the accept list!  It means accept these traces,   ",
"       even if they would otherwise be rejected (except as noted in the",
"       previous paragraph).  To implement accept-only, you can use the ",
"       max=0 option (rejecting everything).  For example, to accept    ",
"       only the tracl values 4, 5 and 6:                               ",
"               ... | suwind max=0 accept=4,5,6 | ...                   ",
"                                                                       ",
"       On most 32 bit machines, LONG_MIN, LONG_MAX and ULONG_MAX are   ",
"       about -2E9,+2E9 and 4E9, they are defined in limits.h.          ",
"                                                                       ",
"       Selecting times beyond the maximum in the data induces          ",
"       zero padding (up to SU_NFLTS).                                  ",
"                                                                       ",
"       The time gating here is to the nearest neighboring sample or    ",
"       time value. Gating to the exact temporal value requires         ",
"       resampling if the selected times fall between samples on the    ",
"       trace. Use suresamp to perform the time gating in this case.    ",
"                                                                       ",
"       It doesn't really make sense to specify both itmin and tmin,	",
d64 1
d68 3
a70 3
 *      SEP: Einar Kjartansson
 *      CWP: Shuki Ronen, Jack Cohen, Chris Liner
 *      Warnemuende: Toralf Foerster
d83 45
a127 45
        cwp_String key; /* header key word from segy.h          */
        Value val;      /* value of key                         */
        int ival;       /* ... cast to int                      */
        cwp_String type;/* type of key                          */
        int indx;       /* index of key                         */
        long min;       /* smallest key value to accept         */
        long max;       /* largest key value to accept          */
        int j;          /* take every jth trace ...             */
        int s;          /* ... starting at the sth trace ...    */
        unsigned
         long count;    /* ... up to a total of count traces    */
        Value *badptr=NULL;  /* pointer to list of traces to reject  */
        unsigned
         int nbad;      /* number of rejected traces            */
        Value *goodptr=NULL; /* pointer to list of traces to accept  */
        unsigned
         int ngood;     /* number unconditionally accepted      */
        short ab;       /* absolute value flag (1=YES, 0=NO)    */
        short verbose;  /* if 1(yes) echo parameters to stderr  */
        register int i; /* counter                              */

        float tmin;     /* minimum time to pass                 */
        float tmax;     /* maximum time to pass                 */
        float dt;       /* sampling rate (secs)                 */
        int itmin;      /* smallest time sample (zero-based)    */
        int itmax;      /* largest time sample (zero-based)     */
        int ntfirst;	/* number of time samples on first trace*/
        int nt;		/* number of time samples on output     */
        size_t nzeros;  /* number of zeroes to pad              */
        char *pzeros;   /* pointer to zero pad                  */


        /* Initialize */
        initargs(argc, argv);
        requestdoc(1);

        /* Default parameters;  User-defined overrides */
        if (!getparstring("key", &key))		key = "tracl";
        if (!getparlong("min", &min))		min = INT_MIN;
        if (!getparlong("max", &max))		max = INT_MAX;
        if (!getparint("j", &j))		j = 1;
        if (!getparint("s", &s))		s = 0;
        if (!getparulong("count", &count))	count = ULONG_MAX;
        if (!getparshort("abs", &ab))		ab = 0;
        if (!getparshort("verbose", &verbose))	verbose = 0;
d129 2
a130 2
        /* Evaluate time bounds from getpars and first header */
        if (!gettr(&tr)) err("can't get first trace");
d132 2
a133 1
        dt = ((double) tr.dt)/1000000.0;
d135 3
a137 3
        /* Time gating parameters */
        if (getparint("itmin", &itmin)) {
                tmin = itmin*dt + tr.delrt/1000.0;
d145 2
a146 2
       if (getparint("itmax", &itmax)) {
                tmax = itmax*dt + tr.delrt/1000.0;
d149 1
a149 1
                itmax = NINT((tmax - tr.delrt/1000.0) / dt);
d152 2
a153 2
                itmax = itmin + nt - 1;
                tmax = itmax*dt + tr.delrt/1000.0;
d160 51
a210 50
        /* Check time gating values */
        if (itmin < 0)
                err("itmin=%d should be positive", itmin);
        if (nt > SU_NFLTS)
                err("nt=%d exceeds SU_NFLTS=%d", nt, SU_NFLTS);
        if (itmin > itmax)
                err("itmin=%d, itmax=%d conflict", itmin, itmax);

        /* compute number of zeros and padding */
        nzeros = (nt - ntfirst > 0) ? (nt - ntfirst) * FSIZE : 0;
        pzeros = (char *) (tr.data + ntfirst - itmin);

        type = hdtype(key);
        indx = getindex(key);


        /* Getpar the reject vector */
        if ((nbad = countparval("reject"))) {
                badptr = (Value *) ealloc1(nbad, sizeof(Value));
                getparval("reject", type, nbad, badptr);
        }


         /* Getpar the accept vector */
        if ((ngood = countparval("accept"))) {
                goodptr = (Value *) ealloc1(ngood, sizeof(Value));
                getparval("accept", type, ngood, goodptr);
        }


        /* Echo parameters */
        if (verbose) {
                warn("key = %s", key);
                warn("type = %s", type);
                warn("min = %ld", min);
                warn("max = %ld", max);
                warn("j = %d", j);
                warn("s = %d", s);
                warn("count = %lu", count);
                warn("abs = %d", ab);
                for (i = 0; i < ngood; i++) {
                        (void) fprintf(stderr, "accept[%d] = ", i);
                        fprintfval(stderr, type, goodptr[i]);
                        putc('\n', stderr);
                }
                for (i = 0; i < nbad; i++) {
                        (void) fprintf(stderr, "reject[%d] = ", i);
                        fprintfval(stderr, type, badptr[i]);
                        putc('\n', stderr);
                }
d213 3
a215 3
                warn("itmin=%d itmax=%d nt=%u", itmin, itmax, nt);
                warn("Padding %d zeroes", nzeros/FSIZE);
        }
d218 4
a221 4
        /* Main loop over traces */
        do {
                cwp_Bool isbad = cwp_false;  /* flag for unconditional reject */
                cwp_Bool isgood = cwp_false; /* flag for unconditional accept */
d224 23
a246 23
                
                for (i = 0; i < nbad; i++) {
                        if (!valcmp(type, val, badptr[i])) {
                                isbad = cwp_true;
                                break;  /* found */
                        }
                }
                
                for (i = 0; i < ngood; i++) {
                        if (!valcmp(type, val, goodptr[i])) {
                                isgood = cwp_true;
                                break;  /* found */
                        }
                }

                if (ab) val = valtoabs(type, val);

                ival = vtoi(type, val);

                /* If trace selected, put it out */
                if ( isgood || 
                    ((min <= ival) && (ival <= max) &&
                     !((ival - s) % j) && !isbad ) ) {
d263 2
a264 2
                }
        } while (gettr(&tr));
d267 1
a267 1
        return EXIT_SUCCESS;
@


1.38
log
@silenced -Wall messages
@
text
@d1 1
a1 1
/* SUWIND: $Revision: 1.37 $ ; $Date: 1996/05/02 19:46:01 $                */
d11 1
a11 1
" suwind <stdin >stdout [options]                                       ",
d109 1
a109 1
        int nzeros;     /* number of zeroes to pad              */
d216 2
a217 2
                cwp_Bool isbad = false;  /* flag for unconditional reject */
                cwp_Bool isgood = false; /* flag for unconditional accept */
d223 1
a223 1
                                isbad = true;
d230 1
a230 1
                                isgood = true;
@


1.37
log
@./main/suwind.c
"suwind.c", line 87: warning: index redefinition hides earlier one
Used indx instead.
@
text
@d1 1
a1 1
/* SUWIND: $Revision: 1.36 $ ; $Date: 1996/03/05 20:45:19 $                */
d78 1
d92 1
a92 1
        Value *badptr;  /* pointer to list of traces to reject  */
d95 1
a95 1
        Value *goodptr; /* pointer to list of traces to accept  */
d174 1
a174 1
        if (nbad = countparval("reject")) {
d181 1
a181 1
        if (ngood = countparval("accept")) {
@


1.36
log
@added Stew Levin's fixes
@
text
@d1 1
a1 1
/* SUWIND: $Revision: 1.35 $ ; $Date: 1996/01/30 23:00:25 $                */
d84 1
a84 1
        int index;      /* index of key                         */
d169 1
a169 1
        index = getindex(key);
d218 1
a218 1
		gethval(&tr, index, &val);
@


1.35
log
@Deal with header words accessed/modified to sudoc.
Fix computation of tr.delrt on output traces.
@
text
@d1 1
a1 1
/* SUWIND: $Revision: 1.34 $ ; $Date: 1995/10/05 16:30:12 $                */
d248 1
a248 1
				tr.delrt = NINT(itmin*tr.dt/1000.0 + tr.delrt);
@


1.34
log
@tr.ntr = 0 to force su graphics programs to count traces
@
text
@d1 1
a1 1
/* SUWIND: $Revision: 1.33 $ ; $Date: 1995/08/04 15:53:57 $                */
d62 1
a62 4
"	Similarly, itmax takes precedence over tmax and tmax over nt.	",	
"                                                                       ",
" Trace header fields accessed: ns, delrt				",
" Trace header fields modified: ns, delrt (for certain time gates)	",
d69 3
d248 1
a248 1
				tr.delrt = NINT(tmin*1000.0);
@


1.33
log
@Cast tr.dt to signed data type.
@
text
@d1 1
a1 1
/* SUWIND: $Revision: 1.32 $ ; $Date: 1995/03/10 11:48:16 $                */
d252 3
@


1.32
log
@Jack forgot to change getparushort to getparint to reflect type
change of nt
@
text
@d1 1
a1 1
/* SUWIND: $Revision: 1.31 $ ; $Date: 95/03/08 14:28:55 $                */
d129 1
a129 1
        dt = tr.dt/1000000.0;
@


1.31
log
@Changed archaic declaration of nt as unsigned short.  Motivated
by strenouus objections from cc on IBM.
@
text
@d1 1
a1 1
/* SUWIND: $Revision: 1.30 $ ; $Date: 95/03/08 11:08:55 $                */
d147 1
a147 1
	} else if (getparushort("nt", &nt)) {
@


1.30
log
@... extra () added in nzeros
@
text
@d1 1
a1 1
/* SUWIND: $Revision: 1.29 $ ; $Date: 95/03/08 11:04:07 $                */
d106 2
a107 2
        unsigned
         short nt;      /* number of time samples               */
d128 1
d151 1
a151 1
		itmax = tr.ns - 1;
d165 2
a166 2
        nzeros = ((int) (nt - tr.ns) > 0) ? ((int) (nt - tr.ns) * FSIZE) : 0;
        pzeros = (char *) (tr.data + tr.ns - itmin);
@


1.29
log
@put explicit cast on nzero computation.
This is not necessary for most compilers, but the IBM cc compiler
didn't accept the first part of the conditional.
@
text
@d1 1
a1 1
/* SUWIND: $Revision: 1.28 $ ; $Date: 95/02/28 13:46:27 $                */
d164 1
a164 1
        nzeros = (int) (nt - tr.ns) > 0 ? (int) (nt - tr.ns) * FSIZE : 0;
@


1.28
log
@Removed those yucky booleans.
@
text
@d1 1
a1 1
/* SUWIND: $Revision: 1.27 $ ; $Date: 95/02/16 15:14:09 $                */
d164 1
a164 1
        nzeros = (nt - tr.ns > 0) ? (nt - tr.ns) * FSIZE : 0;
@


1.27
log
@Toralf pointed out some problems and we found more.  In short, you can
no longer give both tmin and itmin, etc.   The delrt is now honored
consistently.  Integer <--> float conversions done carefully.  Echo
of zero pad in verbose option was corrected.
@
text
@d1 1
a1 1
/* SUWIND: $Revision: 1.26 $ ; $Date: 94/08/25 15:01:42 $                */
d60 3
a62 1
"       Caveat: Code uses delrt from first trace for all traces.	",
d64 2
a110 5
        cwp_Bool got_tmin = false;
        cwp_Bool got_itmin = false;
        cwp_Bool got_tmax = false;
        cwp_Bool got_itmax = false;
        cwp_Bool got_nt = false;
a131 1
		got_itmin = true;
d133 2
d137 1
a138 7
	if (getparfloat("tmin", &tmin)) {
                got_tmin = true;
                itmin = NINT((tmin - tr.delrt/1000.0) / dt);
	} else {
		tmin = itmin*dt + tr.delrt/1000.0;
	}
	if (got_itmin && got_tmin)  err("can't getpar both itmin and tmin");
a140 1
		got_itmax = true;
d142 2
a143 5
	} else {
		 itmax = tr.ns - 1;
	}
        if (getparfloat("tmax", &tmax)) {
                got_tmax = true;
d145 2
a146 8
        } else {
		tmax = itmax*dt+tr.delrt/1000.0;
	}
 	if (got_itmax && got_tmax)  err("can't getpar both itmax and tmax");

        if (getparushort("nt", &nt)) {
		if (got_itmax)  err("can't getpar both itmax and nt");
		got_nt = true;
d149 5
a153 3
        } else {
                nt = itmax - itmin + 1;
        }
d247 1
a250 2
			if (got_tmin || got_itmin)
				tr.delrt = NINT(tmin*1000.0);
@


1.26
log
@Removed copyright statement from codes that had it.
Moved self-doc line for sudoc.
@
text
@d1 1
a1 1
/* SUWIND: $Revision: 1.25 $ ; $Date: 94/06/02 15:28:20 $                */
d8 2
a10 2
" SUWIND - window traces by key word                                    ",
"                                                                       ",
d17 16
a32 17
"	verbose=0	=1 for verbose                                  ",
"	key=tracl	Key header word to window on (see segy.h)       ",
"	min=LONG_MIN	min value of key header word to pass            ",
"	max=LONG_MAX	max value of key header word to pass            ",
"	abs=0		=1 to take absolute value of key header word    ",
"	j=1		Pass every j-th trace ...                       ",
"	s=0		... based at s  (if ((key - s)%j) == 0)         ",
"	count=ULONG_MAX	... up to count traces        		        ",
"	reject=none	Skip traces with specified key values		",
"	accept=none	Pass traces with specified key values(see notes)",
" Options for vertical windowing (time gating):				",
"	tmin = 0.0              min time to pass			",
"	tmax = (from header)	max time to pass 			",
"	itmin = 0               min time sample to pass			",
"	itmax =	(from header)   max time sample to pass			",
"	nt = itmax-itmin+1	number of time samples to pass		",
"       				(nt=itmax-itmin+1)		",
d34 6
a39 14
" Notes:								",
"	On large data sets, the count parameter should be set if	",
"	possible.  Otherwise, every trace in the data set will be	",
"	examined.  However, the count parameter overrides the accept	",
"	parameter, so you can't specify count if you want true		",
"	unconditional acceptance.					",
"									",
"	The accept option is a bit strange--it does NOT mean accept ONLY",
"	the traces on the accept list!  It means accept these traces,	",
"	even if they would otherwise be rejected (except as noted in the",
"	previous paragraph).  To implement accept-only, you can use the	",
"	max=0 option (rejecting everything).  For example, to accept	",
"	only the tracl values 4, 5 and 6:				",
"		... | suwind max=0 accept=4,5,6 | ...			",
d41 8
d50 1
a50 1
"       about -2E9,+2E9 and 4E9, they are defined in limits.h.		",
d52 2
a53 2
"	Selecting times beyond the maximum in the data induces		",
"       zero padding (up to SU_NFLTS).					",
d55 4
a58 4
"       The time gating here is to the nearest neighboring sample or	",
"       time value. Gating to the exact temporal value requires		",
"	resampling if the selected times fall between samples on the	",
"	trace. Use suresamp to perform the time gating in this case.	",
d60 2
d67 1
d92 1
a92 1
         int ngood;     /* number unconditionally accepted	*/
d97 9
a105 9
	float tmin;	/* minimum time to pass			*/
	float tmax;	/* maximum time to pass			*/
	float dt;	/* sampling rate (secs)			*/
	int itmin;	/* smallest time sample (zero-based)	*/
	int itmax;	/* largest time sample (zero-based)	*/
	unsigned
	 short nt;	/* number of time samples		*/
	int nzeros;	/* number of zeroes to pad		*/
	char *pzeros;	/* pointer to zero pad			*/
d107 6
d118 8
a125 8
        if (!getparstring("key"    , &key))            key = "tracl";
        if (!getparlong("min"      , &min))            min = INT_MIN;
        if (!getparlong("max"      , &max))            max = INT_MAX;
        if (!getparint("j"         , &j))              j = 1;
        if (!getparint("s"         , &s))              s = 0;
        if (!getparulong("count"   , &count))          count = ULONG_MAX;
        if (!getparshort("abs"     , &ab))             ab = 0;
        if (!getparshort("verbose" , &verbose))        verbose = 0;
d127 3
a129 3
	/* Evaluate time bounds from getpars and first header */
	if (!gettr(&tr)) err("can't get first trace");
	dt = 0.000001*tr.dt;
d131 4
a134 4
	/* time gating parameters */
	if (!getparint("itmin", &itmin))	itmin = 0;
	if (getparfloat("tmin", &tmin)) {
		itmin = tmin/dt;
d136 1
a136 1
		tmin = itmin*dt+tr.delrt/1000;
d138 3
a140 4

	if (!getparint("itmax", &itmax))   itmax = tr.ns - 1;
	if (getparfloat("tmax", &tmax)) {
		itmax = tmax/dt;
d142 1
a142 1
		tmax = itmax*dt+tr.delrt/1000;
d144 1
d146 3
a148 3
	if (getparushort("nt", &nt)) {
		itmax = itmin + nt - 1;
		tmax = itmax*dt;
d150 1
a150 1
		nt = itmax - itmin + 1;
d152 7
d160 16
a175 7
	/* check time gating values */
	if (itmin < 0)
		err("itmin=%d should be positive", itmin);
	if (nt > SU_NFLTS)
		err("nt=%d exceeds SU_NFLTS=%d", nt, SU_NFLTS);
	if (itmin > itmax)
		err("itmin=%d, itmax=%d conflict", itmin, itmax);
d177 3
a179 3
	/* compute number of zeros and padding */
	nzeros = (nt - tr.ns) * FSIZE;
	pzeros = (char *) (tr.data + tr.ns - itmin);
d187 1
a187 1
		badptr = (Value *) ealloc1(nbad, sizeof(Value));
d189 1
a189 1
	}
d194 1
a194 1
		goodptr = (Value *) ealloc1(ngood, sizeof(Value));
d219 1
d221 2
a222 2
		warn("itmin=%d itmax=%d nt=%u", itmin, itmax, nt);
		if (nzeros) warn("Padding %d zeroes", nzeros/FSIZE);
d228 5
a232 5
        	cwp_Bool isbad = false;  /* flag for unconditional reject */
        	cwp_Bool isgood = false; /* flag for unconditional accept */
		
                gethval(&tr, index, &val);
		
d239 1
a239 1
		
d253 1
a253 1
		    ((min <= ival) && (ival <= max) &&
d256 1
a256 1
			/* perform time windowing */
d259 1
a259 1
					tr.data[i - itmin] = tr.data[i];
d262 1
a262 1
			if (nzeros > 0) memset(pzeros, '\0', nzeros);
d264 2
a265 1
			tr.delrt = tmin*1000.0;
d267 2
a268 2
                        puttr(&tr);
                        if (!(--count)) break; /* all done */
d270 1
a270 1
	} while (gettr(&tr));
@


1.25
log
@Fixed time gating to include tr.delrt.
@
text
@d1 1
a1 14
/* SUWIND: $Revision: 1.24 $ ; $Date: 94/05/06 13:30:52 $                */

/*----------------------------------------------------------------------
 * Copyright (c) Colorado School of Mines, 1990.
 * All rights reserved.
 *
 * This code is part of SU.  SU stands for Seismic Unix, a processing line
 * developed at the Colorado School of Mines, partially based on Stanford
 * Exploration Project (SEP) software.  Inquiries should be addressed to:
 *
 *  Jack K. Cohen, Center for Wave Phenomena, Colorado School of Mines,
 *  Golden, CO 80401  (jkc@@dix.mines.colorado.edu)
 *----------------------------------------------------------------------
 */
@


1.24
log
@Amplify self-doc a bit.
@
text
@d1 1
a1 1
/* SUWIND: $Revision: 1.23 $ ; $Date: 94/03/28 13:11:35 $                */
d141 1
a141 1
		tmin = itmin*dt;
d148 1
a148 1
		tmax = itmax*dt;
@


1.23
log
@oops forgot to put the while(gettr) at the end since we've
already read the first trace to get header info.
@
text
@d1 1
a1 1
/* SUWIND: $Revision: 1.22 $ ; $Date: 94/03/25 13:14:00 $                */
d53 9
a61 4
"	unconditional acceptance.  Using max=0 and the accept option	",
"	will pass the traces in the accept list and no others. If a	",
"	trace is on both the accept list and the reject list, it will	",
"	be accepted--we don't pretend this makes any particular sense	",
@


1.22
log
@Cosmetics.
@
text
@d1 1
a1 1
/* SUWIND: $Revision: 1.21 $ ; $Date: 94/03/25 13:08:08 $                */
d210 1
a210 1
        while (gettr(&tr)){
d252 1
a252 1
        }
@


1.21
log
@changed bzero to memset
@
text
@d1 1
a1 1
/* SUWIND: $Revision: 1.20 $ ; $Date: 94/03/25 11:29:28 $                */
a62 4
"       The time gating here is to the nearest neighboring sample or time",
"       value. Gating to the exact temporal value requires resampling if",
"       the selected times fall between samples on the trace. Use suresamp",
"	to perform the time gating in this case.			",
d64 5
d108 2
a109 1
	unsigned short nt;	/* number of time samples		*/
d245 1
a245 1
			if (nzeros > 0) memset (pzeros, '\0', nzeros);
@


1.20
log
@time gating feature restored !!!!
@
text
@d1 1
a1 1
/* SUWIND: $Revision: 1.19 $ ; $Date: 94/01/12 10:13:13 $                */
d243 1
a243 1
			if (nzeros > 0) bzero(pzeros, nzeros);
@


1.19
log
@Tweak self doc.
@
text
@d1 1
a1 1
/* SUWIND: $Revision: 1.18 $ ; $Date: 94/01/11 15:02:30 $                */
d40 8
d61 7
a67 2
"        Older versions of suwind also did time gating.  Timegating is	",
"        now handled by the program suresamp. 				",
d102 8
d125 38
d201 3
d236 10
@


1.18
log
@Tweak to self doc re accepted traces.
@
text
@d1 1
a1 1
/* SUWIND: $Revision: 1.17 $ ; $Date: 94/01/11 14:25:53 $                */
d46 3
a48 1
"	will pass the traces in the accept list and no others.		",
@


1.17
log
@Documented the accept option a little better.  Cosmetics.
@
text
@d1 1
a1 1
/* SUWIND: $Revision: 1.16 $ ; $Date: 93/08/13 10:28:41 $                */
d46 1
a46 1
"	will pass only the specified traces.				",
@


1.16
log
@changed Bool to cwp_Bool
@
text
@d1 1
a1 1
/* SUWIND: $Revision: 1.15 $ ; $Date: 93/08/09 15:20:11 $                */
d39 1
a39 1
"	accept=none	Pass traces with specified key values	 	",
d43 1
a43 1
"	examined.  However, the count parameter over-rides the accept	",
d45 6
a50 5
"	unconditional acceptance.					",
"                                                                        ",
"        On most 32 bit machines, LONG_MIN, LONG_MAX and ULONG_MAX are   ",
"        about -2E9,+2E9 and 4E9, they are defined in limits.h.		",
"                                                                        ",
a53 1
/**************** end self doc *******************************************/
d56 2
a57 7
 *      SEP: Einar
 *      CWP: Shuki, Jack, Chris
 *
 * Note:
 *
 * Caveat:
 *      A cast to int is made for the s,j selection branch.
d59 1
d66 1
a66 1
        cwp_String key;     /* header key word from segy.h          */
d69 1
a69 1
        cwp_String type;    /* type of key                          */
d145 2
a146 2
        	cwp_Bool isbad = false;    /* flag for unconditional rejection */
        	cwp_Bool isgood = false;   /* flag for unconditional accepting */
@


1.15
log
@changed String to cwp_String
@
text
@d1 1
a1 1
/* SUWIND: $Revision: 1.14 $ ; $Date: 92/10/23 15:23:46 $                */
d149 2
a150 2
        	Bool isbad = false;    /* flag for unconditional rejection */
        	Bool isgood = false;   /* flag for unconditional accepting */
@


1.14
log
@new selfdoc installed
@
text
@d1 1
a1 1
/* SUWIND: $Revision: 1.13 $ ; $Date: 92/02/18 12:38:40 $                */
d70 1
a70 1
        String key;     /* header key word from segy.h          */
d73 1
a73 1
        String type;    /* type of key                          */
@


1.13
log
@Added remark about suresamp to selfdoc.
@
text
@d1 1
a1 1
/* SUWIND: $Revision: 1.12 $ ; $Date: 92/02/18 12:34:12 $                */
d20 33
a52 33
String sdoc = "\
                                                                        \n\
SUWIND - window traces by key word                                      \n\
                                                                        \n\
suwind <stdin >stdout [options]                                         \n\
                                                                        \n\
Required Parameters:                                                    \n\
        none                                                            \n\
                                                                        \n\
Optional Parameters:                                                    \n\
        verbose=0  	=1 for verbose                                  \n\
        key=tracl     	Key header word to window on (see segy.h)       \n\
        min=LONG_MIN  	min value of key header word to pass            \n\
        max=LONG_MAX 	max value of key header word to pass            \n\
        abs=0		=1 to take absolute value of key header word    \n\
        j=1           	Pass every j-th trace ...                       \n\
        s=0     	... based at s  (if ((key - s)%j) == 0)         \n\
        count=ULONG_MAX ... up to count traces         		        \n\
        reject=none     Skip traces with specified key values 		\n\
        accept=none     Pass traces with specified key values	 	\n\
Notes:									\n\
	On large data sets, the count parameter should be set if	\n\
	possible.  Otherwise, every trace in the data set will be	\n\
	examined.  However, the count parameter over-rides the accept	\n\
	parameter, so you can't specify count if you want true		\n\
	unconditional acceptance.					\n\
                                                                        \n\
        On most 32 bit machines, LONG_MIN, LONG_MAX and ULONG_MAX are   \n\
        about -2E9,+2E9 and 4E9, they are defined in limits.h.		\n\
                                                                        \n\
        Older versions of suwind also did time gating.  Timegating is	\n\
        now handled by the program suresamp. 				\n\
";
d94 1
a94 2
        askdoc(1);

@


1.12
log
@Move some subs from suwind to .../su/lib/valpkge
@
text
@d1 1
a1 1
/* SUWIND: $Revision: 1.11 $ ; $Date: 91/10/08 14:52:34 $                */
d49 3
@


1.11
log
@Correct handling of value getpars (big boost from Dave); so now
can use ansi prototypes.
@
text
@d1 1
a1 1
/* SUWIND: $Revision: 1.10 $ ; $Date: 91/10/07 08:43:12 $                */
a61 3
/* Prototypes */
void getparval(String name, String type, int n, Value *valp);
Value valtoabs(String type, Value val);
a181 91
}


/* Value getpar */
void getparval(String name, String type, int n, Value *valp)
{
        register int k;
	short *h;
	unsigned short *u;
	long *l;
	unsigned long *v;
	int *i;
	unsigned int *p;
	float *f;
	double *d;
	
	switch(*type) {
        case 'h':
		h = (short*) ealloc1(n, sizeof(short));
		getparshort(name, h);  
		for (k = 0; k < n; ++k) valp[k].h = h[k];
	break;
        case 'u':
		u = (unsigned short*) ealloc1(n, sizeof(unsigned short));
		getparushort(name, u);  
		for (k = 0; k < n; ++k) valp[k].u = u[k];
	break;
        case 'l':
		l = (long*) ealloc1(n, sizeof(long));
		getparlong(name, l);  
		for (k = 0; k < n; ++k) valp[k].l = l[k];
	break;
        case 'v':
		v = (unsigned long*) ealloc1(n, sizeof(unsigned long));
		getparulong(name, v);  
		for (k = 0; k < n; ++k) valp[k].v = v[k];
	break;
        case 'i':
		i = (int*) ealloc1(n, sizeof(int));
		getparint(name, i);  
		for (k = 0; k < n; ++k) valp[k].i = i[k];
	break;  
        case 'p':
		p = (unsigned int*) ealloc1(n, sizeof(unsigned int));
		getparuint(name, p);  
		for (k = 0; k < n; ++k) valp[k].p = p[k];
	break;
        case 'f':
		f = (float*) ealloc1(n, sizeof(float));
		getparfloat(name, f);  
		for (k = 0; k < n; ++k) valp[k].f = f[k];
	break;  
        case 'd':
		d = (double*) ealloc1(n, sizeof(double));
		getpardouble(name, d);  
		for (k = 0; k < n; ++k) valp[k].d = d[k];
	break;  
        default:
                err("getparval: %d: mysterious type %s", __LINE__, type);
        }
}


/* Get absolute value for type value variable */
Value valtoabs(String type, Value val)
{
        switch(*type) {
        case 'u':       /* do nothing if unsigned */
        case 'v':
        case 'p':
        break;
        case 'h':
                val.h = ABS(val.h);
        break;
        case 'l':
                val.l = ABS(val.l);
        break;
        case 'i':
                val.i = ABS(val.i);
        break;
        case 'f':
                val.f = ABS(val.f);
        break;
        case 'd':
                val.d = ABS(val.d);
        break;
        default:
                err("valtoabs: %d: mysterious type %s", __LINE__, type);
        }

        return val;
@


1.10
log
@add accept vector; change name of bad vector to "reject"
@
text
@d1 1
a1 1
/* SUWIND: $Revision: 1.7 $ ; $Date: 91/09/17 13:11:18 $                */
d62 3
a81 1
        Mixed mbadptr;  /* to arbitrate with getpars    	*/
a84 1
        Mixed mgoodptr; /* to arbitrate with getpars    	*/
a89 4
        void mallocmix();       /* PARMS(Mixed *, char *, uint)         */
        void getparval();       /* PARMS(char *, char *, Value *)       */
        void mixtoval();        /* PARMS(value, Mixed, char *, uint)    */
        Value valtoabs();       /* PARMS(char *, value)                 */
d111 1
a111 1
        /* Getpar the reject vector--need a pointer of the specific type  */
d113 3
a115 2
                mallocmix(&mbadptr, type, nbad);
                getparval("reject", type, mbadptr);
a116 6
                /* Get pointer to value from mixed pointer */
                if (NULL == (badptr = (Value *)
                        malloc((unsigned int) (nbad*sizeof(Value)))))
                        err("malloc failed");
                mixtoval(badptr, mbadptr, type, nbad);
        }
d118 1
a118 2

         /* Getpar the accept vector--need a pointer of the specific type  */
d120 2
a121 8
                mallocmix(&mgoodptr, type, ngood);
                getparval("accept", type, mgoodptr);

                /* Get pointer to value from mixed pointer */
                if (NULL == (goodptr = (Value *)
                        malloc((unsigned int) (ngood*sizeof(Value)))))
                        err("malloc failed");
                mixtoval(goodptr, mgoodptr, type, ngood);
d135 5
d141 1
a141 1
                        (void) fprintf(stderr, "badptr[%d] = ", i);
d188 2
a189 5
/* Mixed malloc */
void mallocmix(mptr, type, n)
Mixed *mptr;
String type;
unsigned int n;
d191 11
a201 6
        switch(*type) {
        case 's':
                if (NULL == (mptr->s =
                         (char *) malloc((unsigned int) (n * DSIZE))))
                        err("mallocmix failed on type %s", type);
        break;
d203 4
a206 3
                if (NULL == (mptr->h = (short *) malloc(n * sizeof(short))))
                        err("mallocmix failed on type %s", type);
        break;
d208 4
a211 4
                if (NULL == (mptr->u = (unsigned short *)
                         malloc(n * sizeof(unsigned short))))
                        err("mallocmix failed on type %s", type);
        break;
d213 4
a216 3
                if (NULL == (mptr->l = (long *) malloc(n * sizeof(long))))
                        err("mallocmix failed on type %s", type);
        break;
d218 4
a221 4
                if (NULL == (mptr->v =
                         (unsigned long *) malloc(n * sizeof(unsigned long))))
                        err("mallocmix failed on type %s", type);
        break;
d223 4
a226 3
                if (NULL == (mptr->i = (int *) malloc(n * sizeof(int))))
                        err("mallocmix failed on type %s", type);
        break;
d228 4
a231 4
                if (NULL == (mptr->p =
                         (unsigned int *) malloc(n * sizeof(unsigned int))))
                        err("mallocmix failed on type %s", type);
        break;
d233 4
a236 3
                if (NULL == (mptr->f = (float *) malloc(n * sizeof(float))))
                        err("mallocmix failed on type %s", type);
        break;
d238 4
a241 2
                if (NULL == (mptr->d = (double *) malloc(n * sizeof(double))))
                        err("mallocmix failed on type %s", type);
a242 23
                err("mallocmix: %d: mysterious type %s", __LINE__, type);
        }
        return;
}


/* Value getpar */
void getparval(name, type, valp)
String name;
String type;
Value *valp;
{
        switch(*type) {
        case 's': getparstring(name, (char**) valp);            break;
        case 'h': getparshort(name, (short*) valp);             break;
        case 'u': getparushort(name, (unsigned short*) valp);   break;
        case 'l': getparlong(name, (long*) valp);               break;
        case 'v': getparulong(name, (unsigned long*) valp);     break;
        case 'i': getparint(name, (int*) valp);                 break;  
        case 'p': getparuint(name, (unsigned int*) valp);       break;
        case 'f': getparfloat(name, (float*) valp);             break;  
        case 'd': getpardouble(name, (double*) valp);           break;  
        default:
a247 58
/* Get value ptr from mixed ptr */
void mixtoval(valp, mixptr, type, n)
Value *valp;
Mixed mixptr;
String type;
unsigned int n;
{
        register int i;

        switch(*type) {
        case 'h':
                for (i = 0; i < n; i++) {
                        (valp++)->h = *mixptr.h++;
                }
        break;
        case 'u':
                for (i = 0; i < n; i++) {
                        (valp++)->u = *mixptr.u++;
                }
        break;
        case 'l':
                for (i = 0; i < n; i++) {
                        (valp++)->l = *mixptr.l++;
                }
        break;
        case 'v':
                for (i = 0; i < n; i++) {
                        (valp++)->v = *mixptr.v++;
                }
        break;
        case 'i':
                for (i = 0; i < n; i++) {
                        (valp++)->i = *mixptr.i++;
                }
        break;
        case 'p':
                for (i = 0; i < n; i++) {
                        (valp++)->p = *mixptr.p++;
                }
        break;
        case 'f':
                for (i = 0; i < n; i++) {
                        (valp++)->f = *mixptr.f++;
                }
        break;
        case 'd':
                for (i = 0; i < n; i++) {
                        (valp++)->d = *mixptr.d++;
                }
        break;
        default:
                err("mixtoval: %d: mysterious type %s", __LINE__, type);
        break;
        }
        return;
}


d249 1
a249 3
Value valtoabs(type, val)
String type;
Value val;
@


1.9
log
@Removed time gating since now done better in suresamp.
@
text
@d22 1
a22 1
SUWIND - window traces by key word	                                \n\
d30 16
a45 12
        verbose = 0     =1 for verbose                                  \n\
...Options for horizontal windowing (trace selection):                  \n\
        key = tracl     Key header word to window on (see segy.h)       \n\
        min = LONG_MIN  min value of key header word to pass            \n\
        max = LONG_MAX  max value of key header word to pass            \n\
        abs = 0         =1 to take absolute value of                    \n\
                        key header word                                 \n\
        j = 1           Pass every j-th trace ...                       \n\
        s = 0           ... based at s  (if ((key - s)%j) == 0)         \n\
        count = ULONG_MAX       ... up to count traces                  \n\
        bad = none      Delete traces with specified bad key            \n\
                        values                                          \n\
d48 1
a48 1
        about -2E9,+2E9 and 4E9 and are defined in general in limits.h  \n\
a56 3
 *      On large data sets, the count parameter should be set
 *      if possible.  Otherwise, every trace in the data set
 *      will be examined.
d78 2
a79 2
        Value *badptr;  /* pointer to list of bad traces        */
        Mixed mbadptr;  /* to arbitrate bad with getpars        */
d81 5
a85 2
         int nbad;      /* number of bad traces                 */
        Bool isbad;     /* flag for bad trace                   */
a86 3
	float dt;	/* time sample interval (sec)		*/
        unsigned
         int nt;        /* number of time samples               */
d101 8
a108 8
        if (!getparstring("key"     , &key))            key = "tracl";
        if (!getparlong("min"     , &min))              min = INT_MIN;
        if (!getparlong("max"     , &max))              max = INT_MAX;
        if (!getparint("j"       , &j))                 j = 1;
        if (!getparint("s"       , &s))                 s = 0;
        if (!getparulong("count"   , &count))           count = ULONG_MAX;
        if (!getparshort("abs"     , &ab))              ab = 0;
        if (!getparshort("verbose" , &verbose))         verbose = 0;
d114 2
a115 2
        /* Getpar the bad vector--need a pointer of the specific type  */
        if (nbad = countparval("bad")) {
d117 1
a117 1
                getparval("bad", type, mbadptr);
d127 4
a130 3
        /* Get first trace info */
        if (!gettr(&tr)) err("can't get first trace");
        dt = 0.000001*tr.dt;
d132 6
d139 1
d159 4
a162 1
        do {
d164 1
a164 1
                isbad = false;
d171 7
d184 4
a187 2
                if ((min <= ival) && (ival <= max) &&
                   !((ival - s) % j) && !isbad && count--) {
d189 1
a189 1
                        if (!count) break; /* all done */
d191 1
a191 1
        } while (gettr(&tr));
@


1.8
log
@Cosmetics
@
text
@d1 1
a1 1
/* SUWIND: $Revision: 1.7 $ ; $Date: 91/09/17 13:11:18 $		*/
d21 24
a44 34
									\n\
SUWIND - window and time gate traces					\n\
									\n\
suwind <stdin >stdout [options]						\n\
									\n\
Required Parameters:							\n\
	none								\n\
									\n\
Optional Parameters:							\n\
	verbose = 0	=1 for verbose					\n\
...Options for horizontal windowing (trace selection):			\n\
	key = tracl	Key header word to window on (see segy.h)	\n\
	min = LONG_MIN	min value of key header word to pass		\n\
	max = LONG_MAX	max value of key header word to pass		\n\
	abs = 0		=1 to take absolute value of 			\n\
			key header word					\n\
	j = 1		Pass every j-th trace ...			\n\
	s = 0		... based at s  (if ((key - s)%j) == 0)		\n\
	count = ULONG_MAX	... up to count traces			\n\
	bad = none	Delete traces with specified bad key		\n\
			values						\n\
...Options for vertical windowing (time gating):			\n\
	tmin = 0.0	min time to pass				\n\
	tmax = (from header)	max time to pass 			\n\
	itmin = 0	min time sample to pass				\n\
	itmax =	(from header)  max time sample to pass			\n\
	nt = itmax-itmin+1	number of time samples to pass		\n\
       				(nt=itmax-itmin+1)			\n\
									\n\
Note: selecting times beyond the maximum in the data induces		\n\
      zero padding (up to SU_NFLTS).					\n\
									\n\
	On most 32 bit machines, LONG_MIN, LONG_MAX and ULONG_MAX are	\n\
	about -2E9,+2E9 and 4E9 and are defined in general in limits.h	\n\
d49 2
a50 2
 *	SEP: Einar
 *	CWP: Shuki, Jack, Chris
d53 3
a55 3
 *	On large data sets, the count parameter should be set
 *	if possible.  Otherwise, every trace in the data set
 *	will be examined.
d58 1
a58 1
 *	A cast to int is made for the s,j selection branch.
d66 26
a91 32
	String key;	/* header key word from segy.h		*/
	Value val;	/* value of key				*/
	int ival;	/* ... cast to int			*/
	String type;	/* type of key				*/
	int index;	/* index of key				*/
	long min;	/* smallest key value to accept		*/
	long max;	/* largest key value to accept		*/
	int j;		/* take every jth trace ...		*/
	int s;		/* ... starting at the sth trace ...	*/
	unsigned
	 long count;	/* ... up to a total of count traces	*/
	Value *badptr;	/* pointer to list of bad traces	*/
	Mixed mbadptr;	/* to arbitrate bad with getpars	*/
	unsigned
	 int nbad;	/* number of bad traces			*/
	Bool isbad;	/* flag for bad trace			*/
	short ab;	/* absolute value flag (1=YES, 0=NO)	*/
	float tmin;	/* minimum time to pass			*/
	float tmax;	/* maximum time to pass			*/
	float dt;	/* sampling rate (secs)			*/
	int itmin;	/* smallest time sample (zero-based)	*/
	int itmax;	/* largest time sample (zero-based)	*/
	unsigned
	 int nt;	/* number of time samples		*/
	int nzeros;	/* number of zeroes to pad		*/
	char *pzeros;	/* pointer to zero pad			*/
	short verbose;	/* if 1(yes) echo parameters to stderr	*/
	register int i;	/* counter				*/
	void mallocmix();	/* PARMS(Mixed *, char *, uint)		*/
	void getparval();	/* PARMS(char *, char *, Value *)	*/
	void mixtoval();	/* PARMS(value, Mixed, char *, uint)	*/
	Value valtoabs();	/* PARMS(char *, value)			*/
d94 3
a96 3
	/* Initialize */
	initargs(argc, argv);
	askdoc(1);
d99 9
a107 9
	/* Default parameters;	User-defined overrides */
	if (!getparstring("key"     , &key))		key = "tracl";
	if (!getparlong("min"     , &min))		min = INT_MIN;
	if (!getparlong("max"     , &max))		max = INT_MAX;
	if (!getparint("j"       , &j))			j = 1;
	if (!getparint("s"       , &s))			s = 0;
	if (!getparulong("count"   , &count))		count = ULONG_MAX;
	if (!getparshort("abs"     , &ab))		ab = 0;
	if (!getparshort("verbose" , &verbose))		verbose = 0;
d109 2
a110 2
	type = hdtype(key);
	index = getindex(key);
d113 4
a116 4
	/* Getpar the bad vector--need a pointer of the specific type  */
	if (nbad = countparval("bad")) {
		mallocmix(&mbadptr, type, nbad);
		getparval("bad", type, mbadptr);
d118 6
a123 6
		/* Get pointer to value from mixed pointer */
		if (NULL == (badptr = (Value *)
			malloc((unsigned int) (nbad*sizeof(Value)))))
			err("malloc failed");
		mixtoval(badptr, mbadptr, type, nbad);
	}
d126 3
a128 3
	/* Evaluate time bounds from getpars and first header */
	if (!gettr(&tr)) err("can't get first trace");
	dt = 0.000001*tr.dt;
a129 6
	if (!getparint("itmin", &itmin))	itmin = 0;
	if (getparfloat("tmin", &tmin)) {
		itmin = tmin/dt;
	} else {
		tmin = itmin*dt;
	}
d131 16
a146 6
	if (!getparint("itmax", &itmax))	itmax = tr.ns - 1;
	if (getparfloat("tmax", &tmax)) {
		itmax = tmax/dt;
	} else {
		tmax = itmax*dt;
	}
a147 6
	if (getparushort("nt", &nt)) {
		itmax = itmin + nt - 1;
		tmax = itmax*dt;
	} else {
		nt = itmax - itmin + 1;
	}
d149 10
a158 6
	if (itmin < 0)
		err("itmin=%d should be positive", itmin);
	if (nt > SU_NFLTS)
		err("nt=%d exceeds SU_NFLTS=%d", nt, SU_NFLTS);
	if (itmin > itmax)
		err("itmin=%d, itmax=%d conflict", itmin, itmax);
d160 1
a160 2
	nzeros = (nt - tr.ns) * FSIZE;
	pzeros = (char *) (tr.data + tr.ns - itmin);
d162 1
a162 20
	/* Echo parameters */
	if (verbose) {
		warn("key = %s", key);
		warn("type = %s", type);
		warn("min = %ld", min);
		warn("max = %ld", max);
		warn("j = %d", j);
		warn("s = %d", s);
		warn("count = %lu", count);
		warn("abs = %d", ab);
		for (i = 0; i < nbad; i++) {
			(void) fprintf(stderr, "badptr[%d] = ", i);
			fprintfval(stderr, type, badptr[i]);
			putc('\n', stderr);
		}
		warn("tmin=%f tmax=%f", tmin, tmax);
		warn("itmin=%d itmax=%d nt=%u",
						itmin, itmax, nt);
		if (nzeros) warn("Padding %d zeroes", nzeros/FSIZE);
	}
d164 7
a171 11
	/* Main loop over traces */
	do {
		/* Time window */
		if (itmin > 0) {
			for (i = itmin; i <= itmax; i++) {
				tr.data[i - itmin] = tr.data[i];
			}
		}
		if (nzeros > 0) bzero(pzeros, nzeros);
		tr.ns = nt;
		tr.delrt = tmin*1000.0;
d173 1
a173 24
		/* Trace window */
		gethval(&tr, index, &val);
		isbad = false;
		for (i = 0; i < nbad; i++) {
			if (!valcmp(type, val, badptr[i])) {
				isbad = true;
				break;	/* found */
			}
		}

		if (ab) val = valtoabs(type, val);

		ival = vtoi(type, val);

		/* If trace selected, put it out */
		if ((min <= ival) && (ival <= max) &&
		   !((ival - s) % j) && !isbad && count--) {
			puttr(&tr);
			if (!count) break; /* all done */
		}
	} while (gettr(&tr));


	return EXIT_SUCCESS;
d183 44
a226 44
	switch(*type) {
	case 's':
		if (NULL == (mptr->s =
			 (char *) malloc((unsigned int) (n * DSIZE))))
			err("mallocmix failed on type %s", type);
	break;
	case 'h':
		if (NULL == (mptr->h = (short *) malloc(n * sizeof(short))))
			err("mallocmix failed on type %s", type);
	break;
	case 'u':
		if (NULL == (mptr->u = (unsigned short *)
			 malloc(n * sizeof(unsigned short))))
			err("mallocmix failed on type %s", type);
	break;
	case 'l':
		if (NULL == (mptr->l = (long *) malloc(n * sizeof(long))))
			err("mallocmix failed on type %s", type);
	break;
	case 'v':
		if (NULL == (mptr->v =
			 (unsigned long *) malloc(n * sizeof(unsigned long))))
			err("mallocmix failed on type %s", type);
	break;
	case 'i':
		if (NULL == (mptr->i = (int *) malloc(n * sizeof(int))))
			err("mallocmix failed on type %s", type);
	break;
	case 'p':
		if (NULL == (mptr->p =
			 (unsigned int *) malloc(n * sizeof(unsigned int))))
			err("mallocmix failed on type %s", type);
	break;
	case 'f':
		if (NULL == (mptr->f = (float *) malloc(n * sizeof(float))))
			err("mallocmix failed on type %s", type);
	break;
	case 'd':
		if (NULL == (mptr->d = (double *) malloc(n * sizeof(double))))
			err("mallocmix failed on type %s", type);
	default:
		err("mallocmix: %d: mysterious type %s", __LINE__, type);
	}
	return;
d236 13
a248 13
	switch(*type) {
	case 's': getparstring(name, (char**) valp);		break;
	case 'h': getparshort(name, (short*) valp);		break;
	case 'u': getparushort(name, (unsigned short*) valp);	break;
	case 'l': getparlong(name, (long*) valp);		break;
	case 'v': getparulong(name, (unsigned long*) valp);	break;
	case 'i': getparint(name, (int*) valp);			break;	
	case 'p': getparuint(name, (unsigned int*) valp);	break;
	case 'f': getparfloat(name, (float*) valp);		break;	
	case 'd': getpardouble(name, (double*) valp);		break;	
	default:
		err("getparval: %d: mysterious type %s", __LINE__, type);
	}
d259 1
a259 1
	register int i;
d261 47
a307 47
	switch(*type) {
	case 'h':
		for (i = 0; i < n; i++) {
			(valp++)->h = *mixptr.h++;
		}
	break;
	case 'u':
		for (i = 0; i < n; i++) {
			(valp++)->u = *mixptr.u++;
		}
	break;
	case 'l':
		for (i = 0; i < n; i++) {
			(valp++)->l = *mixptr.l++;
		}
	break;
	case 'v':
		for (i = 0; i < n; i++) {
			(valp++)->v = *mixptr.v++;
		}
	break;
	case 'i':
		for (i = 0; i < n; i++) {
			(valp++)->i = *mixptr.i++;
		}
	break;
	case 'p':
		for (i = 0; i < n; i++) {
			(valp++)->p = *mixptr.p++;
		}
	break;
	case 'f':
		for (i = 0; i < n; i++) {
			(valp++)->f = *mixptr.f++;
		}
	break;
	case 'd':
		for (i = 0; i < n; i++) {
			(valp++)->d = *mixptr.d++;
		}
	break;
	default:
		err("mixtoval: %d: mysterious type %s", __LINE__, type);
	break;
	}
	return;
}
d315 23
a337 23
	switch(*type) {
	case 'u': 	/* do nothing if unsigned */
	case 'v':
	case 'p':
	break;
	case 'h':
		val.h = ABS(val.h);
	break;
	case 'l':
		val.l = ABS(val.l);
	break;
	case 'i':
		val.i = ABS(val.i);
	break;
	case 'f':
		val.f = ABS(val.f);
	break;
	case 'd':
		val.d = ABS(val.d);
	break;
	default:
		err("valtoabs: %d: mysterious type %s", __LINE__, type);
	}
d339 1
a339 1
	return val;
@


1.7
log
@Get rid of ushort, etc.
@
text
@d1 1
a1 1
/* SUWIND: $Revision: 1.6 $ ; $Date: 91/09/05 08:52:31 $		*/
d119 3
a121 3
	if (!getparint("j"       , &j))		j = 1;
	if (!getparint("s"       , &s))		s = 0;
	if (!getparulong("count"   , &count))	count = ULONG_MAX;
d123 1
a123 1
	if (!getparshort("verbose" , &verbose))	verbose = 0;
d137 1
a137 1
		err("malloc failed");
a241 1

@


1.6
log
@string -> String and so forth
@
text
@d1 1
a1 1
/* SUWIND: $Revision: 1.5 $ ; $Date: 91/05/10 15:42:52 $		*/
d89 2
a90 1
	uint nbad;	/* number of bad traces			*/
d319 1
a319 1
uint n;
@


1.5
log
@Tweaks to improve ansi C compatibility
@
text
@d1 1
a1 1
/* SUWIND: $Revision: 1.4 $ ; $Date: 91/05/10 14:22:07 $		*/
d20 1
a20 1
string sdoc = "\
d76 2
a77 2
	string key;	/* header key word from segy.h		*/
	value val;	/* value of key				*/
d79 1
a79 1
	string type;	/* type of key				*/
d85 4
a88 3
	ulong count;	/* ... up to a total of count traces	*/
	value *badptr;	/* pointer to list of bad traces	*/
	mixed mbadptr;	/* to arbitrate bad with getpars	*/
d90 1
a90 1
	bool isbad;	/* flag for bad trace			*/
d97 2
a98 1
	ushort nt;	/* number of time samples		*/
d103 4
a106 4
	void mallocmix();	/* PARMS(mixed *, char *, uint)		*/
	void getparval();	/* PARMS(char *, char *, value *)	*/
	void mixtoval();	/* PARMS(value, mixed, char *, uint)	*/
	value valtoabs();	/* PARMS(char *, value)			*/
d134 2
a135 2
		if (NULL == (badptr = (value *)
			malloc((uint) (nbad*sizeof(value)))))
d239 4
a242 3
mixed *mptr;
string type;
uint n;
d246 2
a247 1
		if (NULL == (mptr->s = (char *) malloc((uint) (n * DSIZE))))
d255 2
a256 1
		if (NULL == (mptr->u = (ushort *) malloc(n * sizeof(ushort))))
d264 2
a265 1
		if (NULL == (mptr->v = (ulong *) malloc(n * sizeof(ulong))))
d273 2
a274 1
		if (NULL == (mptr->p = (uint *) malloc(n * sizeof(uint))))
d293 3
a295 3
string name;
string type;
value *valp;
d315 3
a317 3
value *valp;
mixed mixptr;
string type;
d372 3
a374 3
value valtoabs(type, val)
string type;
value val;
@


1.4
log
@fixed getparval--somehow breaks got left out in the editor, I guess.
@
text
@d1 1
a1 1
/* SUWIND: $Revision: 1.3 $ ; $Date: 90/09/03 09:56:48 $		*/
d247 1
a247 2
		if (NULL == (mptr->h = (short *)
			malloc((uint) (n * sizeof(short)))))
d251 1
a251 2
		if (NULL == (mptr->u = (ushort *)
			malloc((uint) (n * sizeof(ushort)))))
d255 1
a255 2
		if (NULL == (mptr->l = (long *)
			malloc((uint) (n * sizeof(long)))))
d259 1
a259 2
		if (NULL == (mptr->v = (ulong *)
			malloc((uint) (n * sizeof(ulong)))))
d263 1
a263 2
		if (NULL == (mptr->i = (int *)
			malloc((uint) (n * sizeof(int)))))
d267 1
a267 2
		if (NULL == (mptr->p = (uint *)
			malloc((uint) (n * sizeof(uint)))))
d271 1
a271 2
		if (NULL == (mptr->f = (float *)
			malloc((uint) (n * sizeof(float)))))
d275 1
a275 2
		if (NULL == (mptr->d = (double *)
			malloc((uint) (n * sizeof(double)))))
d291 9
a299 9
	case 's': getparstring(name, valp);	break;
	case 'h': getparshort(name, valp);	break;
	case 'u': getparushort(name, valp);	break;
	case 'l': getparlong(name, valp);	break;
	case 'v': getparulong(name, valp);	break;
	case 'i': getparint(name, valp);	break;
	case 'p': getparuint(name, valp);	break;
	case 'f': getparfloat(name, valp);	break;
	case 'd': getpardouble(name, valp);	break;
@


1.3
log
@New getpar names.
@
text
@d1 1
a1 1
/* SUWIND: $Revision: 1.2 $ ; $Date: 90/05/30 14:09:34 $		*/
d299 9
a307 9
	case 's': getparstring(name, valp);
	case 'h': getparshort(name, valp);
	case 'u': getparushort(name, valp);
	case 'l': getparlong(name, valp);
	case 'v': getparulong(name, valp);
	case 'i': getparint(name, valp);
	case 'p': getparuint(name, valp);
	case 'f': getparfloat(name, valp);
	case 'd': getpardouble(name, valp);
@


1.2
log
@Fixed countparval logic.
@
text
@d1 1
a1 1
/* SUWIND: $Revision: 1.1 $ ; $Date: 90/05/29 19:38:19 $		*/
d113 8
a120 8
	if (!sgetpar("key"     , &key))		key = "tracl";
	if (!lgetpar("min"     , &min))		min = INT_MIN;
	if (!lgetpar("max"     , &max))		max = INT_MAX;
	if (!igetpar("j"       , &j))		j = 1;
	if (!igetpar("s"       , &s))		s = 0;
	if (!vgetpar("count"   , &count))	count = ULONG_MAX;
	if (!hgetpar("abs"     , &ab))		ab = 0;
	if (!hgetpar("verbose" , &verbose))	verbose = 0;
d134 1
a134 1
		syserr("malloc failed");
d143 2
a144 2
	if (!igetpar("itmin", &itmin))	itmin = 0;
	if (fgetpar("tmin", &tmin)) {
d150 2
a151 2
	if (!igetpar("itmax", &itmax))	itmax = tr.ns - 1;
	if (fgetpar("tmax", &tmax)) {
d157 1
a157 1
	if (ugetpar("nt", &nt)) {
d299 9
a307 9
	case 's': sgetpar(name, valp);
	case 'h': hgetpar(name, valp);
	case 'u': ugetpar(name, valp);
	case 'l': lgetpar(name, valp);
	case 'v': vgetpar(name, valp);
	case 'i': igetpar(name, valp);
	case 'p': pgetpar(name, valp);
	case 'f': fgetpar(name, valp);
	case 'd': dgetpar(name, valp);
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/* SUWIND: $Revision: 2.17 $ ; $Date: 89/06/16 13:32:25 $		*/
d127 3
a129 3
	nbad = countparval("bad");	/* length of bad vector */
	mallocmix(&mbadptr, type, nbad);
	getparval("bad", type, mbadptr);
d131 2
a132 3

	/* Get pointer to value from mixed pointer */
	if (NULL == (badptr = (value *)
d135 2
a136 1
	mixtoval(badptr, mbadptr, type, nbad);
@
