head	1.48;
access;
symbols;
locks; strict;
comment	@ * @;


1.48
date	2011.11.12.00.22.43;	author john;	state Exp;
branches;
next	1.47;

1.47
date	2011.09.09.22.31.59;	author john;	state Exp;
branches;
next	1.46;

1.46
date	2003.06.09.16.17.07;	author john;	state Exp;
branches;
next	1.45;

1.45
date	2000.09.22.17.36.08;	author john;	state Exp;
branches;
next	1.44;

1.44
date	97.07.28.22.36.46;	author john;	state Exp;
branches;
next	1.43;

1.43
date	96.09.04.22.54.00;	author jkc;	state Exp;
branches;
next	1.42;

1.42
date	96.01.23.22.44.50;	author jkc;	state Exp;
branches;
next	1.41;

1.41
date	95.08.04.16.38.29;	author jkc;	state Exp;
branches;
next	1.40;

1.40
date	94.08.25.14.58.45;	author jkc;	state Exp;
branches;
next	1.39;

1.39
date	94.07.15.14.05.40;	author john;	state Exp;
branches;
next	1.38;

1.38
date	93.11.29.14.10.27;	author john;	state Exp;
branches;
next	1.37;

1.37
date	93.11.24.15.11.22;	author john;	state Exp;
branches;
next	1.36;

1.36
date	93.11.24.12.53.16;	author john;	state Exp;
branches;
next	1.35;

1.35
date	93.11.24.11.39.05;	author john;	state Exp;
branches;
next	1.34;

1.34
date	93.11.24.11.22.46;	author john;	state Exp;
branches;
next	1.33;

1.33
date	93.08.09.15.19.11;	author john;	state Exp;
branches;
next	1.32;

1.32
date	92.12.11.10.34.40;	author john;	state Exp;
branches;
next	1.31;

1.31
date	92.10.22.16.46.27;	author john;	state Exp;
branches;
next	1.30;

1.30
date	92.04.23.15.25.23;	author john;	state Exp;
branches;
next	1.29;

1.29
date	91.09.17.12.52.32;	author jkcohen;	state Exp;
branches;
next	1.28;

1.28
date	91.09.05.08.49.25;	author jkcohen;	state Exp;
branches;
next	1.27;

1.27
date	90.12.23.23.54.18;	author jkc;	state Exp;
branches;
next	1.26;

1.26
date	90.12.23.09.47.39;	author jkc;	state Exp;
branches;
next	1.25;

1.25
date	90.12.22.18.34.53;	author jkc;	state Exp;
branches;
next	1.24;

1.24
date	90.12.20.09.25.09;	author jkc;	state Exp;
branches;
next	1.23;

1.23
date	90.12.19.18.30.11;	author jkc;	state Exp;
branches;
next	1.22;

1.22
date	90.12.19.18.18.23;	author jkc;	state Exp;
branches;
next	1.21;

1.21
date	90.12.15.21.25.14;	author jkc;	state Exp;
branches;
next	1.20;

1.20
date	90.12.15.20.25.23;	author jkc;	state Exp;
branches;
next	1.19;

1.19
date	90.12.15.20.13.59;	author jkc;	state Exp;
branches;
next	1.18;

1.18
date	90.12.15.19.35.25;	author jkc;	state Exp;
branches;
next	1.17;

1.17
date	90.11.15.10.43.21;	author jkc;	state Exp;
branches;
next	1.16;

1.16
date	90.07.16.22.17.29;	author jkc;	state Exp;
branches;
next	1.15;

1.15
date	90.07.16.21.02.58;	author jkc;	state Exp;
branches;
next	1.14;

1.14
date	90.07.06.15.20.58;	author jkc;	state Exp;
branches;
next	1.13;

1.13
date	90.07.02.13.39.30;	author jkc;	state Exp;
branches;
next	1.12;

1.12
date	90.06.29.16.12.43;	author jkc;	state Exp;
branches;
next	1.11;

1.11
date	90.06.28.17.33.04;	author jkc;	state Exp;
branches;
next	1.10;

1.10
date	90.06.28.12.49.36;	author jkc;	state Exp;
branches;
next	1.9;

1.9
date	90.06.28.10.24.18;	author jkc;	state Exp;
branches;
next	1.8;

1.8
date	90.06.28.08.14.06;	author jkc;	state Exp;
branches;
next	1.7;

1.7
date	90.06.28.06.42.25;	author jkc;	state Exp;
branches;
next	1.6;

1.6
date	90.06.28.00.03.01;	author jkc;	state Exp;
branches;
next	1.5;

1.5
date	90.06.05.15.51.15;	author jkc;	state Exp;
branches;
next	1.4;

1.4
date	90.05.23.10.07.47;	author jkc;	state Exp;
branches;
next	1.3;

1.3
date	90.05.23.09.21.14;	author jkc;	state Exp;
branches;
next	1.2;

1.2
date	90.05.22.16.02.19;	author jkc;	state Exp;
branches;
next	1.1;

1.1
date	90.04.16.14.28.44;	author jkc;	state Exp;
branches;
next	;


desc
@Add noise to synthetic traces
@


1.48
log
@copyright
@
text
@/* Copyright (c) Colorado School of Mines, 2011.*/
/* All rights reserved.                       */

/* SUADDNOISE: $Revision: 1.47 $ ; $Date: 2011/09/09 22:31:59 $		*/

#include "su.h"
#include "segy.h"
#include "header.h"
#include <time.h>
#include <signal.h>

/*********************** self documentation ******************************/
char *sdoc[] = {
" 									",
" SUADDNOISE - add noise to traces					",
" 									",
" suaddnoise <stdin >stdout  sn=20  noise=gauss  seed=from_clock	",
" 									",
" Required parameters:							",
" 	if any of f=f1,f2,... and amp=a1,a2,... are specified by the user",
"	and if dt is not set in header, then dt is mandatory		",
" 									",
" Optional parameters:							",
" 	sn=20			signal to noise ratio			",
" 	noise=gauss		noise probability distribution		",
" 				=flat for uniform; default Gaussian	",
" 	seed=from_clock		random number seed (integer)		",
"	f=f1,f2,...		array of filter frequencies (as in sufilter)",
"	amps=a1,a2,...		array of filter amplitudes		",
" 	dt= (from header)	time sampling interval (sec)		",
"	verbose=0		=1 for echoing useful information	",
" 									",
" 	tmpdir=	 if non-empty, use the value as a directory path	",
"		 prefix for storing temporary files; else if the	",
"	         the CWP_TMPDIR environment variable is set use		",
"	         its value for the path; else use tmpfile()		",
" 									",
" Notes:								",
" Output = Signal +  scale * Noise					",
" 									",
" scale = (1/sn) * (absmax_signal/sqrt(2))/sqrt(energy_per_sample)	",
" 									",
" If the signal is already band-limited, f=f1,f2,... and amps=a1,a2,...	",
" can be used, as in sufilter, to bandlimit the noise traces to match	",
" the signal band prior to computing the scale defined above.		",
" 									",
" Examples of noise bandlimiting:					",
" low freqency:    suaddnoise < data f=40,50 amps=1,0 | ...		",
" high freqency:   suaddnoise < data f=40,50 amps=0,1 | ...		",
" near monochromatic: suaddnoise < data f=30,40,50 amps=0,1,0 | ...	",
" with a notch:    suaddnoise < data f=30,40,50 amps=1,0,1 | ...	",
" bandlimited:     suaddnoise < data f=20,30,40,50 amps=0,1,1,0 | ...	",
" 									",
NULL};

/* Credits:
 *	CWP: Jack Cohen, Brian Sumner, Ken Larner
 *		John Stockwell (fixed filtered noise option)
 *
 * Notes:
 *	At S/N = 2, the strongest reflector is well delineated, so to
 *	see something 1/nth as strong as this dominant reflector
 *	requires S/N = 2*n.
 *
 * Trace header field accessed: ns
 */

/**************** end self doc *******************************************/

/* Default signal to noise ratio */
#define SN	20

/* Noise probability distributions */
#define	GAUSS	0
#define	FLAT	1


/* Prototype */
static void closefiles(void);

/* Globals (so can trap signal) defining temporary disk files */
char tracefile[BUFSIZ];	/* filename for the file of traces	*/
char headerfile[BUFSIZ];/* filename for the file of headers	*/
FILE *tracefp;		/* fp for trace storage file		*/
FILE *headerfp;		/* fp for header storage file		*/
static char bandoutfile[L_tmpnam];  /* output file for sufilter	*/
static FILE *bandoutfp;		    /* fp for output file	*/


segy tr;

int
main(int argc, char **argv)
{
	int nt;			/* number of points on trace		*/
	unsigned long databytes;/* ... in bytes 			*/
	int ntr;		/* number of traces			*/
	int verbose;		/* flag for echoing info		*/
	cwp_String stype;	/* noise type (gauss, flat) as string	*/
	int itype=GAUSS;	/* ... as integer (for use in switch)	*/
	float sn;		/* signal to noise ratio		*/
	time_t seed_time;       /* random number seed                   */
	unsigned int seed;	/* random number seed			*/
	int nfloats;		/* number of floats in "signal"		*/
	float *noise;		/* noise vector				*/
	float noiscale;		/* scale for noise			*/
	float absmaxsig;	/* absolute maximum in signal		*/
	float noipow;		/* a measure of noise power		*/
	cwp_String f="";	/* frequency input for sufilter		*/
	cwp_String amps="";	/* amplitude input for sufilter		*/
	char *tmpdir;		/* directory path for tmp files		*/
	cwp_Bool istmpdir=cwp_false;/* true for user given path		*/

	/* Initialize */
	initargs(argc, argv);
	requestdoc(1);

	/* Get parameters */
	if (!getparint("verbose", &verbose))	verbose = 0;

	/* Look for user-supplied tmpdir */
	if (!getparstring("tmpdir",&tmpdir) &&
	    !(tmpdir = getenv("CWP_TMPDIR"))) tmpdir="";
	if (!STREQ(tmpdir, "") && access(tmpdir, WRITE_OK))
		err("you can't write in %s (or it doesn't exist)", tmpdir);

		
	/* Get noise type */
	if (!getparstring("noise", &stype))	stype = "gauss";

	/* Recall itype initialized as GAUSS */
	if (STREQ(stype, "flat"))  itype = FLAT;
	else if (!STREQ(stype, "gauss"))
		err("noise=\"%s\", must be gauss or flat", stype);


	/* Get signal to noise ratio */
	if (!getparfloat("sn", &sn))	sn = SN;
	if (sn <= 0) err("sn=%d must be positive", sn);


	/* Set seed */
	if (!getparuint("seed", &seed)) { /* if not supplied, use clock */
	  if (((time_t)-1) == (seed_time = time((time_t *) NULL))) {
	     err("time() failed to set seed");
	     seed = 0;
	  }
	  else {
	     seed = (unsigned int)seed_time;
	  }
	}
	(itype == GAUSS) ? srannor(seed) : sranuni(seed);

	/* Prepare temporary files to hold headers and data */
	if (STREQ(tmpdir,"")) {
		tracefp = etmpfile();
		headerfp = etmpfile();
		if (verbose) warn("using tmpfile() call");
	} else { /* user-supplied tmpdir */
		char directory[BUFSIZ];
		strcpy(directory, tmpdir);
		strcpy(tracefile, temporary_filename(directory));
		strcpy(headerfile, temporary_filename(directory));
		/* Trap signals so can remove temp files */
		signal(SIGINT,  (void (*) (int)) closefiles);
		signal(SIGQUIT, (void (*) (int)) closefiles);
		signal(SIGHUP,  (void (*) (int)) closefiles);
		signal(SIGTERM, (void (*) (int)) closefiles);
		tracefp = efopen(tracefile, "w+");
		headerfp = efopen(headerfile, "w+");
      		istmpdir=cwp_true;		
		if (verbose) warn("putting temporary files in %s", directory);
	}

	/* Get info from first trace */
	if (!gettr(&tr)) err("can't get first trace");
	nt = tr.ns;
	databytes = nt * FSIZE;


	/* Loop over input traces & write headers and data to tmp files */
	ntr = 0;
	do {
		++ntr;
		efwrite(&tr, 1, HDRBYTES, headerfp);
		efwrite(tr.data, 1, databytes, tracefp);
	} while (gettr(&tr));
	nfloats = ntr * nt;


	/* Compute absmax of signal over entire data set */
	rewind(tracefp);
	absmaxsig = 0.0;
	{ register int i;
	  for (i = 0; i < nfloats; ++i) {
		float sigval;
		efread(&sigval, FSIZE, 1, tracefp);
		absmaxsig = MAX(absmaxsig, ABS(sigval));
	  }
	}


	/* Compute noise vector elements in [-1, 1] */
	noise = ealloc1float(nfloats);
	switch (itype) {
		register int i;
	case GAUSS: /* frannor gives elements in N(0,1)--ie. pos & negs */
		for (i = 0; i < nfloats; ++i)  noise[i] = frannor();
	break;
	case FLAT: /* franuni gives elements in [0, 1] */
		for (i = 0; i < nfloats; ++i)  noise[i] = 2.0*franuni() - 1.0;
	break;
	default:	/* defensive programming */
		err("%d: mysterious itype = %d", __LINE__, itype);
	}


	/* Band limit noise traces if user getpars any of the f's */
	getparstring("f",&f);   /* get filter frequencies */
	getparstring("amps",&amps);  /* get filter amplitudes */
	if ( (*f !='\0') || (*amps !='\0') ) {

		/* Set up call to sufilter */
		char cmdbuf[BUFSIZ];	    /* build sufilter command	*/
		FILE *bandinfp;		    /* fp for input file	*/
		FILE *fp;                   /* fp for pipe to sufilter	*/
		unsigned long nsegy = HDRBYTES + databytes;
		char *segybuf = ealloc1(nsegy, 1);


		/* Trap signals so can remove temp files */
		signal(SIGINT,  (void (*) (int)) closefiles);
		signal(SIGQUIT, (void (*) (int)) closefiles);
		signal(SIGHUP,  (void (*) (int)) closefiles);
		signal(SIGTERM, (void (*) (int)) closefiles);


		/* Prepare temporary files to hold traces */
		bandinfp  = etmpfile();
		bandoutfp = efopen(tmpnam(bandoutfile), "w+");

		/* Paste headers on noise traces and put in tmpfile */
		rewind(headerfp);
		{ register int itr;
		  for (itr = 0; itr < ntr; ++itr) {
			efread(&tr, 1, HDRBYTES, headerfp);
			memcpy((void *) tr.data,
				(const void *)(noise + itr*nt), databytes); 
			fputtr(bandinfp, &tr);
		  }
		}

		/* build cmdbuf ; append sufilter command */
		sprintf(cmdbuf, "sufilter >%s", bandoutfile);

		/* loop through command line args and pass on to cmdbuf */
        	for (--argc, ++argv; argc; --argc, ++argv) {
			/* don't pass sn=, seed=, noise= */
			if ( strncmp(*argv,"sn=",3) &&
			     strncmp(*argv,"seed=",5) &&
			     strncmp(*argv,"noise=",6) ) {
                          strcat(cmdbuf, " ");   /* append a space */
                          strcat(cmdbuf, *argv); /* append the next arg */
			}
        	}

		fp = epopen(cmdbuf, "w");
		rewind (bandinfp);
		{ register int itr;
		  for (itr = 0; itr < ntr; ++itr) {
			efread(segybuf, 1, nsegy, bandinfp);
			efwrite(segybuf, 1, nsegy, fp);
		  }
		}
		efclose(bandinfp);
		epclose(fp);

		/* Load bandlimited traces back into noise vector */
		rewind(bandoutfp);
		{ register int itr;
		  for (itr = 0; itr < ntr; ++itr) {
			fgettr(bandoutfp, &tr);
			memcpy((void *) (noise + itr*nt),
					(const void *) tr.data, databytes); 
		  }
		}
		efclose(bandoutfp);
		eremove(bandoutfile);

	} /* End optional bandlimiting */
		


	/* Compute noise power */
	noipow = 0.0;
	{ register int i;
	  for (i = 0; i < nfloats; ++i) {
		register float noiseval = noise[i];
		noipow += noiseval * noiseval;
	  }
	}


	/* Compute noise scale for desired noise/signal ratio */
	absmaxsig /= sqrt(2.0);  /* make it look like a rmsq value   */
	noipow /= nfloats;	 /* make it the square of rmsq value */
        if( absmaxsig != 0.0 ){
	   noiscale = absmaxsig / (sn * sqrt(noipow));
        }else{
           noiscale = 1.0;
        }


	/* Add scaled noise to trace and output sum */
	rewind(headerfp);
	rewind(tracefp);
	{ register int itr;
	  for (itr = 0; itr < ntr; ++itr) {
		register int trshift = itr*nt;
		register int i;

		efread(&tr, 1, HDRBYTES, headerfp);
		efread(tr.data, 1, databytes, tracefp);
		for (i = 0; i < nt; ++i)
			tr.data[i] += noiscale * noise[trshift + i];

		puttr(&tr);
	  }
	}

	/* Clean up */
	efclose(headerfp);
	if (istmpdir) eremove(headerfile);
	efclose(tracefp);
	if (istmpdir) eremove(tracefile);

	return(CWP_Exit());
}

/* for graceful interrupt termination */
static void closefiles(void)
{
	efclose(headerfp);
	efclose(tracefp);
	eremove(headerfile);
	eremove(tracefile);
	efclose(bandoutfp);
	eremove(bandoutfile);
	exit(EXIT_FAILURE);
}
@


1.47
log
@*** empty log message ***
@
text
@d1 4
a4 1
/* SUADDNOISE: $Revision: 1.46 $ ; $Date: 2003/06/09 16:17:07 $		*/
@


1.46
log
@9 June 2003
@
text
@d1 1
a1 1
/* SUADDNOISE: $Revision: 1.45 $ ; $Date: 2000/09/22 17:36:08 $		*/
d99 1
d141 7
a147 3
		if (-1 == (seed = (unsigned int) time((time_t *) NULL))) {
			err("time() failed to set seed");
		}
@


1.45
log
@fixed bug in noiscale parameter (error trapping thanks to Reg Beardsley
@
text
@d1 1
a1 1
/* SUADDNOISE: $Revision: 1.44 $ ; $Date: 1997/07/28 22:36:46 $		*/
d232 1
a232 1
		bandoutfp = efopen(etmpnam(bandoutfile), "w+");
d329 1
a329 1
	return EXIT_SUCCESS;
@


1.44
log
@changes suggested by Stew Levin to silence SGI compiler warnings, etc
@
text
@d1 1
a1 1
/* SUADDNOISE: $Revision: 1.43 $ ; $Date: 1996/09/04 22:54:00 $		*/
d299 5
a303 1
	noiscale = absmaxsig / (sn * sqrt(noipow));
@


1.43
log
@Added tmpdir stuff (and learned some signal stuff that should
be in the other tmpdir programs).  Fixed -Wall complaints.
In particular, USE the missing initialization of itype to
simplify the coding.
@
text
@d1 1
a1 1
/* SUADDNOISE: $Revision: 1.42 $ ; $Date: 1996/01/23 22:44:50 $		*/
d93 1
a93 1
	int databytes;		/* ... in bytes 			*/
d108 1
a108 1
	cwp_Bool istmpdir=false;/* true for user given path		*/
d163 1
a163 1
      		istmpdir=true;		
d219 1
a219 1
		int nsegy = HDRBYTES + databytes;
@


1.42
log
@Noted trace field accessed.
Fixed conditional statement that was munged in 1.32.
@
text
@d1 1
a1 1
/* SUADDNOISE: $Revision: 1.41 $ ; $Date: 1995/08/04 16:38:29 $		*/
d28 6
a61 4
 *	My (Jack's) understanding of "signal" has forced some declarations
 *	to be global that would otherwise be made in the local block
 *	that handles the band-limiting.
 *
d76 1
a76 1
static void trapsig(void);
d78 5
a82 1
/* Globals (so can trap signal) defining temporary disk file */
d89 1
d95 1
d97 1
a97 1
	int itype;		/* ... as integer (for use in switch)	*/
a99 2
	FILE *hdrfp;		/* fp for header storage file		*/
	FILE *sigfp;		/* fp for data ("signal")		*/
d107 2
d114 2
d117 7
d127 4
a130 3
	if      (STREQ(stype, "gauss")) itype = GAUSS;
	else if (STREQ(stype, "flat"))  itype = FLAT;
	else     err("noise=\"%s\", must be gauss or flat", stype);
d147 19
a165 3
	hdrfp = etmpfile();
	sigfp = etmpfile();

d177 2
a178 2
		efwrite(&tr, 1, HDRBYTES, hdrfp);
		efwrite(tr.data, 1, databytes, sigfp);
d184 1
a184 1
	rewind(sigfp);
d189 1
a189 1
		efread(&sigval, FSIZE, 1, sigfp);
d223 5
a227 5
		/* Trap signals so can remove tmpnam file */
		signal(SIGINT,  (void (*) (int)) trapsig);
		signal(SIGQUIT, (void (*) (int)) trapsig);
		signal(SIGHUP,  (void (*) (int)) trapsig);
		signal(SIGTERM, (void (*) (int)) trapsig);
d235 1
a235 1
		rewind(hdrfp);
d238 1
a238 1
			efread(&tr, 1, HDRBYTES, hdrfp);
d303 2
a304 2
	rewind(hdrfp);
	rewind(sigfp);
d310 2
a311 2
		efread(&tr, 1, HDRBYTES, hdrfp);
		efread(tr.data, 1, databytes, sigfp);
d319 5
d328 2
a329 4


/* Signal handler to remove tmpnam file */
static void trapsig(void)
d331 4
@


1.41
log
@Changed casts in signal() calls per Stew Levin
@
text
@d1 1
a1 1
/* SUADDNOISE: $Revision: 1.40 $ ; $Date: 1994/08/25 14:58:45 $		*/
d59 2
d126 1
a126 2
	if (itype == GAUSS) srannor(seed); 
			sranuni(seed);
@


1.40
log
@Removed copyright statement from codes that had it.
Moved self-doc line for sudoc.
@
text
@d1 1
a1 1
/* SUADDNOISE: $Revision: 1.39 $ ; $Date: 94/07/15 14:05:40 $		*/
d189 5
a193 4
		signal(SIGINT,  (void *) trapsig);
		signal(SIGQUIT, (void *) trapsig);
		signal(SIGHUP,  (void *) trapsig);
		signal(SIGTERM, (void *) trapsig);
@


1.39
log
@cosmetic
@
text
@d1 1
a1 1
/* SUADDNOISE: $Revision: 1.38 $ ; $Date: 93/11/29 14:10:27 $		*/
@


1.38
log
@revised cmdbuf to reject unneeded arguments.
@
text
@d1 1
a1 1
/* SUADDNOISE: $Revision: 1.37 $ ; $Date: 93/11/24 15:11:22 $		*/
a2 13
/*----------------------------------------------------------------------
 * Copyright (c) Colorado School of Mines, 1990.
 * All rights reserved.
 *
 * This code is part of SU.  SU stands for Seismic Unix, a processing line
 * developed at the Colorado School of Mines, partially based on Stanford
 * Exploration Project (SEP) software.  Inquiries should be addressed to:
 *
 *  Jack K. Cohen, Center for Wave Phenomena, Colorado School of Mines,
 *  Golden, CO 80401  (jkc@@dix.mines.colorado.edu)
 *----------------------------------------------------------------------
 */

a45 1
/**************** end self doc *******************************************/
d56 1
a56 1
 *	My understanding of "signal" has forced some declarations
d61 1
@


1.37
log
@further fixes... added stuff to selfdoc.
@
text
@d1 1
a1 1
/* SUADDNOISE: $Revision: 1.36 $ ; $Date: 93/11/24 12:53:16 $		*/
d222 1
a222 1
		/* Pipe to sufilter - sufilter handles the getpars */
d227 7
a233 2
                         strcat(cmdbuf, " ");   /* put a space between args */
                         strcat(cmdbuf, *argv); /* add the arg */
@


1.36
log
@fixed filtered noise option
uses sufilter now and actually works
@
text
@d1 1
a1 1
/* SUADDNOISE: $Revision: 1.35 $ ; $Date: 93/11/24 11:39:05 $		*/
d42 2
a43 2
" NOTES:								",
" 	Output = Signal +  scale * Noise				",
d45 1
a45 1
" 	scale = (1/sn) * (absmax_signal/sqrt(2))/sqrt(energy_per_sample)",
d47 3
a49 3
" 	If the signal is already band-limited, f=f1,f2,... and amps=a1,a2,...",
"	can be used, as in sufilter, to bandlimit the noise traces to match",
"	the signal band prior to computing the scale defined above.	",
d51 7
d62 2
a63 1
 *	CWP: Jack, Brian, Ken
d223 3
a225 2
		sprintf(cmdbuf, "sufilter f=%s amps=%s >%s",
			f , amps, bandoutfile);
a226 3
                 if (   strncmp(*argv, "f=", 2)  &&
			strncmp(*argv, "amps=", 5) ) {

a227 1
		 	 strcat(cmdbuf, "\"");  /* user quotes are stripped */
a228 2
		 	 strcat(cmdbuf, "\"");  /* user quotes are stripped */
               		}
@


1.35
log
@changed suband to sufilter
@
text
@d1 1
a1 1
/* SUADDNOISE: $Revision: 1.34 $ ; $Date: 93/11/24 11:22:46 $		*/
d30 2
a31 2
" 	if any of f1,f2,f3,f4 are specified by the user and if dt is	",
" 	not set in header, then dt is mandatory				",
d38 2
a39 5
" 							        	",
" 	f1=0.0			left  low  corner frequency (Hz)	",
" 	f2=0.0			left  high corner frequency (Hz)	",
" 	f3= nyquist		right low  corner frequency (Hz)	",
" 	f4= nyquist		right high corner frequency (Hz)	",
d47 3
a49 3
" 	If the signal is already band-limited, f1,f2,f3,f4 can be used	",
" 	as in sufilter to bandlimit the noise traces to match the signal",
" 	band prior to computing the scale defined above.		",
d91 1
a91 1
	cwp_String stype;		/* noise type (gauss, flat) as string	*/
d102 2
a103 4
	float f1;		/* left lower corner frequency		*/
	float f2;		/* left upper corner frequency		*/
	float f4;		/* right lower corner frequency		*/
	float f3;		/* right upper corner frequency		*/
a104 1

d181 3
a183 2
	if (getparfloat("f1", &f1) || getparfloat("f2", &f2) ||
	    getparfloat("f3", &f3) || getparfloat("f4", &f4) ) {
d215 13
a227 1
		sprintf(cmdbuf, "sufilter >%s", bandoutfile);
@


1.34
log
@added explicit casts in memcpy .
@
text
@d1 1
a1 1
/* SUADDNOISE: $Revision: 1.33 $ ; $Date: 93/08/09 15:19:11 $		*/
d51 1
a51 1
" 	as in suband to bandlimit the noise traces to match the signal	",
d83 1
a83 1
static char bandoutfile[L_tmpnam];  /* output file for suband	*/
d190 2
a191 2
		/* Set up call to suband */
		char cmdbuf[BUFSIZ];	    /* build suband command	*/
d193 1
a193 1
		FILE *fp;                   /* fp for pipe to suband	*/
d219 2
a220 2
		/* Pipe to suband - suband handles the getpars */
		sprintf(cmdbuf, "suband >%s", bandoutfile);
@


1.33
log
@changed String to cwp_String
@
text
@d1 1
a1 1
/* SUADDNOISE: $Revision: 1.32 $ ; $Date: 92/12/11 10:34:40 $		*/
d213 2
a214 1
			memcpy(tr.data, noise + itr*nt, databytes); 
d237 2
a238 1
			memcpy(noise + itr*nt, tr.data, databytes); 
@


1.32
log
@changed a conditional to an if, and made  trapsig type compatible with
its prototype.
@
text
@d1 1
a1 1
/* SUADDNOISE: $Revision: 1.31 $ ; $Date: 92/10/22 16:46:27 $		*/
d94 1
a94 1
	String stype;		/* noise type (gauss, flat) as string	*/
@


1.31
log
@new selfdoc installed
@
text
@d1 1
a1 1
/* SUADDNOISE: $Revision: 1.30 $ ; $Date: 92/04/23 15:25:23 $		*/
d135 2
a136 1
	(itype == GAUSS) ? srannor(seed) : sranuni(seed);
a137 1

d286 1
a286 1
void trapsig(void)
@


1.30
log
@*** empty log message ***
@
text
@d1 1
a1 1
/* SUADDNOISE: $Revision: 1.29 $ ; $Date: 91/09/17 12:52:32 $		*/
d23 32
a54 32
String sdoc =
" 									\n"
" SUADDNOISE - add noise to traces					\n"
" 									\n"
" suaddnoise <stdin >stdout  sn=20  noise=gauss  seed=from_clock	\n"
" 									\n"
" Required parameters:							\n"
" 	if any of f1,f2,f3,f4 are specified by the user and if dt is	\n"
" 	not set in header, then dt is mandatory				\n"
" 									\n"
" Optional parameters:							\n"
" 	sn=20			signal to noise ratio			\n"
" 	noise=gauss		noise probability distribution		\n"
" 				=flat for uniform; default Gaussian	\n"
" 	seed=from_clock		random number seed (integer)		\n"
" 							        	\n"
" 	f1=0.0			left  low  corner frequency (Hz)	\n"
" 	f2=0.0			left  high corner frequency (Hz)	\n"
" 	f3= nyquist		right low  corner frequency (Hz)	\n"
" 	f4= nyquist		right high corner frequency (Hz)	\n"
" 	dt= (from header)	time sampling interval (sec)		\n"
" 									\n"
" NOTES:								\n"
" 	Output = Signal +  scale * Noise				\n"
" 									\n"
" 	scale = (1/sn) * (absmax_signal/sqrt(2))/sqrt(energy_per_sample)\n"
" 									\n"
" 	If the signal is already band-limited, f1,f2,f3,f4 can be used	\n"
" 	as in suband to bandlimit the noise traces to match the signal	\n"
" 	band prior to computing the scale defined above.		\n"
" 									\n"
;
d113 1
a113 1
	askdoc(1);
@


1.29
log
@Get rid of ushort, etc.
@
text
@d1 1
a1 1
/* SUADDNOISE: $Revision: 1.28 $ ; $Date: 91/09/05 08:49:25 $		*/
@


1.28
log
@string -> String and so forth
@
text
@d1 1
a1 1
/* SUADDNOISE: $Revision: 1.27 $ ; $Date: 90/12/23 23:54:18 $		*/
d131 1
a131 1
		if (-1 == (seed = (uint) time((time_t *) NULL))) {
@


1.27
log
@Added more sigs and did a safety first rewind of bandoutfp in
light of problem with suedit.
@
text
@d1 1
a1 1
/* SUADDNOISE: $Revision: 1.26 $ ; $Date: 90/12/23 09:47:39 $		*/
d23 1
a23 1
string sdoc =
d94 1
a94 1
	string stype;		/* noise type (gauss, flat) as string	*/
@


1.26
log
@Avoid computation in final double loop and updated comments
about random number generation.
@
text
@d1 1
a1 1
/* SUADDNOISE: $Revision: 1.25 $ ; $Date: 90/12/22 18:34:53 $		*/
d199 3
a201 1
		signal(SIGINT, (void *) trapsig);
d205 1
a205 1
		bandinfp = etmpfile();
d232 1
@


1.25
log
@Uses fp version of fgettr.
Also caught bug introduced in 1.21 in adding noise to
traces wherein, I kept adding noise[i] instead of noise[i + itr*nt]
@
text
@d1 1
a1 1
/* SUADDNOISE: $Revision: 1.24 $ ; $Date: 90/12/20 09:25:09 $		*/
d36 1
a36 1
" 				= flat for uniform; default Gaussian	\n"
d171 1
a171 1
	/* Compute noise vector elements */
d175 1
a175 1
	case GAUSS: /* elements in N[0,1] */
d178 1
a178 1
	case FLAT: /* elements in [-1, 1] */
d264 1
d270 1
a270 1
			tr.data[i] += noiscale * noise[itr*nt + i];
@


1.24
log
@Added signals to remove tmpnam file on termination.
@
text
@d1 1
a1 1
/* SUADDNOISE: $Revision: 1.23 $ ; $Date: 90/12/19 18:30:11 $		*/
a84 1
static int bandoutfd;		    /* ... its file id		*/
d153 2
a154 2
		efwrite(&tr, HDRBYTES, 1, hdrfp);
		efwrite(tr.data, databytes, 1, sigfp);
a158 4
	/* Allocate room for noise vector */
	noise = ealloc1float(nfloats);


d172 1
a192 1
		int bandinfd;		    /* ... its file id		*/
a203 2
		bandinfd = fileno(bandinfp);

a204 1
		bandoutfd = fileno(bandoutfp);
d210 1
d212 1
a212 2
			efread(&tr, HDRBYTES, 1, hdrfp);
			fputtr(bandinfd, &tr);
d222 2
a223 2
			efread(segybuf, nsegy, 1, bandinfp);
			efwrite(segybuf, nsegy, 1, fp);
d232 1
a232 1
			fgettr(bandoutfd, &tr);
d266 4
a269 3
		efread(&tr, HDRBYTES, 1, hdrfp);
		efread(tr.data, databytes, 1, sigfp);
		for (i = 0; i < nt; ++i)  tr.data[i] += noiscale * noise[i];
@


1.23
log
@Tweak
@
text
@d1 1
a1 1
/* SUADDNOISE: $Revision: 1.22 $ ; $Date: 90/12/19 18:18:23 $		*/
d20 1
d64 4
d79 9
a194 1
		char bandoutfile[L_tmpnam]; /* output file for suband	*/
a197 2
		FILE *bandoutfp;	    /* fp for output file	*/
		int bandoutfd;		    /* ... its file id		*/
d203 4
d284 10
@


1.22
log
@The comment re FLAT wasn't terminated!
@
text
@d1 1
a1 1
/* SUADDNOISE: $Revision: 1.21 $ ; $Date: 90/12/15 21:25:14 $		*/
d261 1
a261 2
		for (i = 0; i < nt; ++i) 
			tr.data[i] += noiscale * noise[i];
@


1.21
log
@Replace the old realloc strategy for the data with tmpfile().
@
text
@d1 1
a1 1
/* SUADDNOISE: $Revision: 1.20 $ ; $Date: 90/12/15 20:25:23 $		*/
d168 1
a168 1
	case FLAT: /* elements in [-1, 1]
@


1.20
log
@Close files asap
@
text
@d1 1
a1 1
/* SUADDNOISE: $Revision: 1.19 $ ; $Date: 90/12/15 20:13:59 $		*/
d79 1
a79 1
	int ntsize;		/* ... in bytes 			*/
d85 3
a87 1
	float *signal;		/* mega-vector of data from the segys	*/
a88 2
	int ndata;		/* floats allocated for mega-vectors	*/
	int nfloats;		/* ... floats actually used		*/
a95 1
	FILE *hdrfp;		/* fp for header storage file		*/
d125 1
a125 1
	/* Prepare temporary file to hold headers */
d127 1
d133 1
a133 1
	ntsize = nt * FSIZE;
d136 1
a136 6
	/* Tentatively allocate memory for data mega-vector */
	ndata = MAX(NFALLOC, nt); /* alloc at least one trace */
	signal = ealloc1float(ndata);


	/* Loop over input traces & put them into data mega-vector */
a139 5
		if (ntr*nt > ndata) {	/* need more memory */
			ndata += NFALLOC;
			signal = erealloc1float(signal, ndata);
		}
		memcpy(signal + (ntr - 1)*nt, tr.data, ntsize); 
d141 1
d151 1
d154 5
a158 2
	  for (i = 0; i < nfloats; ++i)
		absmaxsig = MAX(absmaxsig, ABS(signal[i]));
d188 2
a189 2
		char *segybuf;              /* buffer to hold a segy	*/
		int nsegy = HDRBYTES + nt*FSIZE;
a191 3
		/* Allocate trace buffer */
		segybuf = ealloc1(nsegy, 1);

d203 1
a203 1
			memcpy(tr.data, noise + itr*nt, ntsize); 
d209 1
a209 1
		/* System call to suband - suband handles the getpars */
d226 1
a226 1
			memcpy(noise + itr*nt, tr.data, ntsize); 
d252 1
a252 7
	/* Add scaled noise to trace */
	{ register int i;
	  for (i = 0; i < nfloats; ++i)  signal[i] += noiscale * noise[i];
	}


	/* Output the result by pulling traces off data mega-vector  */
d254 1
d256 2
a258 2
	  for (itr = 0; itr < ntr; ++itr) {
		memcpy(tr.data, signal + itr*nt, ntsize); 
d260 4
@


1.19
log
@Various tweaks.
@
text
@d1 1
a1 1
/* SUADDNOISE: $Revision: 1.18 $ ; $Date: 90/12/15 19:35:25 $		*/
d227 2
a236 3

		/* Clean up temp files */
		efclose(bandinfp);
@


1.18
log
@Use tmpfile for input to suband ==> popen instead of system.
@
text
@d1 1
a1 1
/* SUADDNOISE: $Revision: 1.17 $ ; $Date: 90/11/15 10:43:21 $		*/
d22 32
a53 32
string sdoc = "\
									\n\
SUADDNOISE - add noise to traces					\n\
									\n\
suaddnoise <stdin >stdout  sn=3  noise=gauss  seed=from_clock		\n\
									\n\
Required parameters:							\n\
	if any of f1,f2,f3,f4 are specified by the user and if dt is	\n\
	not set in header, then dt is mandatory				\n\
									\n\
Optional parameters:							\n\
	sn=3			signal to noise ratio			\n\
	noise=gauss		noise probability distribution		\n\
				= flat for uniform; default Gaussian	\n\
	seed=from_clock		random number seed (integer)		\n\
							        	\n\
	f1=0.0			left  low  corner frequency (Hz)	\n\
	f2=0.0			left  high corner frequency (Hz)	\n\
	f3= nyquist		right low  corner frequency (Hz)	\n\
	f4= nyquist		right high corner frequency (Hz)	\n\
	dt= (from header)	time sampling interval (sec)		\n\
									\n\
NOTES:									\n\
	Output = Signal +  scale * Noise				\n\
									\n\
	scale = (1/sn) * (absmax_signal/sqrt(2))/sqrt(energy_per_sample)\n\
									\n\
	If the signal is already band-limited, f1,f2,f3,f4 can be used	\n\
	as in suband to bandlimit the noise traces to match the signal	\n\
	band prior to computing the scale defined above.		\n\
									\n\
";
a62 2
 *
 *	It isn't very efficient to system call suband.
d67 1
a67 1
#define SN	3
d79 1
a79 1
	int ntsize;		/* number of data bytes on a trace	*/
d127 1
a127 1
	hdrfp = tmpfile();
d130 1
a130 1
	/* Get info from first trace and store first header */
d136 1
a136 1
	/* Allocate memory for data float and noise mega-vectors */
d150 1
a150 1
		efwrite(&tr, 1, HDRBYTES, hdrfp);
d160 4
a163 6
	{
		register int i;

		absmaxsig = 0.0;
		for (i = 0; i < nfloats; ++i)
			absmaxsig = MAX(absmaxsig, ABS(signal[i]));
d197 3
a209 1

d212 1
a212 1
			efread(&tr, 1, HDRBYTES, hdrfp);
a219 1
		segybuf = ealloc1(nsegy, 1);
a221 1

a229 1

d246 1
a247 3
	  register float noiseval;

	  noipow = 0.0;
d249 2
a250 2
		noiseval = noise[i];
		noipow  += noiseval * noiseval;
d273 1
a273 2
		efread(&tr, 1, HDRBYTES, hdrfp);
		tr.ntr = ntr;
@


1.17
log
@bcopy -> memcpy
@
text
@d1 1
a1 1
/* SUADDNOISE: $Revision: 1.16 $ ; $Date: 90/07/16 22:17:29 $		*/
d86 1
a86 1
	int seed;		/* random number seed			*/
a154 1
	erewind(hdrfp);
a189 1
		char bandinfile[L_tmpnam];  /* input file for suband	*/
d191 1
a191 1
		char cmd[BUFSIZ];	    /* build suband call	*/
d196 3
d200 1
d202 1
a202 2
		tmpnam(bandinfile);
		bandinfp = efopen(bandinfile, "w+");
d205 1
a205 2
		tmpnam(bandoutfile);
		bandoutfp = efopen(bandoutfile, "w+");
d209 2
a210 2
		{
			register int itr;
d212 5
a216 6
			for (itr = 0; itr < ntr; ++itr) {
				memcpy(tr.data, noise + itr*nt, ntsize); 
				efread(&tr, 1, HDRBYTES, hdrfp);
				fputtr(bandinfd, &tr);
			}
			erewind(hdrfp);
d220 5
a224 2
		sprintf(cmd, "suband <%s >%s", bandinfile, bandoutfile);
		system(cmd);
d226 6
d233 1
a233 2
		{
			register int itr;
d235 4
a238 4
			for (itr = 0; itr < ntr; ++itr) {
				fgettr(bandoutfd, &tr);
				memcpy(noise + itr*nt, tr.data, ntsize); 
			}
a242 1
		eremove(bandinfile);
d251 2
a252 3
	{
		register int i;
		register float noiseval;
d254 5
a258 5
		noipow = 0.0;
		for (i = 0; i < nfloats; ++i) {
			noiseval = noise[i];
			noipow  += noiseval * noiseval;
		}
d269 2
a270 5
	{
		register int i;

		for (i = 0; i < nfloats; ++i)
			signal[i] += noiscale * noise[i];
d275 2
a276 2
	{
		register int itr;
d278 6
a283 6
		for (itr = 0; itr < ntr; ++itr) {
			memcpy(tr.data, signal + itr*nt, ntsize); 
			efread(&tr, 1, HDRBYTES, hdrfp);
			tr.ntr = ntr;
			puttr(&tr);
		}
@


1.16
log
@Using frannor, franuni from cwp/lib to generate random numbers.
@
text
@d1 1
a1 1
/* SUADDNOISE: $Revision: 1.15 $ ; $Date: 90/07/16 21:02:58 $		*/
d151 1
a151 1
		bcopy(tr.data, signal + (ntr - 1)*nt, ntsize); 
d213 1
a213 1
				bcopy(noise + itr*nt, tr.data, ntsize); 
d230 1
a230 1
				bcopy(tr.data, noise + itr*nt, ntsize); 
d277 1
a277 1
			bcopy(signal + itr*nt, tr.data, ntsize); 
@


1.15
log
@white->flat
@
text
@d1 1
a1 1
/* SUADDNOISE: $Revision: 1.14 $ ; $Date: 90/07/06 15:20:58 $		*/
a58 4
 *	For the Gaussian noise algorithm:
 *	Donald E. Knuth, "The Art of Computer Programming", Volume 2,
 *	Algorithm P, page 104.
 *
d60 3
a62 3
 *	The Knuth algorithm involves a potentially infinite loop.  If
 *	the code is sound, this has zero probability.  If the code is
 *	to be revised, be aware that bugs could produce infinite run time.
a63 5
 *	Knuth gives better Gaussian algorithms, so look there if
 *	optimization ever becomes an issue.  We felt that for a program
 *	whose raison d'ete is creating synthetic data, the simpler the
 *	algorithm, the better.
 *
d86 1
a86 1
	uint seed;		/* random number seed			*/
d125 1
a125 1
	srand(seed);
d158 2
a159 3
	/* Allocate room for noise vector; allocate 1 extra in case    */
	/* nfloats is odd since Knuth generates pairs of noise values  */
	noise = ealloc1float(nfloats + 1);
d172 1
a172 1
	/* Compute noise vector elements in [-1,1] */
a173 1

d175 2
a176 17
		register float randscale = 2.0 / RAND_MAX; /* scale to [0,2] */

	case GAUSS:
		for (i = 0; i < nfloats; i += 2) {
			register float r1, r2;	/* random numbers in [-1,1] */
			register float magsq, factor; /* temporaries        */

			do { /* infinite looping has zero probability */
				r1    = randscale * rand() - 1.0;
				r2    = randscale * rand() - 1.0;
				magsq = r1 * r1 + r2 * r2;
			} while (magsq >= 1.0);

			factor     = sqrt(-2.0 * log(magsq)/magsq);
			noise[i]   = factor * r1;
			noise[i+1] = factor * r2;
		}
d178 2
a179 7
	case FLAT:
		for (i = 0; i < nfloats; ++i) {
			register float r;  /* random number in [-1, 1] */

			r        = randscale * rand() - 1.0;
			noise[i] = r;
		}
@


1.14
log
@Tweak
@
text
@d1 1
a1 1
/* SUADDNOISE: $Revision: 1.13 $ ; $Date: 90/07/02 13:39:30 $		*/
d35 1
a35 1
				= white for uniform; default Gaussian	\n\
d82 1
a82 1
#define	WHITE	1
d92 1
a92 1
	string stype;		/* noise type (gauss, white) as string	*/
d119 2
a120 2
	else if (STREQ(stype, "white")) itype = WHITE;
	else     err("noise=\"%s\", must be gauss or white", stype);
d204 1
a204 1
	case WHITE:
@


1.13
log
@Tweaks.
@
text
@d1 1
a1 1
/* SUADDNOISE: $Revision: 1.12 $ ; $Date: 90/06/29 16:12:43 $		*/
d42 1
a42 1
	dt= (from header)	time sampling rate (sec)		\n\
@


1.12
log
@Move noipow calculation BELOW bandlimiting.
@
text
@d1 1
a1 1
/* SUADDNOISE: $Revision: 1.11 $ ; $Date: 90/06/28 17:33:04 $		*/
d38 5
a42 5
	f1 = 0.0		left  low  corner frequency (Hz)	\n\
	f2 = 0.0		left  high corner frequency (Hz)	\n\
	f3 = nyquist		right low  corner frequency (Hz)	\n\
	f4 = nyquist		right high corner frequency (Hz)	\n\
	dt = (from header)	time sampling rate (sec)		\n\
d45 1
a45 2
	Output = Input +  (1/sn) *					\n\
		(absmax_signal/sqrt(2)) / sqrt(noise_power/nfloats) 	\n\
d47 1
a47 1
	Here absmax_signal and noise_power are global to the data set.	\n\
d50 2
a51 1
	as in suband to bandlimit the noise traces to match the signal.	\n\
d73 1
a73 3
 *	It isn't very efficient to system call and less so to treat
 *	bandlimiting as an exception by loading the filtered traces
 *	back into the noise vector.
a88 1
	register int i;		/* counter 				*/
d96 1
a96 1
	float *dataptr;		/* mega-vector of data from the segys	*/
a102 1
	float normrand;		/* scale random numbers to [0,2]	*/
a136 4
	/* Factor to map returns from rand() to [0.0, 2.0] */
	normrand = 2.0 / RAND_MAX;


d147 1
a147 1
	/* Allocate memory for data float mega-vector */
d149 1
a149 1
	dataptr = ealloc1float(ndata);
d158 1
a158 1
			dataptr = erealloc1float(dataptr, ndata);
d160 1
a160 1
		bcopy(tr.data, dataptr + (ntr - 1)*nt, ntsize); 
d168 1
a168 1
	/* nfloats is odd since Knuth generates pairs of noise values    */
d178 1
a178 1
			absmaxsig = MAX(absmaxsig, ABS(dataptr[i]));
d184 4
d190 2
a191 3
			register float r1, r2;	/* random numbers */
			register float magsq;	/* r1*r1 + r2*r2  */
			register float factor;	/* temporary      */
d193 3
a195 3
			do {
				r1    = normrand * rand() - 1.0;
				r2    = normrand * rand() - 1.0;
d208 1
a208 1
			r        = normrand * rand() - 1.0;
d220 2
a221 1
		/* set up call to suband */
d224 5
a228 5
		char cmd[BUFSIZ];	   /* build suband call		*/
		FILE *bandinfp;		   /* fp for input file		*/
		int bandinfd;		   /* ... its file id		*/
		FILE *bandoutfp;	   /* fp for output file	*/
		int bandoutfd;		   /* ... its file id		*/
d289 1
a289 1
	absmaxsig /= sqrt(2.0);  /* make it look like a rmsq value */
d299 1
a299 1
			dataptr[i] += noiscale * noise[i];
d308 1
a308 1
			bcopy(dataptr + itr*nt, tr.data, ntsize); 
@


1.11
log
@Tweaks
@
text
@d1 1
a1 1
/* SUADDNOISE: $Revision: 1.10 $ ; $Date: 90/06/28 12:49:36 $		*/
a105 1
	float sigpow;		/* signal power				*/
a110 1
	float dt;		/* sample spacing			*/
d190 1
a190 2
	/* Compute noise vector elements in [-1,1] and noise power */
	noipow = 0.0;
a206 1
			noipow    += factor * factor * magsq;
a214 1
			noipow  += r * r;
a221 6
	/* Compute noise scale for desired noise/signal ratio */
	noipow /= nfloats;
	absmaxsig /= sqrt(2.0);
	noiscale = absmaxsig / (sn * sqrt(noipow));


d278 21
a298 1
	/* Add scaled noise to trace:  dataptr[i] += noiscale*noise[i] */
@


1.10
log
@Add facility to bandlimit the noise traces in case the
signal traces are already bandlimited.
@
text
@d1 1
a1 1
/* SUADDNOISE: $Revision: 1.9 $ ; $Date: 90/06/28 10:24:18 $		*/
d80 1
a80 1
#define SN		3
d260 1
a260 1
				efread(&tr, HDRBYTES, 1, hdrfp);
d304 1
a304 1
			efread(&tr, HDRBYTES, 1, hdrfp);
@


1.9
log
@Tweaks to make more readable.
@
text
@d1 1
a1 1
/* SUADDNOISE: $Revision: 1.8 $ ; $Date: 90/06/28 08:14:06 $		*/
d29 2
a30 1
	none								\n\
d37 6
d45 2
a46 1
	Output = Input + sqrt(signal_power/noise_power) * Noise/sn	\n\
d48 1
a48 1
	Here signal_power and noise_power are global to the data set.	\n\
d50 3
d58 1
d72 4
d108 5
d187 1
a187 1
		for (i = 0; i < nfloats; ++i) {
a188 1
		}
d232 56
@


1.8
log
@Changed computation of signal strength for greater realism (per ken).
Isolated some variables in local blocks.
@
text
@d1 1
a1 1
/* SUADDNOISE: $Revision: 1.7 $ ; $Date: 90/06/28 06:42:25 $		*/
d46 1
a46 1
 *	CWP: Jack, Brian
d161 1
a161 1
	/* Compute absmax of signal */
d209 2
a210 1
	noiscale = absmaxsig * sqrt(2.0/noipow) / sn;
@


1.7
log
@Corrected calculation of normrand.
@
text
@d1 1
a1 1
/* SUADDNOISE: $Revision: 1.6 $ ; $Date: 90/06/28 00:03:01 $		*/
d88 2
a89 1
	float noipow;		/* noise power				*/
a92 4
      	register float r1, r2;	/* random numbers in [-1, 1] (gauss)	*/
	register float magsq;	/* r1*r1 + r2*r2 			*/
	register float factor;	/* multiplier in Gauss algorithm	*/
        register float r;	/* random number in [-1, 1]  (white)	*/
d161 1
a161 1
	/* Compute signal power:  sigpow += dataptr[i]*dataptr[i] */
a163 1
		register float val;
d165 1
a165 1
		sigpow = 0.0;
d167 1
a167 2
			val = dataptr[i];
			sigpow += val * val;
d177 3
d195 2
d208 2
a209 1
	noiscale = sqrt(sigpow/noipow) / sn;
@


1.6
log
@Using the ANSI C interface, srand(), rand() even tho "there are
better random number generators" (like srandom, random).
@
text
@d1 1
a1 1
/* SUADDNOISE: $Revision: 1.5 $ ; $Date: 90/06/05 15:51:15 $		*/
d126 1
a126 1
	normrand = 2.0 / (RAND_MAX + 1);
@


1.5
log
@Eliminated veclib routines.
@
text
@d1 1
a1 5
/* SUADDNOISE: $Revision: 1.4 $ ; $Date: 90/05/23 10:07:47 $		*/
/*
	CAVEAT: Should use rand(), srand() per ansi c, but then code 
		froze on Major.  Not worth puzzling over now.  jkc
*/
d82 1
a82 1
	int seed;		/* random number seed			*/
d117 2
a118 2
	if (!getparint("seed", &seed)) { /* if not supplied, use clock */
		if (-1 == (seed = (int) time((time_t *) NULL))) {
d122 1
a122 1
	srandom(seed);
d125 2
a126 2
	/* Factor to map returns from random() to [0.0, 2.0] */
	normrand = 2.0 / (pow(2.0, 31.0) - 1.0);
d184 2
a185 2
				r1    = normrand * random() - 1.0;
				r2    = normrand * random() - 1.0;
d197 1
a197 1
			r        = normrand * random() - 1.0;
@


1.4
log
@Changed time() call and include per ANSI C.
Tried to use ANSI rand() instead of random(), but no dice
on Major (suaddnoise hung somewhere--did not investigate).
@
text
@d1 1
a1 1
/* SUADDNOISE: $Revision: 1.3 $ ; $Date: 90/05/23 09:21:14 $		*/
a21 1
#include "fconst.h"
a45 2
	Synthetics that are mostly zeroes need sn rather small.		\n\
									\n\
a82 1
	int itr;		/* counter up to ntr 			*/
d108 1
a108 1
	if (!sgetpar("noise", &stype))	stype = "gauss";
d116 1
a116 1
	if (!fgetpar("sn", &sn))	sn = SN;
d121 1
a121 1
	if (!igetpar("seed", &seed)) { /* if not supplied, use clock */
d123 1
a123 1
			syserr("time() failed to set seed");
d169 3
a171 1
	svesq(dataptr, ONE, &sigpow, &nfloats);
d173 6
d180 1
d200 1
a200 1
		for (i = 0; i < nfloats; i++) {
d216 2
a217 1
	vsma(noise, ONE, &noiscale, dataptr, ONE, dataptr, ONE, &nfloats);
d219 3
d223 1
d225 9
a233 5
	for(itr = 0; itr < ntr; ++itr) {
		bcopy(dataptr + itr*nt, tr.data, ntsize); 
		efread(&tr, 1, HDRBYTES, hdrfp);
		tr.ntr = ntr;
		puttr(&tr);
@


1.3
log
@Eliminated some declarations and casts not needed by ANSI C.
Changed to incremental reallocs instead of doubling strategy.
@
text
@d1 5
a5 1
/* SUADDNOISE: $Revision: 1.2 $ ; $Date: 90/05/22 16:02:19 $		*/
d24 1
a24 1
#include <sys/timeb.h>
d126 1
a126 1
		if (-1 == (seed = (int) time(0))) {
@


1.2
log
@Changed noise allocation size to the ACTUAL number of floats
used so that the noise size has some sense to it.
@
text
@d1 1
a1 1
/* SUADDNOISE: $Revision: 1.1 $ ; $Date: 90/04/16 14:28:44 $		*/
a62 2
 *
 *
d95 1
a95 1
	FILE *fphdr;		/* fp for header storage file		*/
a99 4
	long time();		/* system subroutine			*/
	long random();		/* system subroutine			*/
	int srandom();		/* system subroutine			*/
	FILE *tmpfile();	/* system subroutine			*/
d122 1
a122 1
		if (-1 == (seed = (int) time((long *) 0))) {
d134 1
a134 1
	fphdr = tmpfile();
d153 1
a153 1
			ndata <<= 1;	/* ask for double   */
d157 1
a157 1
		efwrite(&tr, 1, HDRBYTES, fphdr);
d160 1
a160 1
	erewind(fphdr);
d213 1
a213 1
		efread(&tr, 1, HDRBYTES, fphdr);
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/* SUADDNOISE: $Revision: 2.16 $ ; $Date: 89/09/20 19:34:22 $		*/
d4 1
a4 1
 * Copyright (c) Colorado School of Mines, 1989.
d12 1
a12 1
 *  Golden, CO 80401  (isis!csm9a!jkcohen)
d33 2
a34 2
	sn = 3			signal to noise ratio			\n\
	noise = gauss		noise probability distribution		\n\
d36 1
a36 1
	seed = from_clock	random number seed (integer)		\n\
a66 5
/* Embed Revision Control System identifier strings */
static string progid =
	"   $Source: /src/su/src/RCS/suaddnoise.c,v $";
static string revid =
	"   $Revision: 2.16 $ ; $Date: 89/09/20 19:34:22 $";
a67 2


d78 1
a78 2
main(argc, argv)
int argc; char **argv;
d92 1
d108 1
a108 1
	/* Initialize SU */
a109 5
	if (!igetpar("ID", &ID))	ID = 0;
	if (ID) {
		(void) fprintf(stderr, "%s\n", progid);
		(void) fprintf(stderr, "%s\n", revid);
	}
d151 1
a151 1
	dataptr = vec(ndata);
d160 1
a160 1
			dataptr = re_vec(dataptr, ndata);
d163 1
a163 1
		efwrite((char *)&tr, 1, HDRBYTES, fphdr);
d165 2
a166 1
	rewind(fphdr);
d170 2
a171 2
	/* ndata is odd since Knuth generates pairs of noise values    */
	noise = vec(ndata + 1);
d175 1
a175 1
	svesq(dataptr, ONE, &sigpow, &ndata);
d182 1
a182 1
		for (i = 0; i < ndata; i += 2) {
d197 1
a197 1
		for (i = 0; i < ndata; i++) {
d213 1
a213 1
	vsma(noise, ONE, &noiscale, dataptr, ONE, dataptr, ONE, &ndata);
d219 1
a219 1
		efread((char *) &tr, 1, HDRBYTES, fphdr);
d225 1
a225 1
	return SUCCEED;
@
