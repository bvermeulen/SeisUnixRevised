head	1.31;
access;
symbols;
locks
	john:1.31; strict;
comment	@ * @;


1.31
date	2013.03.06.20.35.27;	author john;	state Exp;
branches;
next	1.30;

1.30
date	2012.01.03.19.45.15;	author john;	state Exp;
branches;
next	1.29;

1.29
date	2011.12.19.19.55.01;	author john;	state Exp;
branches;
next	1.28;

1.28
date	2011.12.19.18.00.14;	author john;	state Exp;
branches;
next	1.27;

1.27
date	2011.11.16.23.21.55;	author john;	state Exp;
branches;
next	1.26;

1.26
date	2011.11.12.00.39.02;	author john;	state Exp;
branches;
next	1.25;

1.25
date	2010.09.24.21.23.38;	author john;	state Exp;
branches;
next	1.24;

1.24
date	2006.10.31.22.25.06;	author john;	state Exp;
branches;
next	1.23;

1.23
date	2004.11.19.22.02.58;	author john;	state Exp;
branches;
next	1.22;

1.22
date	2003.06.09.16.17.07;	author john;	state Exp;
branches;
next	1.21;

1.21
date	98.08.24.20.54.33;	author john;	state Exp;
branches;
next	1.20;

1.20
date	97.06.26.15.44.50;	author john;	state Exp;
branches;
next	1.19;

1.19
date	96.08.20.18.54.14;	author jkc;	state Exp;
branches;
next	1.18;

1.18
date	96.05.02.19.44.07;	author jkc;	state Exp;
branches;
next	1.17;

1.17
date	96.01.30.16.00.31;	author jkc;	state Exp;
branches;
next	1.16;

1.16
date	95.11.14.20.36.33;	author jkc;	state Exp;
branches;
next	1.15;

1.15
date	95.11.14.20.26.52;	author jkc;	state Exp;
branches;
next	1.14;

1.14
date	95.08.03.16.34.12;	author jkc;	state Exp;
branches;
next	1.13;

1.13
date	95.08.02.21.06.15;	author jkc;	state Exp;
branches;
next	1.12;

1.12
date	94.08.25.15.00.10;	author jkc;	state Exp;
branches;
next	1.11;

1.11
date	93.11.29.14.38.07;	author john;	state Exp;
branches;
next	1.10;

1.10
date	92.10.26.14.20.25;	author john;	state Exp;
branches;
next	1.9;

1.9
date	91.09.05.08.51.15;	author jkcohen;	state Exp;
branches;
next	1.8;

1.8
date	90.12.07.13.35.44;	author jkc;	state Exp;
branches;
next	1.7;

1.7
date	90.12.01.10.33.19;	author dhale;	state Exp;
branches;
next	1.6;

1.6
date	90.06.14.14.38.34;	author jkc;	state Exp;
branches;
next	1.5;

1.5
date	90.06.14.14.31.09;	author jkc;	state Exp;
branches;
next	1.4;

1.4
date	90.05.29.20.44.53;	author jkc;	state Exp;
branches;
next	1.3;

1.3
date	90.05.25.19.26.09;	author jkc;	state Exp;
branches;
next	1.2;

1.2
date	90.04.19.15.53.51;	author jkc;	state Exp;
branches;
next	1.1;

1.1
date	90.03.15.12.59.03;	author jkc;	state Exp;
branches;
next	;


desc
@Normal moveout.
@


1.31
log
@added output interpolated velocity file function on the suggestion of Bruce Verwest.
@
text
@/* Copyright (c) Colorado School of Mines, 2011.*/
/* All rights reserved.                       */

/* SUNMO: $Revision: 1.30 $ ; $Date: 2012/01/03 19:45:15 $		*/
 
#include "su.h"
#include "segy.h"

/*********************** self documentation ******************************/
char *sdoc[] = {
"									     ",
" SUNMO - NMO for an arbitrary velocity function of time and CDP	     ",
"									     ",
"  sunmo <stdin >stdout [optional parameters]				     ",
"									     ",
" Optional Parameters:							     ",
" tnmo=0,...		NMO times corresponding to velocities in vnmo	     ",
" vnmo=1500,...		NMO velocities corresponding to times in tnmo	     ",
" cdp=			CDPs for which vnmo & tnmo are specified (see Notes) ",
" smute=1.5		samples with NMO stretch exceeding smute are zeroed  ",
" lmute=25		length (in samples) of linear ramp for stretch mute  ",
" sscale=1		=1 to divide output samples by NMO stretch factor    ",
" invert=0		=1 to perform (approximate) inverse NMO		     ",
" upward=0		=1 to scan upward to find first sample to kill	     ",
" voutfile=		if set, interplolated velocity function v[cdp][t] is ",
"			output to named file.			     	     ",
" Notes:								     ",
" For constant-velocity NMO, specify only one vnmo=constant and omit tnmo.   ",
"									     ",
" NMO interpolation error is less than 1% for frequencies less than 60% of   ",
" the Nyquist frequency.						     ",
"									     ",
" Exact inverse NMO is impossible, particularly for early times at large     ",
" offsets and for frequencies near Nyquist with large interpolation errors.  ",
" 								     	     ",
" The \"offset\" header field must be set.				     ",
" Use suazimuth to set offset header field when sx,sy,gx,gy are all	     ",
" nonzero. 							   	     ",
"									     ",
" For NMO with a velocity function of time only, specify the arrays	     ",
"	   vnmo=v1,v2,... tnmo=t1,t2,...				     ",
" where v1 is the velocity at time t1, v2 is the velocity at time t2, ...    ",
" The times specified in the tnmo array must be monotonically increasing.    ",
" Linear interpolation and constant extrapolation of the specified velocities",
" is used to compute the velocities at times not specified.		     ",
" The same holds for the anisotropy coefficients as a function of time only. ",
"									     ",
" For NMO with a velocity function of time and CDP, specify the array	     ",
"	   cdp=cdp1,cdp2,...						     ",
" and, for each CDP specified, specify the vnmo and tnmo arrays as described ",
" above. The first (vnmo,tnmo) pair corresponds to the first cdp, and so on. ",
" Linear interpolation and constant extrapolation of 1/velocity^2 is used    ",
" to compute velocities at CDPs not specified.				     ",
"									     ",
" The format of the output interpolated velocity file is unformatted C floats",
" with vout[cdp][t], with time as the fast dimension and may be used as an   ",
" input velocity file for further processing.				     ",
"									     ",
" Note that this version of sunmo does not attempt to deal with	anisotropy.  ",
" The version of sunmo with experimental anisotropy support is \"sunmo_a\"   ",
"									     ",
NULL};

/* Credits:
 *	SEP: Shuki Ronen, Chuck Sword
 *	CWP: Shuki Ronen, Jack, Dave Hale, Bjoern Rommel
 *      Modified: 08/08/98 - Carlos E. Theodoro - option for lateral offset
 *      Modified: 07/11/02 - Sang-yong Suh -
 *	  added "upward" option to handle decreasing velocity function.
 *      CWP: Sept 2010: John Stockwell
 *	  1. replaced Carlos Theodoro's fix 
 *	  2. added  the instruction in the selfdoc to use suazimuth to set 
 *	      offset so that it accounts for lateral offset. 
 *        3. removed  Bjoren Rommel's anisotropy stuff. sunmo_a is the 
 *           version with the anisotropy parameters left in.
 *        4. note that scalel does not scale the offset field in
 *           the segy standard.
 * Technical Reference:
 *	The Common Depth Point Stack
 *	William A. Schneider
 *	Proc. IEEE, v. 72, n. 10, p. 1238-1254
 *	1984
 *
 * Trace header fields accessed: ns, dt, delrt, offset, cdp, scalel
 */
/**************** end self doc *******************************************/

static void interpovv (int nt, int ncdp, float *cdp, 
	float **ovv, float cdpt, float *ovvt );

segy tr;

int
main(int argc, char **argv)
{
	int nt;			/* number of time samples per trace */
	float dt;		/* time sampling interval */
	float ft;		/* time of first sample */
	int it;			/* time sample index */

	int ncdp;		/* number of cdps specified */
	float *cdp=NULL;	/* array[ncdp] of cdps */
	int icdp;		/* index into cdp array */
	int jcdp;		/* index into cdp array */

	int nvnmo;		/* number of vnmos specified */
	float *vnmo=NULL;	/* array[nvnmo] of vnmos */
	int ntnmo;		/* number of tnmos specified */
	float *tnmo=NULL;	/* array[ntnmo] of tnmos */
	float **ovv=NULL;	/* array[ncdp][nt] of sloth */
				/*      i.e. (1/velocity^2) functions */
	float *ovvt=NULL;	/* array[nt] of sloth for a particular trace */

	float smute;		/* zero samples with NMO stretch exceeding */
				/*  smute */
	float osmute;		/* 1/smute */
	int lmute;		/* length in samples of linear ramp for mute */
	int itmute=0;		/* zero samples with indices less than itmute */
	int sscale;		/* if non-zero, apply NMO stretch scaling */
	int invert;		/* if non-zero, do inverse NMO */
	
	long oldoffset;		/* offset of previous trace */
	long oldcdp;		/* cdp of previous trace */

	int newsloth;		/* if non-zero, new sloth function was */
				/* computed */

	float tn;		/* NMO time (time after NMO correction) */
	float v;		/* velocity */
	float *qtn=NULL;	/* NMO-corrected trace q(tn) */
	float *ttn=NULL;	/* time t(tn) for NMO */
	float *atn=NULL;	/* amplitude a(tn) for NMO */
	float *qt=NULL;		/* inverse NMO-corrected trace q(t) */
	float *tnt=NULL;	/* time tn(t) for inverse NMO */
	float *at=NULL;		/* amplitude a(t) for inverse NMO */
	float acdp;		/* temporary used to sort cdp array */

	float *aovv;		/* temporary used to sort ovv array */
	float temp;		/* temporary float */
	float tsq;		/* temporary float */
	int upward;		/* scans upward if it's nonzero. */

	float offset;		/* value of offset honoring scalel */

	char *voutfile="";	/* name of interpolated output vel file */
	FILE *voutfp=NULL;	/* ... its file pointer */
	cwp_Bool isvoutfile=cwp_false; /* is output vel file specified? */
	float voutt[1];	/* output velocities */

	
	/* hook up getpar */
	initargs(argc, argv);
	requestdoc(1);

	/* get information from the first header */
	if (!gettr(&tr)) err("can't get first trace");
	nt = tr.ns;
	dt = ((double) tr.dt)/1000000.0;
	ft = tr.delrt/1000.0;

	/* if specified, open output velocity file */
	getparstring("voutfile",&voutfile);
	if (*voutfile!='\0') {
		isvoutfile=cwp_true;
		
		if((voutfp=fopen(voutfile,"w"))==NULL)
                        err("cannot open voutfile=%s\n",voutfile);
	}
	


	/* get velocity functions, linearly interpolated in time */
	ncdp = countparval("cdp");
	if (ncdp>0) {
		if (countparname("vnmo")!=ncdp)
			err("a vnmo array must be specified for each cdp");
		if (countparname("tnmo")!=ncdp)
			err("a tnmo array must be specified for each cdp");
	} else {
		ncdp = 1;
		if (countparname("vnmo")>1)
			err("only one (or no) vnmo array must be specified");
		if (countparname("tnmo")>1)
			err("only one (or no) tnmo array must be specified");
	}
	cdp = ealloc1float(ncdp);
	if (!getparfloat("cdp",cdp)) cdp[0] = tr.cdp;
	ovv = ealloc2float(nt,ncdp);


	for (icdp=0; icdp<ncdp; ++icdp) {

		nvnmo = countnparval(icdp+1,"vnmo");
		ntnmo = countnparval(icdp+1,"tnmo");

		if (nvnmo!=ntnmo && !(ncdp==1 && nvnmo==1 && ntnmo==0))
			err("number of vnmo and tnmo values must be equal");

		if (nvnmo==0) nvnmo = 1;
		if (ntnmo==0) ntnmo = nvnmo;

		/* equal numbers of parameters vnmo, tnmo */
		vnmo = ealloc1float(nvnmo);
		tnmo = ealloc1float(nvnmo);

		if (!getnparfloat(icdp+1,"vnmo",vnmo)) vnmo[0] = 1500.0;
		if (!getnparfloat(icdp+1,"tnmo",tnmo)) tnmo[0] = 0.0;
		for (it=1; it<ntnmo; ++it)
			if (tnmo[it]<=tnmo[it-1])
				err("tnmo values must increase monotonically");
		for (it=0,tn=ft; it<nt; ++it,tn+=dt) {
			intlin(ntnmo,tnmo,vnmo,vnmo[0],vnmo[nvnmo-1],1,&tn,&v);
			ovv[icdp][it] = 1.0/(v*v);
		}

		free1float(vnmo);
		free1float(tnmo);
	}

	/* sort (by insertion) sloth and anis functions by increasing cdp */
	for (jcdp=1; jcdp<ncdp; ++jcdp) {
		acdp = cdp[jcdp];
		aovv = ovv[jcdp];
		for (icdp=jcdp-1; icdp>=0 && cdp[icdp]>acdp; --icdp) {
			cdp[icdp+1] = cdp[icdp];
			ovv[icdp+1] = ovv[icdp];
		}
		cdp[icdp+1] = acdp;
		ovv[icdp+1] = aovv;
	}

	/* get other optional parameters */
	if (!getparfloat("smute",&smute)) smute = 1.5;
	if (smute<=0.0) err("smute must be greater than 0.0");
	if (!getparint("lmute",&lmute)) lmute = 25;
	if (!getparint("sscale",&sscale)) sscale = 1;
	if (!getparint("invert",&invert)) invert = 0;
	if (!getparint("upward",&upward)) upward = 0;
        checkpars();

	/* allocate workspace */
	ovvt = ealloc1float(nt);
	ttn = ealloc1float(nt);
	atn = ealloc1float(nt);
	qtn = ealloc1float(nt);
	tnt = ealloc1float(nt);
	at = ealloc1float(nt);
	qt = ealloc1float(nt);

	/* interpolate sloth and anis function for first trace */
	interpovv(nt,ncdp,cdp,ovv,(float)tr.cdp,ovvt);

	/* if specified output output velocity for first trace */
	if(isvoutfile) {
			for (it=0; it<nt; ++it) {	
				float veltemp=ovvt[it];
				voutt[0]=sqrt(1.0/veltemp);
				efwrite(voutt,FSIZE,1,voutfp);
			}
	}

	/* set old cdp and old offset for first trace */
	oldcdp = tr.cdp;
	oldoffset = tr.offset-1; /* here offset is used as a marker */
				 /* there is no need to have it honor scalel */

	/* loop over traces */
	do {
		/* if necessary, compute new sloth and anis function */
		if (tr.cdp!=oldcdp && ncdp>1) {
			interpovv(nt,ncdp,cdp,ovv,(float)tr.cdp,
				  ovvt);
			newsloth = 1;
			/* if specified output output velocity */
			if(isvoutfile) {
				for (it=0; it<nt; ++it) {	
					float veltemp=ovvt[it];
					voutt[0]=sqrt(1.0/veltemp);
					efwrite(voutt,FSIZE,1,voutfp);
				}
			}
		} else {
			newsloth = 0;
		}

		/* if sloth function or offset has changed */
		if (newsloth || tr.offset!=oldoffset) {

			offset = (float) (tr.offset);
			

			/* compute time t(tn) (normalized) */
			temp = ((float) offset*offset)/(dt*dt);
			for (it=0,tn=ft/dt; it<nt; ++it,tn+=1.0) {
				tsq = temp*ovvt[it];
				ttn[it] = sqrt (tn*tn + tsq);

	
			}
			/* compute inverse of stretch factor a(tn) */
			atn[0] = ttn[1]-ttn[0];
			for (it=1; it<nt; ++it)
				atn[it] = ttn[it]-ttn[it-1];
			
			/* determine index of first sample to survive mute */
			osmute = 1.0/smute;
			if(!upward) {
				for (it=0; it<nt-1 && atn[it]<osmute; ++it);
			} else {
				/* scan samples from bottom to top */
				for (it=nt-1; it>0 && atn[it]>=osmute; --it);
			}
			itmute = it;


			/* if inverse NMO will be performed */
			if (invert) {
							
				/* compute tn(t) from t(tn) */
				yxtoxy(nt-itmute,1.0,ft/dt+itmute,&ttn[itmute],
					nt-itmute,1.0,ft/dt+itmute,
					ft/dt-nt,ft/dt+nt,&tnt[itmute]);
			
				/* adjust mute time */
				itmute = 1.0+ttn[itmute]-ft/dt;
				itmute = MIN(nt-2,itmute);
								
				/* compute a(t) */
				if (sscale) {
					for (it=itmute+1; it<nt; ++it)
						at[it] = tnt[it]-tnt[it-1];
					at[itmute] = at[itmute+1];
				}
			}
		}
		
		/* if forward (not inverse) nmo */
		if (!invert) {
	
			/* do nmo via 8-point sinc interpolation */
			ints8r(nt,1.0,ft/dt,tr.data,0.0,0.0,
				nt-itmute,&ttn[itmute],&qtn[itmute]);
			
			/* apply mute */
			for (it=0; it<itmute; ++it)
				qtn[it] = 0.0;
			
			/* apply linear ramp */
			for (it=itmute; it<itmute+lmute && it<nt; ++it)
				qtn[it] *= (float)(it-itmute+1)/(float)lmute;
			
			/* if specified, scale by the NMO stretch factor */
			if (sscale)
				for (it=itmute; it<nt; ++it)
					qtn[it] *= atn[it];
			
			/* copy NMO corrected trace to output trace */
			memcpy( (void *) tr.data,
					(const void *) qtn, nt*sizeof(float));
		
		/* else inverse nmo */
		} else {
	
			/* do inverse nmo via 8-point sinc interpolation */
			ints8r(nt,1.0,ft/dt,tr.data,0.0,0.0,
				nt-itmute,&tnt[itmute],&qt[itmute]);
			
			/* apply mute */
			for (it=0; it<itmute; ++it)
				qt[it] = 0.0;
			
			/* if specified, undo NMO stretch factor scaling */
			if (sscale)
				for (it=itmute; it<nt; ++it)
					qt[it] *= at[it];
			
			/* copy inverse NMO corrected trace to output trace */
			memcpy( (void *) tr.data,
					(const void *) qt,nt*sizeof(float));
		}

		/* write output trace */
		puttr(&tr);

		/* remember offset and cdp */
		oldoffset = tr.offset;
		oldcdp = tr.cdp;

	} while (gettr(&tr));

	if (isvoutfile) efclose(voutfp);
	return(CWP_Exit());
}


/* linearly interpolate/extrapolate sloth between cdps */
static void interpovv (int nt, int ncdp, float *cdp, float **ovv, 
	float cdpt, float *ovvt)
{
	static int index=0;
	int it;
	float a1,a2;

	/* if before first cdp, constant extrapolate */
	if (cdpt<=cdp[0]) {
		for (it=0; it<nt; ++it)
			ovvt[it] = ovv[0][it];
	
	/* else if beyond last cdp, constant extrapolate */
	} else if (cdpt>=cdp[ncdp-1]) {
		for (it=0; it<nt; ++it)
			ovvt[it] = ovv[ncdp-1][it];
	
	/* else, linearly interpolate */
	} else {
		xindex(ncdp,cdp,cdpt,&index);
		a1 = (cdp[index+1]-cdpt)/(cdp[index+1]-cdp[index]);
		a2 = (cdpt-cdp[index])/(cdp[index+1]-cdp[index]);
		for (it=0; it<nt; ++it)
			ovvt[it] = a1*ovv[index][it]+a2*ovv[index+1][it];
	}
}
@


1.30
log
@removed references to scalel as scalel does not scale the offset
parameter.
@
text
@d4 1
a4 1
/* SUNMO: $Revision: 1.29 $ ; $Date: 2011/12/19 19:55:01 $		*/
d24 3
a26 2
" upward=0		=1 to scan upward to find first sample to kill	",
"									     ",
d55 4
d145 6
d161 11
d190 1
d253 9
d274 8
d297 3
a299 1
				}
d315 1
d391 1
@


1.29
log
@removed dependence of "offset" on scalel.
@
text
@d4 1
a4 1
/* SUNMO: $Revision: 1.28 $ ; $Date: 2011/12/19 18:00:14 $		*/
d35 2
a36 2
" The \"offset\" header field must be set and the \"scalel\" header field is ",
" honored. Use suazimuth to set offset header field when sx,sy,gx,gy are all ",
d66 1
a66 1
 *	  1. replaced Carlos Theodoro's fix with code to honor the scalel
d71 2
a72 1
 *
@


1.28
log
@removed divison by zero for scalel=0
@
text
@d4 1
a4 1
/* SUNMO: $Revision: 1.27 $ ; $Date: 2011/11/16 23:21:55 $		*/
d248 1
a248 8
			/* get offset value honoring scalel parameter */
			if (tr.scalel < 0 ) {
				offset = (float)(tr.offset * ABS(tr.scalel));
			} else if (tr.scalel > 0 ) {
				offset = (float) (tr.offset/ABS(tr.scalel));
			} else {
				offset = (float) (tr.offset);
			}
@


1.27
log
@added Reg Beardsley's checkpar()
@
text
@d4 1
a4 1
/* SUNMO: $Revision: 1.25 $ ; $Date: 2010/09/24 21:23:38 $		*/
d254 1
a254 1
				offset = (float) (tr.offset/ABS(tr.scalel));
@


1.26
log
@copyright
@
text
@d17 2
a18 2
" tnmo=0		NMO times corresponding to velocities in vnmo	     ",
" vnmo=1500		NMO velocities corresponding to times in tnmo	     ",
d215 1
@


1.25
log
@now honors scalel, anisotropy options removed, and instructions
about using suazimuth to set the offset parameter are included
@
text
@d1 4
a4 1
/* SUNMO: $Revision: 1.24 $ ; $Date: 2006/10/31 22:25:06 $		*/
@


1.24
log
@changed default to vnmo=1500 for water speed
@
text
@d1 1
a1 1
/* SUNMO: $Revision: 1.23 $ ; $Date: 2004/11/19 22:02:58 $		*/
a15 2
" anis1=0		two anisotropy coefficients making up quartic term   ",
" anis2=0		in traveltime curve, corresponding to times in tnmo  ",
d20 2
a21 4
" invert=0		=1 to perform (approximate) inverse NMO	             ",
" ixoffset=0		do not consider cross-line offset                    ",
"                       =1 read cross-line offset from trace header          ",
" upward=0		=1 to scan upward to find first sample to kill       ",
a23 1
"									     ",
d26 9
a34 2
" The anisotropy coefficients anis1, anis2 permit non-hyperbolicity due	     ",
" to layering, mode conversion, or anisotropy. Default is isotropic NMO.     ",
a49 4
" The same holds for the anisotropy coefficients as a function of time and   ",
" CDP.									     ",
"									     ",
" Moveout is defined by							     ",
d51 2
a52 3
"   1		 anis1							     ",
"  --- x^2 + ------------- x^4.						     ",
"  v^2	     1 + anis2 x^2						     ",
a53 17
" Note: In general, the user should set the cdp parameter.  The default is   ",
"	to use tr.cdp from the first trace and assume only one cdp.          ",
" Caveat:								     ",
" Nmo cannot handle negative moveout as in triplication caused by	     ",
" anisotropy. But negative moveout happens necessarily for negative anis1 at ",
" sufficiently large offsets. Then the error-negative moveout- is printed.   ",
" Check anis1. An error (anis2 too small) is also printed if the	     ",
" denominator of the quartic term becomes negative. Check anis2. These errors",
" are prompted even if they occur in traces which would not survive the	     ",
" NMO-stretch threshold. Chop off enough far-offset traces (e.g. with suwind)",
" if anis1, anis2 are fine for near-offset traces.			     ",
"									     ",
" NMO interpolation error is less than 1% for frequencies less than 60% of   ",
" the Nyquist frequency.						     ",
"									     ",
" Exact inverse NMO is impossible, particularly for early times at large     ",
" offsets and for frequencies near Nyquist with large interpolation errors.  ",
d57 2
a58 2
 *	SEP: Shuki, Chuck Sword
 *	CWP: Shuki, Jack, Dave Hale, Bjoern Rommel
d61 7
a67 1
 *          added "upward" option to handle decreasing velocity function.
d75 1
a75 1
 * Trace header fields accessed: ns, dt, delrt, offset, cdp, sy
d80 1
a80 2
	float **ovv, float **oa1, float **oa2, float cdpt, 
	float *ovvt, float *oa1t, float *oa2t);
d87 48
a134 49
	int nt;		/* number of time samples per trace */
	float dt;	/* time sampling interval */
	float ft;	/* time of first sample */
	int it;		/* time sample index */
	int ncdp;	/* number of cdps specified */
	float *cdp;	/* array[ncdp] of cdps */
	int icdp;	/* index into cdp array */
	int jcdp;	/* index into cdp array */
	int nvnmo;	/* number of vnmos specified */
	float *vnmo;	/* array[nvnmo] of vnmos */
	int ntnmo;	/* number of tnmos specified */
	float *tnmo;	/* array[ntnmo] of tnmos */
	float **ovv;	/* array[ncdp][nt] of sloth (1/velocity^2) functions */
	float *ovvt;	/* array[nt] of sloth for a particular trace */
	int nanis1;	/* number of anis1's specified */
	int nanis2;	/* number of anis2's specified */
	float *anis1;	/* array[nanis1] of anis1's */
	float *anis2;	/* array[nanis2] of anis2's */
	float **oa1;	/* array[ncdp][nt] of anis1 functions */
	float **oa2;	/* array[ncdp][nt] of anis2 functions */
	float *oa1t;	/* array[nt] of anis1 for a particular trace */
	float *oa2t;	/* array[nt] of anis2 for a particular trace */
	float smute;	/* zero samples with NMO stretch exceeding smute */
	float osmute;	/* 1/smute */
	int lmute;	/* length in samples of linear ramp for mute */
	int itmute=0;	/* zero samples with indices less than itmute */
	int sscale;	/* if non-zero, apply NMO stretch scaling */
	int invert;	/* if non-zero, do inverse NMO */
	float sy;	/* cross-line offset component */
	int ixoffset;	/* indes for cross-line offset component */
	long oldoffset;	/* offset of previous trace */
	long oldcdp;	/* cdp of previous trace */
	int newsloth;	/* if non-zero, new sloth function was computed */
	float tn;	/* NMO time (time after NMO correction) */
	float v;	/* velocity */
	float *qtn;	/* NMO-corrected trace q(tn) */
	float *ttn;	/* time t(tn) for NMO */
	float *atn;	/* amplitude a(tn) for NMO */
	float *qt;	/* inverse NMO-corrected trace q(t) */
	float *tnt;	/* time tn(t) for inverse NMO */
	float *at;	/* amplitude a(t) for inverse NMO */
	float acdp;	/* temporary used to sort cdp array */
	float *aovv;	/* temporary used to sort ovv array */
	float *aoa1;	/* temporary used to sort oa1 array */
	float *aoa2;	/* temporary used to sort oa2 array */
	float temp;	/* temporary float */
	float tsq;	/* temporary float */
	int i;		/* index used in loop */
	int upward;	/* scans upward if it's nonzero. */
a144 1
	sy  = tr.sy;
a152 8
		if (countparname("anis1")!=ncdp &&
		    countparname("anis1")!=0)
			err("an anis1 array must be specified for each cdp, "
			    "or omitted at all");
		if (countparname("anis2")!=ncdp &&
		    countparname("anis2")!=0)
			err("an anis2 array must be specified for each cdp, "
			    "or omitted at all");
a158 4
		if (countparname("anis1")>1)
			err("only one (or no) anis1 array must be specified");
		if (countparname("anis2")>1)
			err("only one (or no) anis2 array must be specified");
d163 1
a163 2
	oa1 = ealloc2float(nt,ncdp);
	oa2 = ealloc2float(nt,ncdp);
d165 1
d168 1
a168 2
		nanis1 = countnparval(icdp+1,"anis1");
		nanis2 = countnparval(icdp+1,"anis2");
d171 1
a171 4
		if (nanis1!=nvnmo && nanis1 != 0)
			err("number of vnmo and anis1 values must be equal");
		if (nanis2!=nvnmo && nanis2 != 0)
			err("number of vnmo and anis2 values must be equal");
d174 2
a175 3
		if (nanis1==0) nanis1 = nvnmo;
		if (nanis2==0) nanis2 = nvnmo;
		/* equal numbers of parameters vnmo, tnmo, anis1, anis2 */
d178 1
a178 2
		anis1 = ealloc1float(nvnmo);
		anis2 = ealloc1float(nvnmo);
a180 4
		if (!getnparfloat(icdp+1,"anis1",anis1)) 
			for (i=0; i<nvnmo; i++) anis1[i] = 0.0;
		if (!getnparfloat(icdp+1,"anis2",anis2))
			for (i=0; i<nvnmo; i++) anis2[i] = 0.0;
d188 1
a188 8
		for (it=0,tn=ft; it<nt; ++it,tn+=dt) {
			intlin(ntnmo,tnmo,anis1,anis1[0],anis1[nanis1-1],1,&tn,
			       &oa1[icdp][it]);
		}
		for (it=0,tn=ft; it<nt; ++it,tn+=dt) {
			intlin(ntnmo,tnmo,anis2,anis2[0],anis2[nanis2-1],1,&tn,
			       &oa2[icdp][it]);
		}
a190 2
		free1float(anis1);
		free1float(anis2);
a196 2
		aoa1 = oa1[jcdp];
		aoa2 = oa2[jcdp];
a199 2
			oa1[icdp+1] = oa1[icdp];
			oa2[icdp+1] = oa2[icdp];
a202 2
		oa1[icdp+1] = aoa1;
		oa2[icdp+1] = aoa2;
a206 2
	if (!getparint("ixoffset",&ixoffset)) ixoffset=0; 
	  if (ixoffset==0) sy = 0.0;
a214 2
	oa1t = ealloc1float(nt);
	oa2t = ealloc1float(nt);
d223 1
a223 1
	interpovv(nt,ncdp,cdp,ovv,oa1,oa2,(float)tr.cdp,ovvt,oa1t,oa2t);
d227 2
a228 3
	oldoffset = tr.offset-1;

	warn("sy = %f",sy);
d234 2
a235 2
			interpovv(nt,ncdp,cdp,ovv,oa1,oa2,(float)tr.cdp,
				  ovvt,oa1t,oa2t);
d241 1
a241 1
		/* if sloth and anis function or offset has changed */
d243 11
d255 1
a255 1
			temp = ((float) tr.offset*(float) tr.offset + sy*sy)/(dt*dt);
d257 1
a257 10
				tsq = temp*ovvt[it] + \
				      oa1t[it]*temp*temp / (1.0+oa2t[it]*temp);
				if (tsq<0.0)
					err("negative moveout; check anis1, "
					    "anis2, or suwind far-offset "
					    "traces");
				if ((1.0+oa2t[it]*temp)<=0.0)
					err("anis2 negative and too small; "
					    "check anis2, or suwind far-offset"
					    " traces");
d267 2
a268 3
			if( !upward ) {
				for (it=0; it<nt-1 && atn[it]<osmute; ++it)
					;
d271 1
a271 2
				for (it=nt-1; it>0 && atn[it]>=osmute; --it)
					;
d354 3
a356 3
/* linearly interpolate/extrapolate sloth and anis between cdps */
static void interpovv (int nt, int ncdp, float *cdp, float **ovv, float **oa1, 
	float **oa2, float cdpt, float *ovvt, float *oa1t, float *oa2t)
d358 1
a358 1
	static int indx=0;
d364 1
a364 1
		for (it=0; it<nt; ++it) {
a365 3
			oa1t[it] = oa1[0][it];
			oa2t[it] = oa2[0][it];
		      };
d369 1
a369 1
		for (it=0; it<nt; ++it) {
a370 3
			oa1t[it] = oa1[ncdp-1][it];
			oa2t[it] = oa2[ncdp-1][it];
		      };
d374 5
a378 8
		xindex(ncdp,cdp,cdpt,&indx);
		a1 = (cdp[indx+1]-cdpt)/(cdp[indx+1]-cdp[indx]);
		a2 = (cdpt-cdp[indx])/(cdp[indx+1]-cdp[indx]);
		for (it=0; it<nt; ++it) {
			ovvt[it] = a1*ovv[indx][it]+a2*ovv[indx+1][it];
			oa1t[it] = a1*oa1[indx][it]+a2*oa1[indx+1][it];
			oa2t[it] = a1*oa2[indx][it]+a2*oa2[indx+1][it];
		      };
@


1.23
log
@cosmetic
@
text
@d1 1
a1 1
/* SUNMO: $Revision: 1.22 $ ; $Date: 2003/06/09 16:17:07 $		*/
d15 1
a15 1
" vnmo=2000		NMO velocities corresponding to times in tnmo	     ",
d214 1
a214 1
		if (!getnparfloat(icdp+1,"vnmo",vnmo)) vnmo[0] = 2000.0;
@


1.22
log
@9 June 2003
@
text
@d1 1
a1 1
/* NMO: $Revision: 1.21 $ ; $Date: 1998/08/24 20:54:33 $		*/
d9 1
a9 1
" NMO - NMO for an arbitrary velocity function of time and CDP	     ",
d11 1
a11 1
" nmo <stdin >stdout [optional parameters]				     ",
@


1.21
log
@adds Carlos Theodoro's extension to take into account lateral offset as
determined by sy header field
@
text
@d1 1
a1 1
/* NMO: $Revision: 1.20 $ ; $Date: 1997/06/26 15:44:50 $		*/
d25 1
d80 2
d150 1
d267 1
d324 10
a333 3
			for (it=0,itmute=0; it<nt && atn[it]<osmute; ++it)
				itmute++;
			
d409 1
a409 1
	return EXIT_SUCCESS;
@


1.20
log
@explicit casts on multiplication of tr.offset * tr.offset to (float)
@
text
@d1 1
a1 1
/* SUNMO: $Revision: 1.19 $ ; $Date: 1996/08/20 18:54:14 $		*/
d9 1
a9 1
" SUNMO - NMO for an arbitrary velocity function of time and CDP	     ",
d11 1
a11 1
" sunmo <stdin >stdout [optional parameters]				     ",
d23 2
d59 1
a59 1
" Sunmo cannot handle negative moveout as in triplication caused by	     ",
d78 1
d86 1
a86 1
 * Trace header fields accessed: ns, dt, delrt, offset, cdp
d127 2
d157 1
d257 2
d282 2
d298 1
a298 1
			temp = ((float) tr.offset*(float) tr.offset)/(dt*dt);
@


1.19
log
@Use default cdp=tr.cdp instead of 0
@
text
@d1 1
a1 1
/* SUNMO: $Revision: 1.18 $ ; $Date: 1996/05/02 19:44:07 $		*/
d288 1
a288 1
			temp = (tr.offset*tr.offset)/(dt*dt);
@


1.18
log
@./main/sunmo.c
"sunmo.c", line 395: warning: index redefinition hides earlier one
Used indx instead.
@
text
@d1 1
a1 1
/* SUNMO: $Revision: 1.17 $ ; $Date: 1996/01/30 16:00:31 $		*/
d14 9
a22 9
" tnmo=0		  NMO times corresponding to velocities in vnmo	     ",
" vnmo=2000		  NMO velocities corresponding to times in tnmo	     ",
" anis1=0		  two anisotropy coefficients making up quartic term ",
" anis2=0		  in traveltime curve, corresponding to times in tnmo",
" cdp=0			  CDPs for which vnmo and tnmo are specified	     ",
" smute=1.5		  samples with NMO stretch exceeding smute are zeroed",
" lmute=25		  length (in samples) of linear ramp for stretch mute",
" sscale=1		  =1 to divide output samples by NMO stretch factor  ",
" invert=0		  =1 to perform (approximate) inverse NMO	     ",
d54 2
d93 1
d121 1
a121 1
	int itmute;	/* zero samples with indices less than itmute */
d180 1
a180 1
	if (!getparfloat("cdp",cdp)) cdp[0] = 0.0;
@


1.17
log
@Deal with header fields accessed/modified in sudoc.
Fix some wrapped lines.
@
text
@d1 1
a1 1
/* SUNMO: $Revision: 1.16 $ ; $Date: 1995/11/14 20:36:33 $		*/
d392 1
a392 1
	static int index=0;
d414 3
a416 3
		xindex(ncdp,cdp,cdpt,&index);
		a1 = (cdp[index+1]-cdpt)/(cdp[index+1]-cdp[index]);
		a2 = (cdpt-cdp[index])/(cdp[index+1]-cdp[index]);
d418 3
a420 3
			ovvt[it] = a1*ovv[index][it]+a2*ovv[index+1][it];
			oa1t[it] = a1*oa1[index][it]+a2*oa1[index+1][it];
			oa2t[it] = a1*oa2[index][it]+a2*oa2[index+1][it];
@


1.16
log
@Smoothed comments a bit.
@
text
@d1 1
a1 1
/* SUNMO: $Revision: 1.15 $ ; $Date: 1995/11/14 20:26:52 $		*/
a68 2
"									     ",
" Trace header fields accessed:	 ns, dt, delrt, offset, cdp.		     ",
d80 2
d159 2
a160 1
			err("an anis1 array must be specified for each cdp, or omitted at all");
d163 2
a164 1
			err("an anis2 array must be specified for each cdp, or omitted at all");
d289 8
a296 2
				if (tsq<0.0) err("negative moveout; check anis1, anis2, or suwind far-offset traces");
				if ((1.0+oa2t[it]*temp)<=0.0) err("anis2 negative and too small; check anis2, or suwind far-offset traces");
@


1.15
log
@Bjoern Rommel's extension to include the quartic term of the
traveltime series into the NMO-correction.  Isotropy is assumed by
default. Otherwise the anisotropy must be specified like vnmo and
tnmo.
@
text
@d1 1
a1 1
/* SUNMO: $Revision: 1.14 $ ; $Date: 1995/08/03 16:34:12 $		*/
d28 2
a29 4
" The anisotropy coefficients anis1, anis2 allow to take non-hyperbolicity   ",
" due to layering, mode conversion, and even anisotropy into account. For    ",
" isotropic NMO, omit anis1 and anis2 at all; otherwise specify as many	     ",
" anis1's and/or anis2's as you specify vnmo's.				     ",
d54 1
d57 2
a58 2
" sufficiently large offsets. Then an error (negative moveout) is prompted.  ",
" Check anis1. An error (anis2 too small) is also prompted, if only the	     ",
d74 2
a75 2
 *	SEP: Shuki, Chuck
 *	CWP: Shuki, Jack, Dave, Bjoern (including quartic term)
@


1.14
log
@Zapped unneeded cast of tr.delrt (sigh).
@
text
@d1 2
a2 2
/* SUNMO: $Revision: 1.13 $ ; $Date: 1995/08/02 21:06:15 $		*/

d8 29
a36 21
"									",
" SUNMO - NMO for an arbitrary velocity function of time and CDP	",
"									",
" sunmo <stdin >stdout [optional parameters]				",
"									",
" Optional Parameters:							",
" vnmo=2000               NMO velocities corresponding to times in tnmo	",
" tnmo=0                  NMO times corresponding to velocities in vnmo	",
" cdp=0                   CDPs for which vnmo and tnmo are specified	",
" smute=1.5               samples with NMO stretch exceeding smute are zeroed",
" lmute=25                length (in samples) of linear ramp for stretch mute",
" sscale=1                =1 to divide output samples by NMO stretch factor",
" invert=0                =1 to perform (approximate) inverse NMO	",
" 									",
" Notes:								",
" For constant-velocity NMO, specify only one vnmo=constant.		",
" 									",
" For NMO with a velocity function of time only, specify the arrays	",
"          vnmo=v1,v2,... tnmo=t1,t2,...				",
" where v1 is the velocity at time t1, v2 is the velocity at time t2, ...",
" The times specified in the tnmo array must be monotonically increasing.",
d38 34
a71 16
" is used to compute the velocities at times not specified.		",
" 									",
" For NMO with a velocity function of time and CDP, specify the array	",
"          cdp=cdp1,cdp2,...						",
" and, for each CDP specified, specify the vnmo and tnmo arrays as described",
" above.  The first (vnmo,tnmo) pair corresponds to the first cdp, and so on.",
" Linear interpolation and constant extrapolation of 1/velocity^2 is used",
" to compute velocities at CDPs not specified.				",
" 									",
" NMO interpolation error is less than 1% for frequencies less than 60% of",
" the Nyquist frequency.						",
"									",
" Exact inverse NMO is impossible, particularly for early times at large",
" offsets and for frequencies near Nyquist with large interpolation errors.",
"									",
" Trace header fields accessed:  ns, dt, delrt, offset, cdp.		",
d76 1
a76 1
 *	CWP: Shuki, Jack, Dave
d86 3
a88 2
static void interpovv (int nt, int ncdp, float *cdp, float **ovv, 
	float cdpt, float *ovvt);
d108 8
d135 2
d138 2
d158 6
d166 8
d178 2
d183 2
d187 4
d192 4
a195 1
		if (ntnmo==0) ntnmo = 1;
d198 2
d202 4
d213 8
d223 2
d227 1
a227 1
	/* sort (by insertion) sloth functions by increasing cdp */
d231 2
d236 2
d241 2
d254 2
d263 2
a264 2
	/* interpolate sloth function for first trace */
	interpovv(nt,ncdp,cdp,ovv,(float)tr.cdp,ovvt);
d272 1
a272 1
		/* if necessary, compute new sloth function ovv(t) */
d274 2
a275 1
			interpovv(nt,ncdp,cdp,ovv,(float)tr.cdp,ovvt);
d281 1
a281 1
		/* if sloth function or offset has changed */
a282 1
		
d285 7
a291 3
			for (it=0,tn=ft/dt; it<nt; ++it,tn+=1.0)
				ttn[it] = sqrt(tn*tn+temp*ovvt[it]);
			
d381 3
a383 3
/* linearly interpolate/extrapolate sloth between cdps */
static void interpovv (int nt, int ncdp, float *cdp, float **ovv, 
	float cdpt, float *ovvt)
d391 1
a391 1
		for (it=0; it<nt; ++it)
d393 3
d399 1
a399 1
		for (it=0; it<nt; ++it)
d401 3
d410 1
a410 1
		for (it=0; it<nt; ++it)
d412 3
@


1.13
log
@Cast the integers tr.dt and/or tr.delrt and/or clones to double before
division with floating constant (which is implicitly double
precision).  Casting is needed to make some compilers happy and if we
cast to float then there will be an extra conversion to double because
of the floating constant (casting to float and writing 1000000.0F
would save a conversion, but most people find that F yucky and
efficiency is not an issue here).
Motivated by examples from Stew Levin.
@
text
@d1 1
a1 1
/* SUNMO: $Revision: 1.12 $ ; $Date: 1994/08/25 15:00:10 $		*/
d110 1
a110 1
	ft = ((double) tr.delrt)/1000.0;
@


1.12
log
@Removed copyright statement from codes that had it.
Moved self-doc line for sudoc.
@
text
@d1 1
a1 1
/* SUNMO: $Revision: 1.11 $ ; $Date: 93/11/29 14:38:07 $		*/
d109 2
a110 2
	dt = tr.dt/1000000.0;
	ft = tr.delrt/1000.0;
@


1.11
log
@changed bcopy to memcpy
@
text
@d1 1
a1 1
/* SUNMO: $Revision: 1.10 $ ; $Date: 92/10/26 14:20:25 $			*/
a2 13
/*----------------------------------------------------------------------
 * Copyright (c) Colorado School of Mines, 1990.
 * All rights reserved.
 *
 * This code is part of SU.  SU stands for Seismic Unix, a processing line
 * developed at the Colorado School of Mines, partially based on Stanford
 * Exploration Project (SEP) software.  Inquiries should be addressed to:
 *
 *  Jack K. Cohen, Center for Wave Phenomena, Colorado School of Mines,
 *  Golden, CO 80401  (jkc@@dix.mines.colorado.edu)
 *----------------------------------------------------------------------
 */

a46 1
/**************** end self doc *******************************************/
d58 1
@


1.10
log
@new selfdoc installed
@
text
@d1 1
a1 1
/* SUNMO: $Revision: 1.9 $ ; $Date: 91/09/05 08:51:15 $			*/
d265 2
a266 1
			bcopy(qtn,tr.data,nt*sizeof(float));
d285 2
a286 1
			bcopy(qt,tr.data,nt*sizeof(float));
@


1.9
log
@string -> String and so forth
@
text
@d1 1
a1 1
/* SUNMO: $Revision: 1.8 $ ; $Date: 90/12/07 13:35:44 $			*/
d20 40
a59 40
String sdoc =
"\n"
"SUNMO - NMO for an arbitrary velocity function of time and CDP\n"
"\n"
"sunmo <stdin >stdout [optional parameters]\n"
"\n"
"Optional Parameters:\n"
"vnmo=2000               NMO velocities corresponding to times in tnmo\n"
"tnmo=0                  NMO times corresponding to velocities in vnmo\n"
"cdp=0                   CDPs for which vnmo and tnmo are specified\n"
"smute=1.5               samples with NMO stretch exceeding smute are zeroed\n"
"lmute=25                length (in samples) of linear ramp for stretch mute\n"
"sscale=1                =1 to divide output samples by NMO stretch factor\n"
"invert=0                =1 to perform (approximate) inverse NMO\n"
"\n"
"Notes:\n"
"For constant-velocity NMO, specify only one vnmo=constant.\n"
"\n"
"For NMO with a velocity function of time only, specify the arrays\n"
"         vnmo=v1,v2,... tnmo=t1,t2,...\n"
"where v1 is the velocity at time t1, v2 is the velocity at time t2, ...\n"
"The times specified in the tnmo array must be monotonically increasing.\n"
"Linear interpolation and constant extrapolation of the specified velocities\n"
"is used to compute the velocities at times not specified.\n"
"\n"
"For NMO with a velocity function of time and CDP, specify the array\n"
"         cdp=cdp1,cdp2,...\n"
"and, for each CDP specified, specify the vnmo and tnmo arrays as described\n"
"above.  The first (vnmo,tnmo) pair corresponds to the first cdp, and so on.\n"
"Linear interpolation and constant extrapolation of 1/velocity^2 is used\n"
"to compute velocities at CDPs not specified.\n"
"\n"
"NMO interpolation error is less than 1% for frequencies less than 60% of\n"
"the Nyquist frequency.\n"
"\n"
"Exact inverse NMO is impossible, particularly for early times at large\n"
"offsets and for frequencies near Nyquist with large interpolation errors.\n"
"\n"
"Trace header fields accessed:  ns, dt, delrt, offset, cdp.\n"
"\n";
d117 1
a117 1
	askdoc(1);
@


1.8
log
@Oops, self-doc said inmo was default.
@
text
@d1 1
a1 1
/* SUNMO: $Revision: 1.7 $ ; $Date: 90/12/01 10:33:19 $			*/
d20 1
a20 1
string sdoc =
@


1.7
log
@Major re-write including new handling of vel models,
sinc interpolation and folding in of suinmo.
@
text
@d1 1
a1 1
/* SUNMO: $Revision: 1.6 $ ; $Date: 90/06/14 14:38:34 $			*/
d33 1
a33 1
"invert=1                =1 to perform (approximate) inverse NMO\n"
@


1.6
log
@Tweak
@
text
@d1 1
a1 1
/* SUNMO: $Revision: 1.5 $ ; $Date: 90/06/14 14:31:09 $			*/
d20 40
a59 34
string sdoc = "\
									\n\
SUNMO - NMO with arbitrary velocity model				\n\
									\n\
sunmo <stdin >stdout v= [optional parameters]		 		\n\
									\n\
Required parameter:					        	\n\
	v=	velocity--may be a constant, vector or file		\n\
		(1) if v=v0 then do constant velocity nmo.		\n\
		(2) if v=v1,...,vn, then must also supply		\n\
		    tv=t1,...,tn and do stratified velocity nmo.	\n\
		    To read these from a file use par=filename		\n\
		(3) if v=filename, then do v(t,x) nmo.			\n\
	 	    velocity file format:				\n\
							        	\n\
			m 11						\n\
				tv1.1    v1.1				\n\
				tv1.2    v1.2				\n\
			m 247						\n\
				tv2.1    v2.1				\n\
				tv2.2    v2.2				\n\
							        	\n\
		    where 11, 247, etc. are the midpoint (tr.cdp)      	\n\
		    locations corresponding to each velocity function. 	\n\
		    Midpoints should be in increasing order.        	\n\
							        	\n\
Optional parameters:					        	\n\
	stretch=1.5	The maximum nmo stretch for hard mute.		\n\
	dt= (header)	time sample rate				\n\
	verbose=0	verbose=1 for echoing of info to stderr.	\n\
									\n\
Note: sunmo depends on the dt, offset and cdp fields being set.		\n\
									\n\
";
d64 1
a64 1
 *	CWP: Shuki, Jack 
d73 3
a77 3
/* Note: for convenience we coin the phrase, "sloth", to mean   */
/*      the reciprocal of velocity squared (square of slowness) */

d80 34
a113 5
	enum {		/* velocity variation flag: velvar	*/
		vconst,		/* constant velocity nmo	*/
		voft,		/* v(t) nmo			*/
		vofxt		/* v(x,t) nmo			*/
	} velvar;
d115 1
a115 52
	struct vxtstrct {	/* holds vofxt velocity model	*/
		int cmp;		/* midpoint		*/
		float *ovv;		/* sloths: 1.0/(v*v)	*/
	} *vxt;

	bool connmo;	/* constant velocity nmo?		*/
	string vfname;	/* name of velocity file		*/
	FILE *fpvf;	/* ... its file pointer			*/
	float stretch;	/* hard mute limit 			*/
	float os;	/* 1.0/stretch				*/
	float *gain;	/* amount of stretching at each point	*/
	int verbose;	/* if 1 (yes) echo parameters to stderr */
	int nt;		/* number of samples from first header	*/
	int ntsize;	/* nt * sizeof(float) 			*/
	register
	   int it;	/* counter over time samples		*/
	float dt;	/* sample rate from first header	*/
	float tmax;	/* nt*dt				*/
	register
	   float *v;	/* velocity picks for vel model		*/
	register
	   float *tv;	/* time picks for vel model		*/
	int *itv;	/* ... normalized to unit spacing	*/
	int nv;		/* number of v's 			*/
	int ntv;	/* number of tv's read by getpar	*/
	int iv;		/* counter over v's and tv's		*/
	int j;		/* counter over cmp's			*/
	float x;	/* cast offset to float			*/
	float xsq;	/* x squared				*/
	float *tnmo;	/* NMO times				*/
	int *itnmo;	/* base point for the interpolation, i.e.,
			   we use the indices itnmo+1, ...	*/
	float **w;	/* interpolation weights		*/
	float *nmoed;	/* NMO stretched data			*/
	float *vvec;	/* velocity model v[nt]			*/
	register
	   float *ovv;	/* sloth model -- 1.0/(v*v)		*/
	float xxovv;	/* (x/v) squared			*/
	char s[BUFSIZ];	/* buffer for line of velocity file	*/
	char s1[64];	/* first element of velocity file entry	*/
	char s2[64];	/* second element ...			*/
	int ncmp;	/* no of cmp specified in velocity file	*/
	int nvmax;	/* max number of v's for any cmp in ...	*/
	int oldoffset;	/* last tr.offset value			*/
	int oldcmp;	/* last tr.cdp value			*/
	float a, b, c;	/* temps for interpolating sloth	*/
	bool newvelfun;	/* At next cmp where vel is specified?	*/
	bool hit;	/* At cmp where vel is specified? 	*/
	void vintrp();	/* velocity interpolation function	*/


	/* Initialize */
d119 1
a119 6

	/* Set verbose parameter */
	verbose = 0;	igetpar("verbose", &verbose);


	/* Get information from the first header */
a120 2
	dt = tr.dt/1000000.0;	fgetpar("dt", &dt);
	if (!dt) err("dt header field must be set");
d122 2
a123 3
	ntsize = nt * FSIZE;
	tmax = nt * dt;
	if (verbose) warn("\tdt=%g nt=%d tmax=%g", dt, nt, tmax);
d125 30
a154 47

	/* Get hard mute limit */
	stretch = 1.5;	fgetpar("stretch", &stretch);
	if (stretch <= 0.0) err("stretch = %f, must be positive", stretch);
	if (verbose) warn("\tstretch = %.2f", stretch);
	os = 1.0/stretch;


	/* Allocate space for nmo operations.        */
	/*    In general, the 2 should be nwts for w */
	tnmo  = ealloc1float(nt);
	gain  = ealloc1float(nt);
	nmoed = ealloc1float(nt);
	vvec  = ealloc1float(nt);
	ovv   = ealloc1float(nt);
	w     = ealloc2float(2, nt);
	itnmo = ealloc1int(nt);


	/* Determine type of velocity variation and set nmo function */
	/*    For const nmo and voft nmo, allocate velocity vector   */
	/*    Treat v as string to encompass file names & vectors    */
	if (sgetpar("v", &vfname)) {
		fpvf = fopen(vfname, "r");
		if (fpvf != NULL) {		/* v is a file */
			velvar = vofxt;
			connmo = false;

		} else {			/* v is a vector */

			/* Discriminate const vs. voft by length of v  */
			if (nv = countparval("v")) v = ealloc1float(nv);
			fgetpar("v", v);

			switch (nv) {
			case 0: /* defensive programming */
				err("must specify velocity model");
			break;
			case 1:
				velvar = vconst;
				connmo = true;
			break;
			default:
				velvar = voft;
				connmo = false;
			break;
			}
d156 2
a157 2
	} else {	/* sgetpar() came up empty */
		err("must specify velocity model");
d160 7
a166 17

	/* Construct velocity model for each of the three cases */
	switch (velvar) {
	case vconst:
		/* Check that v is nonzero */
		if (*v <= 0.0) err("v must be positive");

		/* Convert to sloth and scale to unit time spacing */
		*ovv = 1.0/(*v * *v * dt * dt);
		if (verbose) warn("\tconstant velocity nmo v=%g", v[0]);
	break;
	case voft:
		/* Check that v's are nonzero */
		for (iv = 0; iv < nv; ++iv) {
			if ( v[iv] == 0.0) {
				err("v's must be non zero");
			}
d168 3
d172 6
a177 3
		/* Allocate space for time picks */
		tv  = ealloc1float(nv);
		itv = ealloc1int(nv);
d179 8
a186 9
		/* Check that we have the right number of tv's */
		switch(ntv = fgetpar("tv", tv)) {
		case 0:
		    err("for v(t) variable velocity, need tv=");
		default:
		    if (ntv != nv)
			    err("number of tv's (%d) and v's (%d) unequal"
								,ntv, nv);
		}
d188 2
a189 7
		/* Test for monotonicity of time picks */
		for (iv = 0; iv < ntv-1; ++iv) {
			if (tv[iv+1] <= tv[iv]) {
			   err("tv's must increase: tv[%d]=%f tv[%d]=%f",
					iv, tv[iv], iv+1, tv[iv+1]);
			}
		}
d191 3
a193 7
		/* Echo v's and tv's before normalizing */
		if (verbose) {
			warn("\tstratified velocity nmo");
			for (iv = 0; iv < nv; ++iv) {
				warn("\ttv=%.4f\tv=%g", tv[iv], v[iv]);
			}
		}
d195 8
a202 4
		/* Normalize v and tv so that dt = 1 (v*tv unchanged) */
		for (iv = 0; iv < nv; ++iv) {
			v[iv] *= dt;
			itv[iv] = tv[iv]/dt;
d205 35
a239 26
		/* Interpolate velocity model */
		vintrp(vvec, nt, v, itv, nv);

		/* Convert it to sloth */
		for (it = 0; it < nt; ++it) {
			ovv[it] = 1.0/(vvec[it]*vvec[it]);
		}
	break;
	case vofxt:  /* v, tv not allocated yet in this case */
		if (verbose)
		  warn("\tlaterally varying velocity nmo, file: %s", vfname);

		/* Scan pass 1 (for ncmp and nvmax) */
		ncmp = 0;
		nvmax = 0;
		nv = 0;
		/* Read lines of vfile into buffer for error checking */
		while (NULL != fgets(s, BUFSIZ, fpvf)) {
			if (2 != sscanf(s, "%s %s", s1, s2)) {
				err("Bad velocity file line: %s\n", s);
			} else {
				if (*s1 == 'm') { /* New cmp */
					ncmp++;
					nv = 0;
				} else {	  /* Another pick */
					nv++;
a240 1
				nvmax = MAX(nvmax, nv);
d243 7
a249 90

		if (verbose) warn("\tncmp=%d nvmax=%d", ncmp, nvmax);


		/* Allocate space for vxt */
		vxt = (struct vxtstrct*) emalloc(ncmp*sizeof(struct vxtstrct));
		for (j = 0; j < ncmp; ++j) {
			vxt[j].ovv = ealloc1float(nt);
		}


		/* Allocate space for v, tv, itv */
		v = ealloc1float(nvmax);
		tv = ealloc1float(nvmax);
		itv = ealloc1int(nvmax);


		/* Scan pass 2 to read the vfile and convert it to vxt */
		/*   Now we are sure that vfile consists of pairs      */
		erewind(fpvf);
		fscanf(fpvf, "%s %s", s1, s2);
		for (j = 0; j < ncmp; ++j) {	/* Loop over midpoint */
			if (*s1 != 'm') {
				err("velocity file is missing an 'm' line");
			}
			vxt[j].cmp = eatoi(s2);
			for (nv = 0; nv <= nvmax; ++nv) {/* Loop on vels */
				if (EOF == fscanf(fpvf, "%s %s", s1, s2))
					break;
				if (*s1 == 'm')
					break;
				tv[nv] = eatof(s1);
				v[nv]  = eatof(s2);
			}

			/* Normalize v and tv so that dt = 1 */
			for (iv = 0; iv < nv; ++iv) {
				v[iv] *= dt;
				itv[iv] = tv[iv]/dt;
			}

			/* Interpolate velocity model */
			vintrp (vxt[j].ovv, nt, v, itv, iv);

			/* Convert it to sloth */
			for (it = 0; it < nt; ++it) {
				vxt[j].ovv[it] = 1.0/
					(vxt[j].ovv[it]*vxt[j].ovv[it]);
			}
		}
		efclose(fpvf);
	break;
	default:	/* defensive programming */
		err("%d: mysterious velvar value", __LINE__, velvar);
	}


	/* Main loop over traces */
	oldcmp = tr.cdp - 1;		/* Force new vel function */
	oldoffset = tr.offset - 1;	/* Force new nmo function */
	do {
		/* New velocity function? */
 		if (velvar == vofxt && tr.cdp != oldcmp) {

			newvelfun = true;

			/* Find j = midpoint index in the velocity model */
			for (j = 0; j < ncmp; ++j) {

			    if (vxt[j].cmp == tr.cdp) {	/* Hit */
				    hit = true;
				    break;
			    } else if (vxt[j].cmp > tr.cdp) { /* Passed */
				    hit = false;
				    break;
			    }
			}

			if (j < 0 || j > ncmp)
			    err("j=%d, must be between 1 and %d", j, ncmp);

			/* Now that j is known, find sloth for the cmp */
			if (hit) {		/* exact */
				bcopy(vxt[j].ovv, ovv, ntsize);

			} else if (j == 0) {	/* end point */
				bcopy(vxt[0].ovv, ovv, ntsize);

			} else if (j == ncmp) {	/* end point */
				bcopy(vxt[ncmp-1].ovv, ovv, ntsize);
d251 17
a267 11
			} else {		/* linearly interpolate */
				a = vxt[j].cmp - tr.cdp;
				b = tr.cdp - vxt[j-1].cmp;
				c = a + b;
				a /= c;
				b /= c;
				for (it = 0 ; it < nt; ++it) {
					ovv[it] = a*vxt[j-1].ovv[it] +
							b*vxt[j].ovv[it];
				}
			}
d269 16
a284 1
			newvelfun = false;
d287 1
a287 54
		/* New nmo function? */
		if (newvelfun || tr.offset != oldoffset) {

			/* Calculate fractional nmo time index, tnmo */
			x = (float) tr.offset;
			if (connmo) {
				xxovv = x * x * *ovv;
				for (it = 0; it < nt; ++it) {
				    tnmo[it] = sqrt(it*it + xxovv);
				}
			} else {
				xsq = x * x;
				for (it = 0; it < nt; ++it) {
				    tnmo[it] = sqrt(it*it + xsq*ovv[it]);
				}
			}

			/* Calculate amount of stretch */
			gain[0] = tnmo[1] - tnmo[0];
			for (it = 1; it < nt - 1; ++it) {
				gain[it] = 0.5*(tnmo[it+1] - tnmo[it-1]);
			}
			gain[nt-1] = tnmo[nt-1] - tnmo[nt-2];

			/* Mute overly stretched points */
			for (it = 0; it < nt; ++it) {
				if (gain[it] < os) gain[it] = 0.0;
			}

			/* Calculate the interpolation coefficients */
			for (it = 0; it < nt; ++it) {
				itnmo[it] = (int) tnmo[it] - 1;
				if (itnmo[it] > -2 && itnmo[it] < nt-2) {
					float p;
					p = tnmo[it] - (int) tnmo[it];
					w[it][0] = (1.0 - p) * gain[it];
					w[it][1] =      p    * gain[it];
				} else {
					itnmo[it] = -1;
					w[it][0] = 0.0;
					w[it][1] = 0.0;
				}
			}
		}

		/* Perform the NMO; put new data into nmoed */
		for (it = 0; it < nt; ++it) {
			nmoed[it] = w[it][0] * tr.data[itnmo[it] + 1] +
					w[it][1] * tr.data[itnmo[it] + 2];
		}

		/* Overwrite the segy data */
		bcopy(nmoed, tr.data, ntsize);

d290 1
d292 1
a292 1
		oldcmp = tr.cdp;
a295 1
	
d300 3
a302 3

/* Interpolate/extrapolate velocity picks to the nt time points */
void vintrp(float *vvec, int nt, float *v, int *itv, int nv)
d304 3
a306 1
	int i, j, minnttv;
d308 17
a324 3
	/* Extend first velocity pick as constant back up to surface */
	for (i = 0; i < itv[0]; ++i) {
		vvec[i] = v[0];
a325 20

	/* Recall that itv, v are normalized, so that dt = 1 */
	minnttv = MIN(nt, itv[nv-1]);
	for (; i < minnttv; ++i) { /* while time picks are on trace */

		/* Have the time i, if last time pick is smaller, */
		/* find the bracketing time pick                  */
		for (j = 1; i >= itv[j]; ++j)
			; 

		/* Have picks that bracket time i, interpolate */
		vvec[i] = v[j-1] +
			(i - itv[j-1])*(v[j] - v[j-1])/(itv[j] - itv[j-1]);
	}

	/* Extend last velocity pick as constant down to basement */
	for (; i < nt; ++i) {
		vvec[i] = v[nv-1];
	}
	return;
@


1.5
log
@Put fortran subs inline in the C main

@
text
@d1 1
a1 1
/* SUNMO: $Revision: 1.4 $ ; $Date: 90/05/29 20:44:53 $			*/
a127 1
	void lintrp();	/* nmo linear interpolation function	*/
@


1.4
log
@Attempt to maxgetpar() -> countparval()
@
text
@d1 1
a1 1
/* SUNMO: $Revision: 1.3 $ ; $Date: 90/05/25 19:26:09 $			*/
d112 1
a112 1
	float *w;	/* interpolation weights		*/
d165 1
a165 1
	w     = ealloc1float(2 * nt);
d215 1
a215 1
		for (iv = 0; iv < nv; iv++) {
d236 1
a236 1
		for (iv = 0; iv < ntv-1; iv++) {
d246 1
a246 1
			for (iv = 0; iv < nv; iv++) {
d252 1
a252 1
		for (iv = 0; iv < nv; iv++) {
d261 1
a261 1
		for (it = 0; it < nt; it++) {
d293 1
a293 1
		for (j = 0; j < ncmp; j++) {
d308 1
a308 1
		for (j = 0; j < ncmp; j++) {	/* Loop over midpoint */
d313 1
a313 1
			for (nv = 0; nv <= nvmax; nv++) {/* Loop on vels */
d323 1
a323 1
			for (iv = 0; iv < nv; iv++) {
d332 1
a332 1
			for (it = 0; it < nt; it++) {
d354 1
a354 1
			for (j = 0; j < ncmp; j++) {
d384 1
a384 1
				for (it = 0 ; it < nt; it++) {
d400 1
a400 1
				for (it = 0; it < nt; it++) {
d405 1
a405 1
				for (it = 0; it < nt; it++) {
d412 1
a412 1
			for (it = 1; it < nt - 1; it++) {
d418 1
a418 1
			for (it = 0; it < nt; it++) {
d423 13
a435 1
			lintrp(itnmo, w, tnmo, &nt, gain);
d439 4
a442 1
		strtch(nmoed, tr.data, &nt, itnmo, w);
d466 1
a466 1
	for (i = 0; i < itv[0]; i++) {
d472 1
a472 1
	for (; i < minnttv; i++) { /* while time picks are on trace */
d476 1
a476 1
		for (j = 1; i >= itv[j]; j++)
d485 1
a485 1
	for (; i < nt; i++) {
@


1.3
log
@vec --> ealloc1float, etc.
@
text
@d1 1
a1 1
/* SUNMO: $Revision: 1.2 $ ; $Date: 90/04/19 15:53:51 $			*/
d103 1
a103 1
	int nv;		/* number of v's estimated by maxgetpar	*/
d181 2
a182 4
			/*    Allocate an upper bound on the space for */
			/*    the velocity model using maxgetpar()     */
			nv = maxgetpar();
			v = ealloc1float(nv);
d184 1
a184 1
			switch (nv = fgetpar("v", v)) {
a190 2
				free1float(v);
				v = ealloc1float(1);
a194 2
				free1float(v);
				v = ealloc1float(nv);
@


1.2
log
@Normal move out
@
text
@d1 1
a1 1
/* SUNMO: $Revision: 1.1 $ ; $Date: 90/03/15 12:59:03 $			*/
d12 1
a12 1
 *  Golden, CO 80401  (isis!csm9a!jkcohen)
d27 1
a27 1
	v =	velocity--may be a constant, vector or file		\n\
d47 3
a49 3
	stretch = 1.5	The maximum nmo stretch for hard mute.		\n\
	dt = (header)	time sample rate				\n\
	verbose = 0	verbose=1 for echoing of info to stderr.	\n\
a64 2
 *
 *
a66 7
/* Embed Revision Control System identifier strings */
static string progid =
	"   $Source: /usr/local/src/su/src/sunmo.c,v $";
static string revid =
	"   $Revision: 1.1 $ ; $Date: 90/03/15 12:59:03 $";


d72 1
a72 2
main(argc,argv)
int argc; char **argv;
a133 5
	if (!igetpar("ID", &ID)) ID = 0;
	if (ID) {
		(void) fprintf(stderr, "%s\n", progid);
		(void) fprintf(stderr, "%s\n", revid);
	}
d160 7
a166 7
	tnmo  = vec(nt);
	gain  = vec(nt);
	nmoed = vec(nt);
	vvec  = vec(nt);
	ovv   = vec(nt);
	w     = vec(2 * nt);
	itnmo = ivec(nt);
d184 1
a184 1
			v = vec(nv);
d193 2
a194 2
				free_vec(v);
				v = vec(1);
d199 2
a200 2
				free_vec(v);
				v = vec(nv);
d228 2
a229 2
		tv  = vec(nv);
		itv = ivec(nv);
d298 1
a298 4
		if (NULL == (vxt = (struct vxtstrct*)
			malloc((uint) (ncmp * sizeof(struct vxtstrct))))) {
			syserr("malloc failed on vxt");
		}
d300 1
a300 1
			vxt[j].ovv = vec(nt);
d305 3
a307 3
		v = vec(nvmax);
		tv = vec(nvmax);
		itv = ivec(nvmax);
d312 1
a312 1
		rewind(fpvf);
d318 1
a318 5
			errno = 0;
			vxt[j].cmp = atoie(s2);
			if (errno) {
				syserr("atoie failed on %s", vxt[j].cmp);
			}
d324 2
a325 2
				tv[nv] = atof(s1);
				v[nv]  = atof(s2);
d343 1
a343 3
		if (EOF == fclose(fpvf)) {
			syserr("fclose failed on velocity file");
		}
d452 1
a452 3
void vintrp(vvec, nt, v, itv, nv)
int nt, nv, *itv;
float *vvec, *v;
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/* SUNMO: $Revision: 2.8 $ ; $Date: 89/09/20 19:37:05 $			*/
d4 1
a4 1
 * Copyright (c) Colorado School of Mines, 1989.
d16 1
a16 1
#include "cwp.h"
d54 1
a54 1
/*************************************************************************/
d71 1
a71 1
	"   $Source: /src/su/src/RCS/sunmo.c,v $";
d73 1
a73 1
	"   $Revision: 2.8 $ ; $Date: 89/09/20 19:37:05 $";
d85 1
a85 1
		const,		/* constant velocity nmo	*/
d142 1
a142 1
	/* Initialize SU */
d206 1
a206 1
				velvar = const;
d226 1
a226 1
	case const:
d470 1
a470 1
	return SUCCEED;
@
