head	1.63;
access;
symbols;
locks; strict;
comment	@ * @;


1.63
date	2019.07.22.16.31.00;	author john;	state Exp;
branches;
next	1.62;

1.62
date	2019.07.22.02.51.12;	author john;	state Exp;
branches;
next	1.61;

1.61
date	2013.10.21.20.15.08;	author john;	state Exp;
branches;
next	1.60;

1.60
date	2011.11.16.17.23.05;	author john;	state Exp;
branches;
next	1.59;

1.59
date	2011.11.11.23.58.23;	author john;	state Exp;
branches;
next	1.58;

1.58
date	2009.07.24.17.04.49;	author john;	state Exp;
branches;
next	1.57;

1.57
date	2008.11.18.01.26.37;	author john;	state Exp;
branches;
next	1.56;

1.56
date	2008.01.14.19.09.14;	author john;	state Exp;
branches;
next	1.55;

1.55
date	2007.02.20.21.46.01;	author john;	state Exp;
branches;
next	1.54;

1.54
date	2007.02.02.22.24.13;	author john;	state Exp;
branches;
next	1.53;

1.53
date	2006.12.18.18.12.03;	author john;	state Exp;
branches;
next	1.52;

1.52
date	2006.12.06.23.34.26;	author john;	state Exp;
branches;
next	1.51;

1.51
date	2006.11.07.21.16.33;	author john;	state Exp;
branches;
next	1.50;

1.50
date	2006.11.01.02.16.49;	author john;	state Exp;
branches;
next	1.49;

1.49
date	2006.10.31.21.59.36;	author john;	state Exp;
branches;
next	1.48;

1.48
date	2006.05.31.22.43.17;	author john;	state Exp;
branches;
next	1.47;

1.47
date	2004.11.16.17.01.25;	author john;	state Exp;
branches;
next	1.46;

1.46
date	2004.11.16.17.00.48;	author john;	state Exp;
branches;
next	1.45;

1.45
date	2003.02.11.19.32.29;	author john;	state Exp;
branches;
next	1.44;

1.44
date	2002.03.19.17.43.39;	author john;	state Exp;
branches;
next	1.43;

1.43
date	98.10.06.14.59.55;	author john;	state Exp;
branches;
next	1.42;

1.42
date	98.08.24.20.11.45;	author john;	state Exp;
branches;
next	1.41;

1.41
date	97.12.12.22.29.21;	author john;	state Exp;
branches;
next	1.40;

1.40
date	97.07.28.22.36.46;	author john;	state Exp;
branches;
next	1.39;

1.39
date	97.03.11.20.28.31;	author jkc;	state Exp;
branches;
next	1.38;

1.38
date	96.08.11.20.51.23;	author jkc;	state Exp;
branches;
next	1.37;

1.37
date	96.05.02.19.26.03;	author jkc;	state Exp;
branches;
next	1.36;

1.36
date	96.01.25.20.10.45;	author jkc;	state Exp;
branches;
next	1.35;

1.35
date	95.10.31.22.09.10;	author jkc;	state Exp;
branches;
next	1.34;

1.34
date	95.10.17.20.38.03;	author john;	state Exp;
branches;
next	1.33;

1.33
date	95.08.03.16.34.12;	author jkc;	state Exp;
branches;
next	1.32;

1.32
date	95.08.02.19.59.37;	author jkc;	state Exp;
branches;
next	1.31;

1.31
date	95.06.30.00.21.17;	author jkc;	state Exp;
branches;
next	1.30;

1.30
date	95.03.31.08.50.01;	author jkc;	state Exp;
branches;
next	1.29;

1.29
date	95.03.23.19.25.01;	author jkc;	state Exp;
branches;
next	1.28;

1.28
date	95.02.20.15.54.14;	author jkc;	state Exp;
branches;
next	1.27;

1.27
date	95.01.19.11.43.56;	author john;	state Exp;
branches;
next	1.26;

1.26
date	94.08.25.14.59.27;	author jkc;	state Exp;
branches;
next	1.25;

1.25
date	94.05.08.14.20.39;	author cartley;	state Exp;
branches;
next	1.24;

1.24
date	93.11.24.15.33.45;	author john;	state Exp;
branches;
next	1.23;

1.23
date	93.08.13.10.28.02;	author john;	state Exp;
branches;
next	1.22;

1.22
date	92.10.22.16.14.39;	author john;	state Exp;
branches;
next	1.21;

1.21
date	92.10.05.10.22.49;	author jkc;	state Exp;
branches;
next	1.20;

1.20
date	92.10.02.14.05.52;	author jkc;	state Exp;
branches;
next	1.19;

1.19
date	91.10.17.13.25.23;	author jkc;	state Exp;
branches;
next	1.18;

1.18
date	91.10.16.13.50.39;	author jkc;	state Exp;
branches;
next	1.17;

1.17
date	91.10.11.11.12.08;	author jkc;	state Exp;
branches;
next	1.16;

1.16
date	91.10.11.11.07.08;	author jkc;	state Exp;
branches;
next	1.15;

1.15
date	91.09.05.08.50.35;	author jkcohen;	state Exp;
branches;
next	1.14;

1.14
date	90.12.22.08.14.32;	author jkc;	state Exp;
branches;
next	1.13;

1.13
date	90.11.11.09.24.44;	author jkc;	state Exp;
branches;
next	1.12;

1.12
date	90.11.11.09.12.17;	author jkc;	state Exp;
branches;
next	1.11;

1.11
date	90.11.07.10.29.52;	author jkc;	state Exp;
branches;
next	1.10;

1.10
date	90.11.06.21.11.12;	author jkc;	state Exp;
branches;
next	1.9;

1.9
date	90.11.06.16.46.17;	author jkc;	state Exp;
branches;
next	1.8;

1.8
date	90.11.06.16.44.15;	author jkc;	state Exp;
branches;
next	1.7;

1.7
date	90.11.05.20.08.27;	author jkc;	state Exp;
branches;
next	1.6;

1.6
date	90.11.05.19.41.24;	author jkc;	state Exp;
branches;
next	1.5;

1.5
date	90.06.28.13.04.45;	author jkc;	state Exp;
branches;
next	1.4;

1.4
date	90.06.28.10.56.53;	author jkc;	state Exp;
branches;
next	1.3;

1.3
date	90.06.05.15.51.20;	author jkc;	state Exp;
branches;
next	1.2;

1.2
date	90.05.25.19.25.47;	author jkc;	state Exp;
branches;
next	1.1;

1.1
date	90.04.17.14.07.46;	author jkc;	state Exp;
branches;
next	;


desc
@Gains, scales, etc.
@


1.63
log
@updated by Dominique Rousset
@
text
@/* Copyright (c) Colorado School of Mines, 2011.*/
/* All rights reserved.                       */

/* SUGAIN: $Revision: 1.61 $ ; $Date: 2013/10/21 20:15:08 $		*/

#include "su.h"
#include "segy.h"
#include "header.h"
#include <signal.h>
#include <float.h>

/*********************** self documentation *****************************/
char *sdoc[] = {
"									",
" SUGAIN - apply various types of gain				  	",
"									",
" sugain <stdin >stdout [optional parameters]			   	",
"									",
" Required parameters:						  	",
"	none (no-op)						    	",
"									",
" Optional parameters:						  	",
"	panel=0	        =1  gain whole data set (vs. trace by trace)	",
"	tpow=0.0	multiply data by t^tpow			 	",
"	epow=0.0	multiply data by exp(epow*t)		    	",
"	etpow=1.0	multiply data by exp(epow*t^etpow)	    	",
"	gpow=1.0	take signed gpowth power of scaled data	 	",
"	agc=0	   flag; 1 = do automatic gain control	     		",
"	gagc=0	  flag; 1 = ... with gaussian taper			",
"	wagc=0.5	agc window in seconds (use if agc=1 or gagc=1)  ",
"	trap=none	zero any value whose magnitude exceeds trapval  ",
"	clip=none	clip any value whose magnitude exceeds clipval  ",
"	pclip=none	clip any value greater than clipval  		",
"	nclip=none	clip any value less than  clipval 		",
"	qclip=1.0	clip by quantile on absolute values on trace    ",
"	qbal=0	  flag; 1 = balance traces by qclip and scale     	",
"	pbal=0	  flag; 1 = bal traces by dividing by rms value   	",
"	mbal=0	  flag; 1 = bal traces by subtracting the mean    	",
"	maxbal=0	flag; 1 = balance traces by subtracting the max ",
"	scale=1.0	multiply data by overall scale factor	   	",
"	norm=0.0	divide data by overall scale factor	     	",
"	bias=0.0	bias data by adding an overall bias value	",
"	jon=0	   	flag; 1 means tpow=2, gpow=.5, qclip=.95	",
"	verbose=0	verbose = 1 echoes info				",
"	mark=0		apply gain only to traces with tr.mark=0	",
"			=1 apply gain only to traces with tr.mark!=0    ",
"	vred=0	  reducing velocity of data to use with tpow		",
"									",
" 	tmpdir=		if non-empty, use the value as a directory path	",
"			prefix for storing temporary files; else if the ",
"			the CWP_TMPDIR environment variable is set use  ",
"			its value for the path; else use tmpfile()	",
"									",
" Operation order:							",
" if (norm) scale/norm						  	",
"									",
" out(t) = scale * BAL{CLIP[AGC{[t^tpow * exp(epow * t^tpow) * ( in(t)-bias )]^gpow}]}",
"									",
" Notes:								",
"	The jon flag selects the parameter choices discussed in		",
"	Claerbout's Imaging the Earth, pp 233-236.			",
"									",
"	Extremely large/small values may be lost during agc. Windowing  ",
"	these off and applying a scale in a preliminary pass through	",
"	sugain may help.						",
"									",
"	Sugain only applies gain to traces with tr.mark=0. Use sushw,	",
"	suchw, suedit, or suxedit to mark traces you do not want gained.",
"	See the selfdocs of sushw, suchw, suedit, and suxedit for more	",
"	information about setting header fields. Use \"sukeyword mark\" ",
"	for more information about the mark header field.		",
"									",
"      debias data by using mbal=1					",
"									",
"      option etpow only becomes active if epow is nonzero		",
NULL};

/* Credits:
 *	SEP: Jon Claerbout
 *	CWP: Jack K. Cohen, Brian Sumner, Dave Hale
 *
 * Note: Have assumed tr.deltr >= 0 in tpow routine.
 *
 * Technical Reference:
 *	Jon's second book, pages 233-236.
 *
 * Trace header fields accessed: ns, dt, delrt, mark, offset
 */
/**************** end self doc *******************************************/

/* subroutine prototypes */
void gain(float *data, float tpow, float epow, float etpow, float gpow, float vred,
	  int agc, int gagc, int qbal, int pbal, int mbal, float scale, float bias,
	  register float trap, register float clip, float qclip, int iwagc,
	  register float tmin, register float dt, int nt,
	  int maxbal ,float pclip ,float nclip );
void do_tpow(float *data, float tpow, float vred, register float tmin,
	     register float dt, int nt);
void do_epow(float *data, float epow, float etpow, register float tmin, register float dt,
	     int nt);
void do_trap(float *data, register float trap, register int nt);
void do_clip(float *data, register float clip, register int nt);
void do_nclip(float *data, register float nclip, register int nt);
void do_pclip(float *data, register float pclip, register int nt);
void do_qclip(float *data, float qclip, int nt);
void do_qbal(float *data, float qclip, int nt);
void do_agc(float *data, int iwagc, int nt);
void do_gagc(float *data, int iwagc, int nt);
float quant(float *a, int k, int n);
static void closefiles(void);

#define TPOW     0.0
#define EPOW     0.0
#define ETPOW    1.0
#define GPOW     1.0
#define TRAP     0.0
#define CLIP     0.0
#define QCLIP    1.0
#define SCALE    1.0
#define BIAS     0.0
#define WAGC     0.5
#define VRED     0.0

/* Globals (so can trap signal) defining temporary disk files */
char tracefile[BUFSIZ];	/* filename for the file of traces	*/
char headerfile[BUFSIZ];/* filename for the file of headers	*/
FILE *tracefp;		/* fp for trace storage file		*/
FILE *headerfp;		/* fp for header storage file		*/

segy tr;

int
main(int argc, char **argv)
{
	int verbose;	/* flag for echoing info			*/
	int jon;	/* flag to get Claerbout values		 	*/
	int agc;	/* agc flag				     	*/
	int gagc;	/* gaussian agc flag			    	*/
	int pbal;	/* power balance flag			   	*/
	int qbal;	/* quantile balance flag			*/
	int mbal=0;     /* mean balance flag			    	*/
	float tpow;     /* exponent of t				*/
	float epow;     /* deattenutation coefficient		   	*/
	float etpow;    /* deattenutation power of t			*/
	float gpow;     /* dynamic compression power		    	*/
	float vred;	/* data reducing velocity in meters per second	*/
	float trap;     /* zero any larger value magnitude than trapval */
	float clip;     /* clip any larger value magnitude than clipval */
	float pclip;    /* clip any value greater than clipval		*/
	float nclip;    /* clip any value less than clipval		*/
	float qclip;    /* clip at qth quantile (100qth percentile)     */
	float scale;    /* overall scale factor				*/
	float norm;     /* reciprocal of scale factor			*/
	float bias=0.0; /* overall bias  value				*/
	float wagc;     /* size of agc window in seconds		*/
	int iwagc=0;    /* ... half window in samples		   	*/
	int nt;	 /* number of samples on trace		   		*/
	float tmin;     /* delay recording time in secs		 	*/
	float dt;	/* sample rate in secs			  	*/
	float *data;	/* the data					*/
	int panel;	/* gain trace by trace or whole data set?	*/

	int maxbal=0;   /* max balance flag			     	*/

	int mark;	/* mark flag					*/


	char *tmpdir;		/* directory path for tmp files		*/
	cwp_Bool istmpdir=cwp_false;/* true for user given path		*/


	/* Initialize */
	initargs(argc, argv);
	requestdoc(1);
	

	/* Look for user-supplied tmpdir */
	if (!getparstring("tmpdir",&tmpdir) &&
	    !(tmpdir = getenv("CWP_TMPDIR"))) tmpdir="";
	if (!STREQ(tmpdir, "") && access(tmpdir, WRITE_OK))
		err("you can't write in %s (or it doesn't exist)", tmpdir);


	/* Get nt from first trace */
	if (!gettr(&tr)) err("can't get first trace");
	nt   = (int) tr.ns;
	dt = ((double) tr.dt)/1000000.0;   /* microsecs to secs */
	tmin = tr.delrt/1000.0;		   /* millisecs to secs */
	if (!dt) getparfloat("dt", &dt);
	if (!dt) MUSTGETPARFLOAT("dt", &dt);


	/* Get parameters */
	if (!getparfloat ("tpow" , &tpow))	tpow     = TPOW;
	if (!getparfloat ("epow" , &epow))	epow     = EPOW;
	if (!getparfloat ("etpow" , &etpow))	etpow    = ETPOW;
	if (!getparfloat ("gpow" , &gpow))	gpow     = GPOW;
	if (!getparfloat ("vred" , &vred))	vred     = VRED;
	if (!getparfloat ("trap" , &trap))	trap     = TRAP;
	if (!getparfloat ("clip" , &clip))	clip     = CLIP;
	if (!getparfloat ("pclip" , &pclip))    pclip    = FLT_MAX;
	if (!getparfloat ("nclip" , &nclip))    nclip    = -FLT_MAX;
	if (!getparfloat ("qclip", &qclip))     qclip    = QCLIP;
	if (!getparfloat ("scale", &scale))     scale    = SCALE;
	if (!getparfloat ("norm",  &norm)) 	norm     = 0.0;
	if (!getparfloat ("bias",  &bias))	bias     = BIAS;
	if (!getparfloat ("wagc" , &wagc))	wagc     = WAGC;
	if (!getparint   ("agc"  , &agc))	agc	= 0;
	if (!getparint   ("gagc" , &gagc))	gagc     = 0;
	if (!getparint   ("pbal" , &pbal))	pbal     = 0;
	if (!getparint   ("qbal" , &qbal))	qbal     = 0;
	if (!getparint   ("mbal" , &mbal))	mbal     = 0;
	if (!getparint   ("panel", &panel))     panel    = 0;
	if (!getparint   ("jon"  , &jon))	jon	= 0;
	if (!getparint("verbose", &verbose))	verbose  = 0;
	if (!getparint   ("maxbal" , &maxbal))	maxbal   = 0;
	if (!getparint   ("mark" , &mark))	mark     = 0;
	
        checkpars();

	/* Data validation */
	if (vred < 0.0) err("vred = %f, must be positive", vred);
	if (trap < 0.0) err("trap = %f, must be positive", trap);
	if (clip < 0.0) err("clip = %f, must be positive", clip);
	if (qclip < 0.0 || qclip > 1.0) 
		err("qclip = %f, must be between 0 and 1", qclip);
	if (agc || gagc) {
		/* iwagc = NINT(wagc/dt); */
		iwagc = NINT(wagc/dt);
		if (iwagc < 1) err("wagc=%g must be positive", wagc);
		if (iwagc > nt) err("wagc=%g too long for trace", wagc);
		iwagc >>= 1;  /* windows are symmetric, so work with half -- right shift by one bit */
                if (verbose) warn("half window: %d samples",iwagc);
	}
	if (jon) { 
		tpow  = 2.0;
		gpow  = 0.5;
		qclip = 0.95;
	}

	if (norm) {
		scale /= norm;
	}

	/* Main loop over traces */
	if (!panel) { /* trace by trace */
		data = ealloc1float(nt);
		do {
			memcpy((void *)data, (const void *) tr.data, nt*FSIZE);

			if (!(tr.mark || mark) ) {
				gain(data, tpow, epow, etpow, gpow, vred, agc, gagc,
				     qbal, pbal, mbal, scale, bias, trap, clip,
				     qclip, iwagc, tmin, dt, nt, maxbal, pclip,
				     nclip );
			} else if ( (mark) && (tr.mark) ) {
				gain(data, tpow, epow, etpow, gpow, vred, agc, gagc,
				     qbal, pbal, mbal, scale, bias, trap, clip,
				     qclip, iwagc, tmin, dt, nt, maxbal, pclip,
				     nclip );
			}

			memcpy((void *)tr.data, (const void *) data, nt*FSIZE);
			puttr(&tr);

		} while(gettr(&tr));
	} else { /* do whole data set at once */
		int itr, ntr = 0;
		
		/* Store traces, headers in tempfiles while getting a count */
		if (STREQ(tmpdir,"")) {
			tracefp = etmpfile();
			headerfp = etmpfile();
			if (verbose) warn("using tmpfile() call");
		} else { /* user-supplied tmpdir */
		char directory[BUFSIZ];
		strcpy(directory, tmpdir);
		strcpy(tracefile, temporary_filename(directory));
		strcpy(headerfile, temporary_filename(directory));
		/* Handle user interrupts */
		signal(SIGINT, (void (*) (int)) closefiles);
		signal(SIGQUIT, (void (*) (int)) closefiles);
		signal(SIGHUP,  (void (*) (int)) closefiles);
		signal(SIGTERM, (void (*) (int)) closefiles);
		tracefp = efopen(tracefile, "w+");
		headerfp = efopen(headerfile, "w+");
			istmpdir=cwp_true;		
		if (verbose) warn("putting temporary files in %s", directory);
	}
		do {
			++ntr;
			efwrite(&tr, HDRBYTES, 1, headerfp);
			efwrite(tr.data, FSIZE, nt, tracefp);
		} while (gettr(&tr));
		erewind(tracefp);
		erewind(headerfp);
		data = ealloc1float(nt*ntr);
		
		/* Load traces into data and close tmpfile */
		efread(data, FSIZE, nt*ntr, tracefp);
		efclose(tracefp);
		if (istmpdir) eremove(tracefile);
	
		gain(data, tpow, epow, etpow, gpow, vred, agc, gagc, qbal,
		     pbal, mbal, scale, bias, trap, clip, qclip,
		     iwagc, tmin, dt, nt*ntr, maxbal, pclip, nclip );

		for (itr = 0; itr < ntr; itr++) {
			memcpy((void *) tr.data, (const void *) (data+itr*nt),
				nt*FSIZE);
			efread(&tr, 1, HDRBYTES, headerfp);
			puttr(&tr);
		}
		efclose(headerfp);
		if (istmpdir) eremove(headerfile);
	}
	
	free1(data);
	
	return(CWP_Exit());
}


/* Multiply by t^tpow */
void do_tpow(
	float *data,		/* the data			*/
	float tpow,	     /* multiply data by t^tpow	*/
	float vred,		/* reducing velocity		*/
	register float tmin,    /* first time on record	 */
	register float dt,	/* sampling rate in seconds     */
	int nt		  /* number of samples	    */
)
{
	static cwp_Bool first = cwp_true;   /* first entry flag     */
	static float *tpowfac;	  /* tpow values	  */
	register int i;		 /* counter		*/
	register float tred;	/* reduced time in seconds	*/

	if (first) { /* first entry, set up array of tpow factors */
		tpowfac = ealloc1float(nt);

		/* protect against negative tpow */
		tpowfac[0] = (tmin == 0.0) ? 0.0 : pow(tmin, tpow);
		for (i = 1; i < nt; ++i) 
			tpowfac[i] = pow(tmin + i*dt, tpow);

		first = cwp_false;
		/* for (i = 0; i < nt; ++i)
		   fprintf(stderr,"%d %f\n",i,tpowfac[i]); */
	} /* end first entry */

	if ( vred > 0.0 ) {	/* recompute array of tpowfac for each trace */
		tred = (float)tr.offset / vred;
		if ( tred < 0.0 ) tred *= -1.0;	/* remove sign */
		for (i = 1; i < nt; ++i)
			tpowfac[i] = pow(tmin + tred + i*dt, tpow);
	} /* fprintf(stderr,"%f %f %f\n",tred,tmin,tmin+(nt-1)*dt); */

	for (i = 0; i < nt; ++i)  data[i] *= tpowfac[i];
}


/* Exponential deattenuation  with deattenuation factor epow */
/* and with  with deattenuation  power etpow */
void do_epow(
	float *data,		/* the data			*/
	float epow,	     /* coefficient of t in exponent */
	float etpow,	     /* exponent of t in exponent */
	register float tmin,    /* first time on record	 */
	register float dt,	/* sampling rate in seconds     */
	int nt		  /* number of samples	    */
)
{
	register int i;		 /* counter		*/
	static cwp_Bool first = cwp_true;   /* first entry flag     */
	static float *epowfac;	  /* exponent stretchs    */
	static float *etpowfac;	  /* etpow values	  */

	if (first) {
		epowfac = ealloc1float(nt);
		etpowfac = ealloc1float(nt);


		/* protect against negative tpow */
		etpowfac[0] = (tmin == 0.0) ? 0.0 : pow(tmin, etpow);
		for (i = 1; i < nt; ++i) 
			etpowfac[i] = pow(tmin + i*dt, etpow);

		for (i = 0; i < nt; i++) 
			epowfac[i] = exp(epow * etpowfac[i]);

		first = cwp_false;
	}

	for (i = 0; i < nt; ++i)  data[i] *= epowfac[i];
}


/* Zero out outliers */
void do_trap(
	float *data,		/* the data			*/
	register float trap,    /* zero if magnitude > trap     */
	register int nt	 /* number of samples	    */
)
{
	register float *dataptr = data;

	while (nt--) {
		if (ABS(*dataptr) > trap) *dataptr = 0.0;
		dataptr++;
	}
}


/* Hard clip outliers */
void do_clip(
	float *data,		/* the data				*/
	register float clip,    /* hard clip if magnitude > clip	*/
	register int nt	 /* number of samples		    */
)
{
	register float *dataptr = data;
	register float mclip = -clip;

	while (nt--) {
		if (*dataptr > clip) {
			*dataptr = clip;
		} else if (*dataptr < mclip) {
			*dataptr = mclip;
		}
		dataptr++;
	}
}



/* Hard clip maxima */
void do_pclip(
	float *data,		/* the data				*/
	register float pclip,    /* hard clip if magnitude > clip	*/
	register int nt	 /* number of samples		    */
)
{
	register float *dataptr = data;

	while (nt--) {
		if (*dataptr > pclip) {
			*dataptr = pclip;
		}
		dataptr++;
	}
}


/* Hard clip minima */
void do_nclip(
	float *data,		/* the data				*/
	register float nclip,    /* hard clip if magnitude > clip	*/
	register int nt	 /* number of samples		    */
)
{
	register float *dataptr = data;

	while (nt--) {
		if (*dataptr < nclip) {
			*dataptr = nclip;
		}
		dataptr++;
	}
}


/* Quantile clip on magnitudes of trace values */
void do_qclip(
	float *data,	/* the data			*/
	float qclip,    /* quantile at which to clip    */
	int nt	  /* number of sample points	*/
)
{
	register int i;
	static cwp_Bool first = cwp_true;   /* first entry flag	     */
	static float *absdata;	  /* absolute value trace	 */
	static int iq;		  /* index of qclipth quantile    */
	float clip;		     /* ... value of rank[iq]	*/

	if (first) {
		absdata = ealloc1float(nt);
		iq = (int) (qclip * nt - 0.5); /* round, don't truncate */
		first = cwp_false;
	}

	/* Clip on value corresponding to qth quantile */
	for (i = 0; i < nt; ++i)  absdata[i] = ABS(data[i]);
	clip = quant(absdata, iq, nt);
	do_clip(data, clip, nt);
}


/* Quantile balance */
void do_qbal(
	float *data,	/* the data			*/
	float qclip,    /* quantile at which to clip    */
	int nt	  /* number of sample points	*/
)
{
	register int i;
	static cwp_Bool first = cwp_true;   /* first entry flag	     */
	static float *absdata;	  /* absolute value trace	 */
	static int iq;		  /* index of qclipth quantile    */
	float bal;			/* value used to balance trace  */

	if (qclip == 1.0) { /* balance by max magnitude on trace */
		bal = ABS(data[0]);
		for (i = 1; i < nt; ++i)  bal = MAX(bal, ABS(data[i]));

		if ((bal == 0.0)) {
			return;
		} else {
			for (i = 0; i < nt; ++i)  data[i] /= bal;
			return;
		}
	} else if (first) {
		absdata = ealloc1float(nt);
		iq = (int) (qclip * nt - 0.5); /* round, don't truncate */
		first = cwp_false;
	}

	/* Balance by quantile value (qclip < 1.0) */
	for (i = 0; i < nt; ++i)  absdata[i] = ABS(data[i]);
	bal = quant(absdata, iq, nt);

	if ((bal == 0.0)) {
		return;
	} else {
		for (i = 0; i < nt; ++i)  data[i] /= bal;
		do_clip(data, 1.0, nt);
		return;
	}
}


/* Automatic Gain Control--standard box */
void do_agc(float *data, int iwagc, int nt)
{
	static cwp_Bool first = cwp_true;
	static float *agcdata;
	register int i,j;
	static float *d2;	/* square of input data		 */
	register float val;
	register float sum;
	register int nwin;
	register float rms;


	/* allocate room for agc'd data and square of data */
	if (first) {
		first = cwp_false;
		agcdata = ealloc1float(nt);
		d2 = ealloc1float(nt);
	}

	/* Compute square of data */
	for (i = 0; i < nt; ++i) {
		val = data[i];
		d2[i] = val * val;
	}

	/* intialize first half window and gain first sample */
	sum = 0.0;
	for (i = 0; i < iwagc; ++i) {
		sum += d2[i];
	}
	nwin = iwagc;  
	rms = sum/nwin;
	/* rms = 0 implies data[0]=0 */
        if (rms == 0) {
		agcdata[0]=0;
	} else {
		agcdata[0]=data[i]/sqrt(rms);
	}	
 
	/* ramping on : increase sum and nwin & gain data until reaching 2*iwagc-1 window */
        /* processing samples from 1 to iwagc-1 */
	for (i = 1; i < iwagc; ++i) {
		sum += d2[i+iwagc-1];
		++nwin;
		rms = sum/nwin;
		/* rms = 0 implies data[i]=0 */
                if (rms == 0) {
                	agcdata[i]=0;
		} else {
			agcdata[i]=data[i]/sqrt(rms);
		}	
 	}

	/*  full 2*iagc rms window -- gain data */
	/* compute sum from 0 at each sample -- decreasing sum give inaccurate results, even negative RMS */
	/* processing samples from iwagc to nt-iwagc-1 */
	++nwin;
	for (i = iwagc; i < nt-iwagc; ++i) {
		sum=0;
                for (j = i-iwagc; j < i+iwagc; ++j) {
			sum +=d2[j];
                }
		rms = sum/nwin;
                if (rms == 0) {
                	agcdata[i]=0;
		} else {
			agcdata[i]=data[i]/sqrt(rms);
		}	
 	}

	/* ramping off -- decrease nwin -- gain data */
	/* compute sum from 0 at each sample -- decreasing sum give inaccurate results, even negative RMS */
	/* processing samples from nt-iwagc to nt-1 */
	for (i = nt-iwagc; i < nt; ++i) {
		sum=0;
                for (j = i-iwagc; j < nt; ++j) {
			sum +=d2[j];
                }
		--nwin;
		rms = sum/nwin;
                if (data[i] == 0) {
                	agcdata[i]=0;
		} else {
			agcdata[i]=data[i]/sqrt(rms);
		}	
 	}

	/* copy data back into trace */
	memcpy( (void *) data, (const void *) agcdata, nt*FSIZE);

	return;
}


#define EPS     3.8090232	/* exp(-EPS*EPS) = 5e-7, "noise" level  */

/* Automatic Gain Control--gaussian taper */
void do_gagc(float *data, int iwagc, int nt)
{
	static cwp_Bool first=cwp_true; /* first entry flag		 */
	static float *agcdata;  /* agc'd data			   */
	static float *w;	/* Gaussian window weights		*/
	static float *d2;	/* square of input data		 */
	static float *s;	/* weighted sum of squares of the data  */
	float u;		/* related to reciprocal of std dev     */
	float usq;		/* u*u				  */


	if (first) {
		first = cwp_false;

		/* Allocate room for agc'd data */
		agcdata = ealloc1float(nt);

		/* Allocate and compute Gaussian window weights */
		w = ealloc1float(iwagc);  /* recall iwagc is HALF window */
		u = EPS / ((float) iwagc);
		usq = u*u;
		{
			register int i;
			float floati;

			for (i = 1; i < iwagc; ++i) {
				floati = (float) i;
				w[i] = exp(-(usq*floati*floati));
			}
		}

		/* Allocate sum of squares and weighted sum of squares */
		d2 = ealloc1float(nt);
		s  = ealloc1float(nt);
	}


	/* Agc the trace */
	{
		register int i, j, k;
		register float val;
		register float wtmp;
		register float stmp;

		/* Put sum of squares of data in d2 and */
		/* initialize s to d2 to get center point set */
		for (i = 0; i < nt; ++i) {
			val = data[i];
			s[i] = d2[i] = val * val;
		}

		/* Compute weighted sum s; use symmetry of Gaussian */
		for (j = 1; j < iwagc; ++j) {
			wtmp = w[j];
			for (i = j; i < nt; ++i)  s[i] += wtmp*d2[i-j]; 
			k = nt - j;
			for (i = 0; i < k; ++i)   s[i] += wtmp*d2[i+j]; 
		}

		for (i = 0; i < nt; ++i) {
			stmp = s[i];
			agcdata[i] = (!stmp) ? 0.0 : data[i]/sqrt(stmp);
		}

		/* Copy data back into trace */
		memcpy( (void *) data, (const void *) agcdata, nt*FSIZE);
	}


	return;
}


/*
 * QUANT - find k/n th quantile of a[]
 *
 * Works by reordering a so a[j] < a[k] if j < k.
 *
 * Parameters:
 *    a	 - data
 *    k	 - indicates quantile
 *    n	 - number of points in data
 *
 * This is Hoare's algorithm worked over by SEP (#10, p100) and Brian.
 */

float quant(float *a, int k, int n)
{
	register int i, j;
	int low, hi;
	register float ak, aa;

	low = 0; hi = n-1;

	while (low < hi) {
		ak = a[k];
		i = low;
		j = hi;
		do {
			while (a[i] < ak) i++;
			while (a[j] > ak) j--;
			if (i <= j) {
				aa = a[i]; a[i] = a[j]; a[j] = aa;
				i++;
				j--;
			}
		} while (i <= j);

		if (j < k) low = i;

		if (k < i) hi = j;
	}

	return(a[k]);
}

/*
 * GAIN - apply all the various gains
 *
 */
void gain(float *data, float tpow, float epow, float etpow, float gpow, float vred,
	  int agc, int gagc, int qbal, int pbal, int mbal, float scale, float bias,
	  register float trap, register float clip, float qclip, int iwagc,
	  register float tmin, register float dt, int nt,
	  int maxbal ,float pclip ,float nclip )
{
    float f_two  = 2.0;
    float f_one  = 1.0;
    float f_half = 0.5;
    register int i;

	if (bias) {
		for (i = 0; i < nt; ++i)  data[i]+=bias ;
	}
	if (tpow) {
		do_tpow(data, tpow, vred, tmin, dt, nt);
	}
	if (epow) {
		do_epow(data, epow, etpow, tmin, dt, nt);
	}
	if (!CLOSETO(gpow, f_one)) {
		register float val;

		if (CLOSETO(gpow, f_half)) {
			for (i = 0; i < nt; ++i) {
				val = data[i];
				data[i] = (val >= 0.0) ?
					sqrt(val) :
				-sqrt(-val);
			}
		} else if (CLOSETO(gpow, f_two)) {
			for (i = 0; i < nt; ++i) {
				val = data[i];
				data[i] = val * ABS(val);
			}
		} else {
			for (i = 0; i < nt; ++i) {
				val = data[i];
				data[i] = (val >= 0.0) ?
					pow(val, gpow) :
				-pow(-val, gpow);
			}
		}
	}
	if (agc)		   do_agc(data, iwagc, nt);
	if (gagc)		  do_gagc(data, iwagc, nt);
	if (trap > 0.0)	    do_trap(data, trap, nt);
	if (clip > 0.0)	    do_clip(data, clip, nt);
	if (pclip < FLT_MAX )	do_pclip(data, pclip, nt);
	if (nclip > -FLT_MAX )     do_nclip(data, nclip, nt);
	if (qclip < 1.0 && !qbal)  do_qclip(data, qclip, nt);
	if (qbal)		  do_qbal(data, qclip, nt);
	if (pbal) {
		register int i;
		register float val;
		register float rmsq = 0.0;
		
		/* rmsq = sqrt (SUM( a()*a() ) / nt) */
		for (i = 0; i < nt; ++i) {
			val = data[i];
			rmsq += val * val;
		}
		rmsq = sqrt(rmsq / nt);

		if (rmsq) {
			for (i = 0; i < nt; ++i)
				data[i] /= rmsq;
		}
	}
	if (mbal) {
		register int i;
		register float mean = 0.0;
		
		/* mean = SUM (data[i] / nt) */
		for (i = 0; i < nt; ++i) {
			mean+=data[i];
		}
		/* compute the mean */
		mean/=nt;

		/* subtract the mean from each sample */
		if (mean) {
			for (i = 0; i < nt; ++i)
				data[i]-=mean;
		}
	}

	if (maxbal) {
		register int i;
		register float max = data[0];
		
		/* max */
		for (i = 0; i < nt; ++i) {
			if( data[i] > max ) max = data[i];
		}

		/* subtract max */
		for (i = 0; i < nt; ++i) data[i]-=max;
	}


	if (!CLOSETO(scale, f_one)) {
		register int i;

		for (i = 0; i < nt; ++i)  data[i] *= scale;
	}
}

/* for graceful interrupt termination */
static void closefiles(void)
{
	efclose(headerfp);
	efclose(tracefp);
	eremove(headerfile);
	eremove(tracefile);
	exit(EXIT_FAILURE);
}

@


1.62
log
@Dominique Rousset fixed a bug in the AGC. The problem was not apparent on seismic data but was seen on GPR data
@
text
@d575 7
a581 2
	agcdata[0] = data[0]/sqrt(rms);

d588 7
a594 2
		agcdata[i] = data[i]/sqrt(rms);
	}
d606 6
a611 2
		agcdata[i] = data[i]/sqrt(rms);
	}
d623 6
a628 2
		agcdata[i] = data[i]/sqrt(rms);
	}
@


1.61
log
@added etpow option
@
text
@d4 1
a4 1
/* SUGAIN: $Revision: 1.60 $ ; $Date: 2011/11/16 17:23:05 $		*/
d228 1
d232 2
a233 1
		iwagc >>= 1;  /* windows are symmetric, so work with half */
d547 2
a548 1
	register int i;
d555 1
a555 1
	/* allocate room for agc'd data */
d559 1
d562 5
d568 1
a568 1
	/* compute initial window for first datum */
d570 2
a571 3
	for (i = 0; i < iwagc+1; ++i) {
		val = data[i];
		sum += val*val;
d573 1
a573 1
	nwin = 2*iwagc+1;
d575 1
a575 1
	agcdata[0] = (rms <= 0.0) ? 0.0 : data[0]/sqrt(rms);
d577 4
a580 4
	/* ramping on */
	for (i = 1; i <= iwagc; ++i) {
		val = data[i+iwagc];
		sum += val*val;
d583 1
a583 1
		agcdata[i] = (rms <= 0.0) ? 0.0 : data[i]/sqrt(rms);
d586 9
a594 6
	/* middle range -- full rms window */
	for (i = iwagc + 1; i <= nt-1-iwagc; ++i) {
		val = data[i+iwagc];
		sum += val*val;
		val = data[i-iwagc];
		sum -= val*val; /* rounding could make sum negative! */
d596 1
a596 1
		agcdata[i] = (rms <= 0.0) ? 0.0 : data[i]/sqrt(rms);
d599 8
a606 4
	/* ramping off */
	for (i = nt - iwagc; i <= nt-1; ++i) {
		val = data[i-iwagc];
		sum -= val*val; /* rounding could make sum negative! */
d609 1
a609 1
		agcdata[i] = (rms <= 0.0) ? 0.0 : data[i]/sqrt(rms);
@


1.60
log
@added Reg Beardsley's checkpar
@
text
@d4 1
a4 1
/* SUGAIN: $Revision: 1.58 $ ; $Date: 2009/07/24 17:04:49 $		*/
d23 1
a23 1
"	panel=0	 =1 gain whole data set (vs. trace by trace)		",
d26 1
d57 1
a57 1
" out(t) = scale * BAL{CLIP[AGC{[t^tpow * exp(epow * t) * ( in(t)-bias )]^gpow}]}",
d74 2
d92 1
a92 1
void gain(float *data, float tpow, float epow, float gpow, float vred,
d99 1
a99 1
void do_epow(float *data, float epow, register float tmin, register float dt,
d114 1
d136 4
a139 4
	int jon;	/* flag to get Claerbout values		 */
	int agc;	/* agc flag				     */
	int gagc;	/* gaussian agc flag			    */
	int pbal;	/* power balance flag			   */
d141 1
a141 1
	int mbal=0;     /* mean balance flag			    */
d143 3
a145 2
	float epow;     /* deattenutation coefficient		   */
	float gpow;     /* dynamic compression power		    */
d149 2
a150 2
	float pclip;    /* clip any value greater than clipval */
	float nclip;    /* clip any value less than clipval */
d152 3
a154 3
	float scale;    /* overall scale factor			 */
	float norm;     /* reciprocal of scale factor		   */
	float bias=0.0; /* overall bias  value			  */
d156 4
a159 4
	int iwagc=0;    /* ... half window in samples		   */
	int nt;	 /* number of samples on trace		   */
	float tmin;     /* delay recording time in secs		 */
	float dt;	/* sample rate in secs			  */
d163 1
a163 1
	int maxbal=0;   /* max balance flag			     */
d196 1
d250 1
a250 1
				gain(data, tpow, epow, gpow, vred, agc, gagc,
d255 1
a255 1
				gain(data, tpow, epow, gpow, vred, agc, gagc,
d302 1
a302 1
		gain(data, tpow, epow, gpow, vred, agc, gagc, qbal,
d342 1
a342 1
		for (i = 1; i < nt; ++i)
d362 1
d366 1
d375 1
d379 8
d388 1
a388 1
			epowfac[i] = exp(epow * (tmin + i * dt));
d727 1
a727 1
void gain(float *data, float tpow, float epow, float gpow, float vred,
d745 1
a745 1
		do_epow(data, epow, tmin, dt, nt);
@


1.59
log
@copyright
@
text
@d213 1
@


1.58
log
@added to selfdoc
@
text
@d1 4
a4 1
/* SUGAIN: $Revision: 1.57 $ ; $Date: 2008/11/18 01:26:37 $		*/
@


1.57
log
@Florian Bleibinhaus removed problem that causes spikes at the
beginning of the data.
@
text
@d1 1
a1 1
/* SUGAIN: $Revision: 1.56 $ ; $Date: 2007/10/15 11:48:01 $               */
d11 42
a52 42
"                                                                       ",
" SUGAIN - apply various types of gain                                  ",
"                                                                       ",
" sugain <stdin >stdout [optional parameters]                           ",
"                                                                       ",
" Required parameters:                                                  ",
"       none (no-op)                                                    ",
"                                                                       ",
" Optional parameters:                                                  ",
"       panel=0         =1 gain whole data set (vs. trace by trace)	",
"       tpow=0.0        multiply data by t^tpow                         ",
"       epow=0.0        multiply data by exp(epow*t)                    ",
"       gpow=1.0        take signed gpowth power of scaled data         ",
"       agc=0           flag; 1 = do automatic gain control             ",
"       gagc=0          flag; 1 = ... with gaussian taper               ",
"       wagc=0.5        agc window in seconds (use if agc=1 or gagc=1)  ",
"       trap=none       zero any value whose magnitude exceeds trapval  ",
"       clip=none       clip any value whose magnitude exceeds clipval  ",
"       pclip=none      clip any value greater than clipval  ",
"       nclip=none      clip any value less than  clipval  ",
"       qclip=1.0       clip by quantile on absolute values on trace    ",
"       qbal=0          flag; 1 = balance traces by qclip and scale     ",
"       pbal=0          flag; 1 = bal traces by dividing by rms value   ",
"       mbal=0          flag; 1 = bal traces by subtracting the mean    ",
"       maxbal=0        flag; 1 = balance traces by subtracting the max ",
"       scale=1.0       multiply data by overall scale factor           ",
"       norm=0.0        divide data by overall scale factor             ",
"       bias=0.0        bias data by adding an overall bias value	",
"       jon=0           flag; 1 means tpow=2, gpow=.5, qclip=.95        ",
"       verbose=0       verbose = 1 echoes info				",
"       mark=0          apply gain only to traces with tr.mark=0	",
"                       =1 apply gain only to traces with tr.mark!=0    ",
"       vred=0          reducing velocity of data to use with tpow      ",
"                                                                       ",
" 	tmpdir=	        if non-empty, use the value as a directory path	",
"	                prefix for storing temporary files; else if the ",
"                       the CWP_TMPDIR environment variable is set use  ",
"                       its value for the path; else use tmpfile()      ",
"                                                                       ",
" Operation order:                                                      ",
" if (norm) scale/norm                                                  ",
"                                                                       ",
d54 2
a55 2
"                                                                       ",
" Notes:                                                                ",
d69 1
d73 2
a74 2
 *      SEP: Jon Claerbout
 *      CWP: Jack K. Cohen, Brian Sumner, Dave Hale
d79 1
a79 1
 *      Jon's second book, pages 233-236.
d128 10
a137 10
        int verbose;	/* flag for echoing info			*/
	int jon;        /* flag to get Claerbout values                 */
	int agc;        /* agc flag                                     */
        int gagc;       /* gaussian agc flag                            */
        int pbal;       /* power balance flag                           */
        int qbal;       /* quantile balance flag                        */
        int mbal=0;     /* mean balance flag                            */
        float tpow;     /* exponent of t                                */
        float epow;     /* deattenutation coefficient                   */
        float gpow;     /* dynamic compression power                    */
d139 13
a151 13
        float trap;     /* zero any larger value magnitude than trapval */
        float clip;     /* clip any larger value magnitude than clipval */
        float pclip;    /* clip any value greater than clipval */
        float nclip;    /* clip any value less than clipval */
        float qclip;    /* clip at qth quantile (100qth percentile)     */
        float scale;    /* overall scale factor                         */
        float norm;     /* reciprocal of scale factor                   */
        float bias=0.0; /* overall bias  value                          */
        float wagc;     /* size of agc window in seconds                */
        int iwagc=0;    /* ... half window in samples                   */
        int nt;         /* number of samples on trace                   */
        float tmin;     /* delay recording time in secs                 */
        float dt;       /* sample rate in secs                          */
d155 1
a155 1
        int maxbal=0;   /* max balance flag                             */
d157 1
a157 1
        int mark;	/* mark flag					*/
d164 4
a167 4
        /* Initialize */
        initargs(argc, argv);
        requestdoc(1);
        
d177 2
a178 2
        if (!gettr(&tr)) err("can't get first trace");
        nt   = (int) tr.ns;
d181 2
a182 2
        if (!dt) getparfloat("dt", &dt);
        if (!dt) MUSTGETPARFLOAT("dt", &dt);
d185 19
a203 19
        /* Get parameters */
        if (!getparfloat ("tpow" , &tpow))      tpow     = TPOW;
        if (!getparfloat ("epow" , &epow))      epow     = EPOW;
        if (!getparfloat ("gpow" , &gpow))      gpow     = GPOW;
        if (!getparfloat ("vred" , &vred))      vred     = VRED;
        if (!getparfloat ("trap" , &trap))      trap     = TRAP;
        if (!getparfloat ("clip" , &clip))      clip     = CLIP;
        if (!getparfloat ("pclip" , &pclip))    pclip    = FLT_MAX;
        if (!getparfloat ("nclip" , &nclip))    nclip    = -FLT_MAX;
        if (!getparfloat ("qclip", &qclip))     qclip    = QCLIP;
        if (!getparfloat ("scale", &scale))     scale    = SCALE;
        if (!getparfloat ("norm",  &norm)) 	norm     = 0.0;
        if (!getparfloat ("bias",  &bias))      bias     = BIAS;
        if (!getparfloat ("wagc" , &wagc))      wagc     = WAGC;
        if (!getparint   ("agc"  , &agc))       agc      = 0;
        if (!getparint   ("gagc" , &gagc))      gagc     = 0;
        if (!getparint   ("pbal" , &pbal))      pbal     = 0;
        if (!getparint   ("qbal" , &qbal))      qbal     = 0;
        if (!getparint   ("mbal" , &mbal))      mbal     = 0;
d205 1
a205 1
        if (!getparint   ("jon"  , &jon))       jon      = 0;
d207 2
a208 2
        if (!getparint   ("maxbal" , &maxbal))	maxbal   = 0;
        if (!getparint   ("mark" , &mark))      mark     = 0;
d211 17
a227 17
        /* Data validation */
        if (vred < 0.0) err("vred = %f, must be positive", vred);
        if (trap < 0.0) err("trap = %f, must be positive", trap);
        if (clip < 0.0) err("clip = %f, must be positive", clip);
        if (qclip < 0.0 || qclip > 1.0) 
                err("qclip = %f, must be between 0 and 1", qclip);
        if (agc || gagc) {
                iwagc = NINT(wagc/dt);
                if (iwagc < 1) err("wagc=%g must be positive", wagc);
                if (iwagc > nt) err("wagc=%g too long for trace", wagc);
                iwagc >>= 1;  /* windows are symmetric, so work with half */
        }
        if (jon) { 
                tpow  = 2.0;
                gpow  = 0.5;
                qclip = 0.95;
        }
d233 1
a233 1
        /* Main loop over traces */
d275 1
a275 1
      		istmpdir=cwp_true;		
d298 1
a298 1
			       nt*FSIZE);
d308 1
a308 1
        return(CWP_Exit());
d315 1
a315 1
        float tpow,             /* multiply data by t^tpow      */
d317 3
a319 3
        register float tmin,    /* first time on record         */
        register float dt,      /* sampling rate in seconds     */
        int nt                  /* number of samples            */
d322 3
a324 3
        static cwp_Bool first = cwp_true;   /* first entry flag     */
        static float *tpowfac;          /* tpow values          */
        register int i;                 /* counter              */
d327 1
a327 1
        if (first) { /* first entry, set up array of tpow factors */
d335 1
a335 1
                first = cwp_false;
d338 1
a338 1
        } /* end first entry */
d347 1
a347 1
        for (i = 0; i < nt; ++i)  data[i] *= tpowfac[i];
d354 4
a357 4
        float epow,             /* coefficient of t in exponent */
        register float tmin,    /* first time on record         */
        register float dt,      /* sampling rate in seconds     */
        int nt                  /* number of samples            */
d360 3
a362 8
        register int i;                 /* counter              */
        static cwp_Bool first = cwp_true;   /* first entry flag     */
        static float *epowfac;          /* exponent stretchs    */

        if (first) {
                epowfac = ealloc1float(nt);
                for (i = 0; i < nt; i++) 
                        epowfac[i] = exp(epow * (tmin + i * dt));
d364 4
a367 2
                first = cwp_false;
        }
d369 4
a372 1
        for (i = 0; i < nt; ++i)  data[i] *= epowfac[i];
d379 2
a380 2
        register float trap,    /* zero if magnitude > trap     */
        register int nt         /* number of samples            */
d383 1
a383 1
        register float *dataptr = data;
d385 4
a388 4
        while (nt--) {
                if (ABS(*dataptr) > trap) *dataptr = 0.0;
                dataptr++;
        }
d395 2
a396 2
        register float clip,    /* hard clip if magnitude > clip        */
        register int nt         /* number of samples                    */
d399 1
a399 1
        register float *dataptr = data;
d402 8
a409 8
        while (nt--) {
                if (*dataptr > clip) {
                        *dataptr = clip;
                } else if (*dataptr < mclip) {
                        *dataptr = mclip;
                }
                dataptr++;
        }
d417 2
a418 2
        register float pclip,    /* hard clip if magnitude > clip        */
        register int nt         /* number of samples                    */
d421 1
a421 1
        register float *dataptr = data;
d423 6
a428 6
        while (nt--) {
                if (*dataptr > pclip) {
                        *dataptr = pclip;
                }
                dataptr++;
        }
d435 2
a436 2
        register float nclip,    /* hard clip if magnitude > clip        */
        register int nt         /* number of samples                    */
d439 1
a439 1
        register float *dataptr = data;
d441 6
a446 6
        while (nt--) {
                if (*dataptr < nclip) {
                        *dataptr = nclip;
                }
                dataptr++;
        }
d453 2
a454 2
        float qclip,    /* quantile at which to clip    */
        int nt          /* number of sample points      */
d457 16
a472 16
        register int i;
        static cwp_Bool first = cwp_true;   /* first entry flag             */
        static float *absdata;          /* absolute value trace         */
        static int iq;                  /* index of qclipth quantile    */
        float clip;                     /* ... value of rank[iq]        */

        if (first) {
                absdata = ealloc1float(nt);
                iq = (int) (qclip * nt - 0.5); /* round, don't truncate */
                first = cwp_false;
        }

        /* Clip on value corresponding to qth quantile */
        for (i = 0; i < nt; ++i)  absdata[i] = ABS(data[i]);
        clip = quant(absdata, iq, nt);
        do_clip(data, clip, nt);
d479 2
a480 2
        float qclip,    /* quantile at which to clip    */
        int nt          /* number of sample points      */
d483 33
a515 33
        register int i;
        static cwp_Bool first = cwp_true;   /* first entry flag             */
        static float *absdata;          /* absolute value trace         */
        static int iq;                  /* index of qclipth quantile    */
        float bal;                      /* value used to balance trace  */

        if (qclip == 1.0) { /* balance by max magnitude on trace */
                bal = ABS(data[0]);
                for (i = 1; i < nt; ++i)  bal = MAX(bal, ABS(data[i]));

                if ((bal == 0.0)) {
                        return;
                } else {
                        for (i = 0; i < nt; ++i)  data[i] /= bal;
                        return;
                }
        } else if (first) {
                absdata = ealloc1float(nt);
                iq = (int) (qclip * nt - 0.5); /* round, don't truncate */
                first = cwp_false;
        }

        /* Balance by quantile value (qclip < 1.0) */
        for (i = 0; i < nt; ++i)  absdata[i] = ABS(data[i]);
        bal = quant(absdata, iq, nt);

        if ((bal == 0.0)) {
                return;
        } else {
                for (i = 0; i < nt; ++i)  data[i] /= bal;
                do_clip(data, 1.0, nt);
                return;
        }
d522 25
a546 25
        static cwp_Bool first = cwp_true;
        static float *agcdata;
        register int i;
        register float val;
        register float sum;
        register int nwin;
        register float rms;


        /* allocate room for agc'd data */
        if (first) {
                first = cwp_false;
                agcdata = ealloc1float(nt);
        }


        /* compute initial window for first datum */
        sum = 0.0;
        for (i = 0; i < iwagc+1; ++i) {
                val = data[i];
                sum += val*val;
        }
        nwin = 2*iwagc+1;
        rms = sum/nwin;
        agcdata[0] = (rms <= 0.0) ? 0.0 : data[0]/sqrt(rms);
d549 17
a565 26
        for (i = 1; i <= iwagc; ++i) {
                val = data[i+iwagc];
                sum += val*val;
                ++nwin;
                rms = sum/nwin;
                agcdata[i] = (rms <= 0.0) ? 0.0 : data[i]/sqrt(rms);
        }

        /* middle range -- full rms window */
        for (i = iwagc + 1; i <= nt-1-iwagc; ++i) {
                val = data[i+iwagc];
                sum += val*val;
                val = data[i-iwagc];
                sum -= val*val; /* rounding could make sum negative! */
                rms = sum/nwin;
                agcdata[i] = (rms <= 0.0) ? 0.0 : data[i]/sqrt(rms);
        }

        /* ramping off */
        for (i = nt - iwagc; i <= nt-1; ++i) {
                val = data[i-iwagc];
                sum -= val*val; /* rounding could make sum negative! */
                --nwin;
                rms = sum/nwin;
                agcdata[i] = (rms <= 0.0) ? 0.0 : data[i]/sqrt(rms);
        }
d567 8
a574 2
        /* copy data back into trace */
        memcpy( (void *) data, (const void *) agcdata, nt*FSIZE);
d576 4
a579 1
        return;
d583 1
a583 1
#define EPS     3.8090232       /* exp(-EPS*EPS) = 5e-7, "noise" level  */
d588 48
a635 65
        static cwp_Bool first=cwp_true; /* first entry flag                 */
        static float *agcdata;  /* agc'd data                           */
        static float *w;        /* Gaussian window weights              */
        static float *d2;       /* square of input data                 */
        static float *s;        /* weighted sum of squares of the data  */
        float u;                /* related to reciprocal of std dev     */
        float usq;              /* u*u                                  */


        if (first) {
                first = cwp_false;

                /* Allocate room for agc'd data */
                agcdata = ealloc1float(nt);

                /* Allocate and compute Gaussian window weights */
                w = ealloc1float(iwagc);  /* recall iwagc is HALF window */
                u = EPS / ((float) iwagc);
                usq = u*u;
                {
                        register int i;
                        float floati;

                        for (i = 1; i < iwagc; ++i) {
                                floati = (float) i;
                                w[i] = exp(-(usq*floati*floati));
                        }
                }

                /* Allocate sum of squares and weighted sum of squares */
                d2 = ealloc1float(nt);
                s  = ealloc1float(nt);
        }


        /* Agc the trace */
        {
                register int i, j, k;
                register float val;
                register float wtmp;
                register float stmp;

                /* Put sum of squares of data in d2 and */
                /* initialize s to d2 to get center point set */
                for (i = 0; i < nt; ++i) {
                        val = data[i];
                        s[i] = d2[i] = val * val;
                }

                /* Compute weighted sum s; use symmetry of Gaussian */
                for (j = 1; j < iwagc; ++j) {
                        wtmp = w[j];
                        for (i = j; i < nt; ++i)  s[i] += wtmp*d2[i-j]; 
                        k = nt - j;
                        for (i = 0; i < k; ++i)   s[i] += wtmp*d2[i+j]; 
                }

                for (i = 0; i < nt; ++i) {
                        stmp = s[i];
                        agcdata[i] = (!stmp) ? 0.0 : data[i]/sqrt(stmp);
                }

                /* Copy data back into trace */
                memcpy( (void *) data, (const void *) agcdata, nt*FSIZE);
        }
d637 12
d650 6
a655 1
        return;
d665 3
a667 3
 *    a         - data
 *    k         - indicates quantile
 *    n         - number of points in data
d674 19
a692 19
        register int i, j;
        int low, hi;
        register float ak, aa;

        low = 0; hi = n-1;

        while (low < hi) {
                ak = a[k];
                i = low;
                j = hi;
                do {
                        while (a[i] < ak) i++;
                        while (a[j] > ak) j--;
                        if (i <= j) {
                                aa = a[i]; a[i] = a[j]; a[j] = aa;
                                i++;
                                j--;
                        }
                } while (i <= j);
d694 1
a694 1
                if (j < k) low = i;
d696 2
a697 2
                if (k < i) hi = j;
        }
d699 1
a699 1
        return(a[k]);
d710 1
a710 1
          int maxbal ,float pclip ,float nclip )
d750 5
a754 5
	if (agc)                   do_agc(data, iwagc, nt);
	if (gagc)                  do_gagc(data, iwagc, nt);
	if (trap > 0.0)            do_trap(data, trap, nt);
	if (clip > 0.0)            do_clip(data, clip, nt);
	if (pclip < FLT_MAX )      do_pclip(data, pclip, nt);
d757 1
a757 1
	if (qbal)                  do_qbal(data, qclip, nt);
@


1.56
log
@added one line in the documentation
@
text
@d1 1
a1 1
/* SUGAIN: $Revision: 1.55 $ ; $Date: 2007/02/20 21:46:01 $               */
d12 1
a12 1
" SUGAIN - apply various types of gain to display traces                ",
d43 1
d45 4
a48 5
"                                                                       ",
" 	tmpdir=	 if non-empty, use the value as a directory path	",
"		 prefix for storing temporary files; else if the	",
"	         the CWP_TMPDIR environment variable is set use		",
"	         its value for the path; else use tmpfile()		",
a78 1
 *  for the rationale for jon=1
d80 1
a80 1
 * Trace header fields accessed: ns, dt, delrt, mark
d85 1
a85 1
void gain(float *data, float tpow, float epow, float gpow,
d88 4
a91 3
	  register float tmin, register float dt, int nt, int maxbal ,float pclip ,float nclip );
void do_tpow(float *data, float tpow, register float tmin, register float dt,
	     int nt);
d114 1
d137 1
d188 1
d206 1
a206 1
        if (!getparint   ("maxbal" , &maxbal))      maxbal     = 0;
d211 1
d239 4
a242 3
				gain(data, tpow, epow, gpow, agc, gagc, qbal,
				     pbal, mbal, scale, bias, trap, clip, qclip,
				     iwagc, tmin, dt, nt, maxbal ,pclip ,nclip );
d244 4
a247 3
				gain(data, tpow, epow, gpow, agc, gagc, qbal,
				     pbal, mbal, scale, bias, trap, clip, qclip,
				     iwagc, tmin, dt, nt, maxbal ,pclip ,nclip );
d291 1
a291 1
		gain(data, tpow, epow, gpow, agc, gagc, qbal,
d293 1
a293 1
		     iwagc, tmin, dt, nt*ntr, maxbal ,pclip ,nclip );
d315 1
d324 1
d327 1
a327 1
                tpowfac = ealloc1float(nt);
d330 3
a332 3
		tpowfac[0] = (tmin == 0.0) ? 1.0 : pow(tmin, tpow);
                for (i = 1; i < nt; ++i)
                        tpowfac[i] = pow(tmin + i*dt, tpow);
d335 2
d339 7
d705 1
a705 1
void gain(float *data, float tpow, float epow, float gpow,
d708 2
a709 2
	  register float tmin, register float dt, int nt, int maxbal 
          ,float pclip ,float nclip )
d720 1
a720 1
		do_tpow(data, tpow, tmin, dt, nt);
@


1.55
log
@added norm to notes in selfdoc
@
text
@d1 1
a1 1
/* SUGAIN: $Revision: 1.54 $ ; $Date: 2007/02/02 22:24:13 $               */
d79 1
@


1.54
log
@Reg Beardsley's latest
@
text
@d1 1
a1 1
/* SUGAIN: $Revision: 1.3 $ ; $Date: 2007/01/10 16:55:58 $               */
d51 1
@


1.53
log
@..try try again. The scale value is divided by norm.
@
text
@d1 1
a1 1
/* SUGAIN: $Revision: 1.1 $ ; $Date: 2006/12/16 16:06:52 $               */
d7 1
d29 2
d87 1
a87 1
	  register float tmin, register float dt, int nt, int maxbal);
d94 2
d136 2
d186 2
d235 1
a235 1
				     iwagc, tmin, dt, nt, maxbal);
d239 1
a239 1
				     iwagc, tmin, dt, nt, maxbal);
d285 1
a285 1
		     iwagc, tmin, dt, nt*ntr, maxbal);
d393 37
d689 2
a690 1
	  register float tmin, register float dt, int nt, int maxbal )
d734 2
d803 1
@


1.52
log
@stopped norm=1 from overriding scale
@
text
@d1 1
a1 1
/* SUGAIN: $Revision: 1.51 $ ; $Date: 2006/11/07 21:16:33 $               */
d34 1
a34 1
"       norm=1.0        divide data by overall scale factor             ",
d181 1
a181 1
        if (!getparfloat ("norm",  &norm)) 	norm     = 1.0;
d213 2
a214 6
	if (norm==0.0) {
		err("parameter norm may not be zero!");
	} else {
		if (verbose && scale!=1.0 && norm!=1.0 )
			warn("value of scale overridden by norm!");
		scale = 1.0/norm;
@


1.51
log
@! inserted
@
text
@d1 1
a1 1
/* SUGAIN: $Revision: 1.50 $ ; $Date: 2006/11/01 02:16:49 $               */
d216 1
a216 1
		if (verbose && scale!=1.0)
@


1.50
log
@added error trapping
@
text
@d1 1
a1 1
/* SUGAIN: $Revision: 1.49 $ ; $Date: 2006/10/31 21:59:36 $               */
d181 1
a181 1
        if (getparfloat ("norm",  &norm)) 	norm     = 1.0;
@


1.49
log
@Reg Beardsley's norm, with an error trapping.
@
text
@d1 1
a1 1
/* SUGAIN: $Revision: 1.48 $ ; $Date: 2006/05/31 22:43:17 $               */
d214 1
a214 1
		err("parameter norm may not be zero!")
@


1.48
log
@added mark= option
@
text
@d1 1
a1 1
/* SUGAIN: $Revision: 1.47 $ ; $Date: 2004/11/16 17:01:25 $               */
d181 1
a181 1
        if (getparfloat ("norm",  &norm))       scale    = 1.0/norm;
d213 7
@


1.47
log
@added vbal and vtrap options, and Piotr Synowiec's maxbal option
@
text
@d1 1
a1 1
/* SUGAIN: $Revision: 1.45 $ ; $Date: 2003/02/11 19:32:29 $               */
d38 2
d143 1
a143 1
        int maxbal=0;   /* max balance flag                            */
d145 1
d193 1
d220 1
a220 1
			if (!tr.mark)
d224 5
@


1.46
log
@added vclip and vtrap
@
text
@a26 1
"       vtrap=none      zero any value whose value exceeds trapval	",
a27 1
"       vclip=none      clip any value whose which exceeds clipval	",
d32 1
d34 1
a34 1
"       norm=1.0        divide data by overall scale factor           ",
d37 2
a38 4
" 	verbose=0	verbose = 1 echoes info				",
" 	mark=0		apply sugain only to traces with mark=0 	",
"                       =1 apply only to traces with mark not equal     ",
"                       to zero                                         ",
d50 2
a51 2
" The jon flag selects the parameter choices discussed in		",
" Claerbout's Imaging the Earth, pp 233-236.				",
d53 3
a55 3
" Extremely large/small values may be lost during agc. Windowing	",
" these off and applying a scale in a preliminary pass through		",
" sugain may help.							",
d57 5
a61 7
" Sugain only applies gain to traces with tr.mark=0 (default),		",
" or if mark=1 to traces with tr.mark=nonzero.  Use sushw,		",
" suchw, suedit, or suxedit to mark traces you do not (or do) want	",
" gained. See the selfdocs of sushw, suchw, suedit, and suxedit		",
" for more information about setting header fields.			",
" Use \"sukeyword mark\"						",
" for more information about the mark header field.			",
d80 3
a82 7
	  int agc, int gagc, int qbal, int pbal, int mbal, float scale,
		float bias, register float trap,
		cwp_Bool isvtrap, register float vtrap,
		register float clip, 
		cwp_Bool isvclip, register float vclip, 
			float qclip, int iwagc, register float tmin, 
			register float dt, int nt);
a88 2
void do_vtrap(float *data, register float trap, register int nt);
void do_vclip(float *data, register float clip, register int nt);
a123 1
        int mark=0;     /* mark flag	                                */
a127 1
        float vtrap=0.0;  /* zero any larger value than trapval		*/
a128 1
        float vclip=0.0;  /* clip any larger value  than clipval	*/
d141 4
a146 2
	cwp_Bool isvtrap=cwp_false;	/* true for vtrap set		*/
	cwp_Bool isvclip=cwp_false;	/* true for vclip set		*/
d189 1
a189 1
	if (!getparint("mark", &mark))	mark  = 0;
a190 2
        if (getparfloat ("vtrap" ,&vtrap))  isvtrap = cwp_true;
        if (getparfloat ("vclip" , &vclip))   isvclip = cwp_true;
d216 4
a219 8
			/* gain (un)marked traces */
			if (!(mark && tr.mark) || (mark && tr.mark) ) {
					gain(data, tpow, epow, gpow, agc,
						gagc, qbal, pbal, mbal, scale,
						bias, trap, isvtrap, vtrap, 
						clip, isvclip, vclip, qclip,
						iwagc, tmin, dt, nt);
			}
d263 2
a264 3
		     pbal, mbal, scale, bias, trap, isvtrap, vtrap,
			 clip, isvclip, vclip, qclip, iwagc, 
			tmin, dt, nt*ntr);
d335 1
a335 1
/* Zero out outlying magnitudes */
a349 8
/* Zero out outlying values */
void do_vtrap(
	float *data,		/* the data			*/
        register float vtrap,   /* zero if value > vtrap        */
        register int nt         /* number of samples            */
)
{
        register float *dataptr = data;
d351 1
a351 8
        while (nt--) {
                if ((*dataptr) > vtrap) *dataptr = 0.0;
                dataptr++;
        }
}


/* Hard clip outlying magnitudes */
a370 17
/* Hard clip outlying values */
void do_vclip(
	float *data,		/* the data				*/
        register float vclip,   /* hard clip if value > vclip           */
        register int nt         /* number of samples                    */
)
{
        register float *dataptr = data;

        while (nt--) {
                if (*dataptr > vclip) {
                        *dataptr = vclip;
                }
                dataptr++;
        }
}

d629 3
a631 5
	  int agc, int gagc, int qbal, int pbal, int mbal,
	float scale, float bias, register float trap, cwp_Bool isvtrap,
	register float vtrap, register float clip, 
	cwp_Bool isvclip, register float vclip, float qclip, int iwagc,
	  register float tmin, register float dt, int nt)
a673 1
	if (isvtrap)               do_vtrap(data, vtrap, nt);
a674 1
	if (isvclip)               do_vclip(data, vclip, nt);
d711 15
@


1.45
log
@Reg Beardsley's norm parameter
@
text
@d1 1
a1 1
/* SUGAIN: $Revision: 1.2 $ ; $Date: 2003/02/11 19:22:49 $               */
d27 1
d29 1
d39 3
d53 2
a54 2
"	The jon flag selects the parameter choices discussed in		",
"	Claerbout's Imaging the Earth, pp 233-236.			",
d56 3
a58 3
"	Extremely large/small values may be lost during agc. Windowing  ",
"	these off and applying a scale in a preliminary pass through	",
"	sugain may help.						",
d60 7
a66 5
"	Sugain only applies gain to traces with tr.mark=0. Use sushw,	",
"	suchw, suedit, or suxedit to mark traces you do not want gained.",
"	See the selfdocs of sushw, suchw, suedit, and suxedit for more	",
"	information about setting header fields. Use \"sukeyword mark\" ",
"	for more information about the mark header field.		",
d85 7
a91 3
	  int agc, int gagc, int qbal, int pbal, int mbal, float scale, float bias,
	  register float trap, register float clip, float qclip, int iwagc,
	  register float tmin, register float dt, int nt);
d98 2
d135 1
d140 1
d142 1
d157 2
d201 1
d203 2
d230 8
a237 4
			if (!tr.mark)
				gain(data, tpow, epow, gpow, agc, gagc, qbal,
				     pbal, mbal, scale, bias, trap, clip, qclip,
				     iwagc, tmin, dt, nt);
d281 3
a283 2
		     pbal, mbal, scale, bias, trap, clip, qclip,
		     iwagc, tmin, dt, nt*ntr);
d354 1
a354 1
/* Zero out outliers */
d369 15
d385 1
a385 1
/* Hard clip outliers */
d405 17
d680 4
a683 2
	  int agc, int gagc, int qbal, int pbal, int mbal, float scale, float bias,
	  register float trap, register float clip, float qclip, int iwagc,
d727 1
d729 1
@


1.44
log
@Balazs Nemeth's bug fix for agc segmentation violation
@
text
@d1 1
a1 1
/* SUGAIN: $Revision: 1.43 $ ; $Date: 1998/10/06 14:59:55 $               */
d33 1
d129 1
d172 1
d271 1
a271 1
        return EXIT_SUCCESS;
@


1.43
log
@added Dominiqe Rousset's fix
@
text
@d1 1
a1 1
/* SUGAIN: $Revision: 1.42 $ ; $Date: 1998/08/24 20:11:45 $               */
d452 1
a452 1
        for (i = 0; i <= iwagc; ++i) {
d456 1
a456 1
        nwin = iwagc + 1;
d458 1
a458 1
        agcdata[0] = (!rms) ? 0.0 : data[0]/sqrt(rms);
d466 1
a466 1
                agcdata[i] = (!rms) ? 0.0 : data[i]/sqrt(rms);
d470 1
a470 1
        for (i = iwagc + 1; i <= nt - iwagc; ++i) {
d473 1
a473 1
                val = data[i-iwagc-1];
d480 2
a481 2
        for (i = nt - iwagc + 1; i < nt; ++i) {
                val = data[i-iwagc-1];
@


1.42
log
@added mbal parameter
@
text
@d1 1
a1 1
/* SUGAIN: $Revision: 1.41 $ ; $Date: 1997/12/12 22:29:21 $               */
d176 1
a176 1
        if (!getparint   ("mbal" , &qbal))      mbal     = 0;
@


1.41
log
@added bias option
@
text
@d1 1
a1 1
/* SUGAIN: $Revision: 1.40 $ ; $Date: 1997/07/28 22:36:46 $               */
d31 1
d77 1
a77 1
	  int agc, int gagc, int qbal, int pbal, float scale, float bias,
d120 1
d176 1
d208 1
a208 1
				     pbal, scale, bias, trap, clip, qclip,
d253 1
a253 1
		     pbal, scale, bias, trap, clip, qclip,
d619 1
a619 1
	  int agc, int gagc, int qbal, int pbal, float scale, float bias,
d682 17
@


1.40
log
@changes suggested by Stew Levin to silence SGI compiler warnings, etc
@
text
@d1 1
a1 1
/* SUGAIN: $Revision: 1.38 $ ; $Date: 1996/08/11 20:51:23 $               */
d32 1
d43 1
a43 1
" out(t) = scale * BAL{CLIP[AGC{[t^tpow * exp(epow * t) * in(t)]^gpow}]}",
d76 1
a76 1
	  int agc, int gagc, int qbal, int pbal, float scale,
d99 1
d126 1
d168 1
d205 1
a205 1
				     pbal, scale, trap, clip, qclip,
d250 1
a250 1
		     pbal, scale, trap, clip, qclip,
d616 1
a616 1
	  int agc, int gagc, int qbal, int pbal, float scale,
d623 5
a634 1
		register int i;
@


1.39
log
@close files on exit.
@
text
@d133 1
a133 1
	cwp_Bool istmpdir=false;/* true for user given path		*/
d228 1
a228 1
      		istmpdir=true;		
d274 1
a274 1
        static cwp_Bool first = true;   /* first entry flag     */
d286 1
a286 1
                first = false;
d303 1
a303 1
        static cwp_Bool first = true;   /* first entry flag     */
d311 1
a311 1
                first = false;
d363 1
a363 1
        static cwp_Bool first = true;   /* first entry flag             */
d371 1
a371 1
                first = false;
d389 1
a389 1
        static cwp_Bool first = true;   /* first entry flag             */
d407 1
a407 1
                first = false;
d427 1
a427 1
        static cwp_Bool first = true;
d438 1
a438 1
                first = false;
d493 1
a493 1
        static cwp_Bool first=true; /* first entry flag                 */
d503 1
a503 1
                first = false;
d616 3
d625 1
a625 1
	if (!CLOSETO(gpow, 1.0)) {
d629 1
a629 1
		if (CLOSETO(gpow, 0.5)) {
d636 1
a636 1
		} else if (CLOSETO(gpow, 2.0)) {
d673 1
a673 1
	if (!CLOSETO(scale, 1.0)) {
@


1.38
log
@Put in tmpdir and cleaned up -Wall stuff including removing
rmsq as a global passed in gain().
@
text
@d1 1
a1 1
/* SUGAIN: $Revision: 1.37 $ ; $Date: 1996/05/02 19:26:03 $               */
d223 2
d684 1
@


1.37
log
@./main/sugain.c
"sugain.c", line 326: warning: dataptr unused in function do_qclip
"sugain.c", line 353: warning: dataptr unused in function do_qbal
@
text
@d1 1
a1 1
/* SUGAIN: $Revision: 1.36 $ ; $Date: 1996/01/25 20:10:45 $               */
d6 1
d33 6
d75 1
a75 1
	  int agc, int gagc, int qbal, int pbal, float rmsq, float scale,
d89 1
a89 1

d100 5
d108 1
a108 1

d111 3
a113 2
        int jon;        /* flag to get Claerbout values                 */
        int agc;        /* agc flag                                     */
a119 1
        float rmsq;     /* root mean square of a trace                  */
d125 1
a125 1
        int iwagc;      /* ... half window in samples                   */
d132 3
d141 8
a148 1
        /* Get nt from first trace */
d172 2
a173 1

d201 1
a201 1
				     pbal, rmsq, scale, trap, clip, qclip,
a208 2
		FILE *tracefp;	/* fp for trace storage */
		FILE *headerfp;	/* fp for header storage file */
d212 17
a228 2
		tracefp = etmpfile();
		headerfp = etmpfile();
d241 2
a242 1
		
d244 1
a244 1
		     pbal, rmsq, scale, trap, clip, qclip,
d254 1
d610 1
a610 1
	  int agc, int gagc, int qbal, int pbal, float rmsq, float scale,
d654 2
a655 1

a656 1
		rmsq = 0.0;
a669 1
		register float val;
d673 9
@


1.36
log
@Deal with specifying header fields accessed/modified in sudoc.
@
text
@d1 1
a1 1
/* SUGAIN: $Revision: 1.35 $ ; $Date: 1995/10/31 22:09:10 $               */
a322 1
        register float *dataptr = data; /* ptr to trace data    	*/
a348 1
        register float *dataptr = data; /* ptr to trace data		*/
@


1.35
log
@Added panel option to gain data set as a whole instead of trace by
trace.
@
text
@d1 1
a1 1
/* SUGAIN: $Revision: 1.34 $ ; $Date: 1995/10/17 20:38:03 $               */
d61 2
d234 1
a234 1
        static cwp_Bool first = true;       /* first entry flag     */
d263 1
a263 1
        static cwp_Bool first = true;       /* first entry flag     */
d323 2
a324 2
        register float *dataptr = data;      /* ptr to trace data    */
        static cwp_Bool first = true;       /* first entry flag             */
d455 1
a455 1
        static cwp_Bool first=true; /* first entry flag                     */
@


1.34
log
@cosmetic. On the suggestion of Bjoern Rommel added comments about
the "mark" header field.
@
text
@d1 1
a1 1
/* SUGAIN: $Revision: 1.33 $ ; $Date: 1995/08/03 16:34:12 $               */
d5 1
d18 1
d38 7
a44 7
"       The jon flag selects the parameter choices discussed in         ",
"       Claerbout's Imaging the Earth, pp 233-236.                      ",
"                                                                       ",
"       Extremely large/small values may be lost during agc. Windowing  ",
"       these off and applying a scale in a preliminary pass through    ",
"       sugain may help.						",
"                                                                       ",
d46 3
a48 3
"       suchw, suedit, or suxedit to mark traces that you do not want gained.",
"       See the selfdocs of sushw, suchw, suedit, and suxedit for more	",
"       information about setting header fields. Use \"sukeyword mark\" ",
d50 1
a50 1
"                                                                       ",
d65 14
a78 8
void do_tpow(float tpow, register float tmin, register float dt, int nt);
void do_epow(float epow, register float tmin, register float dt, int nt);
void do_trap(register float trap, register int nt);
void do_clip(register float clip, register int nt);
void do_qclip(float qclip, int nt);
void do_qbal(float qclip, int nt);
void do_agc(int iwagc, int nt);
void do_gagc(int iwagc, int nt);
a89 5
#define AGC      0
#define GAGC     0
#define PBAL     0
#define QBAL     0
#define JON      0
d115 2
d142 6
a147 5
        if (!getparint   ("agc"  , &agc))       agc      = AGC;
        if (!getparint   ("gagc" , &gagc))      gagc     = GAGC;
        if (!getparint   ("pbal" , &pbal))      pbal     = PBAL;
        if (!getparint   ("qbal" , &qbal))      qbal     = QBAL;
        if (!getparint   ("jon"  , &jon))       jon      = JON;
d169 50
a218 68
        do {
                if (!tr.mark) {
                        if (tpow) {
                                do_tpow(tpow, tmin, dt, nt);
                        }
                        if (epow) {
                                do_epow(epow, tmin, dt, nt);
                        }
                        if (!CLOSETO(gpow, 1.0)) {
                                register int i;
                                register float val;

                                if (CLOSETO(gpow, 0.5)) {
                                        for (i = 0; i < nt; ++i) {
                                                val = tr.data[i];
                                                tr.data[i] = (val >= 0.0) ?
                                                        sqrt(val) :
                                                        -sqrt(-val);
                                        }
                                } else if (CLOSETO(gpow, 2.0)) {
                                        for (i = 0; i < nt; ++i) {
                                                val = tr.data[i];
                                                tr.data[i] = val * ABS(val);
                                        }
                                } else {
                                        for (i = 0; i < nt; ++i) {
                                                val = tr.data[i];
                                                tr.data[i] = (val >= 0.0) ?
                                                         pow(val, gpow) :
                                                        -pow(-val, gpow);
                                        }
                                }
                        }
                        if (agc)                   do_agc(iwagc, nt);
                        if (gagc)                  do_gagc(iwagc, nt);
                        if (trap > 0.0)            do_trap(trap, nt);
                        if (clip > 0.0)            do_clip(clip, nt);
                        if (qclip < 1.0 && !qbal)  do_qclip(qclip, nt);
                        if (qbal)                  do_qbal(qclip, nt);
                        if (pbal) {
                                register int i;
                                register float val;

                                /* rmsq = sqrt (SUM( a()*a() ) / nt) */
                                rmsq = 0.0;
                                for (i = 0; i < nt; ++i) {
                                        val = tr.data[i];
                                        rmsq += val * val;
                                }
                                rmsq = sqrt(rmsq / nt);

                                if (rmsq) {
                                        for (i = 0; i < nt; ++i)
                                                tr.data[i] /= rmsq;
                                }
                        }
                        if (!CLOSETO(scale, 1.0)) {
                                register int i;
                                register float val;

                                for (i = 0; i < nt; ++i)  tr.data[i] *= scale;
                        }
                }
                puttr(&tr);

        } while(gettr(&tr));


d225 1
d247 1
a247 1
        for (i = 0; i < nt; ++i)  tr.data[i] *= tpowfac[i];
d253 1
d272 1
a272 1
        for (i = 0; i < nt; ++i)  tr.data[i] *= epowfac[i];
d278 1
d283 1
a283 1
        register float *dataptr = tr.data;
d294 1
d299 1
a299 1
        register float *dataptr = tr.data;
d315 1
d321 1
a321 1
        register float *dataptr = tr.data;      /* ptr to trace data    */
d334 1
a334 1
        for (i = 0; i < nt; ++i)  absdata[i] = ABS(tr.data[i]);
d336 1
a336 1
        do_clip(clip, nt);
d342 1
d348 2
a349 2
        register float *dataptr = tr.data;      /* ptr to trace data    */
        static cwp_Bool first = true;       /* first entry flag             */
d355 2
a356 2
                bal = ABS(tr.data[0]);
                for (i = 1; i < nt; ++i)  bal = MAX(bal, ABS(tr.data[i]));
d361 1
a361 1
                        for (i = 0; i < nt; ++i)  tr.data[i] /= bal;
d371 1
a371 1
        for (i = 0; i < nt; ++i)  absdata[i] = ABS(tr.data[i]);
d377 2
a378 2
                for (i = 0; i < nt; ++i)  tr.data[i] /= bal;
                do_clip(1.0, nt);
d385 1
a385 1
void do_agc(int iwagc, int nt)
d406 1
a406 1
                val = tr.data[i];
d411 1
a411 1
        agcdata[0] = (!rms) ? 0.0 : tr.data[0]/sqrt(rms);
d415 1
a415 1
                val = tr.data[i+iwagc];
d419 1
a419 1
                agcdata[i] = (!rms) ? 0.0 : tr.data[i]/sqrt(rms);
d424 1
a424 1
                val = tr.data[i+iwagc];
d426 1
a426 1
                val = tr.data[i-iwagc-1];
d429 1
a429 1
                agcdata[i] = (rms <= 0.0) ? 0.0 : tr.data[i]/sqrt(rms);
d434 1
a434 1
                val = tr.data[i-iwagc-1];
d438 1
a438 1
                agcdata[i] = (rms <= 0.0) ? 0.0 : tr.data[i]/sqrt(rms);
d442 1
a442 1
        memcpy( (void *) tr.data, (const void *) agcdata, nt*FSIZE);
d451 1
a451 1
void do_gagc(int iwagc, int nt)
d498 1
a498 1
                        val = tr.data[i];
d512 1
a512 1
                        agcdata[i] = (!stmp) ? 0.0 : tr.data[i]/sqrt(stmp);
d516 1
a516 1
                memcpy( (void *) tr.data, (const void *) agcdata, nt*FSIZE);
d565 71
@


1.33
log
@Zapped unneeded cast of tr.delrt (sigh).
@
text
@d1 1
a1 1
/* SUGAIN: $Revision: 1.32 $ ; $Date: 1995/08/02 19:59:37 $               */
d43 6
d52 2
a53 2
 *      SEP: Jon
 *      CWP: Jack, Brian, Dave
@


1.32
log
@Cast the integers tr.dt and/or tr.delrt and/or clones to double before
division with floating constant (which is implicitly double
precision).  Casting is needed to make some compilers happy and if we
cast to float then there will be an extra conversion to double because
of the floating constant (casting to float and writing 1000000.0F
would save a conversion, but most people find that F yucky and
efficiency is not an issue here).
Motivated by examples from Stew Levin.
@
text
@d1 1
a1 1
/* SUGAIN: $Revision: 1.31 $ ; $Date: 1995/06/30 00:21:17 $               */
d117 1
a117 1
	tmin = ((double) tr.delrt)/1000.0; /* millisecs to secs */
@


1.31
log
@Fixed bug in do_clip that reversed polarity of large negatives.
Thx to Timo Tjan.  Ironically, v1.1 had it right and somewhere
along the way, it got changed (blush).
@
text
@d1 1
a1 1
/* SUGAIN: $Revision: 1.30 $ ; $Date: 95/03/31 08:50:01 $               */
d116 2
a117 2
        dt   = (float) tr.dt/1000000.0;   /* microsecs to secs */
        tmin = (float) tr.delrt/1000.0;   /* millisecs to secs */
@


1.30
log
@Retreated to the old !rms in the two branches where it cannot be
negative.  Did this for consistency with the rest of the program.
@
text
@d1 1
a1 1
/* SUGAIN: $Revision: 1.29 $ ; $Date: 95/03/23 19:25:01 $               */
d302 1
d304 7
a310 3
        while (nt--)  {
		if (ABS(*dataptr) > clip)  *dataptr = clip;
		dataptr++;
a311 1

@


1.29
log
@Allow for sum to be negative due to roundoff error in agc (thx to Toralf).
@
text
@d1 1
a1 1
/* SUGAIN: $Revision: 1.28 $ ; $Date: 95/02/20 15:54:14 $               */
d407 1
a407 1
        agcdata[0] = (rms <= 0.0) ? 0.0 : tr.data[0]/sqrt(rms);
d415 1
a415 1
                agcdata[i] = (rms <= 0.0) ? 0.0 : tr.data[i]/sqrt(rms);
@


1.28
log
@fixed self-doc re gpow being a power instead of a root.
@
text
@d1 1
a1 1
/* SUGAIN: $Revision: 1.27 $ ; $Date: 95/01/19 11:43:56 $               */
d41 1
a41 1
"       sugain may help.                                                ",
d407 1
a407 1
        agcdata[0] = (!rms) ? 0.0 : tr.data[0]/sqrt(rms);
d409 1
a409 1
        /* ramping on */
d415 1
a415 1
                agcdata[i] = (!rms) ? 0.0 : tr.data[i]/sqrt(rms);
d423 1
a423 1
                sum -= val*val;
d425 1
a425 1
                agcdata[i] = (!rms) ? 0.0 : tr.data[i]/sqrt(rms);
d431 1
a431 1
                sum -= val*val;
d434 1
a434 1
                agcdata[i] = (!rms) ? 0.0 : tr.data[i]/sqrt(rms);
@


1.27
log
@fixed unmached comments
@
text
@d1 1
a1 1
/* SUGAIN: $Revision: 1.26 $ ; $Date: 94/08/25 14:59:27 $               */
d19 1
a19 1
"       gpow=1.0        take signed gpowth root of scaled data          ",
@


1.26
log
@Removed copyright statement from codes that had it.
Moved self-doc line for sudoc.
@
text
@d1 1
a1 1
/* SUGAIN: $Revision: 1.25 $ ; $Date: 94/05/08 14:20:39 $               */
d491 1
a491 1
                /* Put sum of squares of data in d2 and
@


1.25
log
@Fixed trace balancing bugs in do_qbal() function---Craig
@
text
@d1 1
a1 1
/* SUGAIN: $Revision: 1.24 $ ; $Date: 93/11/24 15:33:45 $               */
a2 13
/*----------------------------------------------------------------------
 * Copyright (c) Colorado School of Mines, 1990.
 * All rights reserved.
 *
 * This code is part of SU.  SU stands for Seismic Unix, a processing line
 * developed at the Colorado School of Mines, partially based on Stanford
 * Exploration Project (SEP) software.  Inquiries should be addressed to:
 *
 *  Jack K. Cohen, Center for Wave Phenomena, Colorado School of Mines,
 *  Golden, CO 80401  (jkc@@dix.mines.colorado)
 *----------------------------------------------------------------------
 */

a43 1
/**************** end self doc *******************************************/
d54 1
@


1.24
log
@added explicit casts
@
text
@d1 1
a1 1
/* SUGAIN: $Revision: 1.23 $ ; $Date: 93/08/13 10:28:02 $               */
d365 1
a365 1
                for (i = 1; i < nt; ++i)  bal = MAX(bal, tr.data[i]);
d370 1
a370 1
                        for (i = 1; i < nt; ++i)  tr.data[i] /= bal;
d386 1
a386 1
                for (i = 1; i < nt; ++i)  tr.data[i] /= bal;
@


1.23
log
@changed Bool to cwp_Bool
@
text
@d1 1
a1 1
/* SUGAIN: $Revision: 1.22 $ ; $Date: 92/10/22 16:14:39 $               */
d451 1
a451 1
        memcpy(tr.data, agcdata, nt*FSIZE);
d525 1
a525 1
                memcpy(tr.data, agcdata, nt*FSIZE);
@


1.22
log
@new selfdoc installed
@
text
@d1 1
a1 1
/* SUGAIN: $Revision: 1.21 $ ; $Date: 92/10/05 10:22:49 $               */
d250 1
a250 1
        static Bool first = true;       /* first entry flag     */
d278 1
a278 1
        static Bool first = true;       /* first entry flag     */
d332 1
a332 1
        static Bool first = true;       /* first entry flag             */
d358 1
a358 1
        static Bool first = true;       /* first entry flag             */
d396 1
a396 1
        static Bool first = true;
d462 1
a462 1
        static Bool first=true; /* first entry flag                     */
@


1.21
log
@Was bombing on negative tpow, fix in do_tpow routine.
@
text
@d1 1
a1 1
/* SUGAIN: $Revision: 1.19 $ ; $Date: 91/10/17 13:25:23 $               */
d20 37
a56 37
String sdoc =
"                                                                       \n"
" SUGAIN - apply various types of gain to display traces                \n"
"                                                                       \n"
" sugain <stdin >stdout [optional parameters]                           \n"
"                                                                       \n"
" Required parameters:                                                  \n"
"       none (no-op)                                                    \n"
"                                                                       \n"
" Optional parameters:                                                  \n"
"       tpow=0.0        multiply data by t^tpow                         \n"
"       epow=0.0        multiply data by exp(epow*t)                    \n"
"       gpow=1.0        take signed gpowth root of scaled data          \n"
"       agc=0           flag; 1 = do automatic gain control             \n"
"       gagc=0          flag; 1 = ... with gaussian taper               \n"
"       wagc=0.5        agc window in seconds (use if agc=1 or gagc=1)  \n"
"       trap=none       zero any value whose magnitude exceeds trapval  \n"
"       clip=none       clip any value whose magnitude exceeds clipval  \n"
"       qclip=1.0       clip by quantile on absolute values on trace    \n"
"       qbal=0          flag; 1 = balance traces by qclip and scale     \n"
"       pbal=0          flag; 1 = bal traces by dividing by rms value   \n"
"       scale=1.0       multiply data by overall scale factor           \n"
"       jon=0           flag; 1 means tpow=2, gpow=.5, qclip=.95        \n"
"                                                                       \n"
" Operation order:                                                      \n"
"                                                                       \n"
" out(t) = scale * BAL{CLIP[AGC{[t^tpow * exp(epow * t) * in(t)]^gpow}]}\n"
"                                                                       \n"
" Notes:                                                                \n"
"       The jon flag selects the parameter choices discussed in         \n"
"       Claerbout's Imaging the Earth, pp 233-236.                      \n"
"                                                                       \n"
"       Extremely large/small values may be lost during agc. Windowing  \n"
"       these off and applying a scale in a preliminary pass through    \n"
"       sugain may help.                                                \n"
"                                                                       \n"
;
d123 1
a123 1
        askdoc(1);
@


1.20
log
@Fix by Matt Rutty in do_clip (nodded off after previous routine, apparently.
@
text
@d1 1
a1 1
/* SUGAIN: $Revision: 1.19 $ ; $Date: 91/10/17 13:25:23 $		*/
d21 25
a45 25
" 									\n"
" SUGAIN - apply various types of gain to display traces		\n"
" 									\n"
" sugain <stdin >stdout [optional parameters]				\n"
" 							        	\n"
" Required parameters:							\n"
" 	none (no-op)							\n"
" 							        	\n"
" Optional parameters: 							\n"
" 	tpow=0.0	multiply data by t^tpow		    		\n"
" 	epow=0.0	multiply data by exp(epow*t)	       		\n"
" 	gpow=1.0	take signed gpowth root of scaled data		\n"
" 	agc=0		flag; 1 = do automatic gain control		\n"
" 	gagc=0		flag; 1 = ... with gaussian taper		\n"
" 	wagc=0.5	agc window in seconds (use if agc=1 or gagc=1)	\n"
" 	trap=none	zero any value whose magnitude exceeds trapval 	\n"
" 	clip=none	clip any value whose magnitude exceeds clipval	\n"
" 	qclip=1.0	clip by quantile on absolute values on trace	\n"
" 	qbal=0		flag; 1 = balance traces by qclip and scale	\n"
" 	pbal=0		flag; 1 = bal traces by dividing by rms	value	\n"
" 	scale=1.0	multiply data by overall scale factor       	\n"
" 	jon=0		flag; 1 means tpow=2, gpow=.5, qclip=.95	\n"
" 							        	\n"
" Operation order:							\n"
" 							        	\n"
d47 9
a55 9
" 							        	\n"
" Notes:								\n"
" 	The jon flag selects the parameter choices discussed in		\n"
" 	Claerbout's Imaging the Earth, pp 233-236.   			\n"
" 							        	\n"
" 	Extremely large/small values may be lost during agc. Windowing	\n"
"	these off and applying a scale in a preliminary pass through	\n"
"	sugain may help.				 		\n"
" 							        	\n"
d60 2
a61 2
 *	SEP: Jon
 *	CWP: Jack, Brian, Dave
d63 2
d66 1
a66 1
 *	Jon's second book, pages 233-236.
d81 13
a93 13
#define	TPOW     0.0
#define	EPOW     0.0
#define	GPOW     1.0
#define	TRAP     0.0
#define	CLIP     0.0
#define	QCLIP    1.0
#define	SCALE    1.0
#define	WAGC     0.5
#define	AGC      0
#define	GAGC     0
#define	PBAL 	 0
#define	QBAL 	 0
#define	JON 	 0
d101 18
a118 18
	int jon;	/* flag to get Claerbout values			*/
	int agc;	/* agc flag					*/
	int gagc;	/* gaussian agc flag				*/
	int pbal;	/* power balance flag				*/
	int qbal;	/* quantile balance flag			*/
	float tpow;	/* exponent of t 				*/
	float epow;	/* deattenutation coefficient			*/
	float gpow;	/* dynamic compression power			*/
	float rmsq;	/* root mean square of a trace			*/
	float trap;	/* zero any larger value magnitude than trapval	*/
	float clip;	/* clip any larger value magnitude than clipval	*/
	float qclip;	/* clip at qth quantile (100qth percentile)	*/
	float scale;	/* overall scale factor				*/
	float wagc;	/* size of agc window in seconds		*/
	int iwagc;	/* ... half window in samples			*/
	int nt;		/* number of samples on trace			*/
	float tmin;	/* delay recording time in secs			*/
	float dt;	/* sample rate in secs				*/
d121 4
a124 4
	/* Initialize */
	initargs(argc, argv);
	askdoc(1);
	
d126 7
a132 7
	/* Get nt from first trace */
	if (!gettr(&tr)) err("can't get first trace");
	nt   = (int) tr.ns;
	dt   = (float) tr.dt/1000000.0;   /* microsecs to secs */
	tmin = (float) tr.delrt/1000.0;   /* millisecs to secs */
	if (!dt) getparfloat("dt", &dt);
	if (!dt) MUSTGETPARFLOAT("dt", &dt);
d135 14
a148 14
	/* Get parameters */
	if (!getparfloat ("tpow" , &tpow))	tpow     = TPOW;
	if (!getparfloat ("epow" , &epow))	epow     = EPOW;
	if (!getparfloat ("gpow" , &gpow))	gpow     = GPOW;
	if (!getparfloat ("trap" , &trap))	trap     = TRAP;
	if (!getparfloat ("clip" , &clip))	clip     = CLIP;
	if (!getparfloat ("qclip", &qclip))	qclip    = QCLIP;
	if (!getparfloat ("scale", &scale))	scale    = SCALE;
	if (!getparfloat ("wagc" , &wagc))	wagc     = WAGC;
	if (!getparint   ("agc"  , &agc))	agc      = AGC;
	if (!getparint   ("gagc" , &gagc))	gagc     = GAGC;
	if (!getparint   ("pbal" , &pbal))	pbal 	 = PBAL;
	if (!getparint   ("qbal" , &qbal))	qbal 	 = QBAL;
	if (!getparint   ("jon"  , &jon))	jon 	 = JON;
d151 16
a166 16
	/* Data validation */
	if (trap < 0.0) err("trap = %f, must be positive", trap);
	if (clip < 0.0) err("clip = %f, must be positive", clip);
	if (qclip < 0.0 || qclip > 1.0) 
		err("qclip = %f, must be between 0 and 1", qclip);
	if (agc || gagc) {
		iwagc = NINT(wagc/dt);
		if (iwagc < 1) err("wagc=%g must be positive", wagc);
		if (iwagc > nt) err("wagc=%g too long for trace", wagc);
		iwagc >>= 1;  /* windows are symmetric, so work with half */
	}
	if (jon) { 
		tpow  = 2.0;
		gpow  = 0.5;
		qclip = 0.95;
	}
d169 12
a180 12
	/* Main loop over traces */
	do {
		if (!tr.mark) {
			if (tpow) {
				do_tpow(tpow, tmin, dt, nt);
			}
			if (epow) {
				do_epow(epow, tmin, dt, nt);
			}
			if (!CLOSETO(gpow, 1.0)) {
				register int i;
				register float val;
d182 30
a211 30
				if (CLOSETO(gpow, 0.5)) {
					for (i = 0; i < nt; ++i) {
						val = tr.data[i];
						tr.data[i] = (val >= 0.0) ?
							sqrt(val) :
							-sqrt(-val);
					}
				} else if (CLOSETO(gpow, 2.0)) {
					for (i = 0; i < nt; ++i) {
						val = tr.data[i];
						tr.data[i] = val * ABS(val);
					}
				} else {
					for (i = 0; i < nt; ++i) {
						val = tr.data[i];
						tr.data[i] = (val >= 0.0) ?
							 pow(val, gpow) :
							-pow(-val, gpow);
					}
				}
			}
			if (agc)		   do_agc(iwagc, nt);
			if (gagc)		   do_gagc(iwagc, nt);
			if (trap > 0.0)		   do_trap(trap, nt);
			if (clip > 0.0)		   do_clip(clip, nt);
			if (qclip < 1.0 && !qbal)  do_qclip(qclip, nt);
			if (qbal)		   do_qbal(qclip, nt);
			if (pbal) {
				register int i;
				register float val;
d213 7
a219 7
				/* rmsq = sqrt (SUM( a()*a() ) / nt) */
				rmsq = 0.0;
				for (i = 0; i < nt; ++i) {
					val = tr.data[i];
					rmsq += val * val;
				}
				rmsq = sqrt(rmsq / nt);
d221 8
a228 8
				if (rmsq) {
					for (i = 0; i < nt; ++i)
						tr.data[i] /= rmsq;
				}
			}
			if (!CLOSETO(scale, 1.0)) {
				register int i;
				register float val;
d230 4
a233 4
				for (i = 0; i < nt; ++i)  tr.data[i] *= scale;
			}
		}
		puttr(&tr);
d235 1
a235 1
	} while(gettr(&tr));
d238 1
a238 1
	return EXIT_SUCCESS;
d244 4
a247 4
	float tpow,		/* multiply data by t^tpow	*/
	register float tmin,	/* first time on record		*/
	register float dt,	/* sampling rate in seconds	*/
	int nt			/* number of samples		*/
d250 3
a252 3
	static Bool first = true;	/* first entry flag	*/
	static float *tpowfac;		/* tpow values		*/
	register int i;			/* counter		*/
d254 2
a255 2
	if (first) { /* first entry, set up array of tpow factors */
		register float t;
d257 4
a260 7
		tpowfac = ealloc1float(nt);
		for (i = 0; i < nt; ++i)  {
			t = tmin + i*dt;
			tpowfac[i] = (t >= 0.0) ? pow(t, tpow) : -pow(-t, tpow);
		}
		first = false;
	} /* end first entry */
d262 4
a265 1
	for (i = 0; i < nt; ++i)  tr.data[i] *= tpowfac[i];
d271 4
a274 4
	float epow,		/* coefficient of t in exponent	*/
	register float tmin,	/* first time on record		*/
	register float dt,	/* sampling rate in seconds	*/
	int nt			/* number of samples		*/
d277 3
a279 3
	register int i;			/* counter		*/
	static Bool first = true;	/* first entry flag	*/
	static float *epowfac;		/* exponent stretchs	*/
d281 4
a284 4
	if (first) {
		epowfac = ealloc1float(nt);
		for (i = 0; i < nt; i++) 
			epowfac[i] = exp(epow * (tmin + i * dt));
d286 2
a287 2
		first = false;
	}
d289 1
a289 1
	for (i = 0; i < nt; ++i)  tr.data[i] *= epowfac[i];
d295 2
a296 2
	register float trap,	/* zero if magnitude > trap	*/
	register int nt		/* number of samples		*/
d299 1
a299 1
	register float *dataptr = tr.data;
d301 4
a304 4
	while (nt--) {
		if (ABS(*dataptr) > trap) *dataptr = 0.0;
		dataptr++;
	}
d310 2
a311 2
	register float clip,	/* hard clip if magnitude > clip	*/
	register int nt		/* number of samples			*/
d314 1
a314 1
	register float *dataptr = tr.data;
d316 1
a316 1
	while (nt--)  {
d319 2
a320 1
	}
d326 2
a327 2
	float qclip,	/* quantile at which to clip	*/
	int nt		/* number of sample points	*/
d330 6
a335 6
	register int i;
	register float *dataptr = tr.data;	/* ptr to trace data	*/
	static Bool first = true;	/* first entry flag		*/
	static float *absdata;		/* absolute value trace		*/
	static int iq;			/* index of qclipth quantile	*/
	float clip;			/* ... value of rank[iq]	*/
d337 5
a341 5
	if (first) {
		absdata = ealloc1float(nt);
 		iq = (int) (qclip * nt - 0.5); /* round, don't truncate */
		first = false;
	}
d343 4
a346 4
	/* Clip on value corresponding to qth quantile */
	for (i = 0; i < nt; ++i)  absdata[i] = ABS(tr.data[i]);
 	clip = quant(absdata, iq, nt);
	do_clip(clip, nt);
d352 2
a353 2
	float qclip,	/* quantile at which to clip	*/
	int nt		/* number of sample points	*/
d356 6
a361 6
	register int i;
	register float *dataptr = tr.data;	/* ptr to trace data	*/
	static Bool first = true;	/* first entry flag		*/
	static float *absdata;		/* absolute value trace		*/
	static int iq;			/* index of qclipth quantile	*/
	float bal;			/* value used to balance trace	*/
d363 3
a365 3
	if (qclip == 1.0) { /* balance by max magnitude on trace */
		bal = ABS(tr.data[0]);
		for (i = 1; i < nt; ++i)  bal = MAX(bal, tr.data[i]);
d367 11
a377 11
		if ((bal == 0.0)) {
			return;
		} else {
			for (i = 1; i < nt; ++i)  tr.data[i] /= bal;
			return;
		}
	} else if (first) {
		absdata = ealloc1float(nt);
 		iq = (int) (qclip * nt - 0.5); /* round, don't truncate */
		first = false;
	}
d379 3
a381 3
	/* Balance by quantile value (qclip < 1.0) */
	for (i = 0; i < nt; ++i)  absdata[i] = ABS(tr.data[i]);
	bal = quant(absdata, iq, nt);
d383 7
a389 7
	if ((bal == 0.0)) {
		return;
	} else {
		for (i = 1; i < nt; ++i)  tr.data[i] /= bal;
		do_clip(1.0, nt);
		return;
	}
d396 7
a402 7
	static Bool first = true;
	static float *agcdata;
	register int i;
	register float val;
	register float sum;
	register int nwin;
	register float rms;
d405 5
a409 5
	/* allocate room for agc'd data */
	if (first) {
		first = false;
		agcdata = ealloc1float(nt);
	}
d412 9
a420 9
	/* compute initial window for first datum */
	sum = 0.0;
	for (i = 0; i <= iwagc; ++i) {
		val = tr.data[i];
		sum += val*val;
	}
	nwin = iwagc + 1;
	rms = sum/nwin;
	agcdata[0] = (!rms) ? 0.0 : tr.data[0]/sqrt(rms);
d422 8
a429 8
	/* ramping on */
	for (i = 1; i <= iwagc; ++i) {
		val = tr.data[i+iwagc];
		sum += val*val;
		++nwin;
		rms = sum/nwin;
		agcdata[i] = (!rms) ? 0.0 : tr.data[i]/sqrt(rms);
	}
d431 9
a439 9
	/* middle range -- full rms window */
	for (i = iwagc + 1; i <= nt - iwagc; ++i) {
		val = tr.data[i+iwagc];
		sum += val*val;
		val = tr.data[i-iwagc-1];
		sum -= val*val;
		rms = sum/nwin;
		agcdata[i] = (!rms) ? 0.0 : tr.data[i]/sqrt(rms);
	}
d441 8
a448 8
	/* ramping off */
	for (i = nt - iwagc + 1; i < nt; ++i) {
		val = tr.data[i-iwagc-1];
		sum -= val*val;
		--nwin;
		rms = sum/nwin;
		agcdata[i] = (!rms) ? 0.0 : tr.data[i]/sqrt(rms);
	}
d450 2
a451 2
	/* copy data back into trace */
	memcpy(tr.data, agcdata, nt*FSIZE);
d453 1
a453 1
	return;
d457 1
a457 1
#define EPS	3.8090232	/* exp(-EPS*EPS) = 5e-7, "noise" level	*/
d462 7
a468 7
	static Bool first=true;	/* first entry flag			*/
	static float *agcdata;	/* agc'd data				*/
	static float *w;	/* Gaussian window weights		*/
	static float *d2;	/* square of input data			*/
	static float *s;	/* weighted sum of squares of the data	*/
	float u;		/* related to reciprocal of std dev	*/
	float usq;		/* u*u					*/
d471 2
a472 2
	if (first) {
		first = false;
d474 2
a475 2
		/* Allocate room for agc'd data */
		agcdata = ealloc1float(nt);
d477 7
a483 7
		/* Allocate and compute Gaussian window weights */
		w = ealloc1float(iwagc);  /* recall iwagc is HALF window */
		u = EPS / ((float) iwagc);
		usq = u*u;
		{
			register int i;
			float floati;
d485 5
a489 5
			for (i = 1; i < iwagc; ++i) {
				floati = (float) i;
				w[i] = exp(-(usq*floati*floati));
			}
		}
d491 4
a494 4
		/* Allocate sum of squares and weighted sum of squares */
		d2 = ealloc1float(nt);
		s  = ealloc1float(nt);
	}
d497 6
a502 6
	/* Agc the trace */
	{
		register int i, j, k;
		register float val;
		register float wtmp;
		register float stmp;
d504 6
a509 6
		/* Put sum of squares of data in d2 and
		/* initialize s to d2 to get center point set */
		for (i = 0; i < nt; ++i) {
			val = tr.data[i];
			s[i] = d2[i] = val * val;
		}
d511 7
a517 7
		/* Compute weighted sum s; use symmetry of Gaussian */
		for (j = 1; j < iwagc; ++j) {
			wtmp = w[j];
			for (i = j; i < nt; ++i)  s[i] += wtmp*d2[i-j]; 
			k = nt - j;
			for (i = 0; i < k; ++i)   s[i] += wtmp*d2[i+j]; 
		}
d519 4
a522 4
		for (i = 0; i < nt; ++i) {
			stmp = s[i];
			agcdata[i] = (!stmp) ? 0.0 : tr.data[i]/sqrt(stmp);
		}
d524 3
a526 3
		/* Copy data back into trace */
		memcpy(tr.data, agcdata, nt*FSIZE);
	}
d529 1
a529 1
	return;
d539 3
a541 3
 *    a		- data
 *    k		- indicates quantile
 *    n		- number of points in data
d548 3
a550 3
	register int i, j;
	int low, hi;
	register float ak, aa;
d552 1
a552 1
	low = 0; hi = n-1;
d554 13
a566 13
	while (low < hi) {
		ak = a[k];
		i = low;
		j = hi;
		do {
			while (a[i] < ak) i++;
			while (a[j] > ak) j--;
			if (i <= j) {
				aa = a[i]; a[i] = a[j]; a[j] = aa;
				i++;
				j--;
			}
		} while (i <= j);
d568 1
a568 1
		if (j < k) low = i;
d570 2
a571 2
		if (k < i) hi = j;
	}
d573 1
a573 1
	return(a[k]);
@


1.19
log
@Selectively put back CLOSETO macro.
@
text
@d1 1
a1 1
/* SUGAIN: $Revision: 1.18 $ ; $Date: 91/10/16 13:50:39 $		*/
d314 4
a317 1
	while (nt--)  if (ABS(*dataptr) > clip)  *dataptr++ = clip;
@


1.18
log
@Eliminated CLOSETO since data like 10^(-10) zeroed.
On advice of Dave and Craig, it doesn't make sense to
"nervous Nelly" the user's choices.
@
text
@d1 1
a1 1
/* SUGAIN: $Revision: 1.17 $ ; $Date: 91/10/11 11:12:08 $		*/
d170 1
a170 1
			if (!(tpow == 0.0)) {
d173 1
a173 1
			if (!(epow == 0.0)) {
d176 1
a176 1
			if (!(gpow == 1.0)) {
d180 1
a180 1
				if ((gpow == 0.5)) {
d184 2
a185 1
							sqrt(val) : -sqrt(-val);
d187 1
a187 1
				} else if ((gpow == 2.0)) {
d219 1
a219 1
				if (!(rmsq == 0.0)) {
d224 1
a224 1
			if (!(scale == 1.0)) {
d357 1
a357 1
	if ((qclip == 1.0)) { /* balance by max magnitude on trace */
d414 1
a414 1
	agcdata[0] = (rms == 0.0) ? 0.0 : tr.data[0]/sqrt(rms);
d422 1
a422 1
		agcdata[i] = (rms == 0.0) ? 0.0 : tr.data[i]/sqrt(rms);
d432 1
a432 1
		agcdata[i] = (rms == 0.0) ? 0.0 : tr.data[i]/sqrt(rms);
d441 1
a441 1
		agcdata[i] = (rms == 0.0) ? 0.0 : tr.data[i]/sqrt(rms);
d515 1
a515 2
			agcdata[i] = ((stmp == 0.0) ?
					0.0 : tr.data[i]/sqrt(stmp));
@


1.17
log
@Tweaked sdoc
@
text
@d1 1
a1 1
/* SUGAIN: $Revision: 1.16 $ ; $Date: 91/10/11 11:07:08 $		*/
d170 1
a170 1
			if (!CLOSETO(tpow, 0.0)) {
d173 1
a173 1
			if (!CLOSETO(epow, 0.0)) {
d176 1
a176 1
			if (!CLOSETO(gpow, 1.0)) {
d180 1
a180 1
				if (CLOSETO(gpow, 0.5)) {
d186 1
a186 1
				} else if (CLOSETO(gpow, 2.0)) {
d218 1
a218 1
				if (!CLOSETO(rmsq, 0.0)) {
d223 1
a223 1
			if (!CLOSETO(scale, 1.0)) {
d356 1
a356 1
	if (CLOSETO(qclip, 1.0)) { /* balance by max magnitude on trace */
d360 1
a360 1
		if (CLOSETO(bal, 0.0)) {
d376 1
a376 1
	if (CLOSETO(bal, 0.0)) {
d413 1
a413 1
	agcdata[0] = CLOSETO(rms, 0.0) ? 0.0 : tr.data[0]/sqrt(rms);
d421 1
a421 1
		agcdata[i] = CLOSETO(rms, 0.0) ? 0.0 : tr.data[i]/sqrt(rms);
d431 1
a431 1
		agcdata[i] = CLOSETO(rms, 0.0) ? 0.0 : tr.data[i]/sqrt(rms);
d440 1
a440 1
		agcdata[i] = CLOSETO(rms, 0.0) ? 0.0 : tr.data[i]/sqrt(rms);
d514 1
a514 1
			agcdata[i] = (CLOSETO(stmp, 0.0) ?
@


1.16
log
@Tweaked sdoc
@
text
@d1 1
a1 1
/* SUGAIN: $Revision: 1.15 $ ; $Date: 91/09/05 08:50:35 $		*/
d52 3
a54 3
" 	Extreme large/small values may be lost during agc.		\n"
"	windowing these off and applying a scale in a preliminary pass	\n"
"	through sugain may help.			 		\n"
@


1.15
log
@string -> String and so forth
@
text
@d1 1
a1 1
/* SUGAIN: $Revision: 1.14 $ ; $Date: 90/12/22 08:14:32 $		*/
d36 2
a37 2
" 	trap=0.0	zero any value whose magnitude exceeds trapval 	\n"
" 	clip=0.0	clip any value whose magnitude exceeds clipval	\n"
d51 4
a54 2
" 	Selected traces can be marked as not to be gained by		\n"
" 	using sumark to set the tr.mark header field to 1.		\n"
@


1.14
log
@Stole "quant" from old gainpkge.c
@
text
@d1 1
a1 1
/* SUGAIN: $Revision: 1.13 $ ; $Date: 90/11/11 09:24:44 $		*/
d20 1
a20 1
string sdoc =
d128 1
a128 1
	if (!dt) MUSTFGETPAR("dt", &dt);
d245 1
a245 1
	static bool first = true;	/* first entry flag	*/
d273 1
a273 1
	static bool first = true;	/* first entry flag	*/
d323 1
a323 1
	static bool first = true;	/* first entry flag		*/
d349 1
a349 1
	static bool first = true;	/* first entry flag		*/
d387 1
a387 1
	static bool first = true;
d453 1
a453 1
	static bool first=true;	/* first entry flag			*/
@


1.13
log
@Made symbolic defines
@
text
@d1 1
a1 1
/* SUGAIN: $Revision: 1.12 $ ; $Date: 90/11/11 09:12:17 $		*/
d74 1
d522 44
@


1.12
log
@Put agc (std box) and gagc (gauss taper) in-line, replacing
the old inefficient lateral to suagc.
A *lot* of other editing as well, so bug prone.
@
text
@d1 1
a1 1
/* SUGAIN: $Revision: 1.11 $ ; $Date: 90/11/07 10:29:52 $		*/
d75 16
d131 13
a143 13
	if (!getparfloat ("tpow" , &tpow))	tpow     = 0.0;
	if (!getparfloat ("epow" , &epow))	epow     = 0.0;
	if (!getparfloat ("gpow" , &gpow))	gpow     = 1.0;
	if (!getparfloat ("trap" , &trap))	trap     = 0.0;
	if (!getparfloat ("clip" , &clip))	clip     = 0.0;
	if (!getparfloat ("qclip", &qclip))	qclip    = 1.0;
	if (!getparfloat ("scale", &scale))	scale    = 1.0;
	if (!getparfloat ("wagc" , &wagc))	wagc     = 0.5;
	if (!getparint   ("agc"  , &agc))	agc      = 0;
	if (!getparint   ("gagc" , &gagc))	gagc     = 0;
	if (!getparint   ("pbal" , &pbal))	pbal 	 = 0;
	if (!getparint   ("qbal" , &qbal))	qbal 	 = 0;
	if (!getparint   ("jon"  , &jon))	jon 	 = 0;
@


1.11
log
@Oops.  Lots of anarchronistic references to wagc
as an integer.
@
text
@d1 1
a1 1
/* SUGAIN: $Revision: 1.10 $ ; $Date: 90/11/06 21:11:12 $		*/
d34 2
a35 1
" 	wagc=0.5	agc window in seconds (use if agc=1)		\n"
d59 1
a59 1
 *	CWP: Jack
a62 1
 *
d72 2
a73 1
void do_agc(float wagc);
a76 2
char agcinfile[L_tmpnam];	/* tmp file for input to suagc	*/
char agcoutfile[L_tmpnam];	/* tmp file for output to suagc	*/
a77 1

d82 1
d94 1
d105 9
d124 1
d129 1
d135 6
a140 3
	if (wagc < 0) err("wagc = %g, must be positive", wagc);
	if (agc != 0 && agc != 1) err("agc = %d, flag must be 0 or 1", agc);
	if (jon != 0 && jon != 1) err("jon = %d, flag must be 0 or 1", jon);
d147 1
d149 1
a149 4
	while (gettr(&tr)) {
		nt   = (int) tr.ns;
		tmin = (float) tr.delrt/1000.0;   /* millisecs to secs */
		dt   = (float) tr.dt/1000000.0;   /* microsecs to secs */
d181 6
a186 15
			if (agc) {
				do_agc(wagc);
			}
			if (trap > 0.0) {
				do_trap(trap, nt);
			}
			if (clip > 0.0) {
				do_clip(clip, nt);
			}
			if (qclip < 1.0 && !qbal) {
				do_qclip(qclip, nt);
			}
			if (qbal) {
				do_qbal(qclip, nt);
			}
d208 1
a208 2
				for (i = 0; i < nt; ++i)
					tr.data[i] *= scale;
a211 1
	}
d213 1
d215 1
d243 1
a243 2
	for (i = 0; i < nt; ++i)
		tr.data[i] *= tpowfac[i];
a292 1
	register float mclip = -clip;
d294 1
a294 8
	while (nt--) {
		if (*dataptr > clip) {
			*dataptr = clip;
		} else if (*dataptr < mclip) {
			*dataptr = mclip;
		}
		dataptr++;
	}
d318 1
a318 2
	for (i = 0; i < nt; ++i)
		absdata[i] = ABS(tr.data[i]);
d339 2
a340 2
		for (i = 1; i < nt; ++i)
			bal = MAX(bal, tr.data[i]);
d344 1
a344 2
			for (i = 1; i < nt; ++i)
				tr.data[i] /= bal;
d354 1
a354 2
	for (i = 0; i < nt; ++i)
		absdata[i] = ABS(tr.data[i]);
d356 1
d360 1
a360 2
		for (i = 1; i < nt; ++i)
			tr.data[i] /= bal;
d367 10
d378 57
a434 2
/* Automatic Gain Control--lateral to suagc */
void do_agc(float wagc)	/* agc window in seconds	*/
d436 7
a442 5
	char cmd[BUFSIZ];	/* build suagc command for system call	*/
	FILE *agcinfp;		/* fp for suagc input file		*/
	int agcinfd;		/* ... its file id			*/
	FILE *agcoutfp;		/* fp for suagc output file		*/
	int agcoutfd;		/* ... its file id			*/
d445 2
a446 4
	/* Prepare temporary files to hold traces to be agc'd */
	tmpnam(agcinfile);
	agcinfp = efopen(agcinfile, "w+");
	agcinfd = fileno(agcinfp);
d448 2
a449 3
	tmpnam(agcoutfile);
	agcoutfp = efopen(agcoutfile, "w+");
	agcoutfd = fileno(agcoutfp);
d451 7
a457 1
	fputtr(agcinfd, &tr);
d459 5
a463 3
	/* System call to suagc */
	sprintf(cmd, "suagc <%s >%s wagc=%g", agcinfile, agcoutfile, wagc);
	system(cmd);
d465 4
a468 1
	fgettr(agcoutfd, &tr);
d470 33
a502 5
	/* Clean up temp files */
	efclose(agcinfp);
	eremove(agcinfile);
	efclose(agcoutfp);
	eremove(agcoutfile);
@


1.10
log
@Tweak variable name.
@
text
@d1 1
a1 1
/* SUGAIN: $Revision: 1.9 $ ; $Date: 90/11/06 16:46:17 $		*/
d72 1
a72 1
void do_agc(int wagc);
d94 1
a94 1
	int wagc;	/* size of agc window in samples		*/
d113 1
a113 1
	if (!getparint   ("wagc" , &wagc))	wagc     = 0.5;
d124 1
a124 1
	if (wagc < 0) err("wagc = %d, must be positive", wagc);
d378 1
a378 1
void do_agc(int wagc)	/* agc window in samples	*/
d399 1
a399 1
	sprintf(cmd, "suagc <%s >%s wagc=%d", agcinfile, agcoutfile, wagc);
@


1.9
log
@Tweak self-doc
@
text
@d1 1
a1 1
/* SUGAIN: $Revision: 1.8 $ ; $Date: 90/11/06 16:44:15 $		*/
d384 1
a384 1
	int fdagcout;		/* ... its file id			*/
d394 1
a394 1
	fdagcout = fileno(agcoutfp);
d402 1
a402 1
	fgettr(fdagcout, &tr);
@


1.8
log
@Change wagc default from msec to sec (i.e. 500->0.5).
@
text
@d1 1
a1 1
/* SUGAIN: $Revision: 1.7 $ ; $Date: 90/11/05 20:08:27 $		*/
d51 1
a51 1
" 	using (e.g.) suwind to set the tr.mark header field to 1.	\n"
@


1.7
log
@Use ansi c selfdoc and new pars
@
text
@d1 1
a1 1
/* SUGAIN: $Revision: 1.6 $ ; $Date: 90/11/05 19:41:24 $		*/
d34 1
a34 1
" 	wagc=500	agc window in samples (use if agc=1)		\n"
d113 1
a113 1
	if (!getparint   ("wagc" , &wagc))	wagc     = 500;
@


1.6
log
@Improved power algs.  Removed assumption that tmin >= 0.
@
text
@d1 1
a1 1
/* SUGAIN: $Revision: 1.5 $ ; $Date: 90/06/28 13:04:45 $		*/
d20 34
a53 34
string sdoc = "\
									\n\
SUGAIN - apply various types of gain to display traces 			\n\
									\n\
sugain <stdin >stdout [optional parameters]				\n\
							        	\n\
Required parameters:							\n\
	none (no-op)							\n\
							        	\n\
Optional parameters: 							\n\
	tpow=0.0	multiply data by t^tpow		    		\n\
	epow=0.0	multiply data by exp(epow*t)	       		\n\
	gpow=1.0	take signed gpowth root of scaled data		\n\
	agc=0		flag; 1 = do automatic gain control		\n\
	wagc=500	agc window in samples (use if agc=1)		\n\
	trap=0.0	zero any value whose magnitude exceeds trapval 	\n\
	clip=0.0	clip any value whose magnitude exceeds clipval	\n\
	qclip=1.0	clip by quantile on absolute values on trace	\n\
	qbal=0		flag; 1 = balance traces by qclip and scale	\n\
	pbal=0		flag; 1 = bal traces by dividing by rms	value	\n\
	scale=1.0	multiply data by overall scale factor       	\n\
	jon=0		flag; 1 means tpow=2, gpow=.5, qclip=.95	\n\
							        	\n\
Operation order:							\n\
							        	\n\
out(t) = scale * BAL{CLIP[AGC{[t^tpow * exp(epow * t) * in(t)]^gpow}]}	\n\
							        	\n\
Notes:									\n\
	The jon flag selects the parameter choices discussed in		\n\
	Claerbout's Imaging the Earth, pp 233-236.   			\n\
	Selected traces can be marked as not to be gained by		\n\
	using (e.g.) suwind to set the tr.mark header field to 1.	\n\
							        	\n\
";
d106 12
a117 12
	if (!fgetpar("tpow" , &tpow))		tpow     = 0.0;
	if (!fgetpar("epow" , &epow))		epow     = 0.0;
	if (!fgetpar("gpow" , &gpow))		gpow     = 1.0;
	if (!fgetpar("trap" , &trap))		trap     = 0.0;
	if (!fgetpar("clip" , &clip))		clip     = 0.0;
	if (!fgetpar("qclip", &qclip))		qclip    = 1.0;
	if (!fgetpar("scale", &scale))		scale    = 1.0;
	if (!igetpar("wagc" , &wagc))		wagc     = 500;
	if (!igetpar("agc"  , &agc))		agc      = 0;
	if (!igetpar("pbal" , &pbal))		pbal 	 = 0;
	if (!igetpar("qbal" , &qbal))		qbal 	 = 0;
	if (!igetpar("jon"  , &jon))		jon 	 = 0;
@


1.5
log
@Tweaked some names.
Note: this code does multiple system calls per trace if agc is evoked!
@
text
@d1 1
a1 1
/* SUGAIN: $Revision: 1.4 $ ; $Date: 90/06/28 10:56:53 $		*/
d34 1
a34 1
	wagc=20		agc window in samples (use if agc=1)		\n\
d113 1
a113 1
	if (!igetpar("wagc" , &wagc))		wagc     = 20;
d152 2
a153 2
						tr.data[i] = SGN(val) *
							sqrt(ABS(val));
d163 3
a165 2
						tr.data[i] = SGN(val) *
						exp(gpow*log(ABS(val)));
d217 1
a217 1
/* Multiply by t^tpow = exp(tpow * log t) */
d230 2
d233 3
a235 6

		/* First factor exceptional because the log argument is	*/
		/* zero in the common case where tmin = 0.0		*/
		tpowfac[0] = CLOSETO(tmin, 0.0) ? 1.0 : exp(tpow * log(tmin));
		for (i = 1; i < nt; ++i) {
			tpowfac[i] = exp(tpow * log(tmin + i * dt));
d259 1
a259 1
		for (i = 0; i < nt; i++) {
d261 1
a261 1
		}
d265 1
a265 2
	for (i = 0; i < nt; ++i)
		tr.data[i] *= epowfac[i];
@


1.4
log
@Eliminated unneeded declaration of tmpnam().
@
text
@d1 1
a1 1
/* SUGAIN: $Revision: 1.3 $ ; $Date: 90/06/05 15:51:20 $		*/
d76 2
a77 2
char tmpagcin[L_tmpnam];	/* tmp file for input to suagc	*/
char tmpagcout[L_tmpnam];	/* tmp file for output to suagc	*/
d382 3
a384 3
	FILE *fpagcin;		/* fp for suagc input file		*/
	int fdagcin;		/* ... its file id			*/
	FILE *fpagcout;		/* fp for suagc output file		*/
d389 3
a391 3
	tmpnam(tmpagcin);
	fpagcin = efopen(tmpagcin, "w+");
	fdagcin = fileno(fpagcin);
d393 3
a395 3
	tmpnam(tmpagcout);
	fpagcout = efopen(tmpagcout, "w+");
	fdagcout = fileno(fpagcout);
d397 1
a397 1
	fputtr(fdagcin, &tr);
d400 1
a400 1
	sprintf(cmd, "suagc <%s >%s wagc=%d", tmpagcin, tmpagcout, wagc);
d406 4
a409 4
	efclose(fpagcin);
	eremove(tmpagcin);
	efclose(fpagcout);
	eremove(tmpagcout);
@


1.3
log
@Eliminated veclib routines.
@
text
@d1 1
a1 1
/* SUGAIN: $Revision: 1.2 $ ; $Date: 90/05/25 19:25:47 $		*/
a385 1
	char *tmpnam();		/* system subroutine			*/
@


1.2
log
@vec --> ealloc1float, etc.
@
text
@d1 1
a1 1
/* SUGAIN: $Revision: 1.1 $ ; $Date: 90/04/17 14:07:46 $		*/
a17 1
#include "fconst.h"
d139 1
a139 1
			if (tpow != 0.0) {
d142 1
a142 1
			if (epow != 0.0) {
d145 15
a159 6
			if (gpow != 1.0) {
				if (gpow == 0.5) {
					vssqrt(tr.data, ONE,
						tr.data, ONE, &nt);
				} else if (gpow == 2.0) {
					vssq(tr.data, ONE, tr.data, ONE, &nt);
d161 5
a165 2
					vspow(tr.data, ONE, &gpow,
					       tr.data, ONE, &nt);
d184 8
a191 4
				rmvesq(tr.data, ONE, &rmsq, &nt);
				if (rmsq) {
					vsdiv(tr.data, ONE, &rmsq,
					       tr.data, ONE, &nt);
d193 6
d200 6
a205 2
			if (scale != 1.0) {
				vsmul(tr.data, ONE, &scale, tr.data, ONE, &nt);
d233 2
a234 2
		tpowfac[0] = (tmin == 0.0 ? 1.0 : exp(tpow * log(tmin)));
		for (i = 1; i < nt; i++) {
d240 2
a241 1
	vmul(tr.data, ONE, tpowfac, ONE, tr.data, ONE, &nt);
d264 3
a266 1
	vmul(tr.data, ONE, epowfac, ONE, tr.data, ONE, &nt);
d311 1
d325 2
a326 1
	vabs(dataptr, ONE, absdata, ONE, &nt); 
d338 1
a343 1
	int balloc;			/* index of bal (not used)	*/
d345 5
a349 3
	if (qclip == 1.0) { /* balance by max magnitude on trace */
		maxmgv(tr.data, ONE, &bal, &balloc, &nt);
		if (bal == 0.0) {
d352 2
a353 1
			vsdiv(tr.data, ONE, &bal, tr.data, ONE, &nt);
d363 2
a364 1
	vabs(dataptr, ONE, absdata, ONE, &nt); 
d366 1
a366 1
	if (bal == 0.0) {
d369 2
a370 1
		vsdiv(tr.data, ONE, &bal, tr.data, ONE, &nt);
d408 1
a408 1
	eunlink(tmpagcin);
d410 1
a410 1
	eunlink(tmpagcout);
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/* SUGAIN: $Revision: 2.10 $ ; $Date: 89/09/20 19:35:36 $		*/
d12 1
a12 1
 *  Golden, CO 80401  (isis!csm9a!jkcohen)
d31 12
a42 17
	tpow = 0.0	multiply data by t^tpow		    		\n\
	epow = 0.0	multiply data by exp(epow*t)	       		\n\
	gpow = 1.0	take signed gpowth root of scaled data		\n\
	agc  = 0        flag; 1 = do automatic gain control		\n\
	wagc = 20	agc window in samples (use if agc=1)		\n\
	trap = 0.0	zero any value whose magnitude exceeds 		\n\
			trapval					 	\n\
	clip = 0.0	clip any value whose magnitude exceeds 		\n\
			clipval 					\n\
	qclip = 1.0	clip by quantile on absolute values on 		\n\
			trace						\n\
	qbal = 0	flag; 1 = balance traces by qclip and 		\n\
			scale						\n\
	pbal = 0	flag; 1 = bal traces by dividing by rms		\n\
			value						\n\
	scale = 1.0	multiply data by overall scale factor       	\n\
	jon = 0		flag; 1 means tpow=2, gpow=.5, qclip=.95	\n\
a63 1
 *
d66 8
a73 5
/* Embed Revision Control System identifier strings */
static string progid =
	"   $Source: /src/su/src/RCS/sugain.c,v $";
static string revid =
	"   $Revision: 2.10 $ ; $Date: 89/09/20 19:35:36 $";
a74 3



d81 1
a81 2
main(argc, argv)
int argc; char **argv;
a82 2


a98 8
	void do_tpow();	/* PARMS(flt tpow, flt tmin, flt dt, int nt)	*/
	void do_epow();	/* PARMS(flt epow, flt tmin, flt dt, int nt)	*/
	void do_agc();	/* PARMS(int wagc)				*/
	void do_trap();	/* PARMS(float trap, int nt)			*/
	void do_clip();	/* PARMS(float clip, int nt)			*/
	void do_qclip();/* PARMS(float qclip, int nt)			*/
	void do_qbal();	/* PARMS(float qclip, int nt)			*/
	float quant();	/* PARMS(float data, int iq, int nt)		*/
a102 5
	if (!igetpar("ID", &ID))	ID = 0;
	if (ID) {
		(void) fprintf(stderr, "%s\n", progid);
		(void) fprintf(stderr, "%s\n", revid);
	}
d192 6
a197 5
void do_tpow(tpow, tmin, dt, nt)
float tpow;		/* multiply data by t^tpow	*/
register float tmin;	/* first time on record		*/
register float dt;	/* sampling rate in seconds	*/
int nt;			/* number of samples		*/
d204 1
a204 1
		tpowfac = vec(nt);
d220 6
a225 5
void do_epow(epow, tmin, dt, nt)
float epow;		/* coefficient of t in exponent	*/
register float tmin;	/* first time on record		*/
register float dt;	/* sampling rate in seconds	*/
int nt;			/* number of samples		*/
d232 1
a232 1
		epowfac = vec(nt);
d243 4
a246 3
void do_trap(trap, nt)
register float trap;	/* zero if magnitude > trap	*/
register int nt;	/* number of samples		*/
d258 4
a261 3
void do_clip(clip, nt)
register float clip;	/* hard clip if magnitude > clip	*/
register int nt;	/* number of samples			*/
d278 4
a281 3
void do_qclip(qclip, nt)
float qclip;	/* quantile at which to clip	*/
int nt;		/* number of sample points	*/
d290 1
a290 1
		absdata = vec(nt);
d303 4
a306 3
void do_qbal(qclip, nt)
float qclip;	/* quantile at which to clip	*/
int nt;		/* number of sample points	*/
d324 1
a324 1
		absdata = vec(nt);
d344 1
a344 2
void do_agc(wagc)	/* agc window in samples	*/
int wagc;
d356 1
a356 3
	if (NULL == (fpagcin = fopen(tmpagcin, "w+"))) {
		syserr("fopen failed on suagc input tmp file");
	}
d360 1
a360 3
	if (NULL == (fpagcout = fopen(tmpagcout, "w+"))) {
		syserr("fopen failed on suagc output tmp file");
	}
d372 4
a375 12
	if (EOF == fclose(fpagcin)) {
		syserr("fclose failed on suagc input tmp file");
	}
	if (-1 == unlink(tmpagcin)) {
		syserr("unlink of suagc input tmp file failed");
	}
	if (EOF == fclose(fpagcout)) {
		syserr("fclose failed on suagc ouput tmp file");
	}
	if (-1 == unlink(tmpagcout)) {
		syserr("unlink of suagc ouput tmp file failed");
	}
@
