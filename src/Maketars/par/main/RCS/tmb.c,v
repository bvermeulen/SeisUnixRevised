head	1.2;
access;
symbols;
locks; strict;
comment	@ * @;


1.2
date	97.07.16.22.23.01;	author john;	state Exp;
branches;
next	1.1;

1.1
date	97.05.09.16.05.14;	author john;	state Exp;
branches;
next	;


desc
@Tetrahedral Model Builder --- Zhaobo Meng
@


1.2
log
@removed unused varibles to make SGI compiler happy
@
text
@/* TMB: $Revision: 1.1 $ ; $Date: 1997/05/09 16:05:14 $       */

#include "par.h"

/*********************** self documentation *****************************/
char *sdoc[] = {
"						 			",
" TMB - Tetrahedron Model Builder. In each layer, velocity gradient is  ",
"	constant or a 2-D grid; horizons could be a uniform grid and/or	",
"       added by a 2-D grid that you specify. 				",
"									",
" tmb [parameters] > s3dfile		 				",
" 									",
" Required parameters:							",
" nxgd=		number of x samples (2nd dimension)	     		",
"		=number of cells in x + 1				",
" nzgd=		number of z samples (1st dimension)	     		",
" 		=number of cells in z + 1				",
" nxhz=		number of samples (2nd dimension) for horizons		",
" nyhz=		number of samples (1st dimension) for horizons		",
" hzfile=	output xhz,yhz,zhz,vhz for viewer3 & suwcrayt3d		",
" 		(including: nhz,nxhz,nyhz,nzgd)				",
" Optional parameters:							",
" dvdzfile=	output dvdzhzfile (only for viewer3)			",
" nfile=	output normals n1,n2,n3 for suwcrayt3d			",
" ghfile=	output indices for Cartesian grids to horizon triangles ",
"		(including: nxgd,nygd,nzgd,dxgd,dygd,dzgd,fxgd,fygd,gzgd)",
" 									",
" Optional Parameters:							",
" nhz=3		number of layers in the model (except the model base)	",
" nygd=1	number of y samples (3rd dimension) =1 if a 2-D model	",
" 		=number of cells in y + 1				",
" dygd=0.05 	y sampling interval (typically in km)			",
" dxgd=0.05 	x sampling interval					",
" dzgd=0.05 	z sampling interval					",
" fygd=(ymax+ymin)/2 first y sample					",
" fxgd=0.0	first x sample						",
" fzgd=0.0	first z sample						",
" The following four numbers define the four corners for 3-D model;	",
" for 2-D model only first xmin and xmax are needed:			",
" xmin=fxgd       	x of the lower left point in the model		",
" xmax=fxgd+(nxgd-1)*dxgd y of the lower left point in the model	",
" ymin=fygd       	x of the upper right point in the model		",
" ymax=fygd+(nygd-1)*dygd y of the upper right point in the model	",
" z00=0,0.6,1.2,... 	z at (xmin,ymin) on each horizon		",
" z01=0,0.6,1.2,... 	z at (xmin,ymax) on each horizon		",
" z10=0,0.6,1.2,... 	z at (xmax,ymin) on each horizon, useless if nygd=1",
" z11=0,0.6,1.2,... 	z at (xmax,ymax) on each horizon, useless if nygd=1",
" v00=1.0,2.0,3.0,...	v at (xmin,ymin) on each horizon		",
" v01=1.0,2.0,3.0,...	v at (xmin,ymax) on each horizon		",
" v10=1.0,2.0,3.0,...	v at (xmax,xmin) on each horizon, useless if nygd=1",
" v11=1.0,2.0,3.0,...	v at (xmax,xmax) on each horizon, useless if nygd=1",
" dvdz00=0,0,0,...   	dvdz at (xmin,ymin) on each horizon		",
" dvdz01=0,0,0,...   	dvdz at (xmin,ymax) on each horizon		",
" dvdz10=0,0,0,...   	dvdz at (xmax,xmin) on each horizon, useless if nygd=1",
" dvdz11=0,0,0,...   	dvdz at (xmax,xmax) on each horizon, useless if nygd=1",
" x0file=   	x grid for horizon 0 					",
" y0file=   	y grid for horizon 0 					",
" z0file=	z grid for horizon 0 added to 4-z interpolation   	",
" v0file=	v grid for horizon 0 added to 4-v interpolation   	",
" dvdz0file=	dvdz grid for horizon 00 added to 4-dvdz interpolation	",
"									",
" x1file=	x grid for horizon 1					",
" y1file=	y grid for horizon 1					",
" z1file=	z grid for horizon 1 added to 4-z interpolation  	",
" v1file=	v grid for horizon 1 added to 4-v interpolation  	",
" dvdz1file=	dvdz grid for horizon 1 added to 4-dvdz interpolation	",
" ...		for horizon  #2, #3 #4, etc... 				",
" verbose=0	=1 print some useful iinformation			",
"									",
" Remarks:								",
" TMB defines its own grammar to describe a 3-D model (including a 3-D  ",
" sloth grid *.gd, and a file for horizons *.hz. Both of them will	",
" be used to view the model using 3-D visualization tools such as    	",
" VIEWER3 and TRIP; besides, both of them can be used for ray tracing 	",
" by SUWFRAYT3D and 3-D Kirchhoff prestack depth migration by SUKDMIG3D.",
"									",
" Tools to view the model built by TMB include: VIEWER3 and TRIP. 	",
" VIEWER3 can display the 3-D regular grid, the horizons, as well as    ",
" the rays and wavefronts if a raytracing is carried out by SUWFRAYT3D.	",
" TRIP can display the 3-D regular grid.				",
"									",
" Hint: If a model is generated by TMB and you want to apply raytracing ",
" using SUWFRAYT3D, do not put horizons coincident to the grid points.  ",
" Otherwise SUWFRAYT3D may have stability problem. A useful trick is to ",
" add a tiny amount to z00, z01, z10 and z11 (for ihz=1,2,3 but not 	",
" necessarily for ihz=0), see 0.0001, so they look like 1.0001 or 	",
" something.	 							", 
"									",
" Reference:								",
" Zhaobo Meng and Norman Bleistein, Wavefront Construction (WF) Ray  	",
" Tracing in Tetrahedral Models -- Application to 3-D traveltime and 	",
" ray path computations, CWP report xxx, 1997				",
NULL};

/*
 * Credits:
 *  	CWP: Zhaobo Meng, 1996
 */
/**************** end self doc *******************************************/

#define EPS 0.1
#define SmallReal 0.1e-10

/* Function prototypes of internally used subroutines */
void xiygh(float fx,int nx,float dx,
	float fy,int ny,float dy,
	int nxhz,int nyhz,
	float **xhz,float **yhz,int **ixgh,int **iygh);

void tmb_normal(float x0,float x1,float x2,
	float y0,float y1,float y2,
	float z0,float z1,float z2,
	float *n1,float *n2,float *n3);

void tmb_normalize(float *n1,float *n2,float *n3);


int 
main(int argc, char **argv)
{
	/****************************************************************
	There will be two kinds of grids: 3-D Cartesian regular grids, which
	uses nx,ny,nz, it is uniform; the other kind is for horizons,
	which use nxhz and nyhz. For example, the number of triangles
	in x will be 2*nxhzc, and the number of triangles in y will be
	2*nyhzc.
	*****************************************************************/
	int nygd;	/*number of samples in y. for 2-D, nygd=1*/
	int nygdc; 	/*number of cells in y direction*/
	int nxgd; 	/*number of samples in x direction*/
	int nxgdc; 	/*number of cells in x direction*/
 	int nzgd; 	/*number of samples in z direction*/
	int nzgdc;	/*number of cells in z direction*/

	int nhz; 	/*number of horizons except the surface*/
	int nxhz;	/*number of samples in x (2nd dimension)*/
	int nyhz;	/*number of samples in y (1st dimension)*/
	int nxhzc;	/*number of intervals in x*/
	int nyhzc; 	/*number of intervals in y*/

	float fygd; 	/*first sample in y*/
	float fxgd; 	/*first sample in x*/
	float fzgd; 	/*first sample in z*/

	float dygd; 	/*y sample interval*/
	float dxgd; 	/*x sample interval*/
	float dzgd; 	/*z sample interval*/

	float dxhz;	/*==dx*nxgdc/nxhzc*/
	float dyhz;	/*==dy*nygdc/nyhzc*/

	float ***s3d; 	/*3-D sloth grid: fastest z; 2nd x; slowest y*/
	float ***sx3d;	/*3-D sloth gradient grid*/
	float ***sy3d;  /*3-D sloth gradient grid*/
	float ***sz3d;  /*3-D sloth gradient grid*/

	float **xhz;   /*x of upper horizon: fastest x; slowest ihz*/
	float **yhz;   /*y of upper horizon: fastest x; slowest ihz*/
	float **zhz;   /*z of upper horizon: fastest x; slowest ihz*/
	float **vhz; 	/*v below upper horizon: fastest x; slowest y*/
	float **dvdzhz; /*v'z below upper horizon: fastest x; slowest y*/

	float **n1hz;	/*normals on horizon vertexes*/
	float **n2hz;   /*normals on horizon vertexes*/
	float **n3hz;   /*normals on horizon vertexes*/

	float **temp;	/*temporary array for xhz, yhz and zhz*/

	float **n1ll;	/*n1ll[nyhzc][nxhzc]*/
	float **n1ur;	/*n1ur[nyhzc][nxhzc]*/
	float **n2ll;   /*n2ll[nyhzc][nxhzc]*/
        float **n2ur;   /*n2ur[nyhzc][nxhzc]*/
	float **n3ll;   /*n3ll[nyhzc][nxhzc]*/
        float **n3ur;   /*n3ur[nyhzc][nxhzc]*/

	float x,y,z0;
	float xalpha,ybeta;

	float *z00; 	/*z at (xmin,ymin) on each horizon*/
	float *z01; 	/*z at (xmin,ymax) on each horizon*/
	float *z10; 	/*z at (xmax,ymin) on each horizon*/
	float *z11; 	/*z at (xmax,ymax) on each horizon*/

	float *v00; 	/*v at (xmin,ymin) on each horizon*/
	float *v01; 	/*v at (xmin,ymax) on each horizon*/
	float *v10; 	/*v at (xmax,ymin) on each horizon*/
	float *v11; 	/*v at (xmax,ymax) on each horizon*/

	float *dvdz00; 	/*dvdz at (xmin,ymin) on each horizon*/
	float *dvdz01;	/*dvdz at (xmin,ymax) on each horizon*/
	float *dvdz10;  /*dvdz at (xmax,ymin) on each horizon*/
	float *dvdz11;  /*dvdz at (xmax,ymax) on each horizon*/

	char *xfile;    /*grid file for x0*/
	char *yfile;	/*grid file for y0*/
	char *zfile;	/*grid file for z0 (added to z)*/
	char *vfile;	/*grid file for v0 (added to v)*/
	char *dvdzfile; /*grid file for dvdz (added to dvdz)*/

	char *hzfile; 	/*horizon file for viewer3 and wcrayt3d*/
	FILE *hzfp;
	char *nfile="";	/*file for normals for wcrayt3d*/
	FILE *nfp;
        char *dvdzhzfile=""; /*file for normals for wcrayt3d*/
        FILE *dvdzhzfp;
	char *ghfile="";/*file for Cartesian to triangular indices*/
	FILE *ghfp;

	float xmin,ymin;/*first reference point*/
	float xmax,ymax;/*second reference point*/

	int **ixgh;	/*mapping for indices for grid to horizon*/
	int **iygh;	/*mapping for indices for grid to horizon*/

	int iixgh,iiygh;
	int ixhz,iyhz,ixhzc,iyhzc;
	int ixgdc;	/*index for nxgdc*/
	int iygdc; 	/*index for nygdc*/
	int izgdc;	/*index for nzgdc*/
	int ihz; 	/*index for nhz*/
	int iz0;
	float riz0;
	int verbose;    /*=1 then print some useful iinformation*/
	float fz0,fz1,fv0,fv1,fdvdz0,fdvdz1;
	float beta,alpha;
	float vtemp;

	/* hook up getpar */
	initargs(argc,argv);
	requestdoc(1);

	xfile=(char *)malloc(80);
	yfile=(char *)malloc(80);
	zfile=(char *)malloc(80);
	vfile=(char *)malloc(80);
	dvdzfile=(char *)malloc(80);

	/* get parameters */
	if (!getparint("nhz",&nhz))	
		nhz=3;
	if (!getparint("nygd",&nygd)) 	
		nygd=1; 
	if (!getparint("nxgd",&nxgd))	
		err("Must specify nxgd");
	if (!getparint("nzgd",&nzgd))	
		err("Must specify nzgd");
        if (!getparint("nxhz",&nxhz))   
		err("Must specify nxhz");
        if (!getparint("nyhz",&nyhz))   
		err("Must specify nyhz");


	if (!getparstring("hzfile",&hzfile)) 	
		err("Must specify hzfile");
	getparstring("nfile",&nfile);
	getparstring("dvdzhzfile",&dvdzhzfile);
	getparstring("ghfile",&ghfile);
	if (!getparint("verbose",&verbose)) 	
		verbose=0;

	if (verbose)
		warn("hzfile=%s\nnfile=%s\nghfile=%s\ndvdzhzfile=%s",
			hzfile,nfile,ghfile,dvdzhzfile);

	nfp=fopen(nfile,"w");
	dvdzhzfp=fopen(dvdzhzfile,"w");
	ghfp=fopen(ghfile,"w");

	nygdc=MAX(1,nygd-1);
	nxgdc=MAX(1,nxgd-1);
	nzgdc=MAX(1,nzgd-1);

	if (!getparfloat("dygd",&dygd))	dygd=0.05;
	if (!getparfloat("dxgd",&dxgd))	dxgd=0.05;
	if (!getparfloat("dzgd",&dzgd))	dzgd=0.05;
	if (!getparfloat("fygd",&fygd))	fygd=0.0;
	if (!getparfloat("fxgd",&fxgd))	fxgd=0.0;
	if (!getparfloat("fzgd",&fzgd))	fzgd=0.0;
	if (!getparfloat("xmin",&xmin))	xmin=fxgd;
	if (!getparfloat("xmax",&xmax)) xmax=fxgd+nxgdc*dxgd;
	if (!getparfloat("ymin",&ymin)) ymin=fygd;
	if (!getparfloat("ymax",&ymax)) ymax=fygd+nygdc*dygd;

	if ((hzfp=fopen(hzfile,"w"))==NULL)
		err("Can not open hzfile");

	/******************************************
	Write model parameters to hzfile
	******************************************/
	if (fwrite(&nhz,sizeof(int),1,hzfp)!=1) 
		err("Can not write nhz");
	if (fwrite(&nxhz,sizeof(int),1,hzfp)!=1) 
		err("Can not write nxhz");
	if (fwrite(&nyhz,sizeof(int),1,hzfp)!=1) 
		err("Can not write nyhz");
	if (fwrite(&nzgd,sizeof(int),1,hzfp)!=1) 
		err("Can not write nzgd");

	if (ghfp!=(FILE *)NULL) {
	if (fwrite(&nxgd,sizeof(int),1,ghfp)!=1)
		err("Can not write nxgd to ghfile");
	if (fwrite(&nygd,sizeof(int),1,ghfp)!=1)
		err("Can not write nygd to ghfile");
	if (fwrite(&nzgd,sizeof(int),1,ghfp)!=1)
		err("Can not write nzgd to ghfile");
	if (fwrite(&dxgd,sizeof(float),1,ghfp)!=1)
		err("Can not write dxgd to ghfile");
	if (fwrite(&dygd,sizeof(float),1,ghfp)!=1)
		err("Can not write dygd to ghfile");
	if (fwrite(&dzgd,sizeof(float),1,ghfp)!=1)
		err("Can not write dzgd to ghfile");
	if (fwrite(&fxgd,sizeof(float),1,ghfp)!=1)
		err("Can not write fxgd to ghfile");
	if (fwrite(&fygd,sizeof(float),1,ghfp)!=1)
		err("Can not write fygd to ghfile");
	if (fwrite(&fzgd,sizeof(float),1,ghfp)!=1)
		err("Can not write fzgd to ghfile");
	}

	if (verbose) {
		warn("nhz=%d",nhz);
		warn("nxgdc=%d\n nygdc=%d\n,nzgdc=%d",nxgdc,nygdc,nzgdc);
		warn("dxgd=%f dygd=%f dzgd=%f",dxgd,dygd,dzgd);
	}	
	
	/* allocate space */
	s3d =alloc3float(nzgdc,nxgdc,nygdc);
	sx3d=alloc3float(nzgdc,nxgdc,nygdc);
	sy3d=alloc3float(nzgdc,nxgdc,nygdc);
        sz3d=alloc3float(nzgdc,nxgdc,nygdc);

        memset((void *)sx3d[0][0],(int)'\0',
		nzgdc*nxgdc*nygdc*sizeof(float));
	memset((void *)sy3d[0][0],(int)'\0',
		nzgdc*nxgdc*nygdc*sizeof(float));
	memset((void *)sz3d[0][0],(int)'\0',
		nzgdc*nxgdc*nygdc*sizeof(float));

	z00   =alloc1float(nhz);
	z01   =alloc1float(nhz);
	z10   =alloc1float(nhz);
	z11   =alloc1float(nhz);
	v00   =alloc1float(nhz);	
	v01   =alloc1float(nhz);
	v10   =alloc1float(nhz);
	v11   =alloc1float(nhz);
	dvdz00=alloc1float(nhz);
	dvdz01=alloc1float(nhz);
	dvdz10=alloc1float(nhz);
	dvdz11=alloc1float(nhz);

	ixgh=ealloc2int(nxgd,nygd);
	iygh=ealloc2int(nxgd,nygd);

	if (!getparfloat("z00",z00))
		for(ihz=0;ihz<nhz;ihz++) 
			z00[ihz] = ihz*0.6;
	if (!getparfloat("z01",z01))
		for(ihz=0;ihz<nhz;ihz++) 
			z01[ihz] = ihz*0.6;
	if (!getparfloat("z10",z10))
		for(ihz=0;ihz<nhz;ihz++) 
			z10[ihz] = ihz*0.6;
	if (!getparfloat("z11",z11))
		for(ihz=0;ihz<nhz;ihz++) 
			z11[ihz] = ihz*0.6;

	if (verbose) {	
		for (ihz=0;ihz<nhz;ihz++) 
			warn("layer %d z: %f %f %f %f",ihz,
			z00[ihz],z01[ihz],z10[ihz],z11[ihz]);
	}

	for (ihz=1;ihz<nhz;ihz++) {
		if (fabs(z00[ihz]/dzgd-(int)(z00[ihz]/dzgd))<EPS ||
		    fabs(z01[ihz]/dzgd-(int)(z01[ihz]/dzgd))<EPS ||
		    fabs(z10[ihz]/dzgd-(int)(z10[ihz]/dzgd))<EPS ||
		    fabs(z11[ihz]/dzgd-(int)(z11[ihz]/dzgd))<EPS) { 
		warn("Warning: may leads to instablity in wcrayt3d...");	
		warn("z00, z01,z10,z11 should not be integer times of dzgd");
		}
	}

	/************************************************
	The default velocity is 2.0,3.0,...,in km/s
	************************************************/
	if (!getparfloat("v00",v00))
		for(ihz=0;ihz<nhz;ihz++) v00[ihz] = ihz+1;
	if (!getparfloat("v01",v01))
		for(ihz=0;ihz<nhz;ihz++) v01[ihz] = ihz+1;
	if (!getparfloat("v10",v10))
		for(ihz=0;ihz<nhz;ihz++) v10[ihz] = ihz+1;
	if (!getparfloat("v11",v11))
		for(ihz=0;ihz<nhz;ihz++) v11[ihz] = ihz+1;

	if (verbose) 
		for (ihz=0;ihz<nhz;ihz++) 
			warn("layer %d v: %f %f %f %f",ihz,
			v00[ihz],v01[ihz],v10[ihz],v11[ihz]);

	if (!getparfloat("dvdz00",dvdz00))
		for(ihz=0;ihz<nhz;ihz++) dvdz00[ihz] = 0.0;
	if (!getparfloat("dvdz01",dvdz01))
		for(ihz=0;ihz<nhz;ihz++) dvdz01[ihz] = 0.0;
	if (!getparfloat("dvdz10",dvdz10))
		for(ihz=0;ihz<nhz;ihz++) dvdz10[ihz] = 0.0;
	if (!getparfloat("dvdz11",dvdz11))
		for(ihz=0;ihz<nhz;ihz++) dvdz11[ihz] = 0.0;

	if (verbose) 
		for (ihz=0;ihz<nhz;ihz++) 
			warn("layer %d dvdz: %f %f %f %f",ihz,
			dvdz00[ihz],dvdz01[ihz],dvdz10[ihz],dvdz11[ihz]);

	/*************************************************
	Get the size of the horizon (in triangles), which is
	not necessary to be equal to nx and ny, and these
	grids are not uniform 
	*************************************************/
	warn("nxhz=%d",nxhz);
	warn("nyhz=%d",nyhz);
	nxhzc=MAX(1,nxhz-1);
	nyhzc=MAX(1,nyhz-1);

	n1hz=ealloc2float(nxhz,nyhz);
	n2hz=ealloc2float(nxhz,nyhz);
	n3hz=ealloc2float(nxhz,nyhz);

	n1ll=ealloc2float(nxhzc,nyhzc);
	n1ur=ealloc2float(nxhzc,nyhzc);
        n2ll=ealloc2float(nxhzc,nyhzc);
        n2ur=ealloc2float(nxhzc,nyhzc);
        n3ll=ealloc2float(nxhzc,nyhzc);
        n3ur=ealloc2float(nxhzc,nyhzc);

	xhz=ealloc2float(nxhz,nyhz);
	yhz=ealloc2float(nxhz,nyhz);
	zhz=ealloc2float(nxhz,nyhz);
	vhz=ealloc2float(nxhzc,nyhzc);
	dvdzhz=ealloc2float(nxhzc,nyhzc);

	temp=ealloc2float(nxhz,nyhz);

	dxhz=dxgd*nxgdc/nxhzc;
	dyhz=dygd*nygdc/nyhzc;

 	for (ihz=0;ihz<nhz;ihz++) {

		sprintf(xfile,"x%dfile",ihz);
		sprintf(yfile,"y%dfile",ihz);
		sprintf(zfile,"z%dfile",ihz);
		sprintf(vfile,"v%dfile",ihz);
		sprintf(dvdzfile,"dvdz%dfile",ihz);

		if (verbose==1) 
			warn("%s %s %s %s %s",xfile,
				yfile,zfile,vfile,dvdzfile);
		
		if (getparstring(xfile,&xfile)) {
			if (fread(xhz[0],sizeof(float),nxhz*nyhz,
				fopen(xfile,"r"))!=nxhz*nyhz)
				err("Can not read in %s\n",xfile);
			warn("read in %s",xfile);
			for (iyhz=0;iyhz<nyhz;iyhz++) {
				if (fabs(xhz[iyhz][0]-fxgd)>dxgd+EPS) 
				err("xhz[%d][0] != fxgd",iyhz);
				else
					xhz[iyhz][0]=fxgd;
			if (fabs(xhz[iyhz][nxhzc]-fxgd-nxgdc*dxgd)>dxgd+EPS)
				err("xhz[%d][nxhzc]=%e != fxgd+nxgdc*dxgd=%e",
					iyhz,xhz[iyhz][nxhzc],fxgd+nxgdc*dxgd);
				else
					xhz[iyhz][nxhzc]=fxgd+nxgdc*dxgd;
			}

		} else { 
			warn("Using uniform cartesian grids for x-horizon%d",ihz);
			for (ixhz=0;ixhz<nxhz;ixhz++)
				for (iyhz=0;iyhz<nyhz;iyhz++)
					xhz[iyhz][ixhz]=fxgd+ixhz*dxhz; 
		}

		if (getparstring(yfile,&yfile)) {
			if (fread(yhz[0],sizeof(float),nxhz*nyhz,
				fopen(yfile,"r"))!=nyhz*nxhz)
					err("Can not read in %s\n",yfile);
			warn("read in %s",yfile);
			for (ixhz=0;ixhz<nxhz;ixhz++) {
				if (fabs(yhz[0][ixhz]-fygd)>EPS) 
					err("yhz[0][%d]=%e != fygd=%e",ixhz,
						yhz[0][ixhz],fygd);
				else
					yhz[0][ixhz]=fygd;
				if (fabs(yhz[nyhzc][ixhz]-fygd-nygdc*dygd)>EPS)
					err("yhz[nyhzc][%d]=%e!=fygd+nygdc*dygd=%e",
					ixhz,yhz[nyhzc][ixhz],fygd+nygdc*dygd);
				else
					yhz[nyhzc][ixhz]=fygd+nygdc*dygd;
			}
		} else {
			warn("Using uniform cartesian grids for y-horizon%d",ihz);
			for (ixhz=0;ixhz<nxhz;ixhz++)
				for (iyhz=0;iyhz<nyhz;iyhz++)
					yhz[iyhz][ixhz]=fygd+iyhz*dyhz;
		}

		if (getparstring(zfile,&zfile)) {
			if (fread(zhz[0],sizeof(float),nyhz*nxhz,
				fopen(zfile,"r"))!=nyhz*nxhz)
				err("Can not read in %s\n",zfile);
			warn("read in %s",zfile);
		} else {
			warn("Using uniform cartesian grids for z-horizon%d",ihz);
			for (ixhz=0;ixhz<nxhz;ixhz++)
				for (iyhz=0;iyhz<nyhz;iyhz++)
					zhz[iyhz][ixhz]=0;
		}
	
		if (getparstring(vfile,&vfile)) {       
			if (fread(vhz[0],sizeof(float),
				nxhzc*nyhzc,fopen(vfile,"r"))!=
				nxhzc*nyhzc)       
					err("Can not read in %s\n",vfile);  
			warn("read in %s",vfile);
		} else {
			warn("Using default for v-horizon %d",ihz);
			for (ixhzc=0;ixhzc<nxhzc;ixhzc++)
				for (iyhzc=0;iyhzc<nyhzc;iyhzc++)
					vhz[iyhzc][ixhzc]=0;
		}

		if (getparstring(dvdzfile,&dvdzfile)) {
			if (fread(dvdzhz[0],sizeof(float),nyhzc*nxhzc,
				fopen(dvdzfile,"r"))!=nyhzc*nxhzc)       
					err("Can not read in %s\n",dvdzfile);  
			warn("read in %s",dvdzfile);
		} else {
			warn("Using default for dvdz-horizon %d",ihz);
			for (ixhzc=0;ixhzc<nxhzc;ixhzc++)
				for (iyhzc=0;iyhzc<nyhzc;iyhzc++)
					dvdzhz[iyhzc][ixhzc]=0;
		}

		/*************************************************************
		zhz is added to the plane determined by the four corners
		*************************************************************/
		for (ixhz=0;ixhz<nxhz;ixhz++){
			if (nyhz==1) {
				alpha=(xhz[0][ixhz]-xmin)/(xmax-xmin);
				zhz[0][ixhz]+=alpha*z01[ihz]+(1-alpha)*z00[ihz];
			} else {
				for (iyhz=0;iyhz<nyhz;iyhz++) {
					alpha=(xhz[iyhz][ixhz]-xmin)/(xmax-xmin);
					fz0=alpha*z01[ihz]+(1-alpha)*z00[ihz];
					fz1=alpha*z11[ihz]+(1-alpha)*z10[ihz];
					beta =(yhz[iyhz][ixhz]-ymin)/(ymax-ymin);
					zhz[iyhz][ixhz]+=beta*fz1+(1-beta)*fz0;
				}
			}
		}
		/*************************************************************
		vhz and dvdzhz are added to the velocity plane determined by 
		velocity at the four corners
		*************************************************************/
		for (ixhzc=0;ixhzc<nxhzc;ixhzc++){
			if (nyhz==1) {
				alpha=(xhz[0][ixhzc]-xmin)/(xmax-xmin);
				vhz[0][ixhzc]+=alpha*v01[ihz]+(1-alpha)*v00[ihz];
				dvdzhz[0][ixhzc]+=alpha*dvdz01[ihz]
					+(1-alpha)*dvdz00[ihz];
			} else {
				for (iyhzc=0;iyhzc<nyhzc;iyhzc++){
					alpha=(xhz[iyhzc][ixhzc]-xmin)/(xmax-xmin);
					fv0=alpha*v01[ihz]+(1-alpha)*v00[ihz];
					fv1=alpha*v11[ihz]+(1-alpha)*v10[ihz];
					fdvdz0=alpha*dvdz01[ihz]+(1-alpha)*dvdz00[ihz];
					fdvdz1=alpha*dvdz11[ihz]+(1-alpha)*dvdz10[ihz];
					beta =(yhz[iyhzc][ixhzc]-ymin)/(ymax-ymin);
					vhz[iyhzc][ixhzc]+=
						beta*fv1+(1-beta)*fv0;
					dvdzhz[iyhzc][ixhzc]+=
						beta*fdvdz1+(1-beta)*fdvdz0;   
				}
			}
		}

		xiygh(fxgd,nxgd,dxgd,fygd,nygd,dygd,nxhz,nyhz,xhz,yhz,ixgh,iygh);

		/*******************************************************
		Only the cells which completely beneath the horizon use
		the new velocity.
		*******************************************************/
		for (ixgdc=0;ixgdc<nxgdc;ixgdc++) {
			x=fxgd+ixgdc*dxgd;
			for (iygdc=0;iygdc<nygdc;iygdc++) {
				y=fygd+iygdc*dygd;
				iixgh=ixgh[iygdc][ixgdc];
				iiygh=iygh[iygdc][ixgdc];
				iixgh=MIN(iixgh,nxhz-2);
				iiygh=MIN(iiygh,nyhz-2);
				xalpha=(x-xhz[iiygh][iixgh])/
					(xhz[iiygh][iixgh+1]-xhz[iiygh][iixgh]);
                                ybeta=(y-yhz[iiygh][iixgh])/
                                        (yhz[iiygh+1][iixgh]-yhz[iiygh][iixgh]);
				z0=(1.0-ybeta)*
					((1.0-xalpha)*zhz[iiygh][iixgh]
					+xalpha*zhz[iiygh][iixgh+1])
				   	+ybeta*
					((1.0-xalpha)*zhz[iiygh+1][iixgh]
                                        +xalpha*zhz[iiygh+1][iixgh+1]);

				riz0=(z0-fzgd)/dzgd;
				iz0=riz0;
				if (ihz==0) iz0=0;
				for (izgdc=iz0;izgdc<nzgdc;izgdc++){
					s3d[iygdc][ixgdc][izgdc]=
						vhz[iiygh][iixgh]+
						(fzgd+izgdc*dzgd-zhz[iiygh][iixgh])
						*dvdzhz[iiygh][iixgh];
				}
			}
		}

		/*******************************************************
		Only the cells which completely beneath the horizon use
		the new velocity, the new sloth, sloth gradient
		*******************************************************/
		for (ixgdc=1;ixgdc<nxgdc-1;ixgdc++) {
			x=fxgd+ixgdc*dxgd;
			for (iygdc=1;iygdc<nygdc-1;iygdc++) {
				y=fygd+iygdc*dygd;
				iixgh=ixgh[iygdc][ixgdc];
				iiygh=iygh[iygdc][ixgdc];
				iixgh=MIN(iixgh,nxhz-2);
				iiygh=MIN(iiygh,nyhz-2);
				xalpha=(x-xhz[iiygh][iixgh])/
					(xhz[iiygh][iixgh+1]-xhz[iiygh][iixgh]);
                                ybeta=(y-yhz[iiygh][iixgh])/
                                        (yhz[iiygh+1][iixgh]-yhz[iiygh][iixgh]);
				z0=(1.0-ybeta)*
					((1.0-xalpha)*zhz[iiygh][iixgh]
					+xalpha*zhz[iiygh][iixgh+1])
				   	+ybeta*
					((1.0-xalpha)*zhz[iiygh+1][iixgh]
                                        +xalpha*zhz[iiygh+1][iixgh+1]);

				riz0=(z0-fzgd)/dzgd;
				iz0=riz0;
				if (ihz==0) iz0=0;
				for (izgdc=iz0+1;izgdc<nzgdc-1;izgdc++){
					sx3d[iygdc][ixgdc][izgdc]=
						(s3d[iygdc][ixgdc+1][izgdc]-
						s3d[iygdc][ixgdc-1][izgdc])/2.0/dxgd;
                                        sy3d[iygdc][ixgdc][izgdc]=
                                                (s3d[iygdc+1][ixgdc][izgdc]-
                                                s3d[iygdc-1][ixgdc][izgdc])/2.0/dygd;
                                        sz3d[iygdc][ixgdc][izgdc]=
                                                (s3d[iygdc][ixgdc][izgdc+1]-
                                                s3d[iygdc][ixgdc][izgdc-1])/2.0/dzgd;
					vtemp=s3d[iygdc][ixgdc][izgdc];
					vtemp=vtemp*vtemp*vtemp;
					sx3d[iygdc][ixgdc][izgdc]*=-2.0/vtemp;
					sy3d[iygdc][ixgdc][izgdc]*=-2.0/vtemp;
					sz3d[iygdc][ixgdc][izgdc]*=-2.0/vtemp;
				}
				sx3d[iygdc][ixgdc][iz0]=sx3d[iygdc][ixgdc][iz0+1];
				sy3d[iygdc][ixgdc][iz0]=sy3d[iygdc][ixgdc][iz0+1];
				sz3d[iygdc][ixgdc][iz0]=sz3d[iygdc][ixgdc][iz0+1];
                                sx3d[iygdc][ixgdc][nzgdc-1]=sx3d[iygdc][ixgdc][nzgdc-2];
                                sy3d[iygdc][ixgdc][nzgdc-1]=sy3d[iygdc][ixgdc][nzgdc-2];
                                sz3d[iygdc][ixgdc][nzgdc-1]=sz3d[iygdc][ixgdc][nzgdc-2];
			}
		}

		/**********************************************************
		Output the horizon information to file hzfile:
		**********************************************************/	
		for (iyhz=0;iyhz<nyhz;iyhz++) 
			for (ixhz=0;ixhz<nxhz;ixhz++) 
				temp[iyhz][ixhz]=xhz[iyhz][ixhz]/dxgd;
		if (fwrite(temp[0],sizeof(float),nxhz*nyhz,hzfp)!=nxhz*nyhz)
			err("Can not write xhz to hzfp");	

                for (iyhz=0;iyhz<nyhz;iyhz++) 
                        for (ixhz=0;ixhz<nxhz;ixhz++) 
                                temp[iyhz][ixhz]=yhz[iyhz][ixhz]/dygd;
		if (fwrite(temp[0],sizeof(float),nxhz*nyhz,hzfp)!=nxhz*nyhz)
			err("Can not write yhz to hzfp");

                for (iyhz=0;iyhz<nyhz;iyhz++)
                        for (ixhz=0;ixhz<nxhz;ixhz++) 
                                temp[iyhz][ixhz]=zhz[iyhz][ixhz]/dzgd;
		if (fwrite(temp[0],sizeof(float),nxhz*nyhz,hzfp)!=nxhz*nyhz)
			err("Can not write zhz to hzfp");

		if (fwrite(vhz[0],sizeof(float),nxhzc*nyhzc,hzfp)!=
			nxhzc*nyhzc)
			err("Can not write vhz to hzfp");

		if (dvdzhzfp!=NULL) {
			if (fwrite(dvdzhz[0],sizeof(float),nxhzc*nyhzc,hzfp)!=
				nxhzc*nyhzc)
				err("Can not write dvdzhz to hzfp");
		}

		/**********************************************************
		Output the normals to nfile for wcrayt3d
		All triangles look like:

		   (ix,iy+1) (ix+1,iy+1)	
			________
			|\     |
			| \  1 |
			|  \   |
			|   \  | 
			| 0  \ |
			|     \|
			--------  
		    (ix,iy) (ix+1,iy) 

		**********************************************************/
		if (nfp!=NULL) {
		for (ixhz=0;ixhz<nxhzc;ixhz++) {
			for (iyhz=0;iyhz<nyhzc;iyhz++) {
		 		tmb_normal( xhz[iyhz][ixhz],xhz[iyhz][ixhz+1],
				        xhz[iyhz+1][ixhz],
				        yhz[iyhz][ixhz],yhz[iyhz][ixhz+1],
       				        yhz[iyhz+1][ixhz],
				        zhz[iyhz][ixhz],zhz[iyhz][ixhz+1],
       					zhz[iyhz+1][ixhz],n1ll[iyhz]+ixhz,
					n2ll[iyhz]+ixhz,n3ll[iyhz]+ixhz);

				/*if (fwrite(n1ll[iyhz]+ixhz,sizeof(float),1,nfp)!=1)
       			 		err("Can not write n1 to nfp");
				if (fwrite(n2ll[iyhz]+ixhz,sizeof(float),1,nfp)!=1)
					err("Can not write n2 to nfp");   
				if (fwrite(n3ll[iyhz]+ixhz,sizeof(float),1,nfp)!=1)
					err("Can not write n3 to nfp");*/
				tmb_normal( xhz[iyhz][ixhz+1],xhz[iyhz+1][ixhz+1],
				        xhz[iyhz+1][ixhz],
			       	        yhz[iyhz][ixhz+1],yhz[iyhz+1][ixhz+1],
				        yhz[iyhz+1][ixhz],
				        zhz[iyhz][ixhz+1],zhz[iyhz+1][ixhz+1],
				        zhz[iyhz+1][ixhz],n1ur[iyhz]+ixhz,
                                        n2ur[iyhz]+ixhz,n3ur[iyhz]+ixhz);

				/*if (fwrite(n1ur[iyhz]+ixhz,sizeof(float),1,nfp)!=1)
					err("Can not write n1 to nfp");
				if (fwrite(n2ur[iyhz]+ixhz,sizeof(float),1,nfp)!=1)
					err("Can not write n2 to nfp");      
				if (fwrite(n3ur[iyhz]+ixhz,sizeof(float),1,nfp)!=1)
					err("Can not write n3 to nfp");*/
			}
		}

			/****************************************
			Using linear interpolate the normals:
			Four corners first; four edges second;
			interior last
			****************************************/
			n1hz[0][0]=n1ll[0][0];
			n2hz[0][0]=n2ll[0][0];
			n3hz[0][0]=n3ll[0][0];
			n1hz[0][nxhzc]=n1ur[0][nxhzc-1];
                        n2hz[0][nxhzc]=n2ur[0][nxhzc-1];
                        n3hz[0][nxhzc]=n3ur[0][nxhzc-1];
                        n1hz[nyhzc][0]=n1ll[nyhzc-1][0];
                        n2hz[nyhzc][0]=n2ll[nyhzc-1][0];
                        n3hz[nyhzc][0]=n3ll[nyhzc-1][0];
                        n1hz[nyhzc][nxhzc]=n1ur[nyhzc-1][nxhzc-1];
                        n2hz[nyhzc][nxhzc]=n2ur[nyhzc-1][nxhzc-1];
                        n3hz[nyhzc][nxhzc]=n3ur[nyhzc-1][nxhzc-1];
	
			for (ixhz=1;ixhz<nxhzc;ixhz++) {
				n1hz[0][ixhz]=n1ll[0][ixhz-1]
					+n1ur[0][ixhz-1]+n1ll[0][ixhz];
                                n2hz[0][ixhz]=n2ll[0][ixhz-1]
                                        +n2ur[0][ixhz-1]+n2ll[0][ixhz];       
                                n3hz[0][ixhz]=n3ll[0][ixhz-1]
                                        +n3ur[0][ixhz-1]+n1ll[0][ixhz];       

				n1hz[nyhzc][ixhz]=n1ur[nyhzc-1][ixhz-1]
                                        +n1ll[nyhzc-1][ixhz]+n1ur[nyhzc-1][ixhz]; 
                                n2hz[nyhzc][ixhz]=n2ur[nyhzc-1][ixhz-1]
                                        +n2ll[nyhzc-1][ixhz]+n2ur[nyhzc-1][ixhz];  
	                        n3hz[nyhzc][ixhz]=n3ur[nyhzc-1][ixhz-1]
                                        +n3ll[nyhzc-1][ixhz]+n3ur[nyhzc-1][ixhz];  
			}

			for (iyhz=1;iyhz<nyhzc;iyhz++) {
				n1hz[iyhz][0]=n1ll[iyhz-1][0]
                                        +n1ur[iyhz-1][0]+n1ll[iyhz][0];
                                n2hz[iyhz][0]=n2ll[iyhz-1][0]
                                        +n2ur[iyhz-1][0]+n2ll[iyhz][0];
                                n3hz[iyhz][0]=n3ll[iyhz-1][0]
                                        +n3ur[iyhz-1][0]+n3ll[iyhz][0];
                                n1hz[iyhz][nxhzc]=n1ur[iyhz-1][nxhzc-1]
                                        +n1ll[iyhz][nxhzc-1]+n1ur[iyhz][nxhzc-1];
                                n2hz[iyhz][nxhzc]=n2ur[iyhz-1][nxhzc-1]
                                        +n2ll[iyhz][nxhzc-1]+n2ur[iyhz][nxhzc-1];
                                n3hz[iyhz][nxhzc]=n3ur[iyhz-1][nxhzc-1]
                                        +n3ll[iyhz][nxhzc-1]+n3ur[iyhz][nxhzc-1];
			}
		
			for (iyhz=1;iyhz<nyhzc;iyhz++) {
				for (ixhz=1;ixhz<nxhzc;ixhz++) {
					n1hz[iyhz][ixhz]
						=n1ll[iyhz][ixhz-1]
						+n1ur[iyhz][ixhz-1]
						+n1ll[iyhz][ixhz]
						+n1ur[iyhz-1][ixhz]
						+n1ll[iyhz-1][ixhz]
						+n1ur[iyhz-1][ixhz-1];
					n2hz[iyhz][ixhz]
                                                =n2ll[iyhz][ixhz-1]
                                                +n2ur[iyhz][ixhz-1]
                                                +n2ll[iyhz][ixhz]
                                                +n2ur[iyhz-1][ixhz]
                                                +n2ll[iyhz-1][ixhz]
                                                +n2ur[iyhz-1][ixhz-1];
					n3hz[iyhz][ixhz]
                                                =n3ll[iyhz][ixhz-1]
                                                +n3ur[iyhz][ixhz-1]
                                                +n3ll[iyhz][ixhz]
                                                +n3ur[iyhz-1][ixhz]
                                                +n3ll[iyhz-1][ixhz]
                                                +n3ur[iyhz-1][ixhz-1];
				}
			}

			for (iyhz=1;iyhz<nyhz;iyhz++) 
                                for (ixhz=1;ixhz<nxhz;ixhz++) 
					tmb_normalize(&n1hz[iyhz][ixhz],
						  &n2hz[iyhz][ixhz],
						  &n3hz[iyhz][ixhz]);

			if (fwrite(n1hz[0],sizeof(float),nyhz*nxhz,nfp)!=nyhz*nxhz)
                                 err("Can not write n1 to nfp");
			if (fwrite(n2hz[0],sizeof(float),nyhz*nxhz,nfp)!=nyhz*nxhz)
                                 err("Can not write n2 to nfp");
			if (fwrite(n3hz[0],sizeof(float),nyhz*nxhz,nfp)!=nyhz*nxhz)
                                 err("Can not write n3 to nfp");
		}

		/***********************************************************
		output the gh to ghfile for wcrayt3d
		***********************************************************/
		if (ghfp!=(FILE *)NULL) {
			if (fwrite(ixgh[0],sizeof(int),nxgd*nygd,ghfp)!=nxgd*nygd)
				err("Can not write ixgh to ghfp");
			if (fwrite(iygh[0],sizeof(int),nxgd*nygd,ghfp)!=nxgd*nygd)
				err("Can not write iygh to ghfp");
		}
	}

	free2float(xhz);
	free2float(yhz);
	free2float(zhz);
	free2float(vhz);
	free2float(dvdzhz);

	for (ixgdc=0;ixgdc<nxgdc;ixgdc++) 
		for (iygdc=0;iygdc<nygdc;iygdc++) 
			for (izgdc=0;izgdc<nzgdc;izgdc++) 
				s3d[iygdc][ixgdc][izgdc]=
					1.0/s3d[iygdc][ixgdc][izgdc]/
					s3d[iygdc][ixgdc][izgdc];

	fwrite(s3d[0][0],sizeof(float),nxgdc*nygdc*nzgdc,stdout);
	fwrite(sx3d[0][0],sizeof(float),nxgdc*nygdc*nzgdc,stdout);
	fwrite(sy3d[0][0],sizeof(float),nxgdc*nygdc*nzgdc,stdout);
	fwrite(sz3d[0][0],sizeof(float),nxgdc*nygdc*nzgdc,stdout);

	fclose(hzfp);
	if (nfp!=NULL) fclose(nfp);
	if (ghfp!=NULL) fclose(ghfp);
	return EXIT_SUCCESS;
}

void xiygh(float fx,int nx,float dx,
	     float fy,int ny,float dy,
	     int nxhz,int nyhz,
	     float **xhz,float **yhz,int **ixgh,int **iygh)
/*****************************************************************
xiygh - map from a grid to a horizon
******************************************************************
Input:
float fx	first x value
int nx 		number of samples in x
float dx	x sampling interval
float fy	first y value
int ny		number of samples in y
float dy	y sampling interval
int nxhz	number of x samples on horizon
int nyhz	number of y samples on horizon
float **xhz	array of horizon x values
float **yhz	array of horizon y values

Output:
int **ixgh	array of indicies for the x horizon grid
int **iygh	array of indicies for the y horizon grid

******************************************************************
Notes:

The ixgh and iygh arrays represent the indicies of the corners of
the trapezoid below.


(ixhz,iyhz+1)              (ixhz+1,iyhz+1)
         _______(1)________
        /                  \
      (3)                  (4)
      /                      \
     /                        \
    /___________(2)____________\

(ixhz,iyhz)	               (ixhz+1,iyhz)	

To test if (ix,iy) is inside this cell, we need to test up to
four conditions.

For each grid point, this subroutine tests to see if the point
falls inside the trapezoid (really two triangles) and outputs the
array of indicies of the trapezoid. This is to speed up the
computation of the ray tracing.

******************************************************************
Author: CWP: Zhaobo Meng, Sept 1996
******************************************************************/
{
	int ix,iy;
	float x,y; 
	int ixhz,iyhz;
	float result;
	cwp_Bool flag=cwp_false;

	for (ix=0;ix<nx;ix++) {
		x=fx+ix*dx;
		for (iy=0;iy<ny;iy++) {
			y=fy+iy*dy;
			flag=cwp_false;
			for (ixhz=0;ixhz<nxhz-1;ixhz++) {
				for (iyhz=0;iyhz<nyhz-1;iyhz++) {
					/*test (1)*/
					result= y-yhz[iyhz+1][ixhz]-
						(x-xhz[iyhz+1][ixhz])/
						(xhz[iyhz+1][ixhz+1]-xhz[iyhz+1][ixhz])*
						(yhz[iyhz+1][ixhz+1]-yhz[iyhz+1][ixhz]);
					if (result>0.0) continue;

					/*test (2)*/
					result= y-yhz[iyhz][ixhz]-
						(x-xhz[iyhz][ixhz])/
						(xhz[iyhz][ixhz+1]-xhz[iyhz][ixhz])*
						(yhz[iyhz][ixhz+1]-yhz[iyhz][ixhz]);
					if (result<0.0) continue;

					/*test (3)*/
					result= x-xhz[iyhz][ixhz]-
						(y-yhz[iyhz][ixhz])/
						(yhz[iyhz+1][ixhz]-yhz[iyhz][ixhz])*
						(xhz[iyhz+1][ixhz]-xhz[iyhz][ixhz]);
					if (result<0.0) continue;

					/*test (4)*/
					result= x-xhz[iyhz][ixhz+1]-
						(y-yhz[iyhz][ixhz+1])/
						(yhz[iyhz+1][ixhz+1]-yhz[iyhz][ixhz+1])*
						(xhz[iyhz+1][ixhz+1]-xhz[iyhz][ixhz+1]);
					if (result<=0) {
						ixgh[iy][ix]=ixhz;
						iygh[iy][ix]=iyhz;
						flag=cwp_true;
					}
				if (flag==cwp_true) break;
				}
			if (flag==cwp_true) break;
			}
		}
	}
}

void tmb_normal(float x0,float x1,float x2,
	    float y0,float y1,float y2,
	    float z0,float z1,float z2,
	    float *n1,float *n2,float *n3)
/******************************************************************
tmb_normal - calculate the normal to the plane defined by the 
             triangle specified by its 3 vertex points.

******************************************************************
Notes:
3 points (x0,y0,z0), (x1,y1,z1) and (x2,y2,z2) can determine a 
plane. To determine the normal, we use two conditions: i.e. 
the normal must be perpendicular to the intersecting diagonals:

	  (x2,y2,z2)
	       /\
	      /  \
	     /    \
	    /      \
	   /________\
     (x0,y0,z0) (x1,y1,z1)

	(x1-x0)*n1 + (y1-y0)*n2 * (z1-z0)*n3 = 0
	(x2-x0)*n1 + (y2-y0)*n2 * (z2-z0)*n3 = 0 

then if we define
	c = (x1-x0)*(y2-y0)-(x2-x0)*(y1-y0);
	a = ((z0-z1)*(y2-y0)-(z0-z2)*(y1-y0))/c;
	b = ((x1-x0)*(z0-z2)-(x2-x0)*(z0-z1))/c;
then
	n3=1/sqrt(1+a*a+b*b)
	n1=a*n3
	n2=b*n3

*****************************************************************
Author: CWP: Zhaobo Meng, Sept 1996
******************************************************************/
{
	float a,b,c;
	c=(x1-x0)*(y2-y0)-(x2-x0)*(y1-y0);
	if (fabs(c)<SmallReal) err("bad triangle");
	a=((z0-z1)*(y2-y0)-(z0-z2)*(y1-y0))/c;
	b=((x1-x0)*(z0-z2)-(x2-x0)*(z0-z1))/c;
	*n3=1/sqrt(1+a*a+b*b);
	*n1=a*(*n3);
	*n2=b*(*n3);
}

void tmb_normalize(float *n1,float *n2,float *n3)
/*****************************************************************
tmb_normalize - normalize the vector whose components are (n1,n2,n3)
                to 1.

******************************************************************
Author: CWP: Zhaobo Meng, Sept 1996
******************************************************************/
{
	float norm;
	norm=*n1**n1+*n2**n2+*n3**n3;
	norm=sqrt(norm);	
	*n1=*n1/norm;
	*n2=*n2/norm;
	*n3=*n3/norm;
}
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/* TMB: $Revision: x.x $ ; $Date: 1996/09/02  $       */
a3 16
#define EPS 0.1
#define SmallReal 0.1e-10

/* enum Found {NOT_FOUND,FOUND}; */

void xiygh(float fx,int nx,float dx,
	float fy,int ny,float dy,
	int nxhz,int nyhz,
	float **xhz,float **yhz,int **ixgh,int **iygh);

void normal(float x0,float x1,float x2,
	float y0,float y1,float y2,
	float z0,float z1,float z2,
	float *n1,float *n2,float *n3);

void normalize(float *n1,float *n2,float *n3);
d102 17
a176 2
	float n1,n2,n3; /*normals to zhz*/

d195 5
a199 5
	char *xfile="        "; /*grid file for x0*/
	char *yfile="        ";	/*grid file for y0*/
	char *zfile="        ";	/*grid file for z0 (added to z)*/
	char *vfile="        ";	/*grid file for v0 (added to v)*/
	char *dvdzfile="        ";/*grid file for dvdz (added to dvdz)*/
a215 4
	float ***sxgh;	/*sloth gradient stored on horizons*/
	float ***sygh;	/*sloth gradient stored on horizons*/
	float ***szgh;	/*sloth gradient stored on horizons*/

d233 6
a355 4
	sxgh=ealloc3float(nxgdc,nygdc,nhz);
	sygh=ealloc3float(nxgdc,nygdc,nhz);
	szgh=ealloc3float(nxgdc,nygdc,nhz);

d726 1
a726 1
		 		normal( xhz[iyhz][ixhz],xhz[iyhz][ixhz+1],
d740 1
a740 1
				normal( xhz[iyhz][ixhz+1],xhz[iyhz+1][ixhz+1],
d834 1
a834 1
					normalize(&n1hz[iyhz][ixhz],
d885 47
d937 1
a937 17
	cwp_Bool flag;

	/*********************************************************

		(ixhz,iyhz+1)  (ixhz+1,iyhz+1)
		     _______(1)________
		    /                  \
		  (3)                  (4)
		  /                      \
		 /                        \
		/___________(2)____________\

	   (ixhz,iyhz)	       (ixhz+1,iyhz)	

	To test if (ix,iy) is inside this cell, we need to test up
	to four conditions.
	*********************************************************/	
d943 1
a943 1
			flag=false;
d975 1
a975 1
						flag=true;
d977 1
a977 1
				if (flag==true) break;
d979 1
a979 1
			if (flag==true) break;
d985 1
a985 1
void normal(float x0,float x1,float x2,
d989 33
a1023 26
	/******************************************************************
	3 points (x0,y0,z0), (x1,y1,z1) and (x2,y2,z2) can determine a 
	plane. To determine the normal, we use two conditions: i.e. 
	the normal must be perpendicular to the intersecting diagonals:

		  (x2,y2,z2)
		       /\
		      /  \
		     /    \
		    /      \
		   /________\
	     (x0,y0,z0) (x1,y1,z1)

		(x1-x0)*n1 + (y1-y0)*n2 * (z1-z0)*n3 = 0
		(x2-x0)*n1 + (y2-y0)*n2 * (z2-z0)*n3 = 0 

	then if we define
		c = (x1-x0)*(y2-y0)-(x2-x0)*(y1-y0);
		a = ((z0-z1)*(y2-y0)-(z0-z2)*(y1-y0))/c;
		b = ((x1-x0)*(z0-z2)-(x2-x0)*(z0-z1))/c;
	then
		n3=1/sqrt(1+a*a+b*b)
		n1=a*n3
		n2=b*n3
	******************************************************************/
		
d1033 8
a1040 1
void normalize(float *n1,float *n2,float *n3)
@
