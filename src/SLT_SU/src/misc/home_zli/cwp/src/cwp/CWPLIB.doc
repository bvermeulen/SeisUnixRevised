
cwp/lib:  	TABLE OF CONTENTS	(07/17/90)


 1. alloc   - package of routines that allocate and free arrays

 2. complex - package for complex number manipulation

 3. bm      - package to handle big matrices in virtual memory

 4. Prime Factor FFT routines
	a. npfa   - find next allowed fft size for pfacc
	b. npfao  - find optimal fft size for pfacc
	c. npfar  - find next allowed fft size for pfarc
	d. npfaro - find optimal fft size for pfarc
	e. pfacc  - prime factor complex-to-complex fft
	f. pfarc  - prime factor real-to-complex fft
	g. pfacr  - prime factor complex-to-real fft
	h. pfa2cc - 2d prime factor complex-to-complex fft
	i. pfa2rc - 2d prime factor real-to-complex fft
	j. pfa2cr - 2d prime factor complex-to-real fft
	k. pfamcc - multiple dimension prime factor complex-to-complex fft

 5. Interpolation routines
	 a. fsinc  - single precision sinc function
	 b. dsinc  - double precision sinc function
	 c. mksinc - compute least-squares optimal sinc coefficients
	 d. ints8r - uniformly-sampled real function by sinc
	 e. ints8c - uniformly-sampled complex function by sinc
	 f. intt8r - uniformly-sampled real function by table
	 g. intt8c - uniformly-sampled complex function by table
         h. ress8r - resample uniformly-sampled real function by sinc
         i. ress8c - resample uniformly-sampled complex function by sinc
         j. shfs8r - shift a uniformly-sampled real-valued function by sinc
	 k. xindex - determine index of x with respect to array of x values
	 l. intl2b - bilinear interpolation of a 2-D array of bytes
	 m. intlin - eval. y(x) by linear interp of y(x[0]), y(x[1]), ...
	 n. intcub - eval. y(x), y'(x), y''(x), ... by piecewise cubic interp
	 o. cakima - compute cubic interpolation coefficients by Akima's method
	 p. cmonot - compute cubic interpolation coefficients by Fritsch-Carlson
	 q. csplin - cubic spline interp coeffs with continuous 2nd derivatives
	 r. yxtoxy - compute x(y) from monotone increasing y(x)

 6. bf      - package of Butterworth filter routines

 7. Differentiator approximations
	a. mkdiff - discrete Taylor series approximation to n'th derivative
	b. mkhdiff - filter approximating the bandlimited half-differentiator

 8. General Signal Processing
	a. conv - compute z = x convolved with y
	b. xcor - compute z = x cross-correlated with y
	c. hilbert - compute Hilbert transform y of x
	d. antialias - anti-alias filter for use before sub-sampling

 9. Discrete Abel transform package

10. Discrete Hankel transform package

11. Sorting and Searching routines
	a. hpsort - sort an array so that a[0] <= a[1] <= ... <= a[n-1]
	b. qksort - sort functions based on Hoare's quicksort algorithm
	c. qkisort - index sort functions based on Hoare's quicksort algorithm

12. Statistical routines
	a. quest - return an estimate of a specified quantile 
	b. questinit - alloc,init,return pointer to state of quantile estimator 
	c. questupdate - update and return a quantile estimate 

13. Single precision BLAS (basic linear algebra subroutines)
	a. isamax - return index of element with maximum absolute value
	b. sasum - return sum of absolute values
	c. saxpy - compute y[i] = a*x[i]+y[i]
	d. scopy - copy x[i] to y[i] (i.e., set y[i] = x[i])
	e. sdot - return sum of x[i]*y[i] (i.e., dot product of x and y)
	f. snrm2 - return square root of sum of squares of x[i]
	g. sscal - compute x[i] = a*x[i]
	h. sswap - swap x[i] and y[i]

14. Double precision BLAS (basic linear algebra subroutines)
	a. idamax - return index of element with maximum absolute value
	b. dasum - return sum of absolute values
	c. daxpy - compute y[i] = a*x[i]+y[i]
	d. dcopy - copy x[i] to y[i] (i.e., set y[i] = x[i])
	e. ddot - return sum of x[i]*y[i] (i.e., dot product of x and y)
	f. dnrm2 - return square root of sum of squares of x[i]
	g. dscal - compute x[i] = a*x[i]
	h. dswap - swap x[i] and y[i]

15. Single precision LINPACK general matrix functions
	a. sgefa - LU factorization
	b. sgeco - LU factorization and condition number
	c. sgesl - Solve linear system Ax = b or A'x = b after LU factorization.

16. Double precision LINPACK general matrix functions
	a. dgefa - LU factorization
	b. dgeco - LU factorization and condition number
	c. dgesl - Solve linear system Ax = b or A'x = b after LU factorization.

17. Single precision LINPACK QR decomposition functions
	a. sqrdc - QR matrix decomposition
	b. sqrsl - Least squares solutions, etc. by QR
	c. sqrst - Under-determined or over-determined least squares

18. Other Linear System Solving routines
	a. stoepd - double precision symmetric Toeplitz linear systems
	b. stoepf - single precision symmetric Toeplitz linear systems
	c. vanded - double precision Vandermonde systems
	d. vandef - single precision Vandermonde systems
	e. tridif - single precision tridiagonal linear systems

19. Graphics Utility routines
	a. rfwtva - rasterize a float array as wiggle-trace-variable-area
	b. scaxis - compute a readable scale for use in plotting axes
	c. yclip  - clip a uniformly sampled function y(x)

20. Special Function routines
	a. airya - return approximation to the Airy function Ai(x)
	b. airyb - return approximation to the Airy function Bi(x)

21. Timing routines
	a. cpusec  - return cpu time (UNIX user time) in seconds
	b. wallsec - return elapsed time (wall clock time) in seconds
	c. cputime  - same as a using ANSI C built-ins
	d. walltime - same as b using ANSI C built-ins

22. Random Number Generating routines
	a. franuni - return a uniformly distributed random float
	b. sranuni - seed random number generator for uniform distribution
	c. frannor - return a normally distributed random float
	d. srannor - seed random number generator for normal distribution

23. Miscellaneous routines
	a. pp1d   - printer plot of a 1-dimensional array
	b. pplot1 - printer plot of a 1-dimensional array
	c. filestat  - determine type of file from file descriptor
 	d. printstat - print the filetype as a string
------------------------------------------------------------------------

1. alloc.c - package of routines that allocate and free arrays

Contents:

	alloc1, alloc2, alloc3, alloc4 - generic 1D,2D,3D,4D allocation
	free1,  free2,  free3,  free4  - ... their free routines

	alloc1int,     alloc2int,     alloc3int     - 1D,2D,3D int arrays
	alloc1float,   alloc2float,   alloc3float   - ... float arrays
	alloc1double,  alloc2double,  alloc3double  - ... double arrays
	alloc1complex, alloc2complex, alloc3complex - ... complex arrays

	free1int,     free2int,     free3int     - int alloc free routines
	free1float,   free2float,   free3float   - ... float
	free1double,  free2double,  free3double  - ... double
	free1complex, free2complex, free3complex - ... complex

	realloc1        - reallocation routine for alloc1
	realloc1int     - ... for alloc1int
	realloc1float   - ... for alloc1float
	realloc1double  - ... for alloc1double
	realloc1complex - ... for alloc1complex

Notes:
	These functions simplify manipulation of multi-dimensional arrays
	in C.  These functions are useful because true multi-dimensional
	arrays in C cannot have variable dimensions (as in FORTRAN).
	For example, the following function IS NOT valid in C:
		void badFunc(a,n1,n2)
		float a[n2][n1];
		{
			a[n2-1][n1-1] = 1.0;
		}
	However, the following function IS valid in C:
		void goodFunc(a,n1,n2)
		float **a;
		{
			a[n2-1][n1-1] = 1.0;
		}
	Therefore, the functions defined below do not allocate true
	multi-dimensional arrays, as described in the C specification.
	Instead, they allocate and initialize pointers (and pointers to 
	pointers) so that, for example, a[i2][i1] behaves like a 2-D array.

	The array dimensions are numbered, which makes it easy to add 
	functions for arrays of higher dimensions.  In particular,
	the 1st dimension of length n1 is always the fastest dimension,
	the 2nd dimension of length n2 is the next fastest dimension,
	and so on.  Note that the 1st (fastest) dimension n1 is the 
	first argument to the allocation functions defined below, but 
	that the 1st dimension is the last subscript in a[i2][i1].
	(This is another important difference between C and Fortran.)

	The allocation of pointers to pointers implies that more storage
	is required than is necessary to hold a true multi-dimensional array.
	The fraction of the total storage allocated that is used to hold 
	pointers is approximately 1/(n1+1).  This extra storage is unlikely
	to represent a significant waste for large n1.

	The functions defined below are significantly different from similar 
	functions described by Press et al, 1988, Numerical Recipes in C.
	In particular, the functions defined below:
		(1) Allocate arrays of arbitrary size elements.
		(2) Allocate contiguous storage for arrays.
		(3) Return NULL if allocation fails (just like malloc).
		(4) Do not provide arbitrary lower and upper bounds for arrays.

	Contiguous storage enables an allocated multi-dimensional array to
	be passed to a C function that expects a one-dimensional array.
	For example, to allocate and zero an n1 by n2 two-dimensional array
	of floats, one could use
		a = alloc2(n1,n2,sizeof(float));
		zeroFloatArray(n1*n2,a[0]);
	where zeroFloatArray is a function defined as
		void zeroFloatArray(int n, float *a)
		{
			int i;
			for (i=0; i<n; i++)
				a[i] = 0.0;
		}

	Internal error handling and arbitrary array bounds, if desired,
	should be implemented in functions that call the functions defined 
	below, with the understanding that these enhancements may limit 
	portability.  (See .../par/lib/ealloc.c for routines that gracefully
	abort if the allocation fails.)


Prototypes:

void *alloc1 (size_t n1, size_t size);
void *realloc1 (void *v, size_t n1, size_t size);
void **alloc2 (size_t n1, size_t n2, size_t size);
void ***alloc3 (size_t n1, size_t n2, size_t n3, size_t size);
void ****alloc4 (size_t n1, size_t n2, size_t n3, size_t n4, size_t size);
void free1 (void *p);
void free2 (void **p);
void free3 (void ***p);
void free4 (void ****p);
int *alloc1int (size_t n1);
int *realloc1int (int *v, size_t n1);
int **alloc2int (size_t n1, size_t n2);
int ***alloc3int (size_t n1, size_t n2, size_t n3);
float *alloc1float (size_t n1);
float *realloc1float (float *v, size_t n1);
float **alloc2float (size_t n1, size_t n2);
float ***alloc3float (size_t n1, size_t n2, size_t n3);
double *alloc1double (size_t n1);
double *realloc1double (double *v, size_t n1);
double **alloc2double (size_t n1, size_t n2);
double ***alloc3double (size_t n1, size_t n2, size_t n3);
complex *alloc1complex (size_t n1);
complex *realloc1complex (complex *v, size_t n1);
complex **alloc2complex (size_t n1, size_t n2);
complex ***alloc3complex (size_t n1, size_t n2, size_t n3);
void free1int (int *p);
void free2int (int **p);
void free3int (int ***p);
void free1float (float *p);
void free2float (float **p);
void free3float (float ***p);
void free1double (double *p);
void free2double (double **p);
void free3double (double ***p);
void free1complex (complex *p);
void free2complex (complex **p);
void free3complex (complex ***p);

------------------------------------------------------------------------
 2. complex.c - complex number manipulation

Contents:

	cadd  - add two complex numbers
	csub  - subtract two complex numbers
	cmul  - multiply two complex numbers
	cdiv  - divide two complex numbers
	cmplx - make a complex number from two real numbers
	conjg - complex conjugate of a complex number 
	cneg  - negate a complex number
	cinv  - invert a complex number
	csqrt - complex square root of a complex number
	cexp  - complex exponential of a complex number
	crmul - multiply a complex number by a real number 
	fcabs	real magnitude of a complex number

Notes:
	From Numerical Recipes in C, Press, et al. (cinv was added)

Prototypes:

complex cadd (complex a, complex b);
complex csub (complex a, complex b);
complex cmul (complex a, complex b);
complex cdiv (complex a, complex b);
float fcabs (complex z);
complex cmplx (float re, float im);
complex cneg (complex z);
complex cinv (complex z);
complex csqrt (complex z);
complex cexp (complex z);
complex crmul (complex a, float x);

------------------------------------------------------------------------
 3. bm.c - handle big matrices in virtual memory

Contents:

	bmalloc  allocate a big matrix
	bmfree   free a big matrix 
	bmread   read a vector from a big matrix
	bmwrite  write a vector to a big matrix

Notes:

	The bm functions provide access to a big 2-dimensional matrix
	along either the 1st or 2nd dimensions.  Although the matrix
	must be small enough to fit in virtual memory, it can be larger
	than available real memory.  These functions provide equally
	efficient (or equally inefficient) access to vectors in a big
	matrix along either the 1st or 2nd dimensions.

	For example, the following algorithm will efficiently transpose an
	n1 by n2 array of (n1*n2) floats stored in a file:

	bmstate *bm;
	float *v;
	bm = (bmstate*)bmalloc(sizeof(float),n1,n2);
	for (i2=0; i2<n2; i2++) {
		(read n1 floats from input file into array v);
		bmwrite(bm,1,0,i2,n1,(char*)v);
	}
	for (i1=0; i1<n1; i1++) {
		bmread(bm,2,i1,0,n1,(char*)v);
		(write n2 floats in array v to output file);
	}
	bmfree(bm);

Prototypes:

bmstate *bmalloc (int nbpe, int n1, int n2);
void bmfree (bmstate *state);
void bmread (bmstate *state, int dir, int k1, int k2, int n, void *v);
void bmwrite (bmstate *state, int dir, int k1, int k2, int n, void *v);

------------------------------------------------------------------------
4. Prime Factor FFT routines:

	a. npfa - find next allowed fft size for pfacc

Notes:
	npfa returns the smallest valid n not less than nmin for prime
	factor complex-to-complex fft.

	npfa will be composed of mutually prime factors from
	the set {2,3,4,5,7,8,9,11,13,16}.  Because npfa cannot exceed
	720720 = 5*7*9*11*13*16, npfa = 720720 is returned if nmin
	exceeds 720720.


Prototype and parameters:

int npfa (int nmin);
nmin	i lower bound on returned value

-----------------------------------------
	b. npfao  - find optimal fft size for pfacc

Notes:
	npfao returns the optimal n between nmin and nmax
	for prime factor complex-to-complex fft.

	npfao will be composed of mutually prime factors from the set
	{2,3,4,5,7,8,9,11,13,16}.  Because npfao cannot exceed
	720720 = 5*7*9*11*13*16, npfao = 720720 is returned if nmin
	exceeds 720720.  If nmin does not exceed 720720, then the
	returned npfao will not be less than nmin.  The optimal npfao
	is chosen to minimize the number of multiplications and
	additions, while satisfying the constraint, if possible, that
	npfao not exceed nmax.

Prototype and parameters:

int npfao (int nmin, int nmax);
nmin        i lower bound on returned value
nmax        i desired (but not guaranteed) upper bound on returned value

-----------------------------------------
	c. npfar  - find next allowed fft size for pfarc

Notes:
	npfar returns the smallest valid n not less than nmin for 
	real-to-complex or complex-to-real prime factor ffts

	Current implemenations of real-to-complex and complex-to-real
	prime factor ffts require that the transform length n be even
	and that n/2 be a valid length for a complex-to-complex prime
	factor fft.  The value returned by npfar satisfies these
	conditions.

	Also, see notes for npfa.

PARAMETERS:

int npfar (int nmin);
nmin        i lower bound on returned value

-----------------------------------------
	d. npfaro - find optimal fft size for pfarc
Notes:

	npfaro returns the optimal n between nmin and nmax for
	real-to-complex or complex-to-real prime factor ffts.

	Current implemenations of real-to-complex and complex-to-real
	prime factor ffts require that the transform length n be even
	and that n/2 be a valid length for a complex-to-complex prime
	factor fft.  The value returned by npfaro satisfies these
	conditions.

	Also, see notes for npfao.


Prototype and parameters:

int npfaro (int nmin, int nmax);
nmin        i lower bound on returned value
nmax        i desired (but not guaranteed) upper bound on returned value

-----------------------------------------
	e. pfacc  - prime factor complex-to-complex fft

Notes:
	pfacc is a complex-to-complex prime factor fft, in place.
 
	The fft size, n, must be factorable into mutually prime factors
	taken from the set {2,3,4,5,7,8,9,11,13,16}.  In other words,
		n = 2**p * 3**q * 5**r * 7**s * 11**t * 13**u
	where
		0 <= p <= 4,  0 <= q <= 2,  0 <= r,s,t,u <= 1
	is required for pfa to yield meaningful results.  This
	restriction implies that n is restricted to the range
	1 <= n <= 720720 (= 5*7*9*11*13*16).

References:
	Temperton, C., 1985, Implementation of a self-sorting in-place
	prime factor fft algorithm:  Journal of Computational Physics,
	v. 58, p. 283-299.

	Temperton, C., 1988, A new set of minimum-add rotated
	rotated dft modules: Journal of Computational Physics,
	v. 75, p. 190-198.

Prototype and parameters:

void pfacc (int isign, int n, complex z[]);
isign	i sign of isign is the sign of exponent in Fourier kernel
n	i length of transform
z	b array of complex numbers to be transformed in place

-----------------------------------------
	f. pfarc  - prime factor real-to-complex fft

Notes:
	pfarc is a prime factor real-to-complex fft.
 
	Because pfarc uses pfacc to do most of the work, n must be even
	and n/2 must be a valid length for pfacc.  The simplest way to
	obtain a valid n is via n = npfar(nmin).  A more optimal n can
	be obtained with npfaro.

References:  
	Press et al, 1988, Numerical Recipes in C, p. 417.

	Also, see notes and references for function pfacc.

Prototype and parameters:

void pfarc (int isign, int n, float rz[], complex cz[]);
isign       i sign of isign is the sign of exponent in Fourier kernel
n           i length of transform; must be even
rz          i array of n real values (may be equivalenced to cz)
cz          o array of n/2+1 complex values (may be equivalenced to rz)

-----------------------------------------
	g. pfacr  - prime factor complex-to-real fft

NOTES:
	pfacr is a complex-to-real prime factor fft.

	Because pfacr uses pfacc to do most of the work, n must be even
	and n/2 must be a valid length for pfacc.  The simplest way to
	obtain a valid n is via n = npfar(nmin).  A more optimal n can
	be obtained with npfaro.

References:  
	Press et al, 1988, Numerical Recipes in C, p. 417.

	Also, see notes and references for function pfacc.

Prototype and parameters:
void pfacr (int isign, int n, complex cz[], float rz[]);
isign       i sign of isign is the sign of exponent in Fourier kernel
n           i length of transform
cz          i array of n/2+1 complex values (may be equivalenced to rz)
rz          o array of n real values (may be equivalenced to cz)
 
-----------------------------------------
	h. pfa2cc - 2d prime factor complex-to-complex fft

Notes:
	pfa2cc does multiple 2-D complex to complex ffts, in place.

	Only one (either the 1st or 2nd) dimension of the 2-D array is
	transformed.

	If idim equals 1, then n2 transforms of n1 complex elements are
	performed; else, if idim equals 2, then n1 transforms of n2
	complex elements are performed.

	Although z appears in the argument list as a one-dimensional
	array, z may be viewed as an n1 by n2 two-dimensional array:
	z[n2][n1].

	Let n denote the transform length, either n1 or n2, depending
	on idim.  Then, n must be factorable into mutually prime
	factors taken from the set {2,3,4,5,7,8,9,11,13,16}, thus:
	    n = 2**p * 3**q * 5**r * 7**s * 11**t * 13**u
	where
	    0 <= p <= 4,  0 <= q <= 2,  0 <= r,s,t,u <= 1
	is required for pfa2cc to yield meaningful results.  This
	restriction implies that n is restricted to the range
	    1 <= n <= 720720 (= 5*7*9*11*13*16)

	To perform a two-dimensional transform of an n1 by n2 complex
	array (assuming that both n1 and n2 are valid "n"), stored with
	n1 fast and n2 slow:
		pfa2cc(isign,1,n1,n2,z);
		pfa2cc(isign,2,n1,n2,z);

References:  
	Temperton, C., 1985, Implementation of a self-sorting
	in-place prime factor fft algorithm:  Journal of
	Computational Physics, v. 58, p. 283-299.

	Temperton, C., 1988, A new set of minimum-add rotated
	rotated dft modules: Journal of Computational Physics,
	v. 75, p. 190-198.

Prototypes and parameters:

void pfa2cc (int isign, int idim, int n1, int n2, complex z[]);
isign       i sign of isign is the sign of exponent in Fourier kernel
idim        i dimension to transform, which must be either 1 or 2 (see notes)
n1          i 1st (fast) dimension of array to be transformed (see notes)
n2          i 2nd (slow) dimension of array to be transformed (see notes)
z           b array of complex elements to be transformed in place
 
-----------------------------------------
	i. pfa2rc - 2d prime factor real-to-complex fft

Notes:
	pfa2rc does multiple 2-D real-to-complex transforms.

 
	If idim equals 1, then n2 transforms of n1 real elements to
	n1/2+1 complex elements are performed; else, if idim equals 2,
	then n1 transforms of n2 real elements to n2/2+1 complex
	elements are performed.

	Although rz appears in the argument list as a one-dimensional
	array, rz may be viewed as an n1 by n2 two-dimensional array:
	rz[n2][n1].  Likewise, depending on idim, cz may be viewed as
	either an n1/2+1 by n2 or an n1 by n2/2+1 two-dimensional array
	of complex elements.

	Let n denote the transform length, either n1 or n2, depending
	on idim.  Because pfa2rc uses pfa2cc to do most of the work, n
	must be even and n/2 must be a valid length for pfa2cc.  The
	simplest way to obtain a valid n is via n = npfar(nmin).  A
	more optimal n can be obtained with npfaro.

References:
	Press et al, 1988, Numerical Recipes in C, p. 417.

	Also, see notes and references for function pfa2cc.


Prototypes and parameters:

void pfa2rc (int isign, int idim, int n1, int n2, float rz[], complex cz[]);
isign       i sign of isign is the sign of exponent in Fourier kernel
idim        i dimension to transform, which must be either 1 or 2 (see notes)
n1          i 1st (fast) dimension of array to be transformed (see notes)
n2          i 2nd (slow) dimension of array to be transformed (see notes)
rz          i array of real values (may be equivalenced to cz)
cz          o array of complex values (may be equivalenced to rz)

-----------------------------------------
	j. pfa2cr - 2d prime factor complex-to-real fft

Notes:
	pfa2cr does multiple complex-to-real prime factor ffts.  

	Because pfacr uses pfacc to do most of the work, n must be even
	and n/2 must be a valid length for pfacc.  The simplest way to
	obtain a valid n is via n = npfar(nmin).  A more optimal n can
	be obtained with npfaro.

References:  
	Press et al, 1988, Numerical Recipes in C, p. 417.

	Also, see notes and references for function pfacc.

Prototype and parameters:
void pfa2cr (int isign, int idim, int n1, int n2, complex cz[], float rz[]);
isign       i sign of isign is the sign of exponent in Fourier kernel
n           i length of transform (see notes below)
cz          i array of n/2+1 complex values (may be equivalenced to rz)
rz          o array of n real values (may be equivalenced to cz)

-----------------------------------------
	k. pfamcc - multiple dimension prime factor complex-to-complex fft

Notes:
	pfamcc does multiple complex to complex prime factor ffts, in place.

	n must be factorable into mutually prime factors taken 
	from the set {2,3,4,5,7,8,9,11,13,16}.  Thus:
	    n = 2**p * 3**q * 5**r * 7**s * 11**t * 13**u
	where
	    0 <= p <= 4,  0 <= q <= 2,  0 <= r,s,t,u <= 1
	is required for pfamcc to yield meaningful results.  This
	restriction implies that n is restricted to the range
	    1 <= n <= 720720 (= 5*7*9*11*13*16)

	To perform a two-dimensional transform of an n1 by n2 complex
	array (assuming that both n1 and n2 are valid "n"), stored with
	n1 fast and n2 slow:
	    pfamcc(isign,n1,n2,1,n1,z); (to transform 1st dimension)
	    pfamcc(isign,n2,n1,n1,1,z); (to transform 2nd dimension)
 
References:  
	Temperton, C., 1985, Implementation of a self-sorting
	in-place prime factor fft algorithm:  Journal of
	Computational Physics, v. 58, p. 283-299.

	Temperton, C., 1988, A new set of minimum-add rotated
	rotated dft modules: Journal of Computational Physics,
	v. 75, p. 190-198.

Prototype and parameters:
void pfamcc (int isign, int n, int nt, int k, int kt, complex z[]);
isign       i sign of isign is the sign of exponent in Fourier kernel
n           i number of complex elements per transform
nt          i number of transforms
k           i stride in complex elements within transforms
kt          i stride in complex elements between transforms
z           b array of complex elements to be transformed in place
 

------------------------------------------------------------------------
 5. Interpolation routines


  a. fsinc - single precision sinc function
  b. dsinc - double precision sinc function

float fsinc (float x);
double dsinc (double x);

-----------------------------------------
  c. mksinc - compute least-squares optimal sinc interpolation coefficients

Notes:

	The coefficients are a least-squares-best approximation to the
	ideal sinc function for frequencies from zero up to a computed
	maximum frequency.  For a given interpolator length, lsinc,
	mksinc computes the maximum frequency, fmax (expressed as a
	fraction of the nyquist frequency), using the following
	empirically derived relation (from a Western Geophysical
	Technical Memorandum by Ken Larner):

		fmax = min(0.066+0.265*log(lsinc),1.0)

	Note that fmax increases as lsinc increases, up to a maximum of
	1.0.  Use the coefficients to interpolate a uniformly-sampled
	function y(i) as follows:

		    lsinc-1
	    y(i+d) =  sum  sinc[j]*y(i+j+1-lsinc/2)
		      j=0

	Interpolation error is greatest for d=0.5, but for frequencies
	less than fmax, the error should be less than 1.0 percent.


Prototype and parameters:

void mksinc (float d, int lsinc, float sinc[]);
d		i fractional distance to interpolation point; 0.0<=d<=1.0
lsinc		i length of sinc approximation; lsinc%2==0 and lsinc<=20
sinc		o array containing lsinc interpolation coefficients

-----------------------------------------
  d. ints8r - interpolation of a uniformly-sampled real function y(x)
  e. ints8c - interpolation of a uniformly-sampled complex function y(x)


Notes:
	These routines use a table of 8-coefficient sinc approximations;
	maximum error for frequencies less than 0.6 nyquist is less than
	one percent.

	Because extrapolation of the input function y(x) is defined by
	the left and right values yinl and yinr, the xout values are not
	restricted to lie within the range of sample locations defined by
	nxin, dxin, and fxin.


Prototype and parameters:

void ints8r (int nxin, float dxin, float fxin, float yin[], 
	float yinl, float yinr, int nxout, float xout[], float yout[]);
void ints8c (int nxin, float dxin, float fxin, complex yin[], 
	complex yinl, complex yinr, int nxout, float xout[], complex yout[]);

nxin		i number of x values at which y(x) is input
dxin		i x sampling interval for input y(x)
fxin		i x value of first sample input
yin		i array of input y(x) values:  yin[0] = y(fxin), etc.
yinl		i value used to extrapolate yin values to left of yin[0]
yinr		i value used to extrapolate yin values to right of yin[nxin-1]
nxout		i number of x values a which y(x) is output
xout		i array of x values at which y(x) is output
yout		o array of output y(x) values:  yout[0] = y(xout[0]), etc.

-----------------------------------------
  f. intt8r - interpolation of a uniformly-sampled real function y(x)
  g. intt8c - interpolation of a uniformly-sampled complex function y(x)

Notes:

	These routines use a table of 8-coefficient interpolators.

	Because extrapolation of the input function y(x) is defined by
	the left and right values yinl and yinr, the xout values are
	not restricted to lie within the range of sample locations
	defined by nxin, dxin, and fxin.


Prototype and parameters:

void intt8r (int ntable, float table[][8],
	int nxin, float dxin, float fxin, float yin[], 
	float yinl, float yinr, int nxout, float xout[], float yout[]);
ntable		i number of tabulated interpolation operators; ntable>=2
table		i array of tabulated 8-point interpolation operators
nxin		i number of x values at which y(x) is input
dxin		i x sampling interval for input y(x)
fxin		i x value of first sample input
yin		i array of input y(x) values:  yin[0] = y(fxin), etc.
yinl		i value used to extrapolate yin values to left of yin[0]
yinr		i value used to extrapolate yin values to right of yin[nxin-1]
nxout		i number of x values a which y(x) is output
xout		i array of x values at which y(x) is output
yout		o array of output y(x) values:  yout[0] = y(xout[0]), etc.


Notes on parameters:

	ntable must not be less than 2.

	The table of interpolation operators must be as follows:

	Let d be the distance, expressed as a fraction of dxin, from a
	particular xout value to the sampled location xin just to the
	left of xout.  Then, for d = 0.0,

	table[0][0:7] = 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0

	are the weights applied to the 8 input samples nearest xout.
	Likewise, for d = 1.0,

	table[ntable-1][0:7] = 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0

	are the weights applied to the 8 input samples nearest xout.
	In general, for d = (float)itable/(float)(ntable-1),
	table[itable][0:7] are the weights applied to the 8 input
	samples nearest xout.  If the actual sample distance d does not
	exactly equal one of the values for which interpolators are
	tabulated, then the interpolator corresponding to the nearest
	value of d is used.

-----------------------------------------
    h. ress8r.c  - resample a uniformly-sampled real function y(x) by sinc
    i. ress8c.c  - resample a uniformly-sampled complex function y(x) by sinc

Notes:

	Resample a uniformly-sampled real function y(x) via 8-coefficient sinc
	approximations; maximum error for frequiencies less than 0.6 nyquist is 
	less than one percent.

	Because extrapolation of the input function y(x) is defined by the
	left and right values yinl and yinr, the output x values defined
	by nxout, dxout, and fxout are not restricted to lie within the range 
	of input x values defined by nxin, dxin, and fxin.


Prototypes and parameters:

void ress8r (int nxin, float dxin, float fxin, float yin[], 
	float yinl, float yinr, 
	int nxout, float dxout, float fxout, float yout[]);
void ress8c (int nxin, float dxin, float fxin, complex yin[], 
	complex yinl, complex yinr, 
	int nxout, float dxout, float fxout, complex yout[]);

nxin		i number of x values at which y(x) is input
dxin		i x sampling interval for input y(x)
fxin		i x value of first sample input
yin		i array of input y(x) values:  yin[0] = y(fxin), etc.
yinl		i value used to extrapolate yin values to left of yin[0]
yinr		i value used to extrapolate yin values to right of yin[nxin-1]
nxout		i number of x values at which y(x) is output
dxout		i x sampling interval for output y(x)
fxout		i x value of first sample output
yout		o array of output y(x) values:  yout[0] = y(xout[0]), etc.

-----------------------------------------
  j. shfs8r - shift a uniformly-sampled real-valued function by sinc

Notes:

	This routine shifts a uniformly-sampled real-valued function
	y(x) via a table of 8-coefficient sinc approximations; maximum
	error for frequencies less than 0.6*nyquist is less than one
	percent.

	Because extrapolation of the input function y(x) is defined by
	the left and right values yinl and yinr, the output samples
	defined by dx, nxout, and fxout are not restricted to lie
	within the range of input sample locations defined by dx, nxin,
	and fxin.


Prototype and parameters:

void shfs8r (float dx, int nxin, float fxin, float yin[], 
	float yinl, float yinr, int nxout, float fxout, float yout[]);

dx			i x sampling interval for both input and output y(x)
nxin		i number of x values at which y(x) is input
fxin		i x value of first sample input
yin			i array of input y(x) values:  yin[0] = y(fxin), etc.
yinl		i value used to extrapolate yin values to left of yin[0]
yinr		i value used to extrapolate yin values to right of yin[nxin-1]
nxout		i number of x values a which y(x) is output
fxout		i x value of first sample output
yout		o array of output y(x) values:  yout[0] = y(fxout), etc.

-----------------------------------------
   k. xindex - determine index of x with respect to an array of x values

Notes:

	This function is designed to be particularly efficient when
	called repeatedly for slightly changing x values; in such
	cases, the index returned from one call should be used in the
	next.

Prototype and parameters:
void xindex (int nx, float ax[], float x, int *index);

nx	i number of x values in array ax
ax	i array[nx] of monotonically increasing or decreasing x values
x	i the value for which index is to be determined
index	i index determined previously (used to begin search)

index	o for monotonically increasing ax values, the largest index
	  for which ax[index]<=x, except index=0 if ax[0]>x;
	  for monotonically decreasing ax values, the largest index
	  for which ax[index]>=x, except index=0 if ax[0]<x

-----------------------------------------
  l. intl2b - bilinear interpolation of a 2-D array of bytes

Notes:
	The arrays zin and zout must passed as pointers to the first
	element of a two-dimensional contiguous array of unsigned char
	values.

	Constant extrapolation of zin is used to compute zout for
	output x and y outside the range of input x and y.
 
	For efficiency, this function builds a table of interpolation
	coefficents pre-multiplied by byte values.  To keep the table
	reasonably small, the interpolation does not distinguish
	between x and y values that differ by less than dxin/ICMAX and
	dyin/ICMAX, respectively, where ICMAX is a parameter #defined
	in the code (now 100).


Prototype and parameters:

void intl2b(int nxin, float dxin, float fxin,
	int nyin, float dyin, float fyin, unsigned char *zin,
	int nxout, float dxout, float fxout,
	int nyout, float dyout, float fyout, unsigned char *zout);

nxin	i number of x samples input (fast dimension of zin)
dxin	i x sampling interval input
fxin	i first x sample input
nyin	i number of y samples input (slow dimension of zin)
dyin	i y sampling interval input
fyin	i first y sample input
zin	i array[nyin][nxin] of input samples (see notes)
nxout	i number of x samples output (fast dimension of zout)
dxout	i x sampling interval output
fxout	i first x sample output
nyout	i number of y samples output (slow dimension of zout)
dyout	i y sampling interval output
fyout	i first y sample output

zout	o array[nyout][nxout] of output samples (see notes)

-----------------------------------------
   m. intlin - evaluate y(x) via linear interpolation of y(x[0]), y(x[1]), ...

Notes:
	xin values must be monotonically increasing or decreasing.

	Extrapolation of the function y(x) for xout values outside the
	range spanned by the xin values is performed as follows:

	For monotonically increasing xin values,
		yout=yinl if xout<xin[0], and yout=yinr if xout>xin[nin-1].

	For monotonically decreasing xin values, 
		yout=yinl if xout>xin[0], and yout=yinr if xout<xin[nin-1].

	If nin==1, then the monotonically increasing case is used.


Prototype and parameters:

void intlin (int nin, float xin[], float yin[], float yinl, float yinr, 
	int nout, float xout[], float yout[]);

nin	i length of xin and yin arrays
xin	i array[nin] of monotonically increasing or decreasing x values
yin	i array[nin] of input y(x) values
yinl	i value used to extrapolate y(x) to left of input yin values
yinr	i value used to extrapolate y(x) to right of input yin values
nout	i length of xout and yout arrays
xout	i array[nout] of x values at which to evaluate y(x)

yout	o array[nout] of linearly interpolated y(x) values

-----------------------------------------
   n. intcub - eval. y(x), y'(x), y''(x), ... via piecewise cubic interpolation

Notes:

	xin values must be monotonically increasing or decreasing.

	Extrapolation of the function y(x) for xout values outside the
	range spanned by the xin values is performed using the
	derivatives in ydin[0][0:3] or ydin[nin-1][0:3], depending on
	whether xout is closest to xin[0] or xin[nin-1], respectively.


Prototype and parameters:

void intcub (int ideriv, int nin, float xin[], float ydin[][4], 
	int nout, float xout[], float yout[]);

ideriv	i =0 if y(x) desired; =1 if y'(x) desired, ...
nin	i length of xin and ydin arrays; nin>=2 is required
xin	i array[nin] of monotonically increasing or decreasing x values
ydin	i array[nin][4] of y(x), y'(x), y''(x), and y'''(x)
nout	i length of xout and yout arrays
xout	i array[nout] of x values at which to evaluate y(x), y'(x), ...

yout	o array[nout] of y(x), y'(x), ... values

-----------------------------------------
   o. cakima - compute cubic interpolation coefficients via Akima's method

Notes:

	The computed cubic spline coefficients are as follows:
	yd[i][0] = y(x[i])    (the value of y at x = x[i])
	yd[i][1] = y'(x[i])   (the 1st derivative of y at x = x[i])
	yd[i][2] = y''(x[i])  (the 2nd derivative of y at x = x[i])
	yd[i][3] = y'''(x[i]) (the 3rd derivative of y at x = x[i])

	To evaluate y(x) for x between x[i] and x[i+1] and h = x-x[i],
	use the computed coefficients as follows:
	y(x) = yd[i][0]+h*(yd[i][1]+h*(yd[i][2]/2.0+h*yd[i][3]/6.0))

	Akima's method provides continuous 1st derivatives, but 2nd and
	3rd derivatives are discontinuous.  Akima's method is not linear, 
	in that the interpolation of the sum of two functions is not the 
	same as the sum of the interpolations.

	For more information, see Akima, H., 1970, A new method for 
	interpolation and smooth curve fitting based on local procedures,
	Journal of the ACM, v. 17, n. 4, p. 589-602.


Prototype and parameters:

void cakima (int n, float x[], float y[], float yd[][4]);

n	i number of samples (n>=2 is required and assumed)
x  	i array of monotonically increasing or decreasing abscissae
y	i array of ordinates
yd	o array of cubic interpolation coefficients

-----------------------------------------
   p. cmonot - compute cubic interpolation coefficients by Fritsch-Carlson

Notes:
	The Fritsch-Carlson method preserves monotonicity.

	The computed cubic spline coefficients are as follows:
	yd[i][0] = y(x[i])    (the value of y at x = x[i])
	yd[i][1] = y'(x[i])   (the 1st derivative of y at x = x[i])
	yd[i][2] = y''(x[i])  (the 2nd derivative of y at x = x[i])
	yd[i][3] = y'''(x[i]) (the 3rd derivative of y at x = x[i])

	To evaluate y(x) for x between x[i] and x[i+1] and h = x-x[i],
	use the computed coefficients as follows:
	y(x) = yd[i][0]+h*(yd[i][1]+h*(yd[i][2]/2.0+h*yd[i][3]/6.0))

	The Fritsch-Carlson method yields continuous 1st derivatives,
	but 2nd and 3rd derivatives are discontinuous.  The method will
	yield a monotonic interpolant for monotonic data.  1st
	derivatives are set to zero wherever first divided differences
	change sign.

	For more information, see Fritsch, F. N., and Carlson, R. E., 1980, 
	Monotone piecewise cubic interpolation:  SIAM J. Numer. Anal., v. 17,
	n. 2, p. 238-246.

	Also, see the book by Kahaner, D., Moler, C., and Nash, S., 1989, 
	Numerical Methods and Software, Prentice Hall.  This function was 
	derived from SUBROUTINE PCHEZ contained on the diskette that comes 
	with the book.


Prototype and parameters:

void cmonot (int n, float x[], float y[], float yd[][4]);

n	i number of samples (n>=2 is required and assumed)
x  	i array[n] of monotonically increasing or decreasing abscissae
y	i array[n] of ordinates

yd	o array[n][4] of cubic interpolation coefficients (see notes)

-----------------------------------------
   q. csplin - cubic spline interpolation coeffs with continuous 2nd derivatives

Notes:
	The computed cubic spline coefficients are as follows:
	yd[i][0] = y(x[i])    (the value of y at x = x[i])
	yd[i][1] = y'(x[i])   (the 1st derivative of y at x = x[i])
	yd[i][2] = y''(x[i])  (the 2nd derivative of y at x = x[i])
	yd[i][3] = y'''(x[i]) (the 3rd derivative of y at x = x[i])

	To evaluate y(x) for x between x[i] and x[i+1] and h = x-x[i],
	use the computed coefficients as follows:
	y(x) = yd[i][0]+h*(yd[i][1]+h*(yd[i][2]/2.0+h*yd[i][3]/6.0))

Prototype and parameters:

void csplin (int n, float x[], float y[], float yd[][4]);

n	i number of samples (n>=2 is required and assumed)
x  	i array[n] of monotonically increasing or decreasing abscissae
y	i array[n] of ordinates

yd	o array[n][4] of cubic interpolation coefficients (see notes)

-----------------------------------------
   r. yxtoxy - compute x(y) from monotone increasing y(x)

Notes:

	This routine computes a regularly-sampled, monotonically
	increasing function x(y) from a regularly-sampled,
	monotonically increasing function y(x) by inverse linear
	interpolation.

	User must ensure that:
	(1) dx>0.0 && dy>0.0
	(2) y[0] < y[1] < ... < y[nx-1]


Prototype and parameters:

void yxtoxy (int nx, float dx, float fx, float y[], 
	int ny, float dy, float fy, float xylo, float xyhi, float x[]);

nx	i number of samples of y(x)
dx	i x sampling interval; dx>0.0 is required
fx	i first x
y	i array of y(x) values; y[0] < y[1] < ... < y[nx-1] required
ny	i number of samples of x(y)
dy	i y sampling interval; dy>0.0 is required
fy	i first y
xylo	i x value assigned to x(y) when y is less than smallest y(x)
xyhi	i x value assigned to x(y) when y is greater than largest y(x)
x	o array of x(y) values


------------------------------------------------------------------------
6. bf      - package of Butterworth filter routines

Contents:

	bfdesign	design a Butterworth filter
	bfhighpass	apply a high-pass Butterworth filter 
	bflowpass	apply a low-pass Butterworth filter 

Prototypes:

void bfhighpass (int npoles, float f3db, int n, float p[], float q[]);
void bflowpass (int npoles, float f3db, int n, float p[], float q[]);
void bfdesign (float fpass, float apass, float fstop, float astop,
	int *npoles, float *f3db);

------------------------------------------------------------------------
 7. Differentiator approximations

	a. mkdiff - discrete Taylor series approximation to n'th derivative

Notes:
	The abscissae x of a smpled function f(x) can always be
	expressed as x = (j+a)*h, where j is an integer, a is a
	fraction, and h is the sampling interval.  To approximate the
	n'th order derivative fn(x) of the sampled function f(x) at x =
	(j+a)*h, use the m-l+1 coefficients in the output array d[] as
	follows:

	fn(x) = d[0]*f(j-l) + d[1]*f(j-l-1) +...+ d[m-l]*f(j-m)

	i.e., convolve the coefficients in d with the samples in f.

	m-l+1 (the number of coefficients) must not be greater than the
	NCMAX parameter specified in the code.

	For best approximations,
	when n is even, use a = 0.0, l = -m
	when n is odd, use a = 0.5, l = -m-1


Prototype and parameters:

void mkdiff (int n, float a, float h, int l, int m, float d[]);
n	i order of desired derivative (n>=0 && n<=m-l)
a	i fractional distance from integer sampling index
h	i sampling interval
l	i sampling index of first coefficient
m	i sampling index of last coefficient
d	o array of coefficients for n'th order differentiator

-----------------------------------------
	b. mkhdiff - filter approximating the bandlimited half-differentiator

Notes:
	The half-differentiator is defined by

					  pi
	    d[l+j] = sqrt(1/h)/(2pi) * integral dw sqrt(-iw)*exp(-iwj)
		  			 -pi

                                  pi
           = sqrt(2/h)/(2pi) * integral dw sqrt(w)*(cos(wj)-sin(wj))
                                  0 

	for j = -l, -l+1, ... , l.

	An alternative definition is that f'(j) = d(j)*d(j)*f(j), where
	f'(j) denotes the derivative of a sampled function f(j) and *
	denotes a convolution sum.


	The half-derivative g(j) of f(j) may be computed by the
	following sum:

	g(j) = d[0]*f(j+l) + d[1]*f(j+l-1) + ... + d[2*l]*f(j-l)

	The integral over frequency is evaluated numerically using
	Simpson's method.  Although the Filon method of numerical
	integration is more appropriate for this integral, the
	truncation of d[l+j] for |j| > l is probably the greatest
	source of error.  In any case, d[l+j] is cosine-tapered to
	reduce these truncation errors.


Prototype and parameters:

void mkhdiff (float h, int l, float d[]);
h	i sampling interval
l	i half-length of half-differentiator (length = 1+2*l is odd)
d	o array of 1+2*l coefficients for half-differentiator

------------------------------------------------------------------------
 8. General Signal Processing

	a. conv - compute z = x convolved with y

Notes:

           ifx+lx-1
    z[i] =   sum    x[j]*y[i-j]  ;  i = ifz,...,ifz+lz-1
            j=ifx


Prototype and parameters:

void conv (int lx, int ifx, float x[], int ly, int ify, float y[],
	int lz, int ifz, float z[]);
lx	i length of x array
ifx	i sample index of first x
x	i array to be convolved with y
ly	i length of y array
ify	i sample index of first y
y	i array with which x is to be convolved
lz	i length of z array
ifz	i sample index of first z
z	o array containing x convolved with y

-----------------------------------------
	b. xcor - compute z = x cross-correlated with y

Notes:

           ifx+lx-1
    z[i] =   sum    x[j]*y[i+j]  ;  i = ifz,...,ifz+lz-1
            j=ifx


Prototype and parameters:

void xcor (int lx, int ifx, float x[], int ly, int ify, float y[],
	int lz, int ifz, float z[]);
lx	i length of x array
ifx	i sample index of first x
x	i array to be cross-correlated with y
ly	i length of y array
ify	i sample index of first y
y	i array with which x is to be cross-correlated
lz	i length of z array
ifz	i sample index of first z
z	o array containing x cross-correlated with y

-----------------------------------------
	c. hilbert - compute Hilbert transform y of x

Notes:
	The Hilbert transform is computed by convolving x with a
	windowed (approximate) version of the ideal Hilbert
	transformer.


Prototype and parameters:

void hilbert (int n, float x[], float y[]);
n			i length of x and y
x			i function to be Hilbert transformed
y			o Hilbert transform of x

-----------------------------------------
	d. antialias - Anti-alias filter for use before sub-sampling

Notes:
	The anti-alias filter is a recursive (Butterworth) filter.  For
	zero-phase anti-alias filtering, the recursive filter is
	applied forwards and backwards.


Prototype and parameters:

void antialias (float frac, int phase, int n, float p[], float q[]);
frac	i current sampling interval / future interval (should be <= 1)
phase	i =0 for zero-phase filter; =1 for minimum-phase filter
n	i number of samples
p	i array[n] of input samples
q	o array[n] of output (anti-alias filtered) samples		

------------------------------------------------------------------------
 9. Discrete Abel transform package

Contents:

	a. abelalloc - allocate and return a pointer to an Abel transformer
	b. abelfree  - free an Abel transformer
	c. abel	     - compute the Abel transform

Notes:
	The Abel transform is defined by:

			 Infinity
		g(y) = 2 Integral dx f(x)/sqrt(1-(y/x)^2)
			   |y|

	Linear interpolation is used to define the continuous function
	f(x) corresponding to the samples in f[].  The first sample
	f[0] corresponds to f(x=0) and the sampling interval is assumed
	to be 1.  Therefore, the input samples correspond to 0 <= x <=
	n-1.  Samples of f(x) for x > n-1 are assumed to be zero.
	These conventions imply that

		g[0] = f[0] + 2*f[1] + 2*f[2] + ... + 2*f[n-1]

References:

	Hansen, E. W., 1985, Fast Hankel transform algorithm:  IEEE
	Trans. on Acoustics, Speech and Signal Processing, v. ASSP-33,
	n. 3, p. 666-671.  (Beware of several errors in the equations
	in this paper!)


Prototypes:

void *abelalloc (int n);
void abelfree (void *at);
void abel (void *at, float f[], float g[]);

------------------------------------------------------------------------
10. Discrete Hankel transform package

Contents:

	a. hankelalloc - allocate and return a pointer to a Hankel transformer
	b. hankelfree  - free a Hankel transformer
	c. hankel0     - compute the zeroth-order Hankel transform
	d. hankel1     - compute the first-order Hankel transform

Notes:
	The zeroth-order Hankel transform is defined by:

			Infinity
		h0(k) = Integral dr r j0(k*r) f(r)
			   0

	where j0 denotes the zeroth-order Bessel function.

	The first-order Hankel transform is defined by:

			Infinity
		h1(k) = Integral dr r j1(k*r) f(r)
			   0

	where j1 denotes the first-order Bessel function.

	The Hankel transform is its own inverse.

	The Hankel transform is computed by an Abel transform followed
	by a Fourier transform.

References:
	Hansen, E. W., 1985, Fast Hankel transform algorithm:  IEEE
	Trans. on Acoustics, Speech and Signal Processing, v. ASSP-33,
	n. 3, p. 666-671.  (Beware of several errors in the equations
	in this paper!)

Prototypes:
	void *hankelalloc (int nfft);
	void hankelfree (void *ht);
	void hankel0 (void *ht, float f[], float h[]);
	void hankel1 (void *ht, float f[], float h[]);

------------------------------------------------------------------------
11. Sorting and Searching

	a. hpsort - sort an array so that a[0] <= a[1] <= ... <= a[n-1]

Notes:
	Adapted from Standish, T. A., Data Structure Techniques, p. 91.


Prototype and parameters:

void hpsort (int n, float a[]);
n	i number of elements in a
a	i array[n] to be sorted
a	o array[n] sorted

-----------------------------------------
	b. qksort - sort functions based on Hoare's quicksort algorithm

Contents:
	1. qksort - sort an array such that a[0] <= a[1] <= ... <= a[n-1]

	2. qkfind - partially sort an array so that the element a[m] has
		the value it would have if the entire array were sorted
		such that a[0] <= a[1] <= ... <= a[n-1]

Notes:
	This function is adapted from procedure partition by Hoare,
	C.A.R., 1961, Communications of the ACM, v. 4, p. 321.

Prototypes:
void qksort (int n, float a[]);
void qkfind (int m, int n, float a[]);

-----------------------------------------
	c. qkisort - index sort functions based on Hoare's quicksort algorithm

Contents:

	1. qkisort - sort an array of indices i[] so that 
		a[i[0]] <= a[i[1]] <= ... <= a[i[n-1]]

	2. qkifind - partially sort an array of indices i[] so that the 
		     index i[m] has the value it would have if the entire
		     array of indices were sorted such that 
		     a[i[0]] <= a[i[1]] <= ... <= a[i[n-1]]

Notes:
	This function is adapted from procedure partition by Hoare,
	C.A.R., 1961, Communications of the ACM, v. 4, p. 321.


Prototypes:

void qkisort (int n, float a[], int i[]);
void qkifind (int m, int n, float a[], int i[]);

------------------------------------------------------------------------
12. Statistics

	a. quest - return an estimate of a specified quantile 

Notes:
	The estimate should approach the sample quantile in the limit
	of large n.

	The estimate is most accurate for cumulative distribution
	functions that are smooth in the neighborhood of the quantile
	specified by p.

	This function is an implementation of the algorithm published
	by Jain, R. and Chlamtac, I., 1985, The PP algorithm for
	dynamic calculation of quantiles and histograms without storing
	observations:  Comm. ACM, v. 28, n. 10.


Prototype and parameters:

float quest (float p, int n, float x[]);
p	i quantile to be estimated (0.0<=p<=1.0 is required)
n	i number of samples in array x (n>=5 is required)
x	i array of floats

-----------------------------------------
	b. questinit - alloc,init,return pointer to state of quantile estimator 

Notes:
	This function must be called before calling function questUpdate.

	See also notes in questUpdate.

Prototype and parameters:

QuestState *questinit (float p, int n, float x[]);
p	i quantile to be estimated (0.0<=p<=1.0 is required)
n	i number of samples in array x (n>=5 is required)
x	i array of floats

-----------------------------------------
	b. questupdate - update and return a quantile estimate 

Notes:
	The estimate should approach the sample quantile in the limit
	of large n.

	The estimate is most accurate for cumulative distribution
	functions that are smooth in the neighborhood of the quantile
	specified by p.

	This function is an implementation of the algorithm published
	by Jain, R. and Chlamtac, I., 1985, The PP algorithm for
	dynamic calculation of quantiles and histograms without storing
	observations:  Comm. ACM, v. 28, n. 10.


Prototype and parameters:

float questupdate (QuestState *state, int n, float x[]);
s	i pointer to state of quantile estimator
n	i number of samples in array x
x	i array of floats

------------------------------------------------------------------------
13. Single precision BLAS (basic linear algebra subroutines)

Contents:
	a. isamax - return index of element with maximum absolute value
	b. sasum - return sum of absolute values
	c. saxpy - compute y[i] = a*x[i]+y[i]
	d. scopy - copy x[i] to y[i] (i.e., set y[i] = x[i])
	e. sdot - return sum of x[i]*y[i] (i.e., dot product of x and y)
	f. snrm2 - return square root of sum of squares of x[i]
	g. sscal - compute x[i] = a*x[i]
	h. sswap - swap x[i] and y[i]

Notes:
	Adapted from LINPACK FORTRAN.


Prototypes:

int isamax (int n, float *sx, int incx);
float sasum (int n, float *sx, int incx);
void saxpy (int n, float sa, float *sx, int incx, float *sy, int incy);
void scopy (int n, float *sx, int incx, float *sy, int incy);
float sdot (int n, float *sx, int incx, float *sy, int incy);
float snrm2 (int n, float *sx, int incx);
void sscal (int n, float sa, float *sx, int incx);
void sswap (int n, float *sx, int incx, float *sy, int incy);

------------------------------------------------------------------------
14. Double precision BLAS (basic linear algebra subroutines)

Contents:
	a. idamax - return index of element with maximum absolute value
	b. dasum - return sum of absolute values
	c. daxpy - compute y[i] = a*x[i]+y[i]
	d. dcopy - copy x[i] to y[i] (i.e., set y[i] = x[i])
	e. ddot - return sum of x[i]*y[i] (i.e., dot product of x and y)
	f. dnrm2 - return square root of sum of squares of x[i]
	g. dscal - compute x[i] = a*x[i]
	h. dswap - swap x[i] and y[i]

Notes:
	Adapted from LINPACK FORTRAN.


Prototypes:

int idamax (int n, double *sx, int incx);
double dasum (int n, double *sx, int incx);
void daxpy (int n, double sa, double *sx, int incx, double *sy, int incy);
void dcopy (int n, double *sx, int incx, double *sy, int incy);
double ddot (int n, double *sx, int incx, double *sy, int incy);
double dnrm2 (int n, double *sx, int incx);
void dscal (int n, double sa, double *sx, int incx);
void dswap (int n, double *sx, int incx, double *sy, int incy);

------------------------------------------------------------------------
15. Single precision LINPACK general matrix functions

Contents:
	a. sgefa - LU factorization
	b. sgeco - LU factorization and condition number
	c. sgesl - Solve linear system Ax = b or A'x = b after LU factorization.


Prototypes:

void sgeco (float **a, int n, int *ipvt, float *rcond, float *z);
void sgefa (float **a, int n, int *ipvt, int *info);
void sgesl (float **a, int n, int *ipvt, float *b, int job);

------------------------------------------------------------------------
16. Double precision LINPACK general matrix functions

Contents:
	a. dgefa - LU factorization
	b. dgeco - LU factorization and condition number
	c. dgesl - Solve linear system Ax = b or A'x = b after LU factorization.


Prototypes:

void dgeco (double **a, int n, int *ipvt, double *rcond, double *z);
void dgefa (double **a, int n, int *ipvt, int *info);
void dgesl (double **a, int n, int *ipvt, double *b, int job);

------------------------------------------------------------------------
17. Single precision LINPACK QR decomposition functions

Contents:
	a. sqrdc - QR matrix decomposition

	b. sqrsl - Use QR decomposition to solve for coordinate transformations,
		projections, and least squares solutions.

	c. sqrst - Solve under-determined or over-determined least squares
		problems, with a user-specified tolerance.


Prototypes:

void sqrdc (float **x, int n, int p, float *qraux, int *jpvt,
	float *work, int job);
void sqrsl (float **x, int n, int k, float *qraux,
	float *y, float *qy, float *qty,
	float *b, float *rsd, float *xb, int job, int *info);
void sqrst (float **x, int n, int p, float *y, float tol,
	float *b, float *rsd, int *k,
	int *jpvt, float *qraux, float *work);

------------------------------------------------------------------------
18. Other Linear System Solving routines

	a. stoepf - symmetric Toeplitz linear system of equations Rf=g
		for f (single precision)

Notes:
	This routine does NOT solve the case when the main diagonal is
	zero, it just silently returns.


Prototype and parameters:

void stoepd (int n, double r[], double g[], double f[], double a[]);
n	i dimension of system
r	i array of top row of Toeplitz matrix
g	i array of right-hand-side column vector
f	o array of solution (left-hand-side) column vector
a	o array of solution to Ra=v (spiking decon filter)

-----------------------------------------
	b. stoepd - symmetric Toeplitz linear system of equations Rf=g
		for f (double precision)

Notes:
	This routine does NOT solve the case when the main diagonal is
	zero, it just silently returns.


Prototype and parameters:

void stoepf (int n, double r[], double g[], double f[], double a[]);
n	i dimension of system
r	i array of top row of Toeplitz matrix
g	i array of right-hand-side column vector
f	o array of solution (left-hand-side) column vector
a	o array of solution to Ra=v (spiking decon filter)

-----------------------------------------
	c. vanded - solve Vandermonde system of equations Vx=b (double version)

Notes:
	The arrays b and x may be equivalenced.

	Adapted from Algorithm 5.6-2 in Golub, G. H., and Van Loan, C.  F.,
	1983, Matrix Computations, John-Hopkins University Press.


Prototype and parameters:

void vanded (int n, double v[], double b[], double x[]);
n	i dimension of system
v	i array of 2nd row of Vandermonde matrix (1st row is all ones)
b	i array of right-hand-side column vector
x	o array of solution column vector

-----------------------------------------
	d. vandef - solve Vandermonde system of equations Vx=b (single version)

Notes:
	The arrays b and x may be equivalenced.

	Adapted from Algorithm 5.6-2 in Golub, G. H., and Van Loan, C.  F.,
	1983, Matrix Computations, John-Hopkins University Press.


Prototype and parameters:

void vanded (int n, double v[], double b[], double x[]);
n	i dimension of system
v	i array of 2nd row of Vandermonde matrix (1st row is all ones)
b	i array of right-hand-side column vector
x	o array of solution column vector

-----------------------------------------
	e. tridif - solve a tridiagonal linear system of equations Tu=r
		(single version)

Notes:
	For example, a tridiagonal system of dimension 4 is specified as:

	    |b[0]    c[0]     0       0  | |u[0]|     |r[0]|
	    |a[1]    b[1]    c[1]     0  | |u[1]|  =  |r[1]|
	    | 0      a[2]    b[2]    c[2]| |u[2]|     |r[2]|
	    | 0       0      a[3]    b[3]| |u[3]|     |r[3]|

	The tridiagonal matrix is assumed to be non-singular.


Prototype and parameters:

void tridif (int n, float a[], float b[], float c[], float r[], float u[]);
n	i dimension of system
a	i coefficients of lower sub-diagonal of T (a[0] ignored)
b	i coefficients of diagonal of T
c	i coefficients of upper super-diagonal of T (c[n-1] ignored)
r	i array of right-hand-side column vector
u	o array of solution (left-hand-side) column vector

------------------------------------------------------------------------
19. Graphics Utility routines

	a. rfwtva - rasterize a float array as wiggle-trace-variable-area


Notes:
	The raster coordinate of the (top,left) bit in the image is
	(0,0).  In other words, x increases downward and y increases to
	the right.  Raster scan lines run from left to right, and from
	top to bottom.  Therefore, xfirst, xlast, yzmin, and yzmax
	should not be less than 0.  Likewise, yzmin and yzmax should
	not be greater than nbpr*8-1, and care should be taken to
	ensure that xfirst and xlast do not cause bits to be set
	outside (off the bottom) of the image.

	Variable area fill is performed on the right-hand (increasing
	y) side of the wiggle.  If yzmin is greater than yzmax, then z
	values between zmin will be plotted to the right of zmax, and z
	values between zbase and zmin are filled.  Swapping yzmin and
	yzmax is an easy way to reverse the polarity of a wiggle.


Prototype and parameters:

void rfwtva (int n, float z[], float zmin, float zmax, float zbase,
		int yzmin, int yzmax, int xfirst, int xlast,
		int wiggle, int nbpr, unsigned char *bits);
n	i number of samples in array to rasterize
z	i array to rasterize
zmin	i z values below zmin will be clipped
zmax	i z values above zmax will be clipped
zbase	i z values between zbase and zmax will be filled (see notes)
yzmin	i horizontal raster coordinate corresponding to zmin
yzmax	i horizontal raster coordinate corresponding to zmax
xfirst	i vertical raster coordinate of z[0] (see notes)
xlast	i vertical raster coordinate of z[n-1] (see notes)
wiggle	i =0 for no wiggle (VA only); =1 for wiggle (with VA)
nbpr	i number of bytes per row of bits
bits	b pointer to first (top,left) byte in image

-----------------------------------------
	b. scaxis - compute a readable scale for use in plotting axes

Notes:
	scaxis attempts to honor the user-specified nxnum.  However,
	nxnum will be modified if necessary for readability.  Also,
	fxnum and nxnum will be adjusted to compensate for roundoff
	error; in particular, fxnum will not be less than xmin-eps, and
	fxnum+(nxnum-1)*dxnum will not be greater than xmax+eps, where
	eps = 0.0001*(xmax-xmin).  xmin is the minimum of x1 and x2.
	xmax is the maximum of x1 and x2.


Prototype and parameters:

void scaxis (float x1, float x2, int *nxnum, float *dxnum, float *fxnum)
x1	i first x value
x2	i second x value
nxnum	i desired number of numbered values
nxnum	o number of numbered values
dxnum	o increment between numbered values (dxnum>0.0)
fxnum	o first numbered value

-----------------------------------------
	c. yclip - clip a uniformly sampled function y(x)

Notes:
	y(x) is defined by linear interpolation of the uniformly
	sampled values:  y(fx), y(fx+dx), ..., y(fx+(nx-1)*dx).

	Returns the number of samples in the clipped function.

	The output arrays xc and yc should contain space 2*nx values,
	which is the maximum possible number (nc) of xc and yc
	returned.

PARAMETERS:
int yclip (int nx, float dx, float fx, float y[], float ymin, float ymax,
		float xc[], float yc[]);
nc	f returned number of samples in output arrays xc and yc
nx	i number of x (and y) values
dx	i x sampling interval
fx	i first x
y	i array of uniformly sampled y(x) values
ymin	i minimum y value; must not be greater than ymax
ymax	i maximum y value; must not be less than ymin
xc	o array of x values for clipped y(x)
yc	o array of y values for clipped y(x)

------------------------------------------------------------------------
20. Special Function routines

	a. airya - return approximation to the Airy function Ai(x)

Notes:
	The approximation is derived from tables and formulas in
	Abramowitz and Stegun, p. 475-477.


Prototype and parameter:

float airya (float x);
x	i value at which to evaluate Ai(x)

-----------------------------------------
	b. airyb - return approximation to the Airy function Bi(x)

Notes:
	The approximation is derived from tables and formulas in
	Abramowitz and Stegun, p. 475-477.


Prototype and parameter:

float airyb (float x);
x	i value at which to evaluate Bi(x)

------------------------------------------------------------------------
21. Timing routines
	a. cpusec - return cpu time (UNIX user time) in seconds

Prototype:
float cpusec (void);

-----------------------------------------
	b. wallsec - return elapsed time (wall clock time) in seconds

Prototype:
float wallsec (void);

-----------------------------------------
	c. cputime - return cpu time (UNIX user time) in seconds using
		ANSI C built-ins

Prototype:
float cputime (void);

-----------------------------------------
	b. walltime - return elapsed time (wall clock time) in seconds using
		ANSI C built-ins

Notes:
	return value will be an integral number of seconds since t1 and t2,
	as returned by the time() intrinsic, are the number of seconds
	since the epoch


Prototype:
float walltime (void);

------------------------------------------------------------------------
22. Random Number Generating routines

	a. franuni - return a uniformly distributed random float
	b. sranuni - seed random number generator for uniform distribution

Notes:
	functions to generate a pseudo-random float uniformly
	distributed on [0,1)

	Adapted from subroutine uni in "Numerical Methods and
	Software", D. Kahaner, C. Moler, S. Nash, Prentice Hall, 1988.
	This book references, Marsaglia G., "Comments on the perfect
	uniform random number generator", Unpublished notes, Wash S. U.
	According to the reference, this random number generator
	"passes all known tests and has a period that is ...
	approximately 10^19".


Prototypes:

void sranuni (int seed);
float franuni (void);

-----------------------------------------
	c. frannor - return a normally distributed random float
	d. srannor - seed random number generator for normal distribution

Notes:
	functions to generate a pseudo-random float normally
	distributed with N(0,1); i.e., with zero mean and unit
	variance.

	Adapted from subroutine rnor in "Numerical Methods and
	Software", D.  Kahaner, C. Moler, S. Nash, Prentice Hall,
	1988.  Subroutine rnor, in turn, is adapted from a paper by
	Marsaglia G. and Tsang, W. W., 1984, A fast, easily implemented
	method for sampling from decreasing or symmetric unimodal
	density functions:  SIAM J. Sci. Stat. Comput., v. 5, no. 2, p.
	349-359.


Prototypes:

float frannor (void);
void srannor (int seed);

------------------------------------------------------------------------
23. Miscellaneous routines

	a. pp1d - printer plot of a 1-dimensional array


Prototype and parameters:

void pp1d (FILE *fp, char *title, int lx, int ifx, float x[]);
fp	i file pointer for output (e.g., stdout, stderr, etc.)
title	i title of plot
lx	i length of x
ifx	i index of first x
x	i array to be plotted

-----------------------------------------
	b. pplot1 - printer plot of a 1-dimensional array

Prototype and parameters:

void pplot1 (FILE *fp, char *title, int nx, float ax[]);
fp	i file pointer for printed output (e.g., stdout, stderr, etc.)
title	i title of plot
nx	i number of x values to be plotted
ax	i array[nx] of x values

-----------------------------------------
	c. filestat  - determine type of file from file descriptor
 	d. printstat - print the filetype as a string

 Notes:
	filestat returns a defined type called filetype.

	filetype is defined in cwp.h as:

	typedef enum
		{BADFILETYPE = -1, TTY, DISK, DIRECTORY, TAPE, PIPE}
	filetype;

	BADFILETYPE is the error return and it is up to the calling
	program to check for it.

	string is defined in cwp.h as:

	 typedef char *string;


Prototypes:

filetype filestat(int fd);
string printstat(int fd);
