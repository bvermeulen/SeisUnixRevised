head	1.47;
access;
symbols;
locks
	john:1.47; strict;
comment	@ * @;


1.47
date	2014.12.04.23.10.17;	author john;	state Exp;
branches;
next	1.46;

1.46
date	2014.12.04.17.37.23;	author john;	state Exp;
branches;
next	1.45;

1.45
date	2011.11.16.17.47.47;	author john;	state Exp;
branches;
next	1.44;

1.44
date	2011.11.12.00.07.16;	author john;	state Exp;
branches;
next	1.43;

1.43
date	2011.09.09.22.30.20;	author john;	state Exp;
branches;
next	1.42;

1.42
date	2009.12.09.18.32.28;	author john;	state Exp;
branches;
next	1.41;

1.41
date	2006.11.07.22.58.42;	author john;	state Exp;
branches;
next	1.40;

1.40
date	2006.10.31.22.17.58;	author john;	state Exp;
branches;
next	1.39;

1.39
date	2006.07.26.17.56.45;	author john;	state Exp;
branches;
next	1.38;

1.38
date	2006.01.10.20.03.22;	author john;	state Exp;
branches;
next	1.37;

1.37
date	2005.10.04.16.42.43;	author john;	state Exp;
branches;
next	1.36;

1.36
date	2005.03.03.21.38.17;	author john;	state Exp;
branches;
next	1.35;

1.35
date	2003.06.09.16.17.07;	author john;	state Exp;
branches;
next	1.34;

1.34
date	99.04.29.14.00.59;	author john;	state Exp;
branches;
next	1.33;

1.33
date	98.04.14.18.48.35;	author john;	state Exp;
branches;
next	1.32;

1.32
date	98.04.03.23.00.22;	author john;	state Exp;
branches;
next	1.31;

1.31
date	96.09.13.21.49.05;	author john;	state Exp;
branches;
next	1.30;

1.30
date	96.02.05.16.15.40;	author jkc;	state Exp;
branches;
next	1.29;

1.29
date	95.08.02.21.04.10;	author jkc;	state Exp;
branches;
next	1.28;

1.28
date	94.08.25.15.00.24;	author jkc;	state Exp;
branches;
next	1.27;

1.27
date	93.11.24.15.55.48;	author john;	state Exp;
branches;
next	1.26;

1.26
date	92.10.26.11.09.31;	author john;	state Exp;
branches;
next	1.25;

1.25
date	91.09.05.08.51.31;	author jkcohen;	state Exp;
branches;
next	1.24;

1.24
date	91.07.02.15.58.20;	author jkcohen;	state Exp;
branches;
next	1.23;

1.23
date	91.03.14.22.29.33;	author jkc;	state Exp;
branches;
next	1.22;

1.22
date	91.03.14.22.27.12;	author jkc;	state Exp;
branches;
next	1.21;

1.21
date	90.12.17.17.54.06;	author jkc;	state Exp;
branches;
next	1.20;

1.20
date	90.11.30.16.13.53;	author jkc;	state Exp;
branches;
next	1.19;

1.19
date	90.11.15.10.43.36;	author jkc;	state Exp;
branches;
next	1.18;

1.18
date	90.11.06.15.03.07;	author dhale;	state Exp;
branches;
next	1.17;

1.17
date	90.07.22.20.55.40;	author jkc;	state Exp;
branches;
next	1.16;

1.16
date	90.07.22.16.18.26;	author jkc;	state Exp;
branches;
next	1.15;

1.15
date	90.07.14.17.13.41;	author jkc;	state Exp;
branches;
next	1.14;

1.14
date	90.07.12.15.37.36;	author jkc;	state Exp;
branches;
next	1.13;

1.13
date	90.07.12.14.48.53;	author jkc;	state Exp;
branches;
next	1.12;

1.12
date	90.07.12.14.30.57;	author jkc;	state Exp;
branches;
next	1.11;

1.11
date	90.07.12.14.18.20;	author jkc;	state Exp;
branches;
next	1.10;

1.10
date	90.07.12.13.39.19;	author jkc;	state Exp;
branches;
next	1.9;

1.9
date	90.07.11.18.58.54;	author jkc;	state Exp;
branches;
next	1.8;

1.8
date	90.07.11.15.00.33;	author jkc;	state Exp;
branches;
next	1.7;

1.7
date	90.07.11.08.49.39;	author jkc;	state Exp;
branches;
next	1.6;

1.6
date	90.07.10.22.59.42;	author jkc;	state Exp;
branches;
next	1.5;

1.5
date	90.07.10.22.33.43;	author jkc;	state Exp;
branches;
next	1.4;

1.4
date	90.07.10.17.09.51;	author jkc;	state Exp;
branches;
next	1.3;

1.3
date	90.07.09.22.46.30;	author jkc;	state Exp;
branches;
next	1.2;

1.2
date	90.07.07.16.47.29;	author jkc;	state Exp;
branches;
next	1.1;

1.1
date	90.07.07.14.58.07;	author jkc;	state Exp;
branches;
next	;


desc
@Predictive error filtering (deconvolution).
@


1.47
log
@selfdoc update
@
text
@/* Copyright (c) Colorado School of Mines, 2011.*/
/* All rights reserved.                       */

/* SUPEF: $Revision: 1.46 $ ; $Date: 2014/12/04 17:37:23 $		*/

#include "su.h"
#include "segy.h"
#include "header.h"

/*********************** self documentation ******************************/
char *sdoc[] = {
" 									",
" SUPEF - Wiener (least squares) predictive error filtering		",
" 									",
" supef <stdin >stdout  [optional parameters]				",
" 									",
" Required parameters:							",
" dt is mandatory if not set in header			 		",
" 									",
" Optional parameters:							",
" cdp= 			CDPs for which minlag, maxlag, pnoise, mincorr, ",
"			maxcorr are set	(see Notes)			",
" minlag=dt		first lag of prediction filter (sec)		",
" maxlag=last		lag default is (tmax-tmin)/20			",
" pnoise=0.001		relative additive noise level			",
" mincorr=tmin		start of autocorrelation window (sec)		",
" maxcorr=tmax		end of autocorrelation window (sec)		",
" wienerout=0		=1 to show Wiener filter on each trace		",
" mix=1,...	 	array of weights (floats) for moving		",
"				average of the autocorrelations		",
" outpar=/dev/null	output parameter file, contains the Wiener filter",
" 			if wienerout=1 is set				",
" method=linear	 for linear interpolation of cdp values			",
"		       =mono for monotonic cubic interpolation of cdps	",
"		       =akima for Akima's cubic interpolation of cdps	",
"		       =spline for cubic spline interpolation of cdps	",
" 									",
" Trace header fields accessed: ns, dt					",
" Trace header fields modified: none					",
" 									",
" Notes:								",
" 									",
" 1) To apply spiking decon (Wiener filtering with no gap):		",
"									",
" Run the following command						",
"									",
"    suacor < data.su | suximage perc=95				",
"									",
" You will see horizontal strip running across the center of your plot.	",
" This is the autocorrelation wavelet for each trace. The idea of spiking",
" decon is to apply a Wiener filter with no gap to the data to collapse	",
" the waveform into a spike. The idea is to pick the width of the	",
" autocorrelation waveform _from beginning to end_ (not trough to trough)",
" and use this time for MAXLAG_SPIKING:					",
"									",
"  supef < data.su maxlag=MAXLAG_SPIKING  > dataspiked.su		",
"									",
" 2) Prediction Error Filter (i.e. gapped Wiener filtering)		",
" The purpose of gapped decon is to suppress repetitions in the data	",
" such as those caused by water bottom multiples.			",
"									",
" To look for the period of the repetitions				",
" 									",
"    suacor ntout=1000 < dataspiked.su | suximage perc=95		",
" or 									",
"    suacor ntout=1000 < dataspiked.su | sustack key=dt |suxwigb	",
" 									",
" The value of ntout must be larger than the default 100. The idea is	",
" to look for repetitions in the autocorrelation. These repetitions will",
" appear as a family of parallel stripes above and below the main	",
" autocorrelation waveform. Or, if you stack the data, these will be	",
" repetitive spikes.  This repetition time is the GAP. We set 		",
" MINLAG_PEF to the value of this repetition time.			",
" 									",
" We set the minlag to MINLAG_PEF = GAP					",
"									",
" We set the maxlag to MAXLAG_PEF = GAP + MAXLAG_SPIKING		",
" 									",
"  supef < dataspiked.su minlag=MINLAG_PEF maxlag=MAXLAG_PEF > datapef.su",
" 									",
" Some experimentation may be required to get a satisfactory result.	",
" In particular you may find that you need to reduce the value of the   ",
" minlag 								",
" 									",
" 3) It may be effective to sort your data into cdp gathers with susort,",
" and perform sunmo correction to the water speed with sunmo, prior to 	",
" attempts to suppress water bottom multiples. After applying supef, the",
" user should apply inverse nmo to undo the nmo to water speed prior to	",
" further processing. Or, do the predictive decon on fully nmo-corrected",
" gathers.								",
"									",
" If you flatten your data with sunmo, then make sure that you turn off ",
" the stretch mute by using smute=20					",
"									",
"  | sunmo vnmo=v1,v2,... tnmo=t1,t2,... smute=20 | supef ...		",
"									",
" For a filter expressed as a function of cdp, specify the array	",
"     cdp=cdp1,cdp2,...							",
" and for each cdp specified, specify the minlag and maxlag arrays as	",
"      minlag=min1,min2,...     maxlag=max1,max2,...   			",
"  									",
" It is required that the number of minlag and maxlag values be equal to",
" the number of cdp's specified.  If the number of			",
" values in these arrays does not equal the number of cdp's, only the first",
" value will be used.							",
"									",
" Caveat:								",
" The wienerout=1 option writes out the wiener filter to outpar, and   ",
" the prediction error filter to stdout, which is			", 
"     1,0,0,...,-wiener[0],...,-wiener[imaxlag-1] 			",
" where the sample value of -wiener[0], is  iminlag in the pe-filter.	",
" The pe-filter is output as a SU format datafile, one pe-filter for each",
" trace input.								",
"	...| supef ... wienerout | suxwigb				",
" shows the prediction error filters					",
 NULL};

/* Credits:
 *	CWP: Shuki Ronen, Jack K. Cohen, Ken Larner
 *      CWP: John Stockwell, added mixing feature (April 1998)
 *      CSM: Tanya Slota (September 2005) added cdp feature
 *
 *      Technical Reference:
 *	A. Ziolkowski, "Deconvolution", for value of maxlag default:
 *		page 91: imaxlag < nt/10.  I took nt/20.
 *
 * Notes:
 *	The prediction error filter is 1,0,0...,0,-wiener[0], ...,
 *	so no point in explicitly forming it.
 *
 *	If imaxlag < 2*iminlag - 1, then we don't need to compute the
 *	autocorrelation for lags:
 *		imaxlag-iminlag+1, ..., iminlag-1
 *	It doesn't seem worth the duplicated code to implement this.
 *
 * Trace header fields accessed: ns
 */
/**************** end self doc *******************************************/


/* External definitions */
#define PNOISE	0.001			/* default pnoise value		*/
#define VAL0    1.0			/* default weighting value	*/
#define OUTPAR_DEFAULT "/dev/null"	/* default output filename	*/




segy intrace, outtrace;

int
main(int argc, char **argv)
{
	int nt;			/* number of points on trace		*/
	int i,ilag;		/* counters				*/
	int ncdp;		/* number of cdp's specified		*/
	int nminlag;		/* number of minlags specified		*/
	int nmaxlag;		/* number of maxlag specified		*/
	int icdp=0;		/* counter of cdp's			*/
	int jcdp=0;		/* counter of cdp's			*/

	float *cdp=NULL;	/* array[ncdp] of cdps specified 	*/
	float dt;		/* time sample interval (sec)		*/
	float *wiener=NULL;	/* Wiener error filter coefficients	*/
	float *spiker=NULL;	/* spiking decon filter			*/

	float pnoise;		/* pef additive noise level		*/

	float *minlag=NULL;	/* start of error filter (sec)		*/
	int *iminlag=NULL;	/* ... in samples			*/
	float *maxlag=NULL;	/* end of error filter (sec)		*/
	int *imaxlag=NULL;	/* ... in samples			*/
	int nlag;		/* length of error filter in samples	*/
	int ncorr;		/* length of corr window in samples	*/
	int lcorr;		/* length of autocorr in samples	*/

	long oldcdp;		/* cdp of previous trace */

	float *crosscorr=NULL;	/* right hand side of Wiener eqs	*/
	float *autocorr=NULL;	/* vector of autocorrelations		*/

	float mincorr;		/* start time of correlation window	*/
	int imincorr;		/* .. in samples			*/
	float maxcorr;		/* end time of correlation window	*/
	int imaxcorr;		/* .. in samples			*/
	int wienerout;		/* flag to display pred. error filter	*/
	
	size_t lagbytes;	/* bytes in wiener and spiker filters	*/
	size_t maxlagbytes;	/* bytes in autocorrelation		*/
	
	int imix;		/* mixing counter			*/
	int nmix;		/* number of traces to average over	*/
	size_t mixbytes;	/* number of bytes = maxlagbytes*nmix	*/ 
	float *mix=NULL;	/* array of averaging weights		*/
	float **mixacorr=NULL;	/* mixing array				*/
	float *temp=NULL;	/* temporary array			*/

	/* Interpolation */
	float (*zind)[4]=NULL;	/* array of interpolation coefficients  */
	char  *method="linear";	/* interpolation method			*/
	float *cdpinterp=NULL;	/* interpolated cdps			*/
	float *ominlag=NULL;	/* interpolated minlags			*/ 
	float *omaxlag=NULL;	/* interpolated maxlags			*/

        char *outpar=NULL;	/* name of file holding output parfile	*/
        FILE *outparfp=NULL;	/* ... its file pointer			*/


	/* Initialize */
	initargs(argc, argv);
	requestdoc(1);



	/* Get info from first trace */ 
	if (!gettr(&intrace)) err("can't get first trace");
	nt = intrace.ns;
	dt = ((double) intrace.dt)/1000000.0;
	if (!dt) MUSTGETPARFLOAT ("dt", &dt); 

	/* Get parameters and do set up */
	if (!getparstring("outpar", &outpar))	outpar = OUTPAR_DEFAULT;
	outparfp = efopen(outpar, "w");


	/* Count parameters and allocate space */
	ncdp = countparval("cdp");
	if (ncdp>0) {
		if ((nminlag = countparval("minlag"))!=0) {
			if (!(nminlag==ncdp)) 
			   err("number of cdp values must equal number of minlag values");
		} else {
			err("cdp set, but minlag not getparred!");
		}

		if ((nmaxlag = countparval("maxlag"))!=0) {
			if (!(nmaxlag==ncdp)) 
			   err("number of cdp values must equal number of maxlag values");
		} else {
			err("cdp set, but maxlag not getparred!");
		}

		/* allocate space */
		cdp = ealloc1float(ncdp);
		minlag = ealloc1float(ncdp);
		maxlag = ealloc1float(ncdp);
		
		/* get parameters */
		getparfloat("minlag",minlag);
		getparfloat("maxlag",maxlag);
		getparfloat("cdp",cdp);

		/* check cdp values */
		for (icdp = 0; icdp < ncdp-1; ++icdp)  {
			if(cdp[icdp] > cdp[icdp+1])
				err("cdp values must increase monotonically!");
		}


		iminlag = ealloc1int(ncdp);
		imaxlag = ealloc1int(ncdp);

		for (icdp = 0; icdp < ncdp; ++icdp) {
			iminlag[icdp] = NINT(minlag[icdp]/dt);	
			imaxlag[icdp] = NINT(maxlag[icdp]/dt);
			if (iminlag[icdp] < 1) 
				err("minlag[%d]=%g too small",
					icdp, minlag[icdp]);
			if (imaxlag[icdp] >= nt)
				err("maxlag[%d]=%g too large",
					icdp, maxlag[icdp]);
			if (iminlag >= imaxlag)
				err("minlag[%d]=%g, maxlag[%d]=%g",
					icdp, minlag[icdp], icdp, maxlag[icdp]);
		}

	} else {
		ncdp = 1;
		cdp = ealloc1float(ncdp);
		minlag = ealloc1float(ncdp);
		maxlag = ealloc1float(ncdp);
		iminlag = ealloc1int(ncdp);
		imaxlag = ealloc1int(ncdp);

		/* zero out array values */
		memset( (void *) minlag , 0, ncdp * FSIZE);
		memset( (void *) maxlag , 0, ncdp * FSIZE);
		memset( (void *) imaxlag , 0, ncdp * ISIZE);
		memset( (void *) iminlag , 0, ncdp * ISIZE);


		cdp[0] = intrace.cdp;

		if (getparfloat("minlag", minlag)) {
			iminlag[0] = NINT(minlag[0]/dt);
		} else {
			iminlag[0] = 1;
		}

		if (getparfloat("maxlag", maxlag)) {
			imaxlag[0] = NINT(maxlag[0]/dt);
		} else {
			imaxlag[0] = NINT(0.05 * nt);
		}

	}

		
	/* Get parameters  */
	if (!getparint("wienerout",  &wienerout))	wienerout = 0;
	if (!getparfloat("pnoise",  &pnoise))	pnoise = PNOISE;
	
	/* .. mincorr and maxcorr */
	if (getparfloat("mincorr", &mincorr))	imincorr = NINT(mincorr/dt);
	else					imincorr = 0;
	if (imincorr < 0) err("mincorr=%g too small", mincorr);
	
	if (getparfloat("maxcorr", &maxcorr))	imaxcorr = NINT(maxcorr/dt);
	else					imaxcorr = nt;
	if (imaxcorr > nt) err("maxcorr=%g too large", maxcorr);

	if (imincorr >= imaxcorr)
		err("mincorr=%g, maxcorr=%g", mincorr, maxcorr);
	
	/*... Get mix weighting values values */
	if ((nmix = countparval("mix"))!=0) {
		mix = ealloc1float(nmix);
		getparfloat("mix",mix);
		
	} else { /* else use default values */
		nmix = 1;
		mix = ealloc1float(nmix);

		mix[0] = VAL0;
	}

	/* Divide mixing weight by number of traces to mix over */
	for (imix = 0; imix < nmix; ++imix)
		mix[imix]=mix[imix]/((float) nmix);

	/* Getpar interpolation method */
	getparstring("method",&method);
        checkpars();
	

	/* compute filter sizes and correlation number */
	nlag  = imaxlag[0] - iminlag[0] + 1;
	ncorr = imaxcorr - imincorr + 1;
	lcorr = imaxlag[0] + 1;

	/* Compute byte sizes in wiener/spiker and autocorr */
	lagbytes = FSIZE*nlag;
	maxlagbytes = FSIZE*lcorr;
	mixbytes = maxlagbytes*nmix;

	/* Allocate memory */
	wiener	 = ealloc1float(nlag);
	spiker	 = ealloc1float(nlag);
	autocorr = ealloc1float(lcorr);
	temp = ealloc1float(lcorr);
	mixacorr = ealloc2float(lcorr,nmix);

	/* Set pointer to "cross" correlation */
	crosscorr = autocorr + iminlag[0];

	/* Zero out mixing array */
	memset((void *) mixacorr[0], 0, mixbytes);

	/* set old cdp  first trace */
	oldcdp = intrace.cdp;

	jcdp = 0;
	/* Main loop over traces */
	do {
		static int itr = 0;
		++itr;
		
		/* if neccessary, compute new filter parameters */
		if (intrace.cdp!=oldcdp && ncdp>1 && jcdp<ncdp-1) {
			 int cdptotal = cdp[ncdp - 1] - intrace.cdp;

			++jcdp;

			free1float(cdpinterp);
			free1float(ominlag);
			free1float(omaxlag);

			

			 /* Compute uniformly sampled */
		         cdpinterp = ealloc1float(cdptotal);
			 ominlag = ealloc1float(cdptotal);
			 omaxlag = ealloc1float(cdptotal);
			
			 memset( (void *) omaxlag, 0, cdptotal * FSIZE);
                 	 memset( (void *) ominlag, 0, cdptotal * FSIZE);

        		 for(icdp=0; icdp<cdptotal; ++icdp)
                	 	cdpinterp[icdp] = intrace.cdp + icdp;

			 for(icdp=0; icdp<cdptotal; ++icdp)
                                ominlag[icdp] = minlag[icdp] + icdp;

			 for(icdp=0; icdp<cdptotal; ++icdp)
                                omaxlag[icdp] = maxlag[icdp] + icdp;
			

				
			 /* if linear interpolation or only one input sample */
   			if (method[0]=='l' || ncdp==1) {
                        	intlin(cdptotal,minlag,cdp,cdp[0],cdp[ncdp-1],ncdp,cdpinterp,ominlag);
				intlin(cdptotal,maxlag,cdp,cdp[0],cdp[ncdp-1],ncdp,cdpinterp,omaxlag);
				for (icdp = 0; icdp < ncdp; ++icdp) {
                        		iminlag[icdp] = NINT(ominlag[icdp]/dt);
                        		imaxlag[icdp] = NINT(omaxlag[icdp]/dt);
                		}

        		/* else, if monotonic interpolation */
        		} else if (method[0]=='m') {
                       		zind = (float (*)[4])ealloc1float(ncdp*4);
                        	cmonot(ncdp,minlag,cdp,zind);
                        	intcub(0,ncdp,minlag,zind,ncdp,cdpinterp,ominlag);
				cmonot(ncdp,maxlag,cdp,zind);
                                intcub(0,ncdp,maxlag,zind,ncdp,cdpinterp,omaxlag);			
				for (icdp = 0; icdp < ncdp; ++icdp) {
                                        iminlag[icdp] = NINT(ominlag[icdp]/dt);
                                        imaxlag[icdp] = NINT(omaxlag[icdp]/dt);
                                }

        		/* else, if Akima interpolation */
        		} else if (method[0]=='a') {
                        	zind = (float (*)[4])ealloc1float(ncdp*4);
                        	cakima(ncdp,minlag,cdp,zind);
                        	intcub(0,ncdp,minlag,zind,ncdp,cdpinterp,ominlag);
				cakima(ncdp,maxlag,cdp,zind);
                                intcub(0,ncdp,maxlag,zind,ncdp,cdpinterp,omaxlag);
				for (icdp = 0; icdp < ncdp; ++icdp) {
                                        iminlag[icdp] = NINT(ominlag[icdp]/dt);
                                        imaxlag[icdp] = NINT(omaxlag[icdp]/dt);
                                }

       			/* else, if cubic spline interpolation */
       			} else if (method[0]=='s') {
                       		zind = (float (*)[4])ealloc1float(ncdp*4);
                       		csplin(ncdp,minlag,cdp,zind);
                       		intcub(0,ncdp,minlag,zind,ncdp,cdpinterp,ominlag);
				csplin(ncdp,maxlag,cdp,zind);
                                intcub(0,ncdp,maxlag,zind,ncdp,cdpinterp,omaxlag);
				for (icdp = 0; icdp < ncdp; ++icdp) {
                                        iminlag[icdp] = NINT(ominlag[icdp]/dt);
                                        imaxlag[icdp] = NINT(omaxlag[icdp]/dt);
                                }

       			/* else, if unknown method specified */
       			} else {
               			err("%s is an unknown interpolation method!\n",method);
       			}


			/* compute filter sizes and correlation number */
			nlag  = imaxlag[jcdp] - iminlag[jcdp] + 1;
			ncorr = imaxcorr - imincorr + 1;
			lcorr = imaxlag[jcdp] + 1;

			/* Compute byte sizes in wiener/spiker and autocorr */
			/*lagbytes = FSIZE*nlag;*/
			maxlagbytes = FSIZE*lcorr;

			/* free memory */
			free1float(wiener);
			free1float(spiker);
			free1float(autocorr);
			free1float(temp);
			free2float(mixacorr);
			
			/* Allocate memory */
			wiener	 = ealloc1float(nlag);
			spiker	 = ealloc1float(nlag);
			autocorr = ealloc1float(lcorr);
			temp = ealloc1float(lcorr);
			mixacorr = ealloc2float(lcorr,nmix);

			/* Set pointer to "cross" correlation */
			crosscorr = autocorr + iminlag[jcdp];

			/* Zero out mixing array */
			memset((void *) mixacorr[0], 0, mixbytes);

		}

		/* zero out filter vectors */
		memset((void *) wiener, 0, lagbytes);
		memset((void *) spiker, 0, lagbytes);
		memset((void *) autocorr, 0, maxlagbytes);
		memset((void *) temp, 0, maxlagbytes);

		/* Form autocorrelation vector */
		xcor(ncorr, imincorr, intrace.data,
		     ncorr, imincorr, intrace.data,
		     lcorr, 0, autocorr);

		/* fix supplied by Sanyu Ye */

/*
		xcor(ncorr, 0, &intrace.data[imincorr],
			ncorr, 0, &intrace.data[imincorr],
			lcorr, 0, autocorr);

*/


		/* Leave trace alone if autocorr[0] vanishes */
		if (autocorr[0] == 0.0) {
			puttr(&intrace);
			if (wienerout)
				warn("NO Wiener filter, trace: %d", itr);

			continue;
		}


		/* Whiten */
		autocorr[0] *= 1.0 + pnoise;

		/* Read autocorr into first column of mixacorr[][] */
		memcpy( (void *) mixacorr[0], 
				(const void *) autocorr, maxlagbytes);

		/* Loop over values of the autocorrelation array */
		for (ilag = 0; ilag < lcorr; ++ilag) {

			/* Weighted moving average (mix) */
			for(imix=0; imix<nmix; ++imix)
				temp[ilag]+=mixacorr[imix][ilag]*mix[imix];

			/* put mixed data back in seismic trace */
			autocorr[ilag] = temp[ilag]; 

		}

		/* Bump columns of mixacorr[][] over by 1 */
		/* to make space for autocorr from next trace */
		for (imix=nmix-1; 0<imix; --imix)
			for (ilag=0; ilag<lcorr; ++ilag) 
				mixacorr[imix][ilag] = mixacorr[imix-1][ilag];


		/* Get inverse filter by Wiener-Levinson */
		stoepf(nlag, autocorr, crosscorr, wiener, spiker);
		

		/* Convolve pefilter with trace - don't do zero multiplies */
		for (i = 0; i < nt; ++i) {
			register int j;
			register int n = MIN(i, imaxlag[jcdp]); 
			register float sum = intrace.data[i];

			for (j = iminlag[jcdp]; j <= n; ++j)
				sum -= wiener[j-iminlag[jcdp]] * intrace.data[i-j];

			outtrace.data[i] = sum;
		}


		/* Show pefilter on request */
		if (wienerout && autocorr[0] != 0.0) {
			register int i;
			warn("Wiener filter, trace: %d", itr);


                        for (i = 0; i < imaxlag[icdp]; ++i) {
                                fprintf(outparfp, "%10g%c ", wiener[i],' ');
			}

                      	fprintf(outparfp, "\n");

			memcpy( (void *) &outtrace, 
				(const void *) &intrace, HDRBYTES);
		
			memset( (void *) outtrace.data, 0, nt*FSIZE);

			outtrace.data[0] = 1.0;

			for (i=0; i< imaxlag[icdp]; ++i)
				outtrace.data[iminlag[icdp]+i] = -wiener[i];

			puttr(&outtrace);

		} else {
			/* Output filtered trace */
			memcpy( (void *) &outtrace, 
				(const void *) &intrace, HDRBYTES);

			puttr(&outtrace);
		}

		/* update value of oldcdp */
		oldcdp = intrace.cdp;
		
	} while (gettr(&intrace));


	return(CWP_Exit());
}
@


1.46
log
@updated selfdoc to agree with proper usage, removed fix by Ye
@
text
@d4 1
a4 1
/* SUPEF: $Revision: 1.45 $ ; $Date: 2011/11/16 17:47:47 $		*/
d73 4
a76 1
" MINLAG_PEF to the value of GAP.					",
d82 2
d114 2
a115 1
"									",
@


1.45
log
@added Reg Beardsley's checkpar()
@
text
@d4 1
a4 1
/* SUPEF: $Revision: 1.43 $ ; $Date: 2011/09/09 22:30:20 $		*/
d13 1
a13 1
" SUPEF - Wiener predictive error filtering				",
d28 1
a28 1
" showwiener=0		=1 to show Wiener filter on each trace		",
d32 1
a32 1
" 			if showwiener=1 is set				",
d65 2
d71 4
a74 7
" autocorrelation waveform. Set MAXLAG_PEF to the period of the repetitions",
" Set MINLAG_PEF to be slightly larger than the value of MAXLAG_SPIKING	",
" that you used to spike the data. In general, the periodicity of the	",
" repetitions in the autocorrelation will be the GAP_SIZE 		",
" with     MAXLAG_PEF = GAP_SIZE + MINLAG_PEF 				",
" some experimentation may be necessary to see sensitivity to choices	",
" of MAXLAG_PEF.							",
d86 6
a91 1
"  									",
d103 1
a103 1
" The showweiner=1 option writes out the wiener filter to outpar, and   ",
d180 1
a180 1
	int showwiener;		/* flag to display pred. error filter	*/
d304 1
a304 1
	if (!getparint("showwiener",  &showwiener))	showwiener = 0;
d492 1
a492 1
/*		xcor(ncorr, imincorr, intrace.data,
d495 1
a495 1
*/
d498 1
d503 1
d509 1
a509 1
			if (showwiener)
d560 1
a560 1
		if (showwiener && autocorr[0] != 0.0) {
@


1.44
log
@copyright
@
text
@d333 1
a333 1

@


1.43
log
@*** empty log message ***
@
text
@d1 4
a4 1
/* SUPEF: $Revision: 1.42 $ ; $Date: 2009/12/09 18:32:28 $		*/
@


1.42
log
@added to the selfdoc.
@
text
@d1 1
a1 1
/* SUPEF: $Revision: 1.41 $ ; $Date: 2006/11/07 22:58:42 $		*/
d366 1
a366 1
		if (intrace.cdp!=oldcdp && ncdp>1 && icdp<ncdp-1) {
d485 1
a485 1
		xcor(ncorr, imincorr, intrace.data,
d488 7
@


1.41
log
@changed    memset( .., (int) '\0',...) to memset( .., 0,..) as per suggestion of Marion Zhu and Reg Beardsley
@
text
@d1 1
a1 1
/* SUPEF: $Revision: 1.40 $ ; $Date: 2006/10/31 22:17:58 $		*/
d68 5
a72 1
" that you used to spike the data.					",
d82 2
a83 1
" further processing.							",
@


1.40
log
@modified to allow filtering by cdp
@
text
@d1 1
a1 1
/* SUPEF: $Revision: 1.38 $ ; $Date: 2006/01/10 20:03:22 $		*/
d268 4
a271 4
		memset( (void *) minlag , (int) '\0', ncdp * FSIZE);
		memset( (void *) maxlag , (int) '\0', ncdp * FSIZE);
		memset( (void *) imaxlag , (int) '\0', ncdp * ISIZE);
		memset( (void *) iminlag , (int) '\0', ncdp * ISIZE);
d349 1
a349 1
	memset((void *) mixacorr[0], (int) '\0', mixbytes);
d377 2
a378 2
			 memset( (void *) omaxlag, (int) '\0', cdptotal * FSIZE);
                 	 memset( (void *) ominlag, (int) '\0', cdptotal * FSIZE);
d469 1
a469 1
			memset((void *) mixacorr[0], (int) '\0', mixbytes);
d474 4
a477 4
		memset((void *) wiener, (int) '\0', lagbytes);
		memset((void *) spiker, (int) '\0', lagbytes);
		memset((void *) autocorr, (int) '\0', maxlagbytes);
		memset((void *) temp, (int) '\0', maxlagbytes);
d553 1
a553 1
			memset( (void *) outtrace.data, (int) '\0', nt*FSIZE);
@


1.39
log
@small error
@
text
@d89 9
a97 1
"  									",
d196 1
d203 4
a537 5
		/* Output filtered trace */
		memcpy( (void *) &outtrace, (const void *) &intrace, HDRBYTES);
		puttr(&outtrace);


d539 1
a539 1
		if (showwiener) {
a542 4
		        /* Get parameters and do set up */
        		if (!getparstring("outpar", &outpar))
						outpar = OUTPAR_DEFAULT;
        			outparfp = efopen(outpar, "w");
d544 24
a567 2
			for (i = 0; i < imaxlag[icdp]; ++i)
				fprintf(outparfp, "%f",  wiener[i]);
@


1.38
log
@Tanya Slot's updates
@
text
@d1 1
a1 1
/* SUPEF: $Revision: 1.37 $ ; $Date: 2005/10/04 16:42:43 $		*/
d541 1
a541 1
				fprintf(outparfp, "%d", wiener[i]);
@


1.37
log
@4 Oct 2005
@
text
@d1 1
a1 1
/* SUPEF: $Revision: 1.36 $ ; $Date: 2005/03/03 21:38:17 $		*/
d28 6
a33 5
" 									",
" method=linear	 for linear interpolation of cdp values	  ",
"		       =mono for monotonic cubic interpolation of cdps ",
"		       =akima for Akima's cubic interpolation of cdps  ",
"		       =spline for cubic spline interpolation of cdps  ",
a37 4
" 	To get the Wiener filters into an ascii file:			",
" 	... | supef ... showwiener=1 2>file | ...   (sh or ksh)		",
" 	(... | supef ... showwiener=1 | ...) >&file  (csh)		",
" 									",
d116 5
a120 2
#define PNOISE	0.001		/* default pnoise value */
#define VAL0    1.0		/* default weighting value */
d173 8
a180 5
	float (*zind)[4]=NULL;  /* array of interpolation coefficients  */
	char  *method="linear";  /* interpolation method	 */
	float *cdpinterp=NULL;	/* interpolated cdps */
	float *ominlag=NULL;	/* interpolated minlags */ 
	float *omaxlag=NULL;  /* interpolated maxlags */
d534 6
d541 1
a541 2
				fprintf(stderr, "%10g%c", wiener[i],
					(i%6==5 || i==nlag-1) ? '\n' : ' ');
@


1.36
log
@added instructions for spiking decon and gapped wiener decon
@
text
@d1 1
a1 1
/* SUPEF: $Revision: 1.35 $ ; $Date: 2003/06/09 16:17:07 $		*/
d15 1
a15 1
" 	dt is mandatory if not set in header		 		",
d18 9
a26 7
"	minlag=dt		first lag of prediction filter (sec)	",
"	maxlag=last		lag default is (tmax-tmin)/20		",
"	pnoise=0.001		relative additive noise level		",
"	mincorr=tmin		start of autocorrelation window (sec)	",
"	maxcorr=tmax		end of autocorrelation window (sec)	",
"	showwiener=0		=1 to show Wiener filter on each trace	",
"	mix=1,...	 	array of weights (floats) for moving	",
d29 5
d77 3
a79 3
" It may be effective to sort your data into cdps with susort, and	",
" perform sunmo correction to the water speed with sunmo, prior to 	",
" attempts to suppress water bottom multiples. In this case, the the	",
d83 11
a93 1
NULL};
d98 1
d100 1
d118 3
a120 9
#define PNOISE	0.001

/* default weighting values */
#define VAL0    1.0
#define VAL1    1.0
#define VAL2    1.0
#define VAL3    1.0
#define VAL4    1.0
#define VAL5    1.0
d130 5
d136 1
d138 2
a139 2
	float *wiener;		/* Wiener error filter coefficients	*/
	float *spiker;		/* spiking decon filter			*/
d143 4
a146 4
	float minlag;		/* start of error filter (sec)		*/
	int iminlag;		/* ... in samples			*/
	float maxlag;		/* end of error filter (sec)		*/
	int imaxlag;		/* ... in samples			*/
d151 4
a154 2
	float *crosscorr;	/* right hand side of Wiener eqs	*/
	float *autocorr;	/* vector of autocorrelations		*/
d168 10
a177 3
	float *mix;		/* array of averaging weights		*/
	float **mixacorr;	/* mixing array				*/
	float *temp	;	/* temporary array			*/
d189 76
a264 1
	if (!dt) MUSTGETPARFLOAT ("dt", &dt);
d266 7
d274 2
a275 1
	/* Get parameters */
a277 12

	/* .. minlag and maxlag */
	if (getparfloat("minlag", &minlag))	iminlag = NINT(minlag/dt);
	else					iminlag = 1;
	if (iminlag < 1) err("minlag=%g too small", minlag);

	if (getparfloat("maxlag", &maxlag))	imaxlag = NINT(maxlag/dt);
	else					imaxlag = NINT(0.05 * nt);
	if (imaxlag >= nt) err("maxlag=%g too large", maxlag);
	
	if (iminlag >= imaxlag)
		err("minlag=%g, maxlag=%g", minlag, maxlag);
d307 4
d313 1
a313 1
	nlag  = imaxlag - iminlag + 1;
d315 1
a315 1
	lcorr = imaxlag + 1;
d330 1
a330 1
	crosscorr = autocorr + iminlag;
d335 4
d343 113
d482 2
a483 2
                /* Read autocorr into first column of mixacorr[][] */
                memcpy( (void *) mixacorr[0], 
d486 2
a487 2
                /* Loop over values of the autocorrelation array */
                for (ilag = 0; ilag < lcorr; ++ilag) {
d489 14
a502 14
                        /* Weighted moving average (mix) */
                        for(imix=0; imix<nmix; ++imix)
                                temp[ilag]+=mixacorr[imix][ilag]*mix[imix];

                        /* put mixed data back in seismic trace */
                        autocorr[ilag] = temp[ilag]; 

                }

                /* Bump columns of mixacorr[][] over by 1 */
                /* to make space for autocorr from next trace */
                for (imix=nmix-1; 0<imix; --imix)
                        for (ilag=0; ilag<lcorr; ++ilag) 
                                mixacorr[imix][ilag] = mixacorr[imix-1][ilag];
d512 1
a512 1
			register int n = MIN(i, imaxlag); 
d515 2
a516 2
			for (j = iminlag; j <= n; ++j)
				sum -= wiener[j-iminlag] * intrace.data[i-j];
d531 1
a531 1
			for (i = 0; i < imaxlag; ++i)
d535 3
@


1.35
log
@9 June 2003
@
text
@d1 1
a1 4
/* Copyright (c) Colorado School of Mines, 1998.*/
/* All rights reserved.                       */

/* SUPEF: $Revision: 1.34 $ ; $Date: 1999/04/29 14:00:59 $		*/
d34 42
@


1.34
log
@Bent Ole Ruud's fixes
@
text
@d4 1
a4 1
/* SUPEF: $Revision: 1.33 $ ; $Date: 1998/04/14 18:48:35 $		*/
d280 1
a280 1
	return EXIT_SUCCESS;
@


1.33
log
@set default mix to mix=1
@
text
@d1 4
a4 1
/* SUPEF: $Revision: 1.32 $ ; $Date: 1998/04/03 23:00:22 $		*/
d91 1
d173 1
d177 1
a177 1
	maxlagbytes = FSIZE*imaxlag;
d183 3
a185 3
	autocorr = ealloc1float(imaxlag);
	temp = ealloc1float(imaxlag);
	mixacorr = ealloc2float(imaxlag,nmix);
d207 1
a207 1
		     imaxlag, 0, autocorr);
d228 1
a228 1
                for (ilag = 0; ilag < imaxlag; ++ilag) {
d242 1
a242 1
                        for (ilag=0; ilag<imaxlag; ++ilag) 
@


1.32
log
@added autocorrelation mixing (weighted moving average) feature
to balance amplitudes.
@
text
@d1 1
a1 1
/* SUPEF: $Revision: 1.31 $ ; $Date: 1996/09/13 21:49:05 $		*/
d24 1
a24 1
"	mix=1,1,1,1,1,1 	array of weights (floats) for moving	",
d155 1
a155 1
		nmix = 6;
a158 5
		mix[1] = VAL1;
		mix[2] = VAL2;
		mix[3] = VAL3;
		mix[4] = VAL4;
		mix[5] = VAL5;
@


1.31
log
@silenced -Wall messages
@
text
@d1 1
a1 1
/* SUPEF: $Revision: 1.30 $ ; $Date: 1996/02/05 16:15:40 $		*/
d24 2
d37 2
a38 1
 *	CWP: Shuki, Jack, Ken
d59 8
d74 2
d79 1
d81 1
d88 1
d91 1
d97 10
a106 1

a122 1

d125 1
d137 1
d149 23
d175 4
d184 2
a185 1

d190 2
a191 1

d198 6
d223 22
d251 1
a251 2
		{ register int i;
		  for (i = 0; i < nt; ++i) {
a259 1
		  }
@


1.30
log
@Deal with header words accessed/modified down to sudoc.
@
text
@d1 1
a1 1
/* SUPEF: $Revision: 1.29 $ ; $Date: 1995/08/02 21:04:10 $		*/
d59 1
@


1.29
log
@Cast the integers tr.dt and/or tr.delrt and/or clones to double before
division with floating constant (which is implicitly double
precision).  Casting is needed to make some compilers happy and if we
cast to float then there will be an extra conversion to double because
of the floating constant (casting to float and writing 1000000.0F
would save a conversion, but most people find that F yucky and
efficiency is not an issue here).
Motivated by examples from Stew Levin.
@
text
@d1 1
a1 1
/* SUPEF: $Revision: 1.28 $ ; $Date: 1994/08/25 15:00:24 $		*/
d48 2
@


1.28
log
@Removed copyright statement from codes that had it.
Moved self-doc line for sudoc.
@
text
@d1 1
a1 1
/* SUPEF: $Revision: 1.27 $ ; $Date: 93/11/24 15:55:48 $		*/
d88 2
a89 1
	dt = (float) intrace.dt/1000000.0; if (!dt) MUSTGETPARFLOAT ("dt", &dt);
@


1.27
log
@added explicit casts to memcpy
@
text
@d1 1
a1 1
/* SUPEF: $Revision: 1.26 $ ; $Date: 92/10/26 11:09:31 $		*/
a2 13
/*----------------------------------------------------------------------
 * Copyright (c) Colorado School of Mines, 1990.
 * All rights reserved.
 *
 * This code is part of SU.  SU stands for Seismic Unix, a processing line
 * developed at the Colorado School of Mines, partially based on Stanford
 * Exploration Project (SEP) software.  Inquiries should be addressed to:
 *
 *  Jack K. Cohen, Center for Wave Phenomena, Colorado School of Mines,
 *  Golden, CO 80401  (jkc@@dix.mines.colorado.edu)
 *----------------------------------------------------------------------
 */

a32 1
/**************** end self doc *******************************************/
d49 1
@


1.26
log
@new selfdoc installed
@
text
@d1 1
a1 1
/* SUPEF: $Revision: 1.25 $ ; $Date: 91/09/05 08:51:31 $		*/
d101 1
a101 1
	dt = intrace.dt/1000000.0;	if (!dt) MUSTGETPARFLOAT ("dt", &dt);
d191 1
a191 1
		memcpy(&outtrace, &intrace, HDRBYTES);
@


1.25
log
@string -> String and so forth
@
text
@d1 1
a1 1
/* SUPEF: $Revision: 1.21 $ ; $Date: 90/12/17 17:54:06 $		*/
d21 25
a45 31
String sdoc =
" 									\n"
" SUPEF - Wiener predictive error filtering				\n"
" 									\n"
" supef <stdin >stdout  [optional parameters]				\n"
" 									\n"
" Required parameters:							\n"
" 	dt is mandatory if not set in header		 		\n"
" 									\n"
" Optional parameters:							\n"
" 									\n"
"      minlag=dt	first lag of prediction filter (sec)		\n"
" 									\n"
"      maxlag=last lag	default is (tmax-tmin)/20			\n"
" 									\n"
"      pnoise=0.001	relative additive noise level			\n"
" 									\n"
"      mincorr=tmin	start of autocorrelation window (sec)		\n"
" 									\n"
"      maxcorr=tmax	end of autocorrelation window (sec)		\n"
" 									\n"
"      showwiener=0	=1 to show Wiener filter on each trace		\n"
" 									\n"
" Trace header fields accessed: ns, dt					\n"
" Trace header fields modified: none					\n"
" 									\n"
" 	To get the Wiener filters into an ascii file:			\n"
" 	... | supef ... showwiener=1 2>file | ...   (sh or ksh)		\n"
" 	(... | supef ... showwiener=1 | ...) >&file  (csh)		\n"
" 									\n"
;
d95 1
a95 1
	askdoc(1);
@


1.24
log
@Remove spiker option.  Improved self-doc
@
text
@d21 1
a21 1
string sdoc =
@


1.23
log
@... and succeeding test
@
text
@d1 1
a1 1
/* SUPEF: $Revision: 1.22 $ ; $Date: 91/03/14 22:27:12 $		*/
d28 1
a28 1
" 	dt is a mandatory getpar if not set in header	 		\n"
d34 1
a34 1
"      maxlag=trace/20	last lag of prediction filter (sec) [note below]\n"
a43 2
"      showspiker=0	=1 to show spike decon filter on each trace	\n"
" 									\n"
a46 3
" Note: The precise maxlag formula is (tmax-tmin)/20.			\n"
" Caveat: Times are measured relative to the first trace sample.	\n"
" 									\n"
d81 1
a90 1
	float *spiker;		/* spiking decon filter			*/
a94 1
	int showspiker;		/* flag to display spiking filter	*/
a111 1
	if (!getparint("showspiker",  &showspiker))	showspiker = 0;
d131 2
a132 2
	else					imaxcorr = nt-1;
	if (imaxcorr >= nt) err("maxcorr=%g too large", maxcorr);
a167 2
			if (showspiker)
				warn("NO spiking decon filter, trace: %d", itr);
d201 1
a201 1
		/* Show pefilter and/or spiker on request */
a209 8
		if (showspiker) {
			register int i;
			warn("spiking decon filter, trace: %d", itr);
			for (i = 0; i < nlag; ++i)
				fprintf(stderr, "%10g%c", spiker[i],
					(i%6==5 || i==nlag-1) ? '\n' : ' ');
		}

@


1.22
log
@Corrected default assignment for imaxcorr
@
text
@d1 1
a1 1
/* SUPEF: $Revision: 1.21 $ ; $Date: 90/12/17 17:54:06 $		*/
d139 1
a139 1
	if (imaxcorr > nt) err("maxcorr=%g too large", maxcorr);
@


1.21
log
@Using xcor!
@
text
@d1 1
a1 1
/* SUPEF: $Revision: 1.20 $ ; $Date: 90/11/30 16:13:53 $		*/
d138 1
a138 1
	else					imaxcorr = nt;
@


1.20
log
@Tweaks
@
text
@d1 1
a1 1
/* SUPEF: $Revision: 1.19 $ ; $Date: 90/11/15 10:43:36 $		*/
d32 1
a32 1
"      minlag= dt   	start of prediction filter (sec)		\n"
d34 1
a34 1
"      maxlag= (see note)	end of prediction filter (sec)		\n"
d38 1
a38 1
"      mincorr= tmin	start of autocorrelation window	(sec)		\n"
d40 1
a40 1
"      maxcorr= tmax	end of autocorrelation window (sec)		\n"
d49 2
a50 2
" Notes:								\n"
" 	The default maxlag is:  .05*(tmax-tmin)				\n"
d92 1
d144 2
a145 1
	nlag = imaxlag - iminlag + 1;
d165 3
a167 1
		{ register int icr;
a168 4
		  for (icr = 0; icr < imaxlag; ++icr) {
			register int i;
			register int n = MIN(imaxcorr, nt - icr);
			register float sum = 0.0;
a169 8
			for (i = imincorr; i < n; ++i)
				sum += intrace.data[i] * intrace.data[i+icr];
					
			autocorr[icr] = sum;
		  }
		}


a191 1

@


1.19
log
@bcopy -> memcpy
@
text
@d1 1
a1 1
/* SUPEF: $Revision: 1.18 $ ; $Date: 90/11/06 15:03:07 $		*/
d21 36
a56 33
string sdoc = "\
									\n\
SUPEF - Wiener predictive error filtering				\n\
									\n\
supef <stdin >stdout  [optional parameters]				\n\
									\n\
Required parameters:							\n\
	dt is a mandatory getpar if not set in header	 		\n\
									\n\
Optional parameters:							\n\
									\n\
     minlag= dt   	start of prediction filter (sec)		\n\
									\n\
     maxlag= (see note)	end of prediction filter (sec)			\n\
									\n\
     pnoise=0.001	relative additive noise level			\n\
									\n\
     mincorr= tmin	start of autocorrelation window	(sec)		\n\
									\n\
     maxcorr= tmax	end of autocorrelation window (sec)		\n\
									\n\
     showwiener=0	=1 to show Wiener filter on each trace		\n\
									\n\
     showspiker=0	=1 to show spike decon filter on each trace	\n\
									\n\
Notes:									\n\
	The default maxlag is:  .05*(tmax-tmin)				\n\
									\n\
	To get the Wiener filters into an ascii file:			\n\
	... | supef ... showwiener=1 2>file | ...   (sh or ksh)		\n\
	(... | supef ... showwiener=1 | ...) >&file  (csh)		\n\
									\n\
";
d112 1
a112 1
	dt = intrace.dt/1000000.0;	if (!dt) MUSTFGETPAR("dt", &dt);
d163 1
a163 2
		{
			register int icr;
d165 4
a168 4
			for (icr = 0; icr < imaxlag; ++icr) {
				register int i;
				register int n = MIN(imaxcorr, nt - icr);
				register float sum = 0.0;
d170 2
a171 3
				for (i = imincorr; i < n; ++i)
					sum += intrace.data[i] *
						intrace.data[i+icr];
d173 2
a174 2
				autocorr[icr] = sum;
			}
d199 1
a199 2
		{
			register int i;
d201 4
a204 4
			for (i = 0; i < nt; ++i) {
				register int j;
				register int n = MIN(i, imaxlag); 
				register float sum = intrace.data[i];
d206 2
a207 3
				for (j = iminlag; j <= n; ++j)
					sum -= wiener[j-iminlag] *
						intrace.data[i-j];
d209 2
a210 2
				outtrace.data[i] = sum;
			}
@


1.18
log
@msec -> sec
@
text
@d1 1
a1 1
/* SUPEF: $Revision: 1.17 $ ; $Date: 90/07/22 20:55:40 $		*/
d216 1
a216 1
		bcopy(&intrace, &outtrace, HDRBYTES);
@


1.17
log
@Tweak
@
text
@d1 1
a1 1
/* SUPEF: $Revision: 1.16 $ ; $Date: 90/07/22 16:18:26 $		*/
d32 1
a32 1
     minlag= dt*1000	start of prediction filter (msec)		\n\
d34 1
a34 1
     maxlag= (see note)	end of prediction filter (msec)			\n\
d38 1
a38 1
     mincorr= tmin	start of autocorrelation window	(msec)		\n\
d40 1
a40 1
     maxcorr= tmax	end of autocorrelation window (msec)		\n\
d47 1
a47 1
	The default maxlag is:  .05*(tmax-tmin)*1000			\n\
a81 1
	float mdt;		/*  ... * 1000.0			*/
d84 1
a84 1
	float minlag;		/* start of error filter (msec)		*/
d86 1
a86 1
	float maxlag;		/* end of error filter (msec)		*/
a109 1
	mdt = 1000.0 * dt;
d118 1
a118 1
	if (getparfloat("minlag", &minlag))	iminlag = NINT(minlag/mdt);
d122 1
a122 1
	if (getparfloat("maxlag", &maxlag))	imaxlag = NINT(maxlag/mdt);
d129 1
a129 1
	if (getparfloat("mincorr", &mincorr))	imincorr = NINT(mincorr/mdt);
d133 1
a133 1
	if (getparfloat("maxcorr", &maxcorr))	imaxcorr = NINT(maxcorr/mdt);
@


1.16
log
@Tweks
@
text
@d1 1
a1 1
/* SUPEF: $Revision: 1.15 $ ; $Date: 90/07/14 17:13:41 $		*/
d81 1
a81 1
	float dt;		/* time sample interval (msec)		*/
@


1.15
log
@Eliminated superfluous pefilter by just backshifting wiener and
subtracting instead of adding.  This obviates the wiener ->pefilter
paragraph in the main loop.
@
text
@d1 1
a1 1
/* SUPEF: $Revision: 1.14 $ ; $Date: 90/07/12 15:37:36 $		*/
d42 1
a42 1
     showwiener=0	=1 to show pred error filter on each trace	\n\
d49 1
a49 1
	To get the wiener filters into an ascii file:			\n\
@


1.14
log
@Now offer pefilter instead of wiener prediction filter
@
text
@d1 1
a1 1
/* SUPEF: $Revision: 1.13 $ ; $Date: 90/07/12 14:48:53 $		*/
d42 1
a42 1
     showpef=0		=1 to show pred error filter on each trace	\n\
a46 1
	The default minlag is spiking deconvolution			\n\
d50 2
a51 2
	... | supef ... showpef=1 2>file | ...   (sh or ksh)		\n\
	(... | supef ... showpef=1 | ...) >&file  (csh)			\n\
d63 2
a64 1
 *	For iminlag=1, pefilter == spiker.
a82 1
	float *pefilter;	/* prediction error filter coefficients	*/
d98 1
a98 1
	int showpef;		/* flag to display pred. error filter	*/
d115 1
a115 1
	if (!getparint("showpef",  &showpef))		showpef = 0;
a145 1
	pefilter = ealloc1float(imaxlag);
a154 6
	/* Set initial pefilter coefficients - for display only */
	pefilter[0] = 1.0;
	{
		register int i;
		for (i = 1; i < iminlag; i++)	pefilter[i] = 0.0;
	}
a155 1

d182 2
a183 2
			if (showpef)
				warn("NO pred. error filter, trace: %d", itr);
a198 10
		/*  Form prediction error operator */
		{
			register int i;
			register int j;

			for (i = iminlag, j = 0; i <= imaxlag; ++i, ++j)
				pefilter[i] = -wiener[j];
		}

			
d209 2
a210 1
					sum += pefilter[j] * intrace.data[i-j];
d223 1
a223 1
		if (showpef) {
d225 1
a225 1
			warn("pred. error filter, trace: %d", itr);
d227 2
a228 2
				fprintf(stderr, "%10g%c", pefilter[i],
					(i%6==5 || i==imaxlag-1) ? '\n' : ' ');
@


1.13
log
@Added comment about possible optimization not executed.
@
text
@d1 1
a1 1
/* SUPEF: $Revision: 1.12 $ ; $Date: 90/07/12 14:30:57 $		*/
d42 1
a42 1
     showwiener=0	=1 to show wiener filter on each trace		\n\
d51 2
a52 2
	... | supef ... showwiener=1 2>file | ...   (sh or ksh)		\n\
	(... | supef ... showwiener=1 | ...) >&file  (csh)		\n\
d63 5
a67 2
 *	Possible optimization: if imaxlag < 2*iminlag - 1, then we don't
 *	need to compute the autocorrelation for lags:
d69 1
a69 2
 *	For now, I'd rather not increase the testing for this case of
 *	large gap and short filter.  jkc 07/12/90
d99 1
a99 1
	int showwiener;		/* flag to display wiener filter	*/
d116 1
a116 1
	if (!getparint("showwiener",  &showwiener))	showwiener = 0;
d127 1
a127 1
	if (imaxlag > nt) err("maxlag=%g too large", maxlag);
a164 1

d191 2
a192 2
			if (showwiener)
				warn("NO wiener error filter, trace: %d", itr);
d240 2
a241 2
		/* Show wiener and/or spiker on request */
		if (showwiener) {
d243 4
a246 4
			warn("wiener error filter, trace: %d", itr);
			for (i = 0; i < nlag; ++i)
				fprintf(stderr, "%10g%c", wiener[i],
					(i%6==5 || i==nlag-1) ? '\n' : ' ');
@


1.12
log
@Default imincorr from 1 to 0 and slight diddling of autocorr window.
@
text
@d1 1
a1 1
/* SUPEF: $Revision: 1.11 $ ; $Date: 90/07/12 14:18:20 $		*/
d63 5
@


1.11
log
@Optimize final convolution by not doing multiplies by known zeroses.
@
text
@d1 1
a1 1
/* SUPEF: $Revision: 1.10 $ ; $Date: 90/07/12 13:39:19 $		*/
d126 2
a127 2
	else					imincorr = 1;
	if (imincorr < 1) err("mincorr=%g too small", mincorr);
d170 1
a170 1
				register int n = MIN(imaxcorr-1, nt - icr);
d173 1
a173 1
				for (i = imincorr-1; i < n; ++i)
@


1.10
log
@Tweak
@
text
@d1 1
a1 1
/* SUPEF: $Revision: 1.9 $ ; $Date: 90/07/11 18:58:54 $		*/
a144 1
	crosscorr = autocorr + iminlag; /* pointer to "cross" correlation */
d146 5
d212 1
a212 1
		/* Convolve pefilter with trace */
d219 1
a219 1
				register float sum = 0.0;
d221 1
a221 1
				for (j = 0; j <= n; ++j)
@


1.9
log
@Make pnoise relative again.  Trap case when zero lag autocorr vanishes
and just echo input to output.
@
text
@d1 1
a1 1
/* SUPEF: $Revision: 1.8 $ ; $Date: 90/07/11 15:00:33 $		*/
d86 1
a86 1
	float *a;		/* spiking decon filter			*/
d142 1
a142 1
	a	 = ealloc1float(nlag);
d195 1
a195 1
		stoepf(nlag, autocorr, crosscorr, wiener, a);
d243 1
a243 1
				fprintf(stderr, "%10g%c", a[i],
@


1.8
log
@Had verbose stuff in there twice.
@
text
@d1 1
a1 1
/* SUPEF: $Revision: 1.7 $ ; $Date: 90/07/11 08:49:39 $		*/
d36 1
a36 1
     pnoise=0.001	additive noise level 				\n\
d58 1
a58 1
 *	CWP: Shuki, Jeff, Jack
d178 12
d191 1
a191 1
		autocorr[0] += pnoise;
@


1.7
log
@Corrected spelling of Norbert's name.  Blush.
@
text
@d1 1
a1 1
/* SUPEF: $Revision: 1.6 $ ; $Date: 90/07/10 22:59:42 $		*/
a184 18

		/* Show wiener and/or spiker on request */
		if (showwiener) {
			register int i;
			warn("wiener error filter, trace: %d", itr);
			for (i = 0; i < nlag; ++i)
				fprintf(stderr, "%10g%c", wiener[i],
					(i%6==5 || i==nlag-1) ? '\n' : ' ');
		}
		
		if (showspiker) {
			register int i;
			warn("spiking decon filter, trace: %d", itr);
			for (i = 0; i < nlag; ++i)
				fprintf(stderr, "%10g%c", a[i],
					(i%6==5 || i==nlag-1) ? '\n' : ' ');
		}

@


1.6
log
@Tweak up error traps
@
text
@d1 1
a1 1
/* SUPEF: $Revision: 1.5 $ ; $Date: 90/07/10 22:33:43 $		*/
d42 1
a42 1
     showweiner=0	=1 to show weiner filter on each trace		\n\
d50 3
a52 3
	To get the weiner filters into an ascii file:			\n\
	... | supef ... showweiner=1 2>file | ...   (sh or ksh)		\n\
	(... | supef ... showweiner=1 | ...) >&file  (csh)		\n\
d77 1
a77 1
	float *weiner;		/* Weiner error filter coefficients	*/
d84 1
a84 1
	float *crosscorr;	/* right hand side of Weiner eqs	*/
d92 1
a92 1
	int showweiner;		/* flag to display weiner filter	*/
d109 1
a109 1
	if (!getparint("showweiner",  &showweiner))	showweiner = 0;
d141 1
a141 1
	weiner	 = ealloc1float(nlag);
d182 2
a183 2
		/* Get inverse filter by Weiner-Levinson */
		stoepf(nlag, autocorr, crosscorr, weiner, a);
d186 2
a187 2
		/* Show weiner and/or spiker on request */
		if (showweiner) {
d189 1
a189 1
			warn("weiner error filter, trace: %d", itr);
d191 1
a191 1
				fprintf(stderr, "%10g%c", weiner[i],
d210 1
a210 1
				pefilter[i] = -weiner[j];
d236 2
a237 2
		/* Show weiner and/or spiker on request */
		if (showweiner) {
d239 1
a239 1
			warn("weiner error filter, trace: %d", itr);
d241 1
a241 1
				fprintf(stderr, "%10g%c", weiner[i],
@


1.5
log
@Major change of user interface to minlag, maxlag per Ken.
Also offering verbose options for listing filters.Z[?1Z
@
text
@d1 1
a1 1
/* SUPEF: $Revision: 1.4 $ ; $Date: 90/07/10 17:09:51 $		*/
d32 1
a32 1
     minlag= dt		start of prediction filter (msec)		\n\
d48 1
a48 1
	The default maxlag is:  .05*(tmax-tmin)				\n\
d61 1
a61 1
 *		page 91: maxlag < nt/10.  I took nt/20.
d116 1
d120 1
d122 2
a123 1
	if (minlag >= maxlag) err("minlag=%g, maxlag=%g", minlag, maxlag);
d127 1
a127 2
	if (imincorr < 1)
		err("correlation starts (%d) before trace (1)", imincorr);
d131 1
a131 2
	if (imaxcorr > nt)
		err("correlation ends (%d) after trace (%d)", imaxcorr, nt);
d133 3
d160 1
a160 1
		/* Form autocorrelation vector with whitening */
d230 2
d234 18
@


1.4
log
@Using the authentic cwp/lib stoepf (now altered to leave r[0] alone).
@
text
@d1 1
a1 1
/* SUPEF: $Revision: 1.3 $ ; $Date: 90/07/09 22:46:30 $		*/
d32 1
a32 1
     pgap= 0		predictive lag (msec)				\n\
d34 1
a34 1
     ptime= (see note)	length (msec) of pred. error filter (after gap)	\n\
d38 1
a38 1
     corrmin= tmin	start of autocorrelation window	(msec)		\n\
d40 1
a40 1
     corrmax= tmax	end of autocorrelation window (msec)		\n\
d42 4
d47 2
a48 2
	The default pgap = 0 is spiking deconvolution			\n\
	The default value of ptime is:  .05*(tmax-tmin)			\n\
d50 4
d60 2
a61 2
 *	A. Ziolkowski, "Deconvolution", for value of ptime default:
 *		page 91: max lag < nt/10.  I took nt/20.
d78 6
a83 6
	float pnoise;		/* pef noise level			*/
	float pgap;		/* gap in pe filter (msec)		*/
	int ngap;		/* ... in samples 			*/
	float ptime;		/* length of pe filter after gap (msec)	*/
	int ntime;		/* ... in samples			*/
	int nfilt;		/* total filter length in samples	*/ 
d86 7
a92 5
	float corrmin;		/* start time of correlation window	*/
	int icorrmin;		/* .. in samples			*/
	float corrmax;		/* end time of correlation window	*/
	int icorrmax;		/* .. in samples			*/
	float *a;		/* work space for stoepf()		*/
d109 3
d114 2
a115 7
	if (getparfloat("pgap", &pgap))		ngap = NINT(pgap/mdt);
	else					ngap = 0;
	
	if (getparfloat("ptime", &ptime))	ntime = NINT(ptime/mdt);
	else 					ntime = NINT(0.05 * nt);
	if (ntime > nt)
		err("filter (%d) is longer than trace (%d)", ntime, nt);
d117 2
a118 4
	if (getparfloat("corrmin", &corrmin))	icorrmin = NINT(corrmin/mdt);
	else					icorrmin = 1;
	if (icorrmin < 1)
		err("correlation starts (%d) before trace (1)", icorrmin);
d120 11
a130 4
	if (getparfloat("corrmax", &corrmax))	icorrmax = NINT(corrmax/mdt);
	else					icorrmax = nt;
	if (icorrmax > nt)
		err("correlation ends (%d) after trace (%d)", icorrmax, nt);
d132 1
a132 1
	nfilt = 1 + ngap + ntime;
d136 4
a139 4
	pefilter = ealloc1float(nfilt);
	weiner	 = ealloc1float(ntime);
	a	 = ealloc1float(ntime);
	autocorr = ealloc1float(nfilt);
d141 1
a141 1
	crosscorr = autocorr + ngap + 1; /* pointer to "cross" correlation */
d146 1
a146 1
		for (i = 1; i <= ngap; i++)	pefilter[i] = 0.0;
d153 3
d160 1
a160 1
			for (icr = 0; icr < nfilt; ++icr) {
d162 1
a162 1
				register int n = MIN(icorrmax-1, nt - icr);
d165 1
a165 1
				for (i = icorrmin-1; i < n; ++i)
d175 1
a175 1
		autocorr[0] *= 1.0 + pnoise;
d179 2
a180 1
		stoepf(ntime, autocorr, crosscorr, weiner, a);
d182 16
d199 1
d205 1
a205 1
			for (i = ngap+1, j = 0; i < nfilt; ++i, ++j)
d209 1
a209 1

d216 1
a216 1
				register n = MIN(i,nfilt-1); 
@


1.3
log
@Using a variant of stoepf (that I hope will soon become standard).
@
text
@d1 1
a1 1
/* SUPEF: $Revision: 1.2 $ ; $Date: 90/07/07 16:47:29 $		*/
d82 1
a82 1
	float *a;		/* work space for stoep()		*/
d163 1
a163 1
		stoep(ntime, autocorr, crosscorr, weiner, a);
@


1.2
log
@Put things in registers.
Note: v1 had sum declared as int!
@
text
@d1 1
a1 1
/* SUPEF: $Revision: 1.1 $ ; $Date: 90/07/07 14:58:07 $		*/
a54 11
 *	Press, et al, Numerical Recipes in C, section 2.8, for the toeplitz
 *		routine.  The -1 shifts in the args to toeplitz() are because
 *		the routine is written 1-based instead of 0-based.
 *
 *	The Press routine allows non-symmetric Toeplitz matrices.  That
 *	generality gets in the way here, forcing us to create an array
 *	with negative lags (rmatrix).
 *
 *	Thus, the Press routine needs to either be replaced or modified
 *	at an early time.
 *
a75 1
	float *rmatrix;		/* input vector for toeplitz routine 	*/
d82 1
d125 1
a126 1
	rmatrix  = ealloc1float(2*ntime-1);
a161 9
		/* Form matrix for toeplitz routine */
		{
			register int i;
			for (i = 0; i < ntime; i++)
				rmatrix[ntime+1-i] =
					rmatrix[i] = autocorr[ntime-1-i];
		}
		

d163 1
a163 1
		toeplitz(rmatrix-1, weiner-1, crosscorr-1, ntime);
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/* SUPEF: $Revision: 1.13 $ ; $Date: 90/07/02 13:39:30 $		*/
a94 4
	/* These will go into local block registers */
	int i, icr, n, sum, j;
	/* This is just a debugging variable */
	int itr;
a96 1

d142 4
a145 1
	for (i = 1; i <= ngap; i++)	pefilter[i] = 0.0;
d152 14
a165 7
		for (icr = 0; icr < nfilt; ++icr) {
			n = MIN(icorrmax-1, nt - icr);
			sum = 0.0;
			for (i = icorrmin-1; i < n; ++i)
				sum += intrace.data[i] * intrace.data[i+icr];
				
			autocorr[icr] = sum;
d174 6
a179 2
		for (i = 0; i < ntime; i++)
			rmatrix[ntime+1-i] = rmatrix[i] = autocorr[ntime-1-i];
d187 3
a189 2
		for (i = ngap+1, j = 0; i < nfilt; ++i, ++j)
			pefilter[i] = -weiner[j];
d191 3
d195 1
d197 2
a198 4
		for (i = 0; i < nt; ++i) {
			sum = 0.0;
			for (j = 0; j <= MIN(i,nfilt-1); ++j)
				sum += pefilter[j] * intrace.data[i-j];
d200 10
a209 1
			outtrace.data[i] = sum;
@
