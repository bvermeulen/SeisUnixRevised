head	1.26;
access;
symbols;
locks
	john:1.26; strict;
comment	@ * @;


1.26
date	2011.11.16.22.14.43;	author john;	state Exp;
branches;
next	1.25;

1.25
date	2011.11.12.00.21.33;	author john;	state Exp;
branches;
next	1.24;

1.24
date	2006.11.07.22.58.42;	author john;	state Exp;
branches;
next	1.23;

1.23
date	2005.10.04.16.42.43;	author john;	state Exp;
branches;
next	1.22;

1.22
date	2005.09.23.19.04.09;	author john;	state Exp;
branches;
next	1.21;

1.21
date	2005.09.23.16.54.15;	author john;	state Exp;
branches;
next	1.20;

1.20
date	2005.03.21.18.55.26;	author john;	state Exp;
branches;
next	1.19;

1.19
date	2005.03.01.00.10.53;	author john;	state Exp;
branches;
next	1.18;

1.18
date	2004.12.09.17.47.22;	author john;	state Exp;
branches;
next	1.17;

1.17
date	2004.12.09.17.44.56;	author john;	state Exp;
branches;
next	1.16;

1.16
date	2004.05.17.17.53.38;	author john;	state Exp;
branches;
next	1.15;

1.15
date	2003.06.09.16.17.07;	author john;	state Exp;
branches;
next	1.14;

1.14
date	97.07.28.22.36.46;	author john;	state Exp;
branches;
next	1.13;

1.13
date	97.05.05.17.35.34;	author john;	state Exp;
branches;
next	1.12;

1.12
date	96.09.13.21.49.05;	author john;	state Exp;
branches;
next	1.11;

1.11
date	96.09.10.21.01.16;	author john;	state Exp;
branches;
next	1.10;

1.10
date	96.09.10.20.53.45;	author jkc;	state Exp;
branches;
next	1.9;

1.9
date	96.01.25.22.01.33;	author jkc;	state Exp;
branches;
next	1.8;

1.8
date	95.09.27.20.24.24;	author john;	state Exp;
branches;
next	1.7;

1.7
date	95.08.03.16.34.12;	author jkc;	state Exp;
branches;
next	1.6;

1.6
date	95.08.02.20.17.13;	author jkc;	state Exp;
branches;
next	1.5;

1.5
date	95.07.26.09.34.09;	author john;	state Exp;
branches;
next	1.4;

1.4
date	95.05.30.16.30.52;	author john;	state Exp;
branches;
next	1.3;

1.3
date	95.05.03.12.41.25;	author john;	state Exp;
branches;
next	1.2;

1.2
date	95.05.03.12.33.58;	author john;	state Exp;
branches;
next	1.1;

1.1
date	95.04.13.09.46.10;	author john;	state Exp;
branches;
next	;


desc
@Kirchhoff depth migration
@


1.26
log
@added Reg Beardsley checkpar()
@
text
@/* Copyright (c) Colorado School of Mines, 2011.*/
/* All rights reserved.                       */

/* SUKDMIG2D: $Revision: 1.24 $ ; $Date: 2006/11/07 22:58:42 $	*/

#include "su.h"
#include "segy.h"

/*********************** self documentation **********************/
char *sdoc[] = {
" 									",
"SUKDMIG2D - Kirchhoff Depth Migration of 2D poststack/prestack data	",
" 									",
"    sukdmig2d  infile=  outfile=  ttfile=   [parameters] 		",
"									",
" Required parameters:							",
" infile=stdin		file for input seismic traces			",
" outfile=stdout	file for common offset migration output  	",
" ttfile=		file for input traveltime tables		",
"									",
" ...  The following 9 parameters describe traveltime tables:		",
" fzt= 			first depth sample in traveltime table		",
" nzt= 			number of depth samples in traveltime table	",
" dzt=			depth interval in traveltime table		",
" fxt=			first lateral sample in traveltime table	",
" nxt=			number of lateral samples in traveltime table	",
" dxt=			lateral interval in traveltime table		",
" fs= 			x-coordinate of first source			",
" ns= 			number of sources				",
" ds= 			x-coordinate increment of sources		",
"									",
" Optional Parameters:							",
" dt= or from header (dt) 	time sampling interval of input data	",
" ft= or from header (ft) 	first time sample of input data		",
" dxm= or from header (d2) 	sampling interval of midpoints 		",
" fzo=fzt		    z-coordinate of first point in output trace	",
" dzo=0.2*dzt		vertical spacing of output trace 		",
" nzo=5*(nzt-1)+1 	number of points in output trace		",	
" fxo=fxt		    x-coordinate of first output trace 		",
" dxo=0.5*dxt		horizontal spacing of output trace 		",
" nxo=2*(nxt-1)+1  	number of output traces 			",	
" off0=0		   	first offest in output 			",
" doff=99999		offset increment in output 			",
" noff=1	 	number of offsets in output 			",	
" absoff=0      flag for using absolute offsets of input traces		",
"               =0 means use offset=gx-sx                		",
"               =1 means use abs(gx-sx)                  		",
" limoff=0      flag for only using input traces that fall within the range",
"               of defined output offset bins (off0,doff,noff) 		",
"               =0 means use all input traces                 		",
"               =1 means limit traces used by offset           		",
" fmax=0.25/dt		frequency-highcut for input traces		",
" offmax=99999		maximum absolute offset allowed in migration 	",
" aperx=nxt*dxt/2  	migration lateral aperature 			",
" angmax=60		migration angle aperature from vertical 	",
" v0=1500(m/s)		reference velocity value at surface		",	
" dvz=0.0  		reference velocity vertical gradient		",
"									",
" ls=1			flag for line source				",
" jpfile=stderr		job print file name 				",
"									",
" mtr=100  		print verbal information at every mtr traces	",
" ntr=100000		maximum number of input traces to be migrated	",
" npv=0			flag of computing quantities for velocity analysis",
" rscale=1000.0 	scaling for roundoff error suppression		",
"									",
"   ...if npv>0 specify the following three files:			",
" tvfile=tvfile		input file of traveltime variation tables	",
"			tv[ns][nxt][nzt]				",
" csfile=csfile		input file of cosine tables cs[ns][nxt][nzt]	",
" outfile1=outfile1	file containning additional migration output   	",
"			with extra amplitude				",
"									",
" Notes:								",
" 1. Traveltime tables were generated by program rayt2d (or other ones)	",
"    on relatively coarse grids, with dimension ns*nxt*nzt. In the	",
"    migration process, traveltimes are interpolated into shot/gephone 	",
"    positions and output grids.					",
" 2. Input seismic traces must be SU format and can be any type of 	",
"    gathers (common shot, common offset, common CDP, and so on).	", 
" 3. Migrated traces are output in CDP gathers if velocity analysis	",
"    is required, with dimension nxo*noff*nzo.  			", 
" 4. If the offset value of an input trace is not in the offset array 	",
"    of output, the nearest one in the array is chosen. 		",
" 5. Memory requirement for this program is about			",
"    	[ns*nxt*nzt+noff*nxo*nzo+4*nr*nzt+5*nxt*nzt+npa*(2*ns*nxt*nzt   ",
"	+noff*nxo*nzo+4*nxt*nzt)]*4 bytes				",
"    where nr = 1+min(nxt*dxt,0.5*offmax+aperx)/dxo. 			",
" 6. Amplitudes are computed using the reference velocity profile, v(z),",
"    specified by the parameters v0= and dvz=.				",
" 7. Input traces must specify source and receiver positions via the header",
"    fields tr.sx and tr.gx. Offset is computed automatically.		",
" 8. if limoff=0, input traces from outside the range defined by off0, doff, ",
"    noff, will get migrated into the extremal offset bins/planes.  E.g. if ",
"    absoff=0 and limoff=0, all traces with gx<sx will get migrated into the ",
"    off0 bin.",
"									",
NULL};
/*
 * Author:  Zhenyue Liu, 03/01/95,  Colorado School of Mines 
 * Modifcations:
 *    Gary Billings, Talisman Energy, Sept 2005:  added absoff, limoff.
 *
 * Trace header fields accessed: ns, dt, delrt, d2
 * Trace header fields modified: sx, gx
 */
 
/**************** end self doc ***********************************/
  void resit(int nx,float fx,float dx,int nz,int nr,float dr,
	float **tb,float **t,float x0);
  void interpx(int nxt,float fxt,float dxt,int nx,float fx,float dx,
	int nzt,float **tt,float **t);
  void sum2(int nx,int nz,float a1,float a2,float **t1,float **t2,float **t);
  void timeb(int nr,int nz,float dr,float dz,float fz,float a,
	float v0,float **t,float **p,float **sig,float **ang);
  void mig2d(float *trace,int nt,float ft,float dt,
	float sx,float gx,float **mig,float aperx,
  	int nx,float fx,float dx,float nz,float fz,float dz,
	int ls,int mtmax,float dxm,float fmax,float angmax,
	float **tb,float **pb,float **cs0b,float **angb,int nr,
	float **tsum,int nzt,float fzt,float dzt,int nxt,float fxt,float dxt,
	int npv,float **cssum,float **tvsum,float **mig1);

/* define */
#define RSCALE_KDMIG 1000.0

/* segy trace */
segy tr, tro;

int
main (int argc, char **argv)
{
	int nt;		/* number of time samples in input data		*/
	int nzt;	/* number of z-values in traveltime table	*/
	int nxt;	/* number of x-values in traveltime table	*/
	int nzo;	/* number of z-values in output data		*/
	int nxo;	/* number of x-values in output data		*/
	int ns;		/* number of sources				*/
	int noff;	/* number of offsets in output data		*/
	int nr;
	int is,io,ixo,izo; /* counters */
	int ls,ntr,jtr,ktr,mtr,npv,mtmax;
	int   offset,absoff,limoff;
	off_t nseek;
	float   ft,fzt,fxt,fzo,fxo,fs,off0,dt,dzt,dxt,dzo,dxo,ds,doff,dxm,
		ext,ezt,ezo,exo,es,s,scal;	
	float v0,dvz,fmax,angmax,offmax,rmax,aperx,sx=0,gx=0;
	float ***mig=NULL,***ttab=NULL,**tb=NULL,**pb=NULL;
	float **cs0b=NULL,**angb=NULL,**tsum=NULL,**tt=NULL;
	float **tvsum=NULL,***mig1=NULL,***cs=NULL,***tv=NULL,**cssum=NULL;

	float rscale;			/* scaling factor for roundoff */
	
	char *infile="stdin",*outfile="stdout",*ttfile,*jpfile,*tvfile,
	     *csfile,*outfile1;
	FILE *infp,*outfp,*ttfp,*jpfp,*tvfp=NULL,*out1fp=NULL,*csfp=NULL;


	/* hook up getpar to handle the parameters */
	initargs(argc, argv);
	requestdoc(1);

	/* open input and output files	*/
	if( !getparstring("infile",&infile)) {
		infp = stdin;
	} else  
		if ((infp=fopen(infile,"r"))==NULL)
			err("cannot open infile=%s\n",infile);
	if( !getparstring("outfile",&outfile)) {
		outfp = stdout;
	} else  
		outfp = fopen(outfile,"w");
	efseeko(infp,(off_t) 0,SEEK_CUR);
	efseeko(outfp,(off_t) 0,SEEK_CUR);
	if( !getparstring("ttfile",&ttfile))
		err("must specify ttfile!\n");
	if ((ttfp=fopen(ttfile,"r"))==NULL)
		err("cannot open ttfile=%s\n",ttfile);
	if( !getparstring("jpfile",&jpfile)) {
		jpfp = stderr;
	} else  
		jpfp = fopen(jpfile,"w");

	/* get information from the first header */
	if (!fgettr(infp,&tr)) err("can't get first trace");
	nt = tr.ns;
	if (!getparfloat("dt",&dt)) dt = ((double) tr.dt)/1000000.0; 
	if (dt<0.0000001) err("dt must be positive!\n");
	if (!getparfloat("ft",&ft)) ft = tr.delrt/1000.0; 
 	if (!getparfloat("dxm",&dxm)) dxm = tr.d2;
	if  (dxm<0.0000001) err("dxm must be positive!\n");
	
	/* get traveltime tabel parameters	*/
	if (!getparint("nxt",&nxt)) err("must specify nxt!\n");
	if (!getparfloat("fxt",&fxt)) err("must specify fxt!\n");
	if (!getparfloat("dxt",&dxt)) err("must specify dxt!\n");
	if (!getparint("nzt",&nzt)) err("must specify nzt!\n");
	if (!getparfloat("fzt",&fzt)) err("must specify fzt!\n");
	if (!getparfloat("dzt",&dzt)) err("must specify dzt!\n");
	if (!getparint("ns",&ns)) err("must specify ns!\n");
	if (!getparfloat("fs",&fs)) err("must specify fs!\n");
	if (!getparfloat("ds",&ds)) err("must specify ds!\n");
	if (!getparfloat("rscale",&rscale))   rscale = RSCALE_KDMIG;

	ext = NINT(rscale*(fxt+(nxt-1)*dxt))/rscale;
	ezt = NINT(rscale*(fzt+(nzt-1)*dzt))/rscale;
	es = NINT(rscale*(fs+(ns-1)*ds))/rscale;

	/* optional parameters	*/
	if (!getparint("nxo",&nxo)) nxo = (nxt-1)*2+1;
	if (!getparfloat("fxo",&fxo)) fxo = fxt;
	if (!getparfloat("dxo",&dxo)) dxo = dxt*0.5;
	if (!getparint("nzo",&nzo)) nzo = (nzt-1)*5+1;
	if (!getparfloat("fzo",&fzo)) fzo = fzt;
	if (!getparfloat("dzo",&dzo)) dzo = dzt*0.2;
	exo = NINT(rscale*(fxo+(nxo-1)*dxo))/rscale;
	ezo = NINT(rscale*(fzo+(nzo-1)*dzo))/rscale;

	fprintf(jpfp," fxt=%f fxo=%f \n",fxt,fxo);
	fprintf(jpfp," ext=%f exo=%f \n",ext,exo);
	fprintf(jpfp," fzt=%f fzo=%f \n",fzt,fzo);
	fprintf(jpfp," ezt=%f ezo=%f \n",ezt,ezo);
	fprintf(jpfp," es=%f \n",es);
	fprintf(jpfp," \n");
	if(fxt>fxo || ext<exo || fzt>fzo || ezt<ezo) {
		warn("This condition must NOT be satisfied: fxt>fxo || ext<exo || fzt>fzo || ezt<ezo");
		warn("fxt=%f fxo=%f ext=%f exo=%f fzt=%f fzo=%f ezt=%f ezo=%f",
			  fxt,fxo,ext,exo,fzt,fzo,ezt,ezo);
		err(" migration output range is out of traveltime table!\n");
	  }

	if (!getparfloat("v0",&v0)) v0 = 1500;
	if (!getparfloat("dvz",&dvz)) dvz = 0;
	if (!getparfloat("angmax",&angmax)) angmax = 60.;
	if  (angmax<0.00001) err("angmax must be positive!\n");
	mtmax = 2*dxm*sin(angmax*PI/180.)/(v0*dt);
	if(mtmax<1) mtmax = 1;
	if (!getparfloat("aperx",&aperx)) aperx = 0.5*nxt*dxt;
	if (!getparfloat("offmax",&offmax)) offmax = 3000;
	if (!getparfloat("fmax",&fmax)) fmax = 0.25/dt;
	if (!getparint("noff",&noff))	noff = 1;
	if (!getparfloat("off0",&off0)) off0 = 0.;
	if (!getparfloat("doff",&doff)) doff = 99999;

	if (!getparint("ls",&ls))	ls = 1;
	if (!getparint("absoff",&absoff))   absoff=0;
	if (!getparint("limoff",&limoff))   limoff=0;
	if (!getparint("ntr",&ntr))	ntr = 100000;
	if (!getparint("mtr",&mtr))	mtr = 100;
	if (!getparint("npv",&npv))	npv = 0;
	if(npv){
		if( !getparstring("tvfile",&tvfile))
			err("must specify tvfile!\n");
 		tvfp = fopen(tvfile,"r");
		if( !getparstring("csfile",&csfile))
			err("must specify csfile!\n");
 		csfp = fopen(csfile,"r");
		if( !getparstring("outfile1",&outfile1))
			outfile1="outfile1";
 		out1fp = fopen(outfile1,"w");
	}

        checkpars();

	fprintf(jpfp,"\n");
	fprintf(jpfp," Migration parameters\n");
	fprintf(jpfp," ================\n");
	fprintf(jpfp," infile=%s \n",infile);
	fprintf(jpfp," outfile=%s \n",outfile);
	fprintf(jpfp," ttfile=%s \n",ttfile);
	fprintf(jpfp," \n");
	fprintf(jpfp," nzt=%d fzt=%g dzt=%g\n",nzt,fzt,dzt);
	fprintf(jpfp," nxt=%d fxt=%g dxt=%g\n",nxt,fxt,dxt);
 	fprintf(jpfp," ns=%d fs=%g ds=%g\n",ns,fs,ds);
	fprintf(jpfp," \n");
	fprintf(jpfp," nzo=%d fzo=%g dzo=%g\n",nzo,fzo,dzo);
	fprintf(jpfp," nxo=%d fxo=%g dxo=%g\n",nxo,fxo,dxo);
	fprintf(jpfp," \n");
	
	/* compute reference traveltime and slowness  */
	rmax = MAX(es-fxt,ext-fs);
	rmax = MIN(rmax,0.5*offmax+aperx);
	nr = 2+(int)(rmax/dxo);
	tb = ealloc2float(nzt,nr);
	pb = ealloc2float(nzt,nr);
	cs0b = ealloc2float(nzt,nr);
	angb = ealloc2float(nzt,nr);
	timeb(nr,nzt,dxo,dzt,fzt,dvz,v0,tb,pb,cs0b,angb);

	fprintf(jpfp," nt=%d ft=%g dt=%g \n",nt,ft,dt);
 	fprintf(jpfp," dxm=%g fmax=%g\n",dxm,fmax);
 	fprintf(jpfp," noff=%d off0=%g doff=%g\n",noff,off0,doff);
	fprintf(jpfp," v0=%g dvz=%g \n",v0,dvz);
 	fprintf(jpfp," aperx=%g offmax=%g angmax=%g\n",aperx,offmax,angmax);
 	fprintf(jpfp," ntr=%d mtr=%d ls=%d npv=%d\n",ntr,mtr,ls,npv);
	fprintf(jpfp," absoff=%d limoff=%d\n",absoff,limoff);
	if(npv)
 	  fprintf(jpfp," tvfile=%s csfile=%s outfile1=%s\n",
		tvfile,csfile,outfile1);
	fprintf(jpfp," ================\n");
	fflush(jpfp);

	/* allocate space */
	mig = ealloc3float(nzo,nxo,noff);
	ttab = ealloc3float(nzt,nxt,ns);
	tt = ealloc2float(nzt,nxt);
	tsum = ealloc2float(nzt,nxt);
	if(npv){
		tv = ealloc3float(nzt,nxt,ns);
		tvsum = ealloc2float(nzt,nxt);
		cs = ealloc3float(nzt,nxt,ns);
		cssum = ealloc2float(nzt,nxt);
	}
	if(!npv) 
		mig1 = ealloc3float(1,1,noff);
	else
		mig1 = ealloc3float(nzo,nxo,noff);


 	memset((void *) mig[0][0],0,noff*nxo*nzo*sizeof(float)); 
	 if(npv)
		memset((void *) mig1[0][0], 0,
			noff*nxo*nzo*sizeof(float));

 	fprintf(jpfp," input traveltime tables \n");
			     
	/* compute traveltime residual	*/
	for(is=0; is<ns; ++is){
		nseek = (off_t) nxt*nzt*is;
		efseeko(ttfp,nseek*((off_t) sizeof(float)),SEEK_SET);
		fread(ttab[is][0],sizeof(float),nxt*nzt,ttfp);
		s = fs+is*ds;
		resit(nxt,fxt,dxt,nzt,nr,dxo,tb,ttab[is],s);
		if(npv) {
			efseeko(tvfp, nseek*((off_t) sizeof(float)),SEEK_SET);
			fread(tv[is][0],sizeof(float),nxt*nzt,tvfp);
			efseeko(csfp, nseek*((off_t) sizeof(float)),SEEK_SET);
			fread(cs[is][0],sizeof(float),nxt*nzt,csfp);
		}
		
	}

	fprintf(jpfp," start migration ... \n");
	fprintf(jpfp," \n");
	fflush(jpfp);
	

	jtr = 1;
	ktr = 0;

	  fprintf(jpfp," fs=%g es=%g offmax=%g\n",fs,es,offmax);

	do {
		/* determine offset index	*/
	    float as,res;

		if (tr.scalco) { /* if tr.scalco is set, apply value */
			if (tr.scalco>0) {
				sx = tr.sx*tr.scalco;
				gx = tr.gx*tr.scalco;
		   	} else { /* if tr.scalco is negative divide */
				sx = tr.sx/ABS(tr.scalco);
				gx = tr.gx/ABS(tr.scalco);
			}
			
		} else {
			     sx = tr.sx;
			     gx = tr.gx;
		}

		/* GWB 2005.09.22: */
		/* io = (int)((gx-sx-off0)/doff+0.5); */
		offset=gx-sx;
		if( absoff && offset<0 )offset=-offset;
		io = (int)((offset-off0)/doff+0.5);
		if( limoff && (io<0 || io>=noff) ) continue;
		/* end of GWB 2005.09.22 */

	    if(io<0) io = 0;
	    if(io>=noff) io = noff-1;

		/* fprintf(jpfp," read trace jtr=%d: sx=%g gx=%g io=%d ktr=%d\n",jtr,sx,gx,io,ktr); */

	    if(MIN(sx,gx)>=fs && MAX(sx,gx)<=es && 
		 MAX(gx-sx,sx-gx)<=offmax ){
		/*     migrate this trace	*/

		    /* fprintf(jpfp," Good! Condition NOT satisfied\n"); */

	    	as = (sx-fs)/ds;
	    	is = (int)as;
		if(is==ns-1) is=ns-2;
		res = as-is;
		if(res<=0.01) res = 0.0;
		if(res>=0.99) res = 1.0;
		sum2(nxt,nzt,1-res,res,ttab[is],ttab[is+1],tsum);
		if(npv)  {
			sum2(nxt,nzt,1-res,res,tv[is],tv[is+1],tvsum);
			sum2(nxt,nzt,1-res,res,cs[is],cs[is+1],cssum);
		}
		
	    	as = (gx-fs)/ds;
	    	is = (int)as;
		if(is==ns-1) is=ns-2;
		res = as-is;
		if(res<=0.01) res = 0.0;
		if(res>=0.99) res = 1.0;
		sum2(nxt,nzt,1-res,res,ttab[is],ttab[is+1],tt);
		sum2(nxt,nzt,1,1,tt,tsum,tsum);
		if(npv)  {
			sum2(nxt,nzt,1-res,res,tv[is],tv[is+1],tt);
			sum2(nxt,nzt,1,1,tt,tvsum,tvsum);
			sum2(nxt,nzt,1-res,res,cs[is],cs[is+1],tt);
			sum2(nxt,nzt,1,1,tt,cssum,cssum);
		}

		mig2d(tr.data,nt,ft,dt,sx,gx,mig[io],aperx,
		  nxo,fxo,dxo,nzo,fzo,dzo,
		  ls,mtmax,dxm,fmax,angmax,
		  tb,pb,cs0b,angb,nr,tsum,nzt,fzt,dzt,nxt,fxt,dxt,
		  npv,cssum,tvsum,mig1[io]);

		  ktr++;
		  if((jtr-1)%mtr ==0 ){
			fprintf(jpfp," migrated trace %d\n",jtr);
			fflush(jpfp);
	    	}
	    }
	    jtr++;
	} while (fgettr(infp,&tr) && jtr<ntr);

	fprintf(jpfp," migrated %d traces in total\n",ktr);

	memset((void *) &tro, 0, sizeof(segy));
	tro.ns = nzo;
	tro.d1 = dzo;
	tro.dt = 1000*(int)(1000*dt+0.5);
	tro.delrt = 0.0;
	tro.f1 = fzo;
	tro.f2 = fxo;
	tro.d2 = dxo;
	tro.trid = 200;

	scal = 4/sqrt(PI)*dxm/v0;
	for(ixo=0; ixo<nxo; ixo++) {
		for(io=0; io<noff; io++)  {
			memcpy((void *) tro.data,
				 (const void *) mig[io][ixo], nzo*sizeof(float));
			tro.offset = off0+io*doff;
			tro.tracr = 1+ixo;
			tro.tracl = 1+io+noff*ixo;
			tro.cdp = fxo+ixo*dxo;
			tro.cdpt = 1+io;

			for(izo=0; izo<nzo; ++izo)
				tro.data[izo] *=scal;

			/* write out */
			fputtr(outfp,&tro); 

		   if(npv){
			memcpy((void *) tro.data,
				 (const void *) mig1[io][ixo],nzo*sizeof(float));
			for(izo=0; izo<nzo; ++izo)
				tro.data[izo] *=scal;
			/* write out */
			fputtr(out1fp,&tro); 
		    }		 
		}
	}

	fprintf(jpfp," \n");
	fprintf(jpfp," output done\n");
	fflush(jpfp);

	efclose(jpfp);
	efclose(outfp);

	    
	free2float(tsum);
	free2float(tt);
	free2float(pb);
	free2float(tb);
	free2float(cs0b);
	free2float(angb);
	free3float(ttab);
	free3float(mig);
	free3float(mig1);
	if(npv){
		free3float(tv);
		free3float(cs);
		free2float(tvsum);
		free2float(cssum);
	}
	return(CWP_Exit());
}

/* residual traveltime calculation based  on reference   time	*/
  void resit(int nx,float fx,float dx,int nz,int nr,float dr,
		float **tb,float **t,float x0)
{
	int ix,iz,jr;
	float xi,ar,sr,sr0;

	for(ix=0; ix<nx; ++ix){
		xi = fx+ix*dx-x0;
		ar = abs(xi)/dr;
		jr = (int)ar;
		sr = ar-jr;
		sr0 = 1.0-sr;
		if(jr>nr-2) jr = nr-2;
		for(iz=0; iz<nz; ++iz)
			t[ix][iz] -= sr0*tb[jr][iz]+sr*tb[jr+1][iz];
	}
} 

/* lateral interpolation	*/

/* sum of two tables	*/
  void sum2(int nx,int nz,float a1,float a2,float **t1,float **t2,float **t)
{
	int ix,iz;

	for(ix=0; ix<nx; ++ix) 
		for(iz=0; iz<nz; ++iz)
			t[ix][iz] = a1*t1[ix][iz]+a2*t2[ix][iz];
}
 
/* compute  reference traveltime and slowness	*/
	void timeb(int nr,int nz,float dr,float dz,float fz,float a,
	float v0,float **t,float **p,float **cs0,float **ang)
{
	int  ir,iz;
	float r,z,v,rc,oa,temp,rou,zc;


	if( a==0.0) {
		for(ir=0,r=0;ir<nr;++ir,r+=dr)
			for(iz=0,z=fz;iz<nz;++iz,z+=dz){
				rou = sqrt(r*r+z*z);
				if(rou<dz) rou = dz;
				t[ir][iz] = rou/v0;
				p[ir][iz] = r/(rou*v0);
				cs0[ir][iz] = z/rou;
				ang[ir][iz] = asin(r/rou);
			}
	} else {
		oa = 1.0/a; 	zc = v0*oa;
		for(ir=0,r=0;ir<nr;++ir,r+=dr)
			for(iz=0,z=fz+zc;iz<nz;++iz,z+=dz){
				rou = sqrt(r*r+z*z);
				v = v0+a*(z-zc);
				if(ir==0){ 
					t[ir][iz] = log(v/v0)*oa;
					p[ir][iz] = 0.0;
					ang[ir][iz] = 0.0;
					cs0[ir][iz] = 1.0;
				} else {
					rc = (r*r+z*z-zc*zc)/(2.0*r);
					rou = sqrt(zc*zc+rc*rc);
					t[ir][iz] = log((v*(rou+rc))
						/(v0*(rou+rc-r)))*oa;
					p[ir][iz] = sqrt(rou*rou-rc*rc)
						/(rou*v0);
					temp = v*p[ir][iz];
					if(temp>1.0) temp = 1.0;
					ang[ir][iz] = asin(temp);
					cs0[ir][iz] = rc/rou;
				}
			}
	}
}

void filt(float *trace,int nt,float dt,float fmax,int ls,int m,float *trf);

  void mig2d(float *trace,int nt,float ft,float dt,
	float sx,float gx,float **mig,float aperx,
  	int nx,float fx,float dx,float nz,float fz,float dz,
	int ls,int mtmax,float dxm,float fmax,float angmax,
	float **tb,float **pb,float **cs0b,float **angb,int nr,
	float **tsum,int nzt,float fzt,float dzt,int nxt,float fxt,float dxt,
	int npv,float **cssum,float **tvsum,float **mig1)
/*****************************************************************************
Migrate one trace 
******************************************************************************
Input:
*trace		one seismic trace 
nt		number of time samples in seismic trace
ft		first time sample of seismic trace
dt		time sampleing interval in seismic trace
sx,gx		lateral coordinates of source and geophone 
aperx		lateral aperature in migration
nx,fx,dx,nz,fz,dz	dimension parameters of migration region
ls		=1 for line source; =0 for point source
mtmax		number of time samples in triangle filter
dxm		midpoint sampling interval
fmax		frequency-highcut for input trace	 
angmax		migration angle aperature from vertical 	 
tb,pb,cs0b,angb		reference traveltime, lateral slowness, cosine of 
		incident angle, and emergent angle
nr		number of lateral samples in reference quantities
tsum		sum of residual traveltimes from shot and receiver
nxt,fxt,dxt,nzt,fzt,dzt		dimension parameters of traveltime table
npv=0		flag of computing quantities for velocity analysis
cssume		sum of cosine of emergence angles from shot and recerver 
tvsum		sum of  traveltime variations from shot and recerver 

Output:
mig		migrated section
mig1		additional migrated section for velocity analysis if npv>0
*****************************************************************************/
{
	int nxf,nxe,nxtf,nxte,ix,iz,iz0,izt0,nzp,jrs,jrg,jz,jt,mt,jx;
	float xm,x,dis,rxz,ar,srs,srg,srs0,srg0,sigp,z0,rdz,ampd,res0,
		angs,angg,cs0s,cs0g,ax,ax0,pmin,
		odt=1.0/dt,pd,az,sz,sz0,at,td,res,temp;
	float **tmt,**ampt,**ampti,**ampt1=NULL,*tm,*amp,*ampi,*amp1=NULL,
		*tzt,*trf,*zpt;

	tmt = alloc2float(nzt,nxt);
	ampt = alloc2float(nzt,nxt);
	ampti = alloc2float(nzt,nxt);
	tm = alloc1float(nzt);
	tzt = alloc1float(nzt);
	amp = alloc1float(nzt);
	ampi = alloc1float(nzt);
	zpt = alloc1float(nxt);
	trf = alloc1float(nt+2*mtmax);
	if(npv) {
		ampt1 = alloc2float(nzt,nxt);
		amp1 = alloc1float(nzt);
	}

	z0 = (fz-fzt)/dzt;
	rdz = dz/dzt;
	pmin = 1.0/(2.0*dxm*fmax);
	
	filt(trace,nt,dt,fmax,ls,mtmax,trf);

	xm = 0.5*(sx+gx);
	rxz = (angmax==90)?0.0:1.0/tan(angmax*PI/180.);
	nxtf = (xm-aperx-fxt)/dxt;
	if(nxtf<0) nxtf = 0;
	nxte = (xm+aperx-fxt)/dxt+1;
	if(nxte>=nxt) nxte = nxt-1;

	/* compute amplitudes and filter length	*/
	for(ix=nxtf; ix<=nxte; ++ix){
		x = fxt+ix*dxt;
		dis = (xm>=x)?xm-x:x-xm;
		izt0 = ((dis-dxt)*rxz-fzt)/dzt-1;
		if(izt0<0) izt0 = 0;
		if(izt0>=nzt) izt0 = nzt-1;

		ar = (sx>=x)?(sx-x)/dx:(x-sx)/dx;
		jrs = (int)ar;
		if(jrs>nr-2) jrs = nr-2;
		srs = ar-jrs;
		srs0 = 1.0-srs;
		ar = (gx>=x)?(gx-x)/dx:(x-gx)/dx;
		jrg = (int)ar;
		if(jrg>nr-2) jrg = nr-2;
		srg = ar-jrg;
		srg0 = 1.0-srg;
		sigp = ((sx-x)*(gx-x)>0)?1.0:-1.0;
		zpt[ix] = fzt+(nzt-1)*dzt;

		for(iz=izt0; iz<nzt; ++iz){
			angs = srs0*angb[jrs][iz]+srs*angb[jrs+1][iz]; 
			angg = srg0*angb[jrg][iz]+srg*angb[jrg+1][iz]; 
			cs0s = srs0*cs0b[jrs][iz]+srs*cs0b[jrs+1][iz]; 
			cs0g = srg0*cs0b[jrg][iz]+srg*cs0b[jrg+1][iz]; 
			ampd = (cs0s+cs0g)*cos(0.5*(angs-angg));
			if(ampd<0.0) ampd = -ampd;
			ampt[ix][iz] = ampd;

			pd = srs0*pb[jrs][iz]+srs*pb[jrs+1][iz]+sigp 
			     *(srg0*pb[jrg][iz]+srg*pb[jrg+1][iz]);
			if(pd<0.0) pd = -pd;
			temp = pd*dxm*odt;
			if(temp<1) temp = 1.0;
			if(temp>mtmax) temp = mtmax;
			ampti[ix][iz] = ampd/(temp*temp);
			tmt[ix][iz] = temp;
			if(pd<pmin && zpt[ix]>fzt+(nzt-1.1)*dzt) 
				zpt[ix] = fzt+iz*dzt;

		    if(npv){
			if(cssum[ix][iz]<1.0) 
			     ampt1[ix][iz] = 0; 
			else 
			     ampt1[ix][iz] = tvsum[ix][iz]/cssum[ix][iz];
		    }
		}
	}

	nxf = (xm-aperx-fx)/dx+0.5;
	if(nxf<0) nxf = 0;
	nxe = (xm+aperx-fx)/dx+0.5;
	if(nxe>=nx) nxe = nx-1;
	
	/* interpolate amplitudes and filter length along lateral	*/
	for(ix=nxf; ix<=nxe; ++ix){
		x = fx+ix*dx;
		dis = (xm>=x)?xm-x:x-xm;
		izt0 = (dis*rxz-fzt)/dzt;
		if(izt0<0) izt0 = 0;
		if(izt0>=nzt) izt0 = nzt-1;
		iz0 = (dis*rxz-fz)/dz;
		if(iz0<0) iz0 = 0;
		if(iz0>=nz) iz0 = nz-1;

		ax = (x-fxt)/dxt;
		jx = (int)ax;
		ax = ax-jx;
		if(ax<=0.01) ax = 0.;
		if(ax>=0.99) ax = 1.0;
		ax0 = 1.0-ax;
		if(jx>nxte-1) jx = nxte-1;
		if(jx<nxtf) jx = nxtf;

		ar = (sx>=x)?(sx-x)/dx:(x-sx)/dx;
		jrs = (int)ar;
		if(jrs>nr-2) jrs = nr-2;
		srs = ar-jrs;
		srs0 = 1.0-srs;
		ar = (gx>=x)?(gx-x)/dx:(x-gx)/dx;
		jrg = (int)ar;
		if(jrg>nr-2) jrg = nr-2;
		srg = ar-jrg;
		srg0 = 1.0-srg;

		for(iz=izt0; iz<nzt; ++iz){
		    tzt[iz] = ax0*tsum[jx][iz]+ax*tsum[jx+1][iz]
				+srs0*tb[jrs][iz]+srs*tb[jrs+1][iz]
				+srg0*tb[jrg][iz]+srg*tb[jrg+1][iz];

		    amp[iz] = ax0*ampt[jx][iz]+ax*ampt[jx+1][iz];
		    ampi[iz] = ax0*ampti[jx][iz]+ax*ampti[jx+1][iz];
		    tm[iz] = ax0*tmt[jx][iz]+ax*tmt[jx+1][iz];

		    if(npv) 
		    	amp1[iz] = ax0*ampt1[jx][iz]+ax*ampt1[jx+1][iz];

		}

		nzp = (ax0*zpt[jx]+ax*zpt[jx+1]-fz)/dz+1.5;
		if(nzp<iz0) nzp = iz0;
		if(nzp>nz) nzp = nz;

		/* interpolate along depth if operater aliasing 	*/
		for(iz=iz0; iz<nzp; ++iz) {
			az = z0+iz*rdz;
			jz = (int)az;
			if(jz>=nzt-1) jz = nzt-2;
			sz = az-jz;
			sz0 = 1.0-sz;
			td = sz0*tzt[jz]+sz*tzt[jz+1];
			at = (td-ft)*odt+mtmax;
			jt = (int)at;
			if(jt > mtmax && jt < nt+mtmax-1){
			    ampd = sz0*ampi[jz]+sz*ampi[jz+1];
			    mt = (int)(0.5+sz0*tm[jz]+sz*tm[jz+1]);
			    res = at-jt;
			    res0 = 1.0-res;
 			    temp = (res0*(-trf[jt-mt]+2.0*trf[jt]-trf[jt+mt]) 
				+res*(-trf[jt-mt+1]+2.0*trf[jt+1]
				-trf[jt+mt+1]))*ampd;
			    mig[ix][iz] += temp;

			    if(npv) 
				mig1[ix][iz]  += temp
					*(sz0*amp1[jz]+sz*amp1[jz+1]);
			}
		}

		/* interpolate along depth if not operater aliasing 	*/
		for(iz=nzp; iz<nz; ++iz) {
			az = z0+iz*rdz;
			jz = (int)az;
			if(jz>=nzt-1) jz = nzt-2;
			sz = az-jz;
			sz0 = 1.0-sz;
			td = sz0*tzt[jz]+sz*tzt[jz+1];
			at = (td-ft)*odt;
			jt = (int)at;
			if(jt > 0 && jt < nt-1){
			    ampd = sz0*amp[jz]+sz*amp[jz+1];
			    res = at-jt;
			    res0 = 1.0-res;
 			    temp = (res0*trace[jt]+res*trace[jt+1])*ampd; 
			    mig[ix][iz] += temp;
			    if(npv) 
				mig1[ix][iz]  += temp
					*(sz0*amp1[jz]+sz*amp1[jz+1]);
			}
		}

	}

	free2float(ampt);
	free2float(ampti);
	free2float(tmt);
	free1float(amp);
	free1float(ampi);
	free1float(zpt);
	free1float(tm);
	free1float(tzt);
	free1float(trf);
	if(npv) {
		free1float(amp1);
		free2float(ampt1);
	}
}

void filt(float *trace,int nt,float dt,float fmax,int ls,int m,float *trf)
/* Low-pass filter, integration and phase shift for input data	 
   input: 
    trace(nt)	single seismic trace
   fmax	high cut frequency
    ls		ls=1, line source; ls=0, point source
  output:
    trace(nt) 	filtered and phase-shifted seismic trace 
    tracei(nt) 	filtered, integrated and phase-shifted seismic trace 
 */
{
	static int nfft=0, itaper, nw, nwf;
	static float *taper, *amp, *ampi, dw;
	int  it, iw, itemp;
	float temp, ftaper, const2, *rt;
	complex *ct;

	fmax *= 2.0*PI;
	ftaper = 0.1*fmax;
	const2 = sqrt(2.0);

	if(nfft==0) {
	  	/* Set up FFT parameters */
	  	nfft = npfaro(nt+m, 2 * (nt+m));
	  	if (nfft >= SU_NFLTS || nfft >= 720720)
		    	err("Padded nt=%d -- too big", nfft);

	  	nw = nfft/2 + 1;
		dw = 2.0*PI/(nfft*dt);

		itaper = 0.5+ftaper/dw;
		taper = ealloc1float(2*itaper+1);
		for(iw=-itaper; iw<=itaper; ++iw){
			temp = (float)iw/(1.0+itaper); 
			taper[iw+itaper] = (1-temp)*(1-temp)*(temp+2)/4;
		}

		nwf = 0.5+fmax/dw;
		if(nwf>nw-itaper-1) nwf = nw-itaper-1;
		amp = ealloc1float(nwf+itaper+1);
		ampi = ealloc1float(nwf+itaper+1);
		amp[0] = ampi[0] = 0.;
		for(iw=1; iw<=nwf+itaper; ++iw){
			amp[iw] = sqrt(dw*iw)/nfft;
			ampi[iw] = 0.5/(1-cos(iw*dw*dt));
		}
	}

	  /* Allocate fft arrays */
	  rt   = ealloc1float(nfft);
	  ct   = ealloc1complex(nw);

	  memcpy(rt, trace, nt*FSIZE);
	  memset((void *) (rt + nt), (int) '\0', (nfft-nt)*FSIZE); 
	  pfarc(1, nfft, rt, ct);

	for(iw=nwf-itaper;iw<=nwf+itaper;++iw){
		itemp = iw-(nwf-itaper);
		ct[iw].r = taper[itemp]*ct[iw].r; 
		ct[iw].i = taper[itemp]*ct[iw].i; 
	}
	for(iw=nwf+itaper+1;iw<nw;++iw){
		ct[iw].r = 0.; 
		ct[iw].i = 0.; 
	}

	 	if(!ls){
		for(iw=0; iw<=nwf+itaper; ++iw){
			/* phase shifts PI/4 	*/
			temp = (ct[iw].r-ct[iw].i)*amp[iw]*const2;
			ct[iw].i = (ct[iw].r+ct[iw].i)*amp[iw]*const2;
			ct[iw].r = temp;
		    }
	} else {
		for(iw=0; iw<=nwf+itaper; ++iw){
			ct[iw].i = ct[iw].i*amp[iw];
			ct[iw].r = ct[iw].r*amp[iw];
		}
	}		  
	  pfacr(-1, nfft, ct, rt);
		
	  /* Load traces back in */
	for (it=0; it<nt; ++it) trace[it] = rt[it];

	  /* Integrate traces   */
	for(iw=0; iw<=nwf+itaper; ++iw){
		ct[iw].i = ct[iw].i*ampi[iw];
		ct[iw].r = ct[iw].r*ampi[iw];
	}
	  pfacr(-1, nfft, ct, rt);
	  for (it=0; it<m; ++it)  trf[it] = rt[nfft-m+it];
	  for (it=0; it<nt+m; ++it)  trf[it+m] = rt[it];

	free1float(rt);
	free1complex(ct);
}



@


1.25
log
@copyright
@
text
@d263 2
@


1.24
log
@changed    memset( .., (int) '\0',...) to memset( .., 0,..) as per suggestion of Marion Zhu and Reg Beardsley
@
text
@d1 4
a4 1
/* SUKDMIG2D: $Revision: 1.23 $ ; $Date: 2005/10/04 16:42:43 $	*/
@


1.23
log
@4 Oct 2005
@
text
@d1 1
a1 1
/* SUKDMIG2D: $Revision: 1.22 $ ; $Date: 2005/09/23 19:04:09 $	*/
d315 1
a315 1
 	memset((void *) mig[0][0],(int) '\0',noff*nxo*nzo*sizeof(float)); 
d317 1
a317 1
		memset((void *) mig1[0][0], (int)'\0',
d429 1
a429 1
	memset((void *) &tro, (int) '\0', sizeof(segy));
@


1.22
log
@Gary Billings' modifications to deal with problems of offsets positive and negative
@
text
@d1 1
a1 1
/* SUKDMIG2D: $Revision: 1.21 $ ; $Date: 2005/09/23 16:54:15 $	*/
d41 4
a44 4
" noff=1	 		number of offsets in output 		",	
" absoff=0      flag for using absolute offsets of input traces",
"               =0 means use offset=gx-sx                ",
"               =1 means use abs(gx-sx)                  ",
d46 3
a48 3
"               of defined output offset bins (off0,doff,noff) ",
"               =0 means use all input traces                  ",
"               =1 means limit traces used by offset           ",
d55 2
a56 1
" ls=1			    flag for line source			",
d62 2
d130 10
a139 2
	int 	nt,nzt,nxt,nzo,nxo,ns,noff,nr,is,io,ixo,izo;
	int 	ls,ntr,jtr,ktr,mtr,npv,mtmax;
d145 3
a147 3
	float ***mig,***ttab,**tb,**pb,**cs0b,**angb,**tsum,**tt;
	float **tvsum=NULL,***mig1=NULL,***cs=NULL,***tv=NULL,
		**cssum=NULL;
d213 9
a221 2
	exo = fxo+(nxo-1)*dxo;
	ezo = fzo+(nzo-1)*dzo;
d224 1
a224 1
		warn("fxt=%g fxo=%g ext=%g exo=%g fzt=%g fzo=%g ezt=%g ezo=%g",
@


1.21
log
@small changes, rscale some documentation
@
text
@d1 1
a1 1
/* SUKDMIG2D: $Revision: 1.20 $ ; $Date: 2005/03/21 18:55:26 $	*/
d42 7
d87 4
d95 2
d129 1
d225 2
d273 1
d348 8
a355 1
	    io = (int)((gx-sx-off0)/doff+0.5);
@


1.20
log
@put tr.d
tr.scalco stuff back in
@
text
@d1 1
a1 1
/* SUKDMIG2D: $Revision: 1.18 $ ; $Date: 2004/12/09 17:47:22 $	*/
d11 1
a11 1
"    sukdmig2d  infile=  outfile=  [parameters] 			",
d17 2
a18 1
"   The following 9 parameters describe traveltime tables:		",
d31 1
a31 1
" ft= or from header (ft) 	first time sample of input data	",
d33 1
a33 1
" fzo=fzt		    z-coordinate of first point in output trace 	",
d39 1
a39 1
" off0=0		   	first offest in output 				",
d41 1
a41 1
" noff=1	 		number of offsets in output 			",	
d48 1
a48 1
" ls=1			    flag for line source				",
d50 1
d58 1
a58 1
" dataout1=dataout1	file containning additional migration output   	",
d105 3
d123 2
d126 2
a127 2
	char *datain="stdin",*dataout="stdout",*ttfile,*jpfile,*tvfile,
	     *csfile,*dataout1;
d136 1
a136 1
	if( !getparstring("datain",&datain)) {
d139 3
a141 3
		if ((infp=fopen(datain,"r"))==NULL)
			err("cannot open datain=%s\n",datain);
	if( !getparstring("dataout",&dataout)) {
d144 1
a144 1
		outfp = fopen(dataout,"w");
d175 5
a179 3
	ext = fxt+(nxt-1)*dxt;
	ezt = fzt+(nzt-1)*dzt;
	es = fs+(ns-1)*ds;
d221 3
a223 3
		if( !getparstring("dataout1",&dataout1))
			dataout1="dataout1";
 		out1fp = fopen(dataout1,"w");
d229 2
a230 2
	fprintf(jpfp," datain=%s \n",datain);
	fprintf(jpfp," dataout=%s \n",dataout);
d258 2
a259 2
 	  fprintf(jpfp," tvfile=%s csfile=%s dataout1=%s\n",
		tvfile,csfile,dataout1);
@


1.19
log
@modified to make correct use of sc al
scalco
@
text
@d32 1
a32 1
" fzo=fzt                z-coordinate of first point in output trace 	",
d35 1
a35 1
" fxo=fxt                x-coordinate of first output trace 		",
d38 1
a38 1
" off0=0               	first offest in output 				",
d40 1
a40 1
" noff=1       		number of offsets in output 			",	
d47 1
a47 1
" ls=1	                flag for line source				",
d182 3
a184 3
            warn("This condition must NOT be satisfied: fxt>fxo || ext<exo || fzt>fzo || ezt<ezo");
            warn("fxt=%g fxo=%g ext=%g exo=%g fzt=%g fzo=%g ezt=%g ezo=%g",
                    fxt,fxo,ext,exo,fzt,fzo,ezt,ezo);
d186 1
a186 1
        }
d277 1
a277 1
                       
d302 1
a302 4
        fprintf(jpfp," fs=%g es=%g offmax=%g\n",fs,es,offmax);
        fprintf(jpfp," Must NOT satisfy this: if(MIN(sx,gx)>=fs && MAX(sx,gx)<=es && MAX(gx-sx,sx-gx)<=offmax )\n");

		
d308 12
a319 9
		if (tr.scalco > 0 ) {
	    		sx = tr.sx*tr.scalco;
	    		gx = tr.gx*tr.scalco;
		} else if (tr.scalco < 0) {
	    		sx = tr.sx/ABS(tr.scalco);
	    		gx = tr.gx/ABS(tr.scalco);
		} else if (tr.scalco == 0) {
			sx = tr.sx;
			gx = tr.gx;
d326 1
a326 1
            /* fprintf(jpfp," read trace jtr=%d: sx=%g gx=%g io=%d ktr=%d\n",jtr,sx,gx,io,ktr); */
d329 1
a329 1
	       MAX(gx-sx,sx-gx)<=offmax ){
d332 1
a332 1
                /* fprintf(jpfp," Good! Condition NOT satisfied\n"); */
d367 2
a368 2
	        ktr++;
	        if((jtr-1)%mtr ==0 ){
d392 1
a392 1
			       (const void *) mig[io][ixo], nzo*sizeof(float));
d407 1
a407 1
			       (const void *) mig1[io][ixo],nzo*sizeof(float));
d474 1
a474 1
      void timeb(int nr,int nz,float dr,float dz,float fz,float a,
d559 2
a560 2
	      angs,angg,cs0s,cs0g,ax,ax0,pmin,
	      odt=1.0/dt,pd,az,sz,sz0,at,td,res,temp;
d782 4
a785 4
        	/* Set up FFT parameters */
        	nfft = npfaro(nt+m, 2 * (nt+m));
        	if (nfft >= SU_NFLTS || nfft >= 720720)
                	err("Padded nt=%d -- too big", nfft);
d787 1
a787 1
        	nw = nfft/2 + 1;
d808 7
a814 7
        /* Allocate fft arrays */
        rt   = ealloc1float(nfft);
        ct   = ealloc1complex(nw);

        memcpy(rt, trace, nt*FSIZE);
        memset((void *) (rt + nt), (int) '\0', (nfft-nt)*FSIZE); 
        pfarc(1, nfft, rt, ct);
d826 1
a826 1
       	if(!ls){
d838 2
a839 2
	}              
        pfacr(-1, nfft, ct, rt);
d841 1
a841 1
        /* Load traces back in */
d844 1
a844 1
        /* Integrate traces   */
d849 3
a851 3
        pfacr(-1, nfft, ct, rt);
        for (it=0; it<m; ++it)  trf[it] = rt[nfft-m+it];
        for (it=0; it<nt+m; ++it)  trf[it+m] = rt[it];
@


1.18
log
@zhaobo's version
@
text
@d1 1
a1 1
/* SUKDMIG2D: $Revision: 1.15 $ ; $Date: 2003/06/09 16:17:07 $	*/
d114 1
a114 1
	float v0,dvz,fmax,angmax,offmax,rmax,aperx,sx,gx;
d305 2
d310 12
a321 2
	    sx = tr.sx/1000;
	    gx = tr.gx/1000;
@


1.17
log
@9 dec version
@
text
@d1 1
a1 1
/* SUKDMIG2D: $Revision: 1.16 $ ; $Date: 2004/05/17 17:53:38 $	*/
d18 1
a18 1
" fzt=			first depth sample in traveltime table		",
d24 1
a24 1
" fs=			x-coordinate of first source			",
d29 3
a31 4
" dt=or from header (dt) 	time sampling interval of input data	",
" ft=or from header (f1) 	first time sample of input data		",
" dxm=or from header (d2) 	sampling interval of midpoints 		",
" verbose=0		silent =1 chatty				",
a84 7
 *
 * The code reads traveltime tables first which
 * are calculated by rayt2d or other programs. Then for each input seismic
 * trace, the code interpolates traveltime table at that trace location. Then
 * spreads the seismic trace into output grids according to traveltime values.
 * The amplitude treatment is very simple.
 *
d109 9
a117 89
	int nt=0;
	int nzt=0;
	int nxt=0;
	int nzo=0;
	int nxo=0;

	int ns=0;
	int noff=0;
	int nr=0;

	int is=0;
	int io=0;
	int ixo=0;
	int izo=0;

	int ls=0;
	int ntr=0;
	int jtr=0;
	int ktr=0;
	int mtr=0;

	int npv=0;
	int mtmax=0;
	int verbose=0;
	off_t nseek=0;
	float ft=0.0;
	float fzt=0.0;
	float fxt=0.0;
	float fzo=0.0;
	float fxo=0.0;
	float fs=0.0;
	float off0=0.0;
	float dt=0.0;
	float dzt=0.0;
	float dxt=0.0;
	float dzo=0.0;
	float dxo=0.0;
	float ds=0.0;
	float doff=0.0;
	float dxm=0.0;
	float ext=0.0;
	float ezt=0.0;
	float ezo=0.0;
	float exo=0.0;

	float es=0.0;
	float s=0.0;
	float scal=0.0;

	float v0=0.0;
	float dvz=0.0;

	float fmax=0.0;
	float angmax=0.0;
	float offmax=0.0;
	float rmax=0.0;
	float aperx=0.0;
	float sx=0.0;
	float gx=0.0;

	float ***mig=NULL;
	float ***ttab=NULL;
	float **tb=NULL;
	float **pb=NULL;
	float **cs0b=NULL;
	float **angb=NULL;
	float **tsum=NULL;
	float **tt=NULL;
	float **tvsum=NULL;
	float ***mig1=NULL;
	float ***cs=NULL;
	float ***tv=NULL;
	float **cssum=NULL;
	
	char *datain="stdin";
	char *dataout="stdout";
	char *ttfile=NULL;
	char *jpfile=NULL;
	char *tvfile=NULL;
	char *csfile=NULL;
	char *dataout1=NULL;

	FILE *infp=NULL;
	FILE *outfp=NULL;
	FILE *ttfp=NULL;
	FILE *jpfp=NULL;
	FILE *tvfp=NULL;
	FILE *out1fp=NULL;
	FILE *csfp=NULL;
d119 5
d129 1
a129 1
	if (!getparstring("datain",&datain)) {
d136 1
a136 1
	} else {  
a137 2
	}

d146 1
a146 1
	} else {
a147 1
	}
a167 1

a172 1
	if (!getparint("verbose",&verbose))	verbose=0;
d182 5
a186 8
		if (verbose) {
			if (fxt>fxo) warn("fxt = %f < fxo = %f", fxt,fxo);
			if (ext>exo) warn("ext = %f > exo = %f", ext,exo);
			if (fzt>fzo) warn("fzt = %f < fzo = %f", fzt,fzo);
			if (ezt<ezo) warn("ezt = %f > ezo = %f", ezt,ezo);
			err(" migration output range is out of traveltime table!\n");
		}
	}
d206 1
a206 1
		if (!getparstring("tvfile",&tvfile))
a207 1

d209 1
a209 2

		if (!getparstring("csfile",&csfile))
d212 1
a212 2

		if (!getparstring("dataout1",&dataout1))
d265 1
a265 1
	if(!npv) {
d267 1
a267 1
	} else {
a268 1
	}
d301 4
d308 2
a309 2
	    sx = tr.sx*10^tr.scalco;
	    gx = tr.gx*10^tr.scalco;
d314 2
d319 3
d355 1
a355 1
	        ++ktr;
d387 2
a388 1
			for(izo=0; izo<nzo; ++izo) tro.data[izo] *=scal;
d434 2
a435 7
	int ix=0;
	int iz=0;
	int jr=0;
	float xi=0.0;
	float ar=0.0;
	float sr=0.0;
	float sr0=0.0;
d454 1
a454 2
	int ix=0;
	int iz=0;
d465 2
a466 10
	int ir=0;
	int iz=0;
	float r=0.0;
	float z=0.0;
	float v=0.0;
	float rc=0.0;
	float oa=0.0;
	float temp=0.0;
	float rou=0.0;
	float zc;
d469 1
a469 1
	if(a==0.0) {
d545 1
a545 20
	int nxf=0;
	int nxe=0;
	int nxtf=0;
	int nxte=0;

	int ix=0;
	int iz=0;
	int iz0=0;
	int izt0=0;

	int nzp=0;

	int jrs=0;
	int jrg=0;
	int jz=0;
	int jt=0;

	int mt=0;
	int jx=0;

@


1.16
log
@cosmetic, initializations
@
text
@d1 1
a1 1
/* SUKDMIG2D: $Revision: 1.15 $ ; $Date: 2003/06/09 16:17:07 $	*/
d86 7
d399 2
a400 2
	    sx = tr.sx;
	    gx = tr.gx;
@


1.15
log
@9 June 2003
@
text
@d1 1
a1 1
/* SUKDMIG2D: $Revision: 1.14 $ ; $Date: 1997/07/28 22:36:46 $	*/
d16 1
a16 1
" ttfile		file for input traveltime tables		",
d18 9
a26 9
" fzt 			first depth sample in traveltime table		",
" nzt 			number of depth samples in traveltime table	",
" dzt			depth interval in traveltime table		",
" fxt			first lateral sample in traveltime table	",
" nxt			number of lateral samples in traveltime table	",
" dxt			lateral interval in traveltime table		",
" fs 			x-coordinate of first source			",
" ns 			number of sources				",
" ds 			x-coordinate increment of sources		",
d29 4
a32 3
" dt= or from header (dt) 	time sampling interval of input data	",
" ft= or from header (ft) 	first time sample of input data	",
" dxm= or from header (d2) 	sampling interval of midpoints 		",
d110 89
a198 9
	int 	nt,nzt,nxt,nzo,nxo,ns,noff,nr,is,io,ixo,izo;
	int 	ls,ntr,jtr,ktr,mtr,npv,mtmax;
	off_t nseek;
	float   ft,fzt,fxt,fzo,fxo,fs,off0,dt,dzt,dxt,dzo,dxo,ds,doff,dxm,
		ext,ezt,ezo,exo,es,s,scal;	
	float v0,dvz,fmax,angmax,offmax,rmax,aperx,sx,gx;
	float ***mig,***ttab,**tb,**pb,**cs0b,**angb,**tsum,**tt;
	float **tvsum=NULL,***mig1=NULL,***cs=NULL,***tv=NULL,
		**cssum=NULL;
a199 5
	char *datain="stdin",*dataout="stdout",*ttfile,*jpfile,*tvfile,
	     *csfile,*dataout1;
	FILE *infp,*outfp,*ttfp,*jpfp,*tvfp=NULL,*out1fp=NULL,*csfp=NULL;


d205 1
a205 1
	if( !getparstring("datain",&datain)) {
d212 1
a212 1
	} else  
d214 2
d224 1
a224 1
	} else  
d226 1
d247 1
d253 1
d262 9
a270 2
	if(fxt>fxo || ext<exo || fzt>fzo || ezt<ezo) 
		err(" migration output range is out of traveltime table!\n");
d290 1
a290 1
		if( !getparstring("tvfile",&tvfile))
d292 1
d294 2
a295 1
		if( !getparstring("csfile",&csfile))
d298 2
a299 1
		if( !getparstring("dataout1",&dataout1))
d352 1
a352 1
	if(!npv) 
d354 1
a354 1
	else
d356 1
d434 1
a434 1
	        ktr++;
d466 1
a466 2
			for(izo=0; izo<nzo; ++izo)
				tro.data[izo] *=scal;
d512 7
a518 2
	int ix,iz,jr;
	float xi,ar,sr,sr0;
d537 2
a538 1
	int ix,iz;
d549 10
a558 2
	int  ir,iz;
	float r,z,v,rc,oa,temp,rou,zc;
d561 1
a561 1
	if( a==0.0) {
d637 20
a656 1
	int nxf,nxe,nxtf,nxte,ix,iz,iz0,izt0,nzp,jrs,jrg,jz,jt,mt,jx;
@


1.14
log
@changes suggested by Stew Levin to silence SGI compiler warnings, etc
@
text
@d1 1
a1 1
/* SUKDMIG2D: $Revision: 1.12 $ ; $Date: 1996/09/13 21:49:05 $	*/
d111 1
a111 1
	ssize_t	nseek;
d138 2
a139 2
	fseek(infp,0,1);
	fseek(outfp,0,1);
d276 2
a277 2
		nseek = nxt*nzt*is;
		fseek(ttfp,(ssize_t) (nseek*sizeof(float)),0);
d282 1
a282 1
			fseek(tvfp,(ssize_t) (nseek*sizeof(float)),0);
d284 1
a284 1
			fseek(csfp,(ssize_t) (nseek*sizeof(float)),0);
d414 1
a414 1
	return EXIT_SUCCESS;
@


1.13
log
@added Jan Thorbeck's fix to take advantage of the scalco header field.
@
text
@d110 2
a111 1
	int 	ls,nseek,ntr,jtr,ktr,mtr,npv,mtmax;
a117 1
	float scl;
d277 1
a277 1
		fseek(ttfp,nseek*sizeof(float),0);
d282 1
a282 1
			fseek(tvfp,nseek*sizeof(float),0);
d284 1
a284 1
			fseek(csfp,nseek*sizeof(float),0);
a293 3
	if (tr.scalco < 0) scl = -1.0/(float)tr.scalco;
	else if (tr.scalco != 0) scl = (float)tr.scalco;
	else scl = 1.0;
d298 1
a298 1
	    /* determine offset index	*/
d300 2
a301 4

	    sx = tr.sx*scl;
            gx = tr.gx*scl;

d759 1
a759 1
        	if (nfft >= MIN(SU_NFLTS, 720720))
@


1.12
log
@silenced -Wall messages
@
text
@d1 1
a1 1
/* SUKDMIG2D: $Revision: 1.11 $ ; $Date: 1996/09/10 21:01:16 $	*/
d117 1
d294 3
d301 1
a301 1
		/* determine offset index	*/
d303 4
a306 2
	    sx = tr.sx;
	    gx = tr.gx;
@


1.11
log
@added new fixed from Zhenyue and Trino
@
text
@d1 1
a1 1
/* SUKDMIG2D: $Revision: 1.9 $ ; $Date: 1996/01/25 22:01:33 $	*/
d106 1
d115 2
a116 1
	float **tvsum,***mig1,***cs,***tv,**cssum;
d120 1
a120 1
	FILE *infp,*outfp,*ttfp,*jpfp,*tvfp,*out1fp,*csfp;
d535 2
a536 1
	float **tmt,**ampt,**ampti,**ampt1,*tm,*amp,*ampi,*amp1,*tzt,*trf,*zpt;
d736 1
a736 1
  input: 
d738 1
a738 1
    fmax	high cut frequency
d743 1
a743 1
*/
d747 1
a747 1
	int  it, iw, jf, itemp;
@


1.10
log
@changed 240 to sizeof(segy)
@
text
@d314 2
a315 2
			sum2(nxt,nzt,res,1-res,tv[is],tv[is+1],tvsum);
			sum2(nxt,nzt,res,1-res,cs[is],cs[is+1],cssum);
d450 1
a450 1
	float r,z,v,rc,oa,rou,zc;
d481 3
a483 1
					ang[ir][iz] = asin(v*p[ir][iz]);
@


1.9
log
@Deal with specifying header fields accessed/modified in sudoc.
Cosmetics.
@
text
@d1 1
a1 1
/* SUKDMIG2D: $Revision: 1.8 $ ; $Date: 1995/09/27 20:24:24 $	*/
d350 1
a350 1
	memset((void *) &tro, (int) '\0', 240);
@


1.8
log
@added return EXIT_SUCCESS at the end of main
@
text
@d1 1
a1 1
/* SUKDMIG2D: $Revision: 1.7 $ ; $Date: 1995/08/03 16:34:12 $	*/
d9 1
a9 1
"SUKDMIG2D - Kirchhoff Depth Migration of 2D postack/prestack data	",
d82 3
d364 1
a364 1
				(const void *) mig[io][ixo], nzo*sizeof(float));
d379 1
a379 1
				(const void *) mig1[io][ixo],nzo*sizeof(float));
d681 1
a681 1
				-trf[jt+mt+1]))*ampd;				
@


1.7
log
@Zapped unneeded cast of tr.delrt (sigh).
@
text
@d1 1
a1 1
/* SUKDMIG2D: $Revision: 1.6 $ ; $Date: 1995/08/02 20:17:13 $	*/
d408 1
@


1.6
log
@Cast the integers tr.dt and/or tr.delrt and/or clones to double before
division with floating constant (which is implicitly double
precision).  Casting is needed to make some compilers happy and if we
cast to float then there will be an extra conversion to double because
of the floating constant (casting to float and writing 1000000.0F
would save a conversion, but most people find that F yucky and
efficiency is not an issue here).
Motivated by examples from Stew Levin.
@
text
@d1 1
a1 1
/* SUKDMIG2D: $Revision: 1.5 $ ; $Date: 1995/07/26 09:34:09 $	*/
d148 1
a148 1
	if (!getparfloat("ft",&ft)) ft = ((double)tr.delrt)/1000.0; 
@


1.5
log
@additional bug fix by Zhenyue Liu. Made is so that nzp<=nz.
@
text
@d1 1
a1 1
/* SUKDMIG2D: $Revision: 1.3 $ ; $Date: 95/05/03 12:41:25 $	*/
d146 1
a146 1
	if (!getparfloat("dt",&dt)) dt = tr.dt/1000000.0; 
d148 1
a148 1
	if (!getparfloat("ft",&ft)) ft = (float)tr.delrt/1000.; 
@


1.4
log
@minor fixes
@
text
@d247 2
a248 2
	tt = alloc2float(nzt,nxt);
	tsum = alloc2float(nzt,nxt);
d251 1
a251 1
		tvsum = alloc2float(nzt,nxt);
d253 1
a253 1
		cssum = alloc2float(nzt,nxt);
a293 1
	    int is;
d656 1
a656 1
		nzp = (ax0*zpt[jx]+ax*zpt[jx+1]-fz)/dz+0.5;
d658 1
a658 1
 /*	fprintf(stderr," ampt=%g,tmt=%g\n",ampt[nxtf][izt0],tmt[nxtf][izt0]); */
@


1.3
log
@changed bcopy to memcpy
@
text
@d1 1
a1 1
/* SUKDMIG2D: $Revision: 1.2 $ ; $Date: 95/05/03 12:33:58 $	*/
a248 1
	mig1 = ealloc3float(1,1,noff);
a249 2
		free3float(mig1);
		mig1 = ealloc3float(nzo,nxo,noff);
d255 4
d261 1
a261 1
	memset((void *) mig[0][0],(int) '\0',noff*nxo*nzo*sizeof(float));
d561 1
a561 1
		izt0 = ((dis-dxt)*rxz-fzt)/dzt;
d629 1
a629 1
		if(jx>nxte-2) jx = nxte-2;
d779 1
a779 1
        memset((void *) rt + nt, (int) '\0', (nfft-nt)*FSIZE);
@


1.2
log
@changed bzero to memset
@
text
@d1 1
a1 1
/* SUKDMIG2D: $Revision: 1.1 $ ; $Date: 95/04/13 09:46:10 $	*/
d360 2
a361 1
			bcopy(mig[io][ixo],tro.data,nzo*sizeof(float));
d375 2
a376 1
			bcopy(mig1[io][ixo],tro.data,nzo*sizeof(float));
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/* SUKDMIG2D: $Revision: 1.3 $ ; $Date: 95/03/01 13:51 $	*/
d260 4
a263 2
	bzero(mig[0][0],noff*nxo*nzo*sizeof(float));
	if(npv) bzero(mig1[0][0],noff*nxo*nzo*sizeof(float)); 
d347 1
a347 1
	bzero(&tro,240);
d776 1
a776 1
        bzero(rt + nt, (nfft-nt)*FSIZE);
@
