head	1.55;
access;
symbols;
locks
	john:1.55; strict;
comment	@ * @;


1.55
date	2015.08.07.22.00.09;	author john;	state Exp;
branches;
next	1.54;

1.54
date	2011.11.16.17.43.20;	author john;	state Exp;
branches;
next	1.53;

1.53
date	2011.11.12.00.01.45;	author john;	state Exp;
branches;
next	1.52;

1.52
date	2011.09.09.22.29.48;	author john;	state Exp;
branches;
next	1.51;

1.51
date	2008.06.27.16.23.39;	author john;	state Exp;
branches;
next	1.50;

1.50
date	2008.06.27.15.18.22;	author john;	state Exp;
branches;
next	1.49;

1.49
date	2007.12.20.18.39.49;	author john;	state Exp;
branches;
next	1.48;

1.48
date	2007.04.26.23.48.09;	author john;	state Exp;
branches;
next	1.47;

1.47
date	2006.11.07.22.58.42;	author john;	state Exp;
branches;
next	1.46;

1.46
date	2005.12.07.17.18.09;	author john;	state Exp;
branches;
next	1.45;

1.45
date	2003.06.09.16.17.07;	author john;	state Exp;
branches;
next	1.44;

1.44
date	2000.09.22.19.09.22;	author john;	state Exp;
branches;
next	1.43;

1.43
date	98.09.09.19.42.09;	author john;	state Exp;
branches;
next	1.42;

1.42
date	98.08.27.20.00.28;	author john;	state Exp;
branches;
next	1.41;

1.41
date	98.08.11.16.21.02;	author john;	state Exp;
branches;
next	1.40;

1.40
date	98.03.26.22.47.49;	author john;	state Exp;
branches;
next	1.39;

1.39
date	97.08.07.14.58.39;	author john;	state Exp;
branches;
next	1.38;

1.38
date	96.09.09.16.30.31;	author john;	state Exp;
branches;
next	1.37;

1.37
date	96.09.03.21.37.46;	author jkc;	state Exp;
branches;
next	1.36;

1.36
date	95.09.27.16.47.36;	author john;	state Exp;
branches;
next	1.35;

1.35
date	95.09.18.13.38.51;	author jkc;	state Exp;
branches;
next	1.34;

1.34
date	95.08.23.19.56.21;	author jkc;	state Exp;
branches;
next	1.33;

1.33
date	95.08.23.19.54.09;	author jkc;	state Exp;
branches;
next	1.32;

1.32
date	95.04.26.14.03.48;	author john;	state Exp;
branches;
next	1.31;

1.31
date	94.10.28.10.21.29;	author john;	state Exp;
branches;
next	1.30;

1.30
date	94.10.10.10.48.28;	author john;	state Exp;
branches;
next	1.29;

1.29
date	94.10.07.09.58.38;	author john;	state Exp;
branches;
next	1.28;

1.28
date	94.10.07.09.55.19;	author john;	state Exp;
branches;
next	1.27;

1.27
date	94.09.06.10.00.28;	author jkc;	state Exp;
branches;
next	1.26;

1.26
date	94.08.25.14.58.25;	author jkc;	state Exp;
branches;
next	1.25;

1.25
date	94.08.18.13.57.07;	author jkc;	state Exp;
branches;
next	1.24;

1.24
date	94.08.15.12.39.06;	author jkc;	state Exp;
branches;
next	1.23;

1.23
date	94.08.02.14.41.19;	author jkc;	state Exp;
branches;
next	1.22;

1.22
date	94.07.15.14.05.26;	author john;	state Exp;
branches;
next	1.21;

1.21
date	94.07.12.17.11.56;	author john;	state Exp;
branches;
next	1.20;

1.20
date	94.03.30.11.07.05;	author john;	state Exp;
branches;
next	1.19;

1.19
date	94.03.25.09.56.50;	author john;	state Exp;
branches;
next	1.18;

1.18
date	93.11.12.15.58.55;	author john;	state Exp;
branches;
next	1.17;

1.17
date	93.11.12.15.57.48;	author john;	state Exp;
branches;
next	1.16;

1.16
date	93.08.26.20.03.02;	author jkc;	state Exp;
branches;
next	1.15;

1.15
date	93.08.26.13.46.12;	author john;	state Exp;
branches;
next	1.14;

1.14
date	93.08.24.08.57.42;	author john;	state Exp;
branches;
next	1.13;

1.13
date	93.08.09.15.18.53;	author john;	state Exp;
branches;
next	1.12;

1.12
date	92.11.17.10.33.39;	author jkc;	state Exp;
branches;
next	1.11;

1.11
date	92.11.06.08.30.04;	author john;	state Exp;
branches;
next	1.10;

1.10
date	92.10.22.16.33.43;	author john;	state Exp;
branches;
next	1.9;

1.9
date	92.06.15.13.04.58;	author jkc;	state Exp;
branches;
next	1.8;

1.8
date	91.09.05.08.49.15;	author jkcohen;	state Exp;
branches;
next	1.7;

1.7
date	91.06.02.21.31.50;	author jkcohen;	state Exp;
branches;
next	1.6;

1.6
date	90.12.18.14.13.07;	author jkc;	state Exp;
branches;
next	1.5;

1.5
date	90.11.25.18.50.14;	author jkc;	state Exp;
branches;
next	1.4;

1.4
date	90.11.25.18.43.33;	author jkc;	state Exp;
branches;
next	1.3;

1.3
date	90.11.25.18.22.18;	author jkc;	state Exp;
branches;
next	1.2;

1.2
date	90.09.03.09.42.57;	author jkc;	state Exp;
branches;
next	1.1;

1.1
date	90.04.15.17.52.52;	author jkc;	state Exp;
branches;
next	;


desc
@Write a segy tape
@


1.55
log
@fixed selfdoc
@
text
@/* Copyright (c) Colorado School of Mines, 2011.*/
/* All rights reserved.                       */

/* SEGYWRITE: $Revision: 1.54 $ ; $Date: 2011/11/16 17:43:20 $    */

#ifdef SUXDR    /* begin if SUXDR */
#include "su_xdr.h"

#else		/* else if not SUXDR */


#include "su.h"
#include "segy.h"
#include "tapebhdr.h"

#endif		/* end if  SUXDR */

#include "tapesegy.h"
#include "bheader.h"

/*********************** self documentation **********************/
char *sdoc[] = {
"									",
" SEGYWRITE - write an SEG-Y tape					",
"									",
" segywrite <stdin tape=						",
"									",
" Required parameters:							",
"	tape=		tape device to use (see sudoc segyread)		",
"									",
" Optional parameter:							",
" verbose=0	silent operation				",
"		=1 ; echo every 'vblock' traces			",
" vblock=50	echo every 'vblock' traces under verbose option ",
" buff=1		for buffered device (9-track reel tape drive)	",
"		=0 possibly useful for 8mm EXABYTE drive	",
" conv=1		=0 don't convert to IBM format			",
" ebcdic=1	convert text header to ebcdic, =0 leave as ascii	",
" hfile=header	ebcdic card image header file			",
" bfile=binary	binary header file				",
" trmin=1 first trace to write					",
" trmax=INT_MAX  last trace to write			       ",
" endian=(autodetected)	=1 for big-endian and =0 for little-endian byte order",
" errmax=0	allowable number of consecutive tape IO errors	",
" format=		override value of format in binary header file	",
"									",
" Note: The header files may be created with  'segyhdrs'.		",
"									",
"									",
" Note: For buff=1 (default) tape is accessed with 'write', for buff=0	",
"	tape is accessed with fwrite. Try the default setting of buff=1 ",
"	for all tape types.						",
" Caveat: may be slow on an 8mm streaming (EXABYTE) tapedrive		",
" Warning: segyread or segywrite to 8mm tape is fragile. Allow time	",
"	   between successive reads and writes.				",
" Precaution: make sure tapedrive is set to read/write variable blocksize",
"	   tapefiles.							",
"									",
" For more information, type:	sudoc <segywrite>			",
"									",
NULL};

/*
 * Warning: may return the error message "efclose: fclose failed"
 *	 intermittently when segyreading/segywriting to 8mm EXABYTE tape,
 *	 even if actual segyread/segywrite is successful. However, this
 *	 may indicate that your tape drive has been set to a fixed block
 *	 size. Tape drives should be set to variable block size before reading
 *	 or writing tapes in the SEG-Y format.
 *
 * Credits:
 *	SEP: Einar Kjartansson
 *	CWP: Jack, Brian, Chris
 *	   : John Stockwell (added EXABYTE functionality)
 * Notes:
 *	Brian's subroutine, float_to_ibm, for converting IEEE floating
 *	point to IBM floating point is NOT portable and must be
 *	altered for non-IEEE machines.	See the subroutine notes below.
 *
 *	On machines where shorts are not 2 bytes and/or ints are not 
 *	4 bytes, routines to convert SEGY 16 bit and 32 bit integers 
 *	will be required.
 *
 *	The program, segyhdrs, can be used to make the ascii and binary
 *	files required by this code.
 */

/**************** end self doc ***********************************/

/* typedefs */
#ifdef SUXDR		/* begin if SUXDR */
#if defined(_CRAYMPP)	  /* begin if _CRAYMPP */
typedef short fourbyte;
#else			  /* else if SUXDR but not _CRAYMPP */
typedef int fourbyte;
#endif			  /* end if _CRAYMPP */
#endif			/* end if SUXDR */

/* subroutine prototypes */
#ifdef SUXDR		/* begin if  SUXDR */
static void float_to_ibm(fourbyte *from, fourbyte *to, int n, int endian);

#else			/* if not SUXDR */
static void float_to_ibm(int from[], int to[], int n, int endian);
static void bhed_to_tapebhed(const bhed *bhptr, tapebhed *tapebhptr); 
static void
	segy_to_tapesegy(const segy *trptr, tapesegy *tapetrptr, size_t nsegy); 

/*  globals */
tapesegy tapetr;
tapebhed tapebh;
#endif			/* end if SUXDR */

/* globals */
segy tr;
bhed bh;

int
main(int argc, char **argv)
{
	cwp_String tape;	/* name of raw tape device		*/
	cwp_String hfile;	/* name of ebcdic header file		*/
	cwp_String bfile;	/* name of binary header file		*/

#ifdef SUXDR	/* begin SUXDR */
	int j;			/* counter				*/
	FILE *headerfp;		/* file pointer to header file		*/
#else		/* else if not SUXDR */
	FILE *pipefp;		/* file pointer for popen read		*/
#endif		/* end if SUXDR */
	FILE *tapefp=NULL;	/* file pointer for tape		*/
	FILE *binaryfp;		/* file pointer for bfile		*/

	int tapefd=0;		/* file descriptor for tape buff=0	*/

	int i;			/* counter				*/
	int ns;			/* number of data samples		*/
	size_t nsegy;		/* size of whole trace in bytes		*/
	int itr;		/* current trace number			*/
	int trmax;		/* last trace to write			*/
	int trmin;		/* first trace to write			*/
	int verbose;		/* echo every ...			*/
	int vblock;		/* ... vblock traces with verbose=1	*/
	int buff;		/* buffered or unbuffered device	*/
	int endian;		/* =0 little endian; =1 big endian	*/
	int conv;		/* =1 IBM format =0 don't convert	*/
	int ebcdic=1;		/* =1 ebcdic =0 don't convert	*/
	int errmax;		/* max consecutive tape io errors	*/
	int errcount = 0;	/* counter for tape io errors		*/
	int format = 0;		/* tape format				*/
	cwp_Bool format_set = cwp_false; /* tape format			*/

#ifdef SUXDR	/* begin if SUXDR */
#if defined(CRAY) /* begin if defined CRAY */
#if defined(_CRAYMPP)  /* begin if defined _CRAYMPP */
	fourbyte imone = -1;	/* constant for Fortran linkage		*/
	fourbyte fns;		/* for Fortran CRAYMPP linkage		*/
#else		/* CRAY but not _CRAYMPP */	
	int ier;		/* CRAY ibmfloat error flag		*/
	fourbyte ione = -1;	/* constant for Fortran linkage		*/
#endif		/* end if _CRAYMPP */
#endif /* end if SUXDR and CRAY but not _CRAYMPP  */

	char ebcbuf[EBCBYTES+1];/* ebcdic data buffer			*/
	char bhbuf[BNYBYTES];	/* binary reel header buffer		*/
	char *trbuf;		/* output trace buffer			*/
	XDR bhed_xdr, bhbuf_xdr;/* for handling binary reel header	*/
	XDR trhd_xdr;
	unsigned int trstart;	/* "offset" of trhd stream buffer	*/

#else /* not Cray and not SUXDR */
	char cmdbuf[BUFSIZ];	/* dd command buffer			*/
	char ebcbuf[EBCBYTES];	/* ebcdic data buffer			*/
#endif		/* end if  SUXDR */
	
	/* Initialize */
	initargs(argc, argv);
	requestdoc(1);


	/* Get parameters */
	MUSTGETPARSTRING("tape", &tape);
	if (!getparstring("hfile", &hfile))	hfile = "header";
	if (!getparstring("bfile", &bfile))	bfile = "binary";
	if (!getparint	 ("trmin", &trmin))	trmin = 1;
	if (!getparint	 ("trmax", &trmax))	trmax = INT_MAX;
	if (!getparint	 ("verbose", &verbose)) verbose = 0;
	if (!getparint	 ("vblock", &vblock))	vblock = 50;
	if (!getparint	 ("buff", &buff))	buff = 1;
	if (!getparint	 ("conv", &conv))	conv = 1;
	if (!getparint	 ("ebcdic", &ebcdic))	ebcdic = 1;
	if (!getparint("endian", &endian))      {
		union { short s; char c[2]; } testend;
			testend.s = 1;
			endian = (testend.c[0] == '\0') ? 1 : 0;
	}
	
	if (!getparint	 ("errmax", &errmax))	errmax = 0;
	if (getparint("format", &format))	format_set = cwp_true;
        checkpars();
	
	/* Check parameters */
	if (trmin < 1 || trmax < 1 || trmax < trmin)
		err("bad trmin/trmax values, trmin = %d, trmax = %d",
			trmin, trmax);

	/* Get first trace early to be sure that binary file is ready */
	gettr(&tr);

	/* Open files - first the tape */
	if (buff) tapefd = eopen(tape, O_WRONLY | O_CREAT | O_TRUNC, 0666);
	else tapefp = efopen(tape, "w");
	if (verbose) warn("tape opened successfully ");

#ifdef SUXDR	/* begin SUXDR */

	/* Open ascii header file */
	headerfp = efopen(hfile, "r");

	if (verbose) warn("header file opened successfully");

	/* - binary header file */
	binaryfp = efopen(bfile, "r");
	xdrstdio_create(&bhed_xdr,binaryfp,XDR_DECODE);
	xdrmem_create(&bhbuf_xdr,bhbuf,BNYBYTES,XDR_ENCODE);

	if (verbose) warn("binary file opened successfully");

	/* Read ascii header into buffer and blank newlines & nulls */
	memset(&(ebcbuf[0]),0,EBCBYTES);
	if (ebcdic==1) {
		for(i = 0; i<EBCBYTES; i += 80) {
			fgets(&(ebcbuf[i]),81, headerfp);
			j = (int) strlen(&(ebcbuf[i]));
			ebcbuf[i+j] = ' ';
			j--;
	
		}

		/* Convert to EBCDIC */
		if (ebcdic==1) zebc(&(ebcbuf[0]),&(ebcbuf[0]),EBCBYTES);
	} else {
		fread(ebcbuf,1,EBCBYTES,headerfp);
	}
		

	efclose(headerfp);
	if (verbose) warn("header file closed successfully");

	/* Write ebcdic stream to tape */
	if (buff) {
		if (EBCBYTES != write(tapefd, ebcbuf, EBCBYTES)) {
			if (verbose)
				warn("tape write error on ebcdic header");
			if (++errcount > errmax)
				err("exceeded maximum io errors");
		} else { /* Reset counter on successful tape IO */
			errcount = 0;
		}
	} else {
		 fwrite(ebcbuf, 1, EBCBYTES, tapefp);
		 if (ferror(tapefp)) {
			if (verbose)
				warn("tape write error on ebcdic header");
			if (++errcount > errmax)
				err("exceeded maximum io errors");
			clearerr(tapefp);
		} else { /* Reset counter on successful tape IO */
			errcount = 0;
		}
	}

	/* Read binary file into bh structure */
	xdrbhdrsub(&bhed_xdr, &bh);

	/* update requisite field */
	if (format_set) bh.format = format;  /* manually set format */
	bh.ntrpr  = 1;  /* one trace per record */

#else  /* not SUXDR */

	/* - binary header file */
	binaryfp = efopen(bfile, "r");
	if (verbose) warn("binary file opened successfully");

	/* Open pipe to use dd to convert ascii to ebcdic */
	if (ebcdic==1) {
		sprintf(cmdbuf, "dd if=%s conv=ebcdic cbs=80 obs=3200", hfile);
	} else {
		sprintf(cmdbuf, "dd if=%s cbs=80 obs=3200", hfile);
	}
	pipefp = epopen(cmdbuf, "r");

	/* Read ebcdic stream from pipe into buffer */
	efread(ebcbuf, 1, EBCBYTES, pipefp);

	/* Write ebcdic stream to tape */
	if (buff) {
		if (EBCBYTES != write(tapefd, ebcbuf, EBCBYTES)) {
			if (verbose)
				warn("tape write error on ebcdic header");
			if (++errcount > errmax)
				err("exceeded maximum io errors");
		} else { /* Reset counter on successful tape IO */
			errcount = 0;
		}
	} else {
		 fwrite(ebcbuf, 1, EBCBYTES, tapefp);
		 if (ferror(tapefp)) {
			if (verbose)
				warn("tape write error on ebcdic header");
			if (++errcount > errmax)
				err("exceeded maximum io errors");
			clearerr(tapefp);
		} else { /* Reset counter on successful tape IO */
			errcount = 0;
		}
	}

	/* Read binary file into bh structure */
	efread((char *) &bh, 1, BNYBYTES, binaryfp);
	if (format_set) bh.format = format;  /* manually set format  */

	if (bh.ntrpr == 0) bh.ntrpr  = 1;	/* one trace per record */

#endif		/* end if SUXDR */

	/* Compute trace size (can't use HDRBYTES here!) */
	ns = bh.hns;
	if (!ns) err("bh.hns not set in binary header");
	nsegy = ns*4 + SEGY_HDRBYTES;

#ifdef SUXDR 	/* begin SUXDR */
	/* Convert from ints to shorts */
	xdrbhdrsub(&bhbuf_xdr, &bh);

	/* Write binary structure to tape */
	if (buff) {
		if (BNYBYTES != write(tapefd, bhbuf, BNYBYTES)) {
			if (verbose)
				warn("tape write error on binary header");
			if (++errcount > errmax)
				err("exceeded maximum io errors");
		} else { /* Reset counter on successful tape IO */
			errcount = 0;
		}
	} else {
		 fwrite(bhbuf, 1, BNYBYTES, tapefp);
		 if (ferror(tapefp)) {
			if (verbose)
				warn("tape write error on binary header");
			if (++errcount > errmax)
				err("exceeded maximum io errors");
			clearerr(tapefp);
		} else { /* Reset counter on successful tape IO */
			errcount = 0;
		}
	}

#else /* not SUXDR */

	/* if little endian (endian=0) swap bytes of binary header */
	if (endian==0) for (i = 0; i < BHED_NKEYS; ++i) swapbhval(&bh,i);


	/* Convert from ints/shorts to bytes */
	bhed_to_tapebhed(&bh, &tapebh);


	/* Write binary structure to tape */
	if (buff) {
		if (BNYBYTES != write(tapefd, (char *) &tapebh, BNYBYTES)) {
			if (verbose)
				warn("tape write error on binary header");
			if (++errcount > errmax)
				err("exceeded maximum io errors");
		} else { /* Reset counter on successful tape IO */
			errcount = 0;
		}
	} else {
		 fwrite((char *) &tapebh, 1, BNYBYTES, tapefp);
		 if (ferror(tapefp)) {
			if (verbose)
				warn("tape write error on binary header");
			if (++errcount > errmax)
				err("exceeded maximum io errors");
			clearerr(tapefp);
		} else { /* Reset counter on successful tape IO */
			errcount = 0;
		}
	}
#endif		/* end if SUXDR */


	/* Copy traces from stdin to tape */

#ifdef SUXDR	/* begin SUXDR */

	trbuf = (char *) alloc1(nsegy, sizeof(char));
	xdrmem_create(&trhd_xdr,trbuf,(unsigned int) nsegy,XDR_ENCODE);
	trstart = xdr_getpos(&trhd_xdr);

#endif 		/* end if SUXDR */

	itr = 0;
	do {

		/* Set/check trace header words */
		tr.tracr = ++itr;
		if (tr.ns != ns)
			warn("conflict: tr.ns = %d, bh.ns = %d: trace %d",
					tr.ns, ns, itr);

		/* Convert and write desired traces */
		if (itr >= trmin) {

#ifdef SUXDR 	/* begin SUXDR */
	 		/* convert trace header to SEGY standard */       
			if(FALSE == xdr_setpos(&trhd_xdr,trstart)) 
			    err("%s: trouble \"seeking\" start of trace",
				__FILE__);
			xdrhdrsub(&trhd_xdr,&tr);

			/* Convert internal floats to IBM floats */
			if (conv) {
#if defined(CRAY)
#if defined(_CRAYMPP)
			    float_to_ibm((fourbyte *) (&(tr.data[0])),
					 (fourbyte *) (&(tr.data[0])),
					 ns, endian);
/* Stew's Fortran routine...
			    fns = ns;
			    IBMFLT(tr.data,tr.data,&fns,&imone);
*/
#else /* !_CRAYMPP */
			    USSCTI(tr.data,tr.data,&ione,&ns,&ier);
#endif /* _CRAYMPP */
#else /* !CRAY */
			    float_to_ibm((fourbyte *) (&(tr.data[0])),
					 (fourbyte *) (&(tr.data[0])),
					 ns, endian);
#endif /* !CRAY */
			    memcpy(trbuf+SEGY_HDRBYTES,(char *) tr.data,
				ns*4*sizeof(char));
			} else {
			    xdr_vector(&trhd_xdr,(char *) tr.data,
				ns, sizeof(float), (xdrproc_t) xdr_float);
			}

			/* Write the trace to tape */
			if (buff) {
			    if (nsegy !=
			       write(tapefd, trbuf, nsegy)){
				if (verbose)
				    warn("tape write error on trace %d", itr);
				if (++errcount > errmax)
				    err("exceeded maximum io errors");
			    } else { /* Reset counter on successful tape IO */
				errcount = 0;
			    }
			} else {
			    fwrite(trbuf,sizeof(char),nsegy,tapefp);
			    if (ferror(tapefp)) {
				if (verbose)
				    warn("tape write error on trace %d", itr);
				if (++errcount > errmax)
				    err("exceeded maximum io errors");
				    clearerr(tapefp);
			    } else { /* Reset counter on successful tape IO */
				errcount = 0;
			    }
			}

#else /* not SUXDR */
		
			/* Convert internal floats to IBM floats */
			if (conv)
				float_to_ibm((int *) tr.data, (int *) tr.data,
								ns, endian);

		       /* handle no ibm conversion for little endian case */
		       if (conv==0 && endian==0)
				for (i = 0; i < ns ; ++i)
					swap_float_4(&tr.data[i]);
			
			/* if little endian, swap bytes in header */
			if (endian==0)
			    for (i = 0; i < SEGY_NKEYS; ++i) swaphval(&tr,i);

			/* Convert from ints/shorts to bytes */
			segy_to_tapesegy(&tr, &tapetr, nsegy);

			/* Write the trace to tape */
			if (buff) {
			    if (nsegy !=
			       write(tapefd, (char *) &tapetr, nsegy)){
				if (verbose)
				    warn("tape write error on trace %d", itr);
				if (++errcount > errmax)
				    err("exceeded maximum io errors");
			    } else { /* Reset counter on successful tape IO */
				errcount = 0;
			    }
			} else {
			    fwrite((char *)&tapetr,1,nsegy,tapefp);
			    if (ferror(tapefp)) {
				if (verbose)
				    warn("tape write error on trace %d", itr);
				if (++errcount > errmax)
				    err("exceeded maximum io errors");
				    clearerr(tapefp);
			    } else { /* Reset counter on successful tape IO */
				errcount = 0;
			    }
			}

#endif		/* end if SUXDR */

			/* Echo under verbose option */
			if (verbose && itr % vblock == 0)
				warn(" %d traces written to tape", itr);
		}
	} while (gettr(&tr) && itr < trmax);


	/* Clean up */
	(buff) ?  eclose(tapefd) :
		  efclose(tapefp);
	if (verbose) warn("tape closed successfully");

#ifdef SUXDR	/* begin SUXDR */
	xdr_destroy(&trhd_xdr);
	xdr_destroy(&bhed_xdr);
	xdr_destroy(&bhbuf_xdr);
#endif 		/* end if SUXDR */

	efclose(binaryfp);
	if (verbose) warn("binary file closed successfully");

#ifndef SUXDR	/* begin not SUXDR */
	epclose(pipefp);
#endif		/* end if not SUXDR */

	return(CWP_Exit());
}

#ifdef SUXDR	/* begin SUXDR */

/* Assumes fourbyte == 4 byte integer */
static void float_to_ibm(fourbyte *from, fourbyte *to, int n, int endian)
/**********************************************************************
 float_to_ibm - convert between 32 bit IBM and IEEE floating numbers
*********************************************************************** 
Input:
from       input vector
n	  number of floats in vectors
endian     =0 for little endian machine, =1 for big endian machines

Output:
to	 output vector, can be same as input vector

*********************************************************************** 
Notes:
Up to 3 bits lost on IEEE -> IBM

IBM -> IEEE may overflow or underflow, taken care of by 
substituting large number or zero

Only integer shifting and masking are used.
*********************************************************************** 
Credits:     CWP: Brian Sumner
***********************************************************************/
{
    register fourbyte fconv, fmant, t;
    register int i;

    for (i=0;i<n;++i) {
	fconv = from[i];
	if (fconv) {
	    fmant = (0x007fffff & fconv) | 0x00800000;
	    t = (fourbyte) ((0x7f800000 & fconv) >> 23) - 126;
	    while (t & 0x3) { ++t; fmant >>= 1; }
	    fconv = (0x80000000 & fconv) | (((t>>2) + 64) << 24) | fmant;
	}
	if(endian==0)
		fconv = (fconv<<24) | ((fconv>>24)&0xff) |
			((fconv&0xff00)<<8) | ((fconv&0xff0000)>>8);

	to[i] = fconv;
    }
    return;
}

#else	/* not SUXDR */

#ifdef _HPUX_SOURCE
void float_to_ibm(int from[], int to[], int n, int endian)
{
    register int fconv, fmant, i, t, dummy;

	dummy = endian;

    for (i=0;i<n;++i) {
	fconv = from[i];
	if (fconv) {
	    fmant = (0x007fffff & fconv) | 0x00800000;
	    t = (int) ((0x7f800000 & fconv) >> 23) - 126;
	    while (t & 0x3) { ++t; fmant >>= 1; }
	    fconv = (0x80000000 & fconv) | (((t>>2) + 64) << 24) | fmant;
	}
	to[i] = fconv;
    }
    return;
}

#else

/* Assumes sizeof(int) == 4 */
static void float_to_ibm(int from[], int to[], int n, int endian)
/**********************************************************************
 float_to_ibm - convert between 32 bit IBM and IEEE floating numbers
*********************************************************************** 
Input:
from	   input vector
n	   number of floats in vectors
endian	   =0 for little endian machine, =1 for big endian machines

Output:
to	   output vector, can be same as input vector

*********************************************************************** 
Notes:
Up to 3 bits lost on IEEE -> IBM

IBM -> IEEE may overflow or underflow, taken care of by 
substituting large number or zero

Only integer shifting and masking are used.
*********************************************************************** 
Credits:     CWP: Brian Sumner
***********************************************************************/
{
    register int fconv, fmant, i, t;

    for (i=0;i<n;++i) {
	fconv = from[i];
	if (fconv) {
	    fmant = (0x007fffff & fconv) | 0x00800000;
	    t = (int) ((0x7f800000 & fconv) >> 23) - 126;
	    while (t & 0x3) { ++t; fmant >>= 1; }
	    fconv = (0x80000000 & fconv) | (((t>>2) + 64) << 24) | fmant;
	}
	if(endian==0)
		fconv = (fconv<<24) | ((fconv>>24)&0xff) |
			((fconv&0xff00)<<8) | ((fconv&0xff0000)>>8);

	to[i] = fconv;
    }
    return;
}

#endif 

static void bhed_to_tapebhed(const bhed *bhptr, tapebhed *tapebhptr)
/***************************************************************************
bhed_tape_bhed -- converts the binary tape header in the machine's short
and int types to, respectively, the seg-y standard 2 byte and 4 byte integer
types.
****************************************************************************
Input:
bhptr		pointer to binary header vector

Output:
tapebhptr	pointer to tape binary header vector
****************************************************************************
Notes:
The present implementation assumes that these types are actually the "right"
size (respectively 2 and 4 bytes), so this routine is only a placeholder for
the conversions that would be needed on a machine not using this convention.
****************************************************************************
Author: CWP: Jack K. Cohen  August 1994
***************************************************************************/
{
	register int i;
	Value val;
	
	/* convert the binary header field by field */
	for (i = 0; i < BHED_NKEYS; ++i) {
		getbhval(bhptr, i, &val);
		puttapebhval(tapebhptr, i, &val);
	}
}

static
void segy_to_tapesegy(const segy *trptr, tapesegy *tapetrptr, size_t nsegy)
/***************************************************************************
tapesegy_to_segy -- converts the integer header fields from, respectively,
		    the machine's short and int types to the  seg-y standard
		    2 byte and 4 byte types.
****************************************************************************
Input:
trptr		pointer to SU SEG-Y data vector		
nsegy		whole size of a SEG-Y trace in bytes

Output:
tapetrptr	pointer to tape SEG-Y data vector
****************************************************************************
Notes:
Also copies the float data byte by byte.  The present implementation assumes
that the integer types are actually the "right" size (respectively 2 and
4 bytes), so this routine is only a placeholder for the conversions that
would be needed on a machine not using this convention.	 The float data
is preserved as four byte fields and is later converted to internal floats
by float_to_ibm (which, in turn, makes additonal assumptions)
****************************************************************************
Author: CWP: Jack K. Cohen  August 1994
***************************************************************************/
{
	register int i;
	Value val;
	
	/* convert trace header, field by field */
	for (i = 0; i < SEGY_NKEYS; ++i) {
		gethval(trptr, i, &val);
		puttapehval(tapetrptr, i, &val);
	}
	
	/* copy optional portion */
	memcpy(tapetrptr->unass, (char *)&(trptr->otrav)+2, 60);

	/* copy data portion */
	memcpy(tapetrptr->data, trptr->data, 4*SU_NFLTS);

} 
#endif		/* end if SUXDR */
@


1.54
log
@added Reg Beardsley's checkpar()
@
text
@d4 1
a4 1
/* SEGYWRITE: $Revision: 1.52 $ ; $Date: 2011/09/09 22:29:48 $    */
d43 1
a43 1
" endian=1	=0 for little-endian machines (PC's, DEC,etc...)",
@


1.53
log
@copyright
@
text
@d200 1
@


1.52
log
@*** empty log message ***
@
text
@d1 4
a4 1
/* SEGYWRITE: $Revision: 1.51 $ ; $Date: 2008/06/27 16:23:39 $    */
@


1.51
log
@*** empty log message ***
@
text
@d1 1
a1 1
/* SEGYWRITE: $Revision: 1.50 $ ; $Date: 2008/06/27 15:18:22 $    */
d190 5
a194 4
                                        union { short s; char c[2]; } testend;
                                        testend.s = 1;
                                        endian = (testend.c[0] == '\0') ? 1 : 0;
                                       }
d213 1
a213 1
        /* Open ascii header file */
d216 1
a216 1
        if (verbose) warn("header file opened successfully");
d218 2
a219 2
        /* - binary header file */
        binaryfp = efopen(bfile, "r");
d223 1
a223 1
        if (verbose) warn("binary file opened successfully");
d225 1
a225 1
        /* Read ascii header into buffer and blank newlines & nulls */
d230 1
a230 1
                	j = (int) strlen(&(ebcbuf[i]));
d243 2
a244 2
        efclose(headerfp);
        if (verbose) warn("header file closed successfully");
d246 22
a267 22
        /* Write ebcdic stream to tape */
        if (buff) {
                if (EBCBYTES != write(tapefd, ebcbuf, EBCBYTES)) {
                        if (verbose)
                                warn("tape write error on ebcdic header");
                        if (++errcount > errmax)
                                err("exceeded maximum io errors");
                } else { /* Reset counter on successful tape IO */
                        errcount = 0;
                }
        } else {
                 fwrite(ebcbuf, 1, EBCBYTES, tapefp);
                 if (ferror(tapefp)) {
                        if (verbose)
                                warn("tape write error on ebcdic header");
                        if (++errcount > errmax)
                                err("exceeded maximum io errors");
                        clearerr(tapefp);
                } else { /* Reset counter on successful tape IO */
                        errcount = 0;
                }
        }
d269 1
a269 1
        /* Read binary file into bh structure */
d273 2
a274 2
        if (format_set) bh.format = format;  /* manually set format */
        bh.ntrpr  = 1;  /* one trace per record */
d318 1
a318 1
        if (format_set) bh.format = format;  /* manually set format  */
d333 22
a354 22
        /* Write binary structure to tape */
        if (buff) {
                if (BNYBYTES != write(tapefd, bhbuf, BNYBYTES)) {
                        if (verbose)
                                warn("tape write error on binary header");
                        if (++errcount > errmax)
                                err("exceeded maximum io errors");
                } else { /* Reset counter on successful tape IO */
                        errcount = 0;
                }
        } else {
                 fwrite(bhbuf, 1, BNYBYTES, tapefp);
                 if (ferror(tapefp)) {
                        if (verbose)
                                warn("tape write error on binary header");
                        if (++errcount > errmax)
                                err("exceeded maximum io errors");
                        clearerr(tapefp);
                } else { /* Reset counter on successful tape IO */
                        errcount = 0;
                }
        }
d407 1
a407 1
			err("conflict: tr.ns = %d, bh.ns = %d: trace %d",
d414 1
a414 1
         		/* convert trace header to SEGY standard */       
d420 1
a420 1
                        /* Convert internal floats to IBM floats */
d428 2
a429 2
                            fns = ns;
                            IBMFLT(tr.data,tr.data,&fns,&imone);
d446 23
a468 23
                        /* Write the trace to tape */
                        if (buff) {
                            if (nsegy !=
                               write(tapefd, trbuf, nsegy)){
                                if (verbose)
                                    warn("tape write error on trace %d", itr);
                                if (++errcount > errmax)
                                    err("exceeded maximum io errors");
                            } else { /* Reset counter on successful tape IO */
                                errcount = 0;
                            }
                        } else {
                            fwrite(trbuf,sizeof(char),nsegy,tapefp);
                            if (ferror(tapefp)) {
                                if (verbose)
                                    warn("tape write error on trace %d", itr);
                                if (++errcount > errmax)
                                    err("exceeded maximum io errors");
                                    clearerr(tapefp);
                            } else { /* Reset counter on successful tape IO */
                                errcount = 0;
                            }
                        }
d552 1
a552 1
n          number of floats in vectors
d556 1
a556 1
to         output vector, can be same as input vector
d574 10
a583 10
        fconv = from[i];
        if (fconv) {
            fmant = (0x007fffff & fconv) | 0x00800000;
            t = (fourbyte) ((0x7f800000 & fconv) >> 23) - 126;
            while (t & 0x3) { ++t; fmant >>= 1; }
            fconv = (0x80000000 & fconv) | (((t>>2) + 64) << 24) | fmant;
        }
        if(endian==0)
                fconv = (fconv<<24) | ((fconv>>24)&0xff) |
                        ((fconv&0xff00)<<8) | ((fconv&0xff0000)>>8);
d585 1
a585 1
        to[i] = fconv;
d600 8
a607 8
        fconv = from[i];
        if (fconv) {
            fmant = (0x007fffff & fconv) | 0x00800000;
            t = (int) ((0x7f800000 & fconv) >> 23) - 126;
            while (t & 0x3) { ++t; fmant >>= 1; }
            fconv = (0x80000000 & fconv) | (((t>>2) + 64) << 24) | fmant;
        }
        to[i] = fconv;
@


1.50
log
@added flag to give the user the choice of ebcdic or ascii reel
textural header.
@
text
@d1 1
a1 1
/* SEGYWRITE: $Revision: 1.49 $ ; $Date: 2007/12/20 18:39:49 $    */
d144 1
a144 1
	int ebcdic;		/* =1 ebcdic =0 don't convert	*/
d188 1
d226 13
a238 6
	for(i = 0; i<EBCBYTES; i += 80) {
		fgets(&(ebcbuf[i]),81, headerfp);
                j = (int) strlen(&(ebcbuf[i]));
		ebcbuf[i+j] = ' ';
		j--;
		if(ebcbuf[j] == '\n') ebcbuf[j] = ' ';
d240 1
a240 2
	/* Convert to EBCDIC */
        if (ebcdic==1) zebc(&(ebcbuf[0]),&(ebcbuf[0]),EBCBYTES);
@


1.49
log
@Stew Levin's automatic endian checker added
@
text
@d1 1
a1 1
/* SEGYWRITE: $Revision: 1.47 $ ; $Date: 2006/11/07 22:58:42 $    */
d29 14
a42 13
"	verbose=0	silent operation				",
"			=1 ; echo every 'vblock' traces			",
"	vblock=50	echo every 'vblock' traces under verbose option ",
"	buff=1		for buffered device (9-track reel tape drive)	",
"			=0 possibly useful for 8mm EXABYTE drive	",
"	conv=1		=0 don't convert to IBM format			",
"	hfile=header	ebcdic card image header file			",
"	bfile=binary	binary header file				",
"	trmin=1 first trace to write					",
"	trmax=INT_MAX  last trace to write			       ",
"	endian=1	=0 for little-endian machines (PC's, DEC,etc...)",
"	errmax=0	allowable number of consecutive tape IO errors	",
"	format=		override value of format in binary header file	",
d144 1
d233 1
a233 1
        zebc(&(ebcbuf[0]),&(ebcbuf[0]),EBCBYTES);
d275 5
a279 1
	sprintf(cmdbuf, "dd if=%s conv=ebcdic cbs=80 obs=3200", hfile);
@


1.48
log
@Stew Levin's automated endian detection added.
@
text
@d54 1
a54 2
" Endian: now tests for endian, and assumes endian of your machine. Set ",
" verbose=1 to see value of endian assumed.				",
d186 5
a190 11
        if (!getparint("endian", &endian))  {

                /* Stew Levin's endian test */
                union { short s; char c[2]; } endianTest;
                endianTest.s = 1;

                endian = ((endianTest.c[0] == '\0') ? 1 : 0);
		if (verbose) warn("assuming endian=%d", endian);

        }

@


1.47
log
@changed    memset( .., (int) '\0',...) to memset( .., 0,..) as per suggestion of Marion Zhu and Reg Beardsley
@
text
@d1 1
a1 1
/* SEGYWRITE: $Revision: 1.46 $ ; $Date: 2005/12/07 17:18:09 $    */
d54 2
a55 1
"									",
d187 11
a197 1
	if (!getparint	 ("endian", &endian))	endian = 1;
@


1.46
log
@put in an explicit cast
@
text
@d1 1
a1 1
/* SEGYWRITE: $Revision: 1.45 $ ; $Date: 2003/06/09 16:17:07 $    */
d218 1
a218 1
	memset(&(ebcbuf[0]),' ',EBCBYTES);
d425 1
a425 1
				ns, sizeof(float), (xdr_proc_t) xdr_float);
@


1.45
log
@9 June 2003
@
text
@d1 1
a1 1
/* SEGYWRITE: $Revision: 1.44 $ ; $Date: 2000/09/22 19:09:22 $    */
d425 1
a425 1
				ns, sizeof(float), xdr_float);
@


1.44
log
@HPUX support improved
@
text
@d1 1
a1 1
/* SEGYWRITE: $Revision: 1.43 $ ; $Date: 1998/09/09 19:42:09 $    */
d522 1
a522 1
	return EXIT_SUCCESS;
@


1.43
log
@test revision
@
text
@d1 1
a1 1
/* SEGYWRITE: $Revision: 1.42 $ ; $Date: 1998/08/27 20:00:28 $    */
d574 22
d640 1
@


1.42
log
@updated to be cleaner and to not automatically set bh.format to 1
@
text
@d1 1
a1 1
/* SEGYWRITE: $Revision: 1.41 $ ; $Date: 1998/08/11 16:21:02 $    */
d7 1
@


1.41
log
@removed prototype and definition of zebc subroutine to avoid
duplication with version in libcwp.a
@
text
@d1 1
a1 3
/* SEGYWRITE: $Revision: 1.40 $ ; $Date: 1998/03/26 22:47:49 $    */

#ifdef SUXDR
d3 1
a4 2
#include "tapesegy.h"
#include "bheader.h"
d6 1
a6 38
/*********************** self documentation **********************/
char *sdoc[] = {
"                                                                       ",
" SEGYWRITE - write an SEG-Y tape                                       ",
"                                                                       ",
" segywrite <stdin                                                      ",
"                                                                       ",
" Required parameters:                                                  ",
"       tape=           tape device or disk filename to use             ",
"                                                                       ",
" Optional parameter:                                                   ",
"       verbose=0       silent operation                                ",
"                       =1 ; echo every 'vblock' traces                 ",
"       vblock=50       echo every 'vblock' traces under verbose option ",
"       buff=1          for buffered device (9-track reel tape drive)   ",
"                       =0 possibly useful for 8mm EXABYTE drive	",
"	conv=1		=0 don't convert to IBM format			",
"       hfile=header    ebcdic card image header file                   ",
"       bfile=binary    binary header file                              ",
"       trmin=1         first trace to write                            ",
"       trmax=INT_MAX   last trace to write                             ",
"       endian=1        =0 for little-endian machines (PC's, DEC,etc...)",
"       errmax=0        allowable number of consecutive tape IO errors  ",
"                                                                       ",
" Note: The header files may be created with  'segyhdrs'.               ",
"                                                                       ",
"                                                                       ",
" Note: For buff=1 (default) tape is accessed with 'write', for buff=0  ",
"       tape is accessed with fwrite. Try the default setting of buff=1 ",
"       for all tape types.                                             ",
" Caveat: may be slow on an 8mm streaming (EXABYTE) tapedrive           ",
" Warning: segyread or segywrite to 8mm tape is fragile. Allow time     ",
"          between successive reads and writes.                         ",
" Precaution: make sure tapedrive is set to read/write variable blocksize",
"          tapefiles.                                                   ",
"                                                                       ",
" For more information, type:   sudoc <segywrite>                       ",
NULL};
d8 3
a10 348
/*
 * Warning: may return the error message "efclose: fclose failed"
 *       intermittently when segyreading/segywriting to 8mm EXABYTE tape,
 *       even if actual segyread/segywrite is successful. However, this
 *       may indicate that your tape drive has been set to a fixed block
 *       size. Tape drives should be set to variable block size before reading
 *       or writing tapes in the SEG-Y format.
 */

/* Credits:
 *      SEP: Einar Kjartansson
 *      CWP: Jack, Brian, Chris
 *         : John Stockwell (added EXABYTE functionality)
 * Notes:
 *      Brian's subroutine, float_to_ibm, for converting IEEE floating
 *      point to IBM floating point is NOT portable and must be
 *      altered for non-IEEE machines.  See the subroutine notes below.
 *
 *      On machines where shorts are not 2 bytes and/or ints are not 
 *      4 bytes, routines to convert SEGY 16 bit and 32 bit integers 
 *      will be required.
 *
 *      The program, segyhdrs, can be used to make the ascii and binary
 *      files required by this code.
 */

/**************** end self doc ***********************************/
/*
 * Revised:  7/5/95  Stewart A. Levin   (Mobil)
 *         Use xdr routines for portability.
 *         Add CRAY support for floating point conversions.
 * Revised:  4/4/96  Stewart A. Levin   (Mobil)
 *         Direct ascii to ebcdic conversion
 */

/* subroutine prototypes */
#if defined(_CRAYMPP)
typedef short fourbyte;
#else
typedef int fourbyte;
#endif
static void float_to_ibm(fourbyte *from, fourbyte *to, int n, int endian);

static segy tr;
static bhed bh;

int
main(int argc, char **argv)
{
        cwp_String tape;        /* name of raw tape device              */
        cwp_String hfile;       /* name of ebcdic header file           */
        cwp_String bfile;       /* name of binary header file           */

        FILE *tapefp;           /* file pointer for tape                */
        FILE *headerfp;         /* file pointer for hfile               */
        FILE *binaryfp;         /* file pointer for bfile               */

        int tapefd;             /* file discriptor for tape buff=0      */

        int i,j;                /* counter                              */
        int ns;                 /* number of data samples               */
        size_t nsegy;           /* size of whole trace in bytes         */
        int itr;                /* current trace number                 */
        int trmax;              /* last trace to write                  */
        int trmin;              /* first trace to write                 */
        int verbose;            /* echo every ...                       */
        int vblock;             /* ... vblock traces with verbose=1     */
        int buff;               /* buffered or unbuffered device        */
        int endian;             /* =0 little endian; =1 big endian      */
        int conv;               /* =1 IBM format =0 don't convert	*/
        int errmax;             /* max consecutive tape io errors       */
        int errcount = 0;       /* counter for tape io errors           */
#if defined(CRAY)
#if defined(_CRAYMPP)
	fourbyte imone = -1;	/* constant for Fortran linkage		*/
        fourbyte fns;           /* for Fortran CRAYMPP linkage          */
#else
	int ier;		/* CRAY ibmfloat error flag		*/
	fourbyte ione = 1;	/* constant for Fortran linkage		*/
#endif
#endif
        char ebcbuf[EBCBYTES+1];  /* ebcdic data buffer                 */
	char bhbuf[BNYBYTES];   /* binary reel header buffer		*/
	char *trbuf;            /* output trace buffer 			*/
	XDR  bhed_xdr, bhbuf_xdr; /* for handling binary reel header    */
	XDR  trhd_xdr;
	unsigned int trstart;   /* "offset" of trhd stream buffer 	*/


        /* Initialize */
        initargs(argc, argv);
        requestdoc(1);


        /* Get parameters */
        MUSTGETPARSTRING("tape", &tape);
        if (!getparstring("hfile", &hfile))     hfile = "header";
        if (!getparstring("bfile", &bfile))     bfile = "binary";
        if (!getparint   ("trmin", &trmin))     trmin = 1;
        if (!getparint   ("trmax", &trmax))     trmax = INT_MAX;
        if (!getparint   ("verbose", &verbose)) verbose = 0;
        if (!getparint   ("vblock", &vblock))   vblock = 50;
        if (!getparint   ("buff", &buff))       buff = 1;
        if (!getparint   ("conv", &conv))       conv = 1;
        if (!getparint   ("endian", &endian))   endian = 1;
        if (!getparint   ("errmax", &errmax))   errmax = 0;
        
        /* Check parameters */
        if (trmin < 1 || trmax < 1 || trmax < trmin)
                err("bad trmin/trmax values, trmin = %d, trmax = %d",
                        trmin, trmax);

        /* Get first trace early to be sure that binary file is ready */
        gettr(&tr);

        /* Open files - first the tape */
        if (buff) tapefd = eopen(tape, O_WRONLY | O_CREAT | O_TRUNC, 0666);
        else tapefp = efopen(tape, "w");
        if (verbose) warn("tape opened successfully ");

        /* Open ascii header file */
	headerfp = efopen(hfile, "r");

        if (verbose) warn("header file opened successfully");

        /* - binary header file */
        binaryfp = efopen(bfile, "r");
	xdrstdio_create(&bhed_xdr,binaryfp,XDR_DECODE);
	xdrmem_create(&bhbuf_xdr,bhbuf,BNYBYTES,XDR_ENCODE);

        if (verbose) warn("binary file opened successfully");

        /* Read ascii header into buffer and blank newlines & nulls */
	memset(&(ebcbuf[0]),' ',EBCBYTES);
	for(i = 0; i<EBCBYTES; i += 80) {
		fgets(&(ebcbuf[i]),81, headerfp);
                j = (int) strlen(&(ebcbuf[i]));
		ebcbuf[i+j] = ' ';
		j--;
		if(ebcbuf[j] == '\n') ebcbuf[j] = ' ';
	}
	/* Convert to EBCDIC */
        zebc(&(ebcbuf[0]),&(ebcbuf[0]),EBCBYTES);

        efclose(headerfp);
        if (verbose) warn("header file closed successfully");

        /* Write ebcdic stream to tape */
        if (buff) {
                if (EBCBYTES != write(tapefd, ebcbuf, EBCBYTES)) {
                        if (verbose)
                                warn("tape write error on ebcdic header");
                        if (++errcount > errmax)
                                err("exceeded maximum io errors");
                } else { /* Reset counter on successful tape IO */
                        errcount = 0;
                }
        } else {
                 fwrite(ebcbuf, 1, EBCBYTES, tapefp);
                 if (ferror(tapefp)) {
                        if (verbose)
                                warn("tape write error on ebcdic header");
                        if (++errcount > errmax)
                                err("exceeded maximum io errors");
                        clearerr(tapefp);
                } else { /* Reset counter on successful tape IO */
                        errcount = 0;
                }
        }

        /* Read binary file into bh structure */
	xdrbhdrsub(&bhed_xdr, &bh);

	/* update requisite field */
        bh.format = 1;  /* indicate SEG-Y data  */
        bh.ntrpr  = 1;  /* one trace per record */

        /* Compute trace size (can't use HDRBYTES here!) */
        ns = bh.hns;
        if (!ns) err("bh.hns not set in binary header");
        nsegy = ns*4 + SEGY_HDRBYTES;

        /* Convert from ints/shorts to bytes */
        xdrbhdrsub(&bhbuf_xdr,&bh);

        /* Write binary structure to tape */
        if (buff) {
                if (BNYBYTES != write(tapefd, bhbuf, BNYBYTES)) {
                        if (verbose)
                                warn("tape write error on binary header");
                        if (++errcount > errmax)
                                err("exceeded maximum io errors");
                } else { /* Reset counter on successful tape IO */
                        errcount = 0;
                }
        } else {
                 fwrite(bhbuf, 1, BNYBYTES, tapefp);
                 if (ferror(tapefp)) {
                        if (verbose)
                                warn("tape write error on binary header");
                        if (++errcount > errmax)
                                err("exceeded maximum io errors");
                        clearerr(tapefp);
                } else { /* Reset counter on successful tape IO */
                        errcount = 0;
                }
        }


        /* Copy traces from stdin to tape */
	trbuf = (char *) alloc1(nsegy, sizeof(char));
	xdrmem_create(&trhd_xdr,trbuf,(unsigned int) nsegy,XDR_ENCODE);
	trstart = xdr_getpos(&trhd_xdr);

        itr = 0;
        do {

                /* Set/check trace header words */
                tr.tracr = ++itr;
                if (tr.ns != ns)
                        err("conflict: tr.ns = %d, bh.ns = %d: trace %d",
                                        tr.ns, ns, itr);

                /* Convert and write desired traces */
                if (itr >= trmin) {

         		/* convert trace header to SEGY standard */       
			if(FALSE == xdr_setpos(&trhd_xdr,trstart)) 
			    err("%s: trouble \"seeking\" start of trace",
				__FILE__);
			xdrhdrsub(&trhd_xdr,&tr);

                        /* Convert internal floats to IBM floats */
			if (conv) {
#if defined(CRAY)
#if defined(_CRAYMPP)
			    float_to_ibm((fourbyte *) (&(tr.data[0])),
					 (fourbyte *) (&(tr.data[0])),
					 ns, endian);
/* Stew's Fortran routine...
                            fns = ns;
                            IBMFLT(tr.data,tr.data,&fns,&imone);
*/
#else /* !_CRAYMPP */
			    USSCTI(tr.data,tr.data,&ione,&ns,&ier);
#endif /* _CRAYMPP */
#else /* !CRAY */
			    float_to_ibm((fourbyte *) (&(tr.data[0])),
					 (fourbyte *) (&(tr.data[0])),
					 ns, endian);
#endif /* !CRAY */
			    memcpy(trbuf+SEGY_HDRBYTES,(char *) tr.data,
				ns*4*sizeof(char));
			} else {
			    xdr_vector(&trhd_xdr,(char *) tr.data,
				ns, sizeof(float), xdr_float);
			}
                        
                        /* Write the trace to tape */
                        if (buff) {
                            if (nsegy !=
                               write(tapefd, trbuf, nsegy)){
                                if (verbose)
                                    warn("tape write error on trace %d", itr);
                                if (++errcount > errmax)
                                    err("exceeded maximum io errors");
                            } else { /* Reset counter on successful tape IO */
                                errcount = 0;
                            }
                        } else {
                            fwrite(trbuf,sizeof(char),nsegy,tapefp);
                            if (ferror(tapefp)) {
                                if (verbose)
                                    warn("tape write error on trace %d", itr);
                                if (++errcount > errmax)
                                    err("exceeded maximum io errors");
                                    clearerr(tapefp);
                            } else { /* Reset counter on successful tape IO */
                                errcount = 0;
                            }
                        }

                        /* Echo under verbose option */
                        if (verbose && itr % vblock == 0)
                                warn(" %d traces written to tape", itr);
                }
        } while (gettr(&tr) && itr < trmax);


        /* Clean up */
        (buff) ?  eclose(tapefd) :
                  efclose(tapefp);
        if (verbose) warn("tape closed successfully");

        xdr_destroy(&trhd_xdr);
	xdr_destroy(&bhed_xdr);
	xdr_destroy(&bhbuf_xdr);
        efclose(binaryfp);
        if (verbose) warn("binary file closed successfully");

        return EXIT_SUCCESS;
}

/* Assumes fourbyte == 4 byte integer */
static void float_to_ibm(fourbyte *from, fourbyte *to, int n, int endian)
/**********************************************************************
 float_to_ibm - convert between 32 bit IBM and IEEE floating numbers
*********************************************************************** 
Input:
from       input vector
n          number of floats in vectors
endian     =0 for little endian machine, =1 for big endian machines

Output:
to         output vector, can be same as input vector

*********************************************************************** 
Notes:
Up to 3 bits lost on IEEE -> IBM

IBM -> IEEE may overflow or underflow, taken care of by 
substituting large number or zero

Only integer shifting and masking are used.
*********************************************************************** 
Credits:     CWP: Brian Sumner
***********************************************************************/
{
    register fourbyte fconv, fmant, t;
    register int i;

    for (i=0;i<n;++i) {
        fconv = from[i];
        if (fconv) {
            fmant = (0x007fffff & fconv) | 0x00800000;
            t = (fourbyte) ((0x7f800000 & fconv) >> 23) - 126;
            while (t & 0x3) { ++t; fmant >>= 1; }
            fconv = (0x80000000 & fconv) | (((t>>2) + 64) << 24) | fmant;
        }
        if(endian==0)
                fconv = (fconv<<24) | ((fconv>>24)&0xff) |
                        ((fconv&0xff00)<<8) | ((fconv&0xff0000)>>8);

        to[i] = fconv;
    }
    return;
}
#else
d12 1
a12 1
/* SEGYWRITE: $Revision: 1.40 $ ; $Date: 1998/03/26 22:47:49 $    */
a13 2
#include "su.h"
#include "segy.h"
a14 1
#include "tapebhdr.h"
d40 1
d55 1
d65 2
a66 3
 */

/* Credits:
d85 9
d95 4
d104 1
d107 3
d120 4
d125 1
d144 22
d168 2
a169 2


d187 1
d202 61
d299 1
a299 1
	bh.format = 1;	/* indicate SEG-Y data	*/
d303 2
d310 29
d342 1
d346 1
d369 1
d373 9
d394 58
d494 2
d508 6
d517 1
d519 1
d524 49
d689 1
a689 1
#endif
@


1.40
log
@XDR version
@
text
@d1 1
a1 1
/* SEGYWRITE: $Revision: 1.33 $ ; $Date: 95/07/05 00:00:00 $    */
a89 1
static void zebc(char *input,char *output, int nchar);
a394 50
void zebc(char *input,char *output, int nchar)
/*************************************************************************
zasc -- convert strings from ASCII to EBCDIC

char *input    input string of ASCII characters
char *output   output string of EBCDIC characters (may be same as input)
int nchar      number of characters to convert
**************************************************************************/
{
  static unsigned char const ascii_to_ebcdic[] =
  {
  0, 01, 02, 03, 067, 055, 056, 057,
  026, 05, 045, 013, 014, 015, 016, 017,
  020, 021, 022, 023, 074, 075, 062, 046,
  030, 031, 077, 047, 034, 035, 036, 037,
  0100, 0117, 0177, 0173, 0133, 0154, 0120, 0175,
  0115, 0135, 0134, 0116, 0153, 0140, 0113, 0141,
  0360, 0361, 0362, 0363, 0364, 0365, 0366, 0367,
  0370, 0371, 0172, 0136, 0114, 0176, 0156, 0157,
  0174, 0301, 0302, 0303, 0304, 0305, 0306, 0307,
  0310, 0311, 0321, 0322, 0323, 0324, 0325, 0326,
  0327, 0330, 0331, 0342, 0343, 0344, 0345, 0346,
  0347, 0350, 0351, 0112, 0340, 0132, 0137, 0155,
  0171, 0201, 0202, 0203, 0204, 0205, 0206, 0207,
  0210, 0211, 0221, 0222, 0223, 0224, 0225, 0226,
  0227, 0230, 0231, 0242, 0243, 0244, 0245, 0246,
  0247, 0250, 0251, 0300, 0152, 0320, 0241, 07,
  040, 041, 042, 043, 044, 025, 06, 027,
  050, 051, 052, 053, 054, 011, 012, 033,
  060, 061, 032, 063, 064, 065, 066, 010,
  070, 071, 072, 073, 04, 024, 076, 0341,
  0101, 0102, 0103, 0104, 0105, 0106, 0107, 0110,
  0111, 0121, 0122, 0123, 0124, 0125, 0126, 0127,
  0130, 0131, 0142, 0143, 0144, 0145, 0146, 0147,
  0150, 0151, 0160, 0161, 0162, 0163, 0164, 0165,
  0166, 0167, 0170, 0200, 0212, 0213, 0214, 0215,
  0216, 0217, 0220, 0232, 0233, 0234, 0235, 0236,
  0237, 0240, 0252, 0253, 0254, 0255, 0256, 0257,
  0260, 0261, 0262, 0263, 0264, 0265, 0266, 0267,
  0270, 0271, 0272, 0273, 0274, 0275, 0276, 0277,
  0312, 0313, 0314, 0315, 0316, 0317, 0332, 0333,
  0334, 0335, 0336, 0337, 0352, 0353, 0354, 0355,
  0356, 0357, 0372, 0373, 0374, 0375, 0376, 0377
  };
  int i;
  for(i=0;i<nchar;i++) {
      output[i]=ascii_to_ebcdic[input[i]];
  }
  return;
}
d397 1
a397 1
/* SEGYWRITE: $Revision: 1.39 $ ; $Date: 1997/08/07 14:58:39 $    */
@


1.39
log
@added Toralf's if (bh.ntrpr == 0)
@
text
@d1 448
a448 1
/* SEGYWRITE: $Revision: 1.38 $ ; $Date: 1996/09/09 16:30:31 $    */
d861 1
@


1.38
log
@changed includes to reflect new include file tapebhdr.h
@
text
@d1 1
a1 1
/* SEGYWRITE: $Revision: 1.37 $ ; $Date: 1996/09/03 21:37:46 $    */
d185 2
a186 1
	bh.ntrpr  = 1;	/* one trace per record */
@


1.37
log
@Did -Wall stuff.
@
text
@d1 1
a1 1
/* SEGYWRITE: $Revision: 1.36 $ ; $Date: 1995/09/27 16:47:36 $    */
d6 1
@


1.36
log
@changed LONG_MAX to INT_MAX to prevent truncation error
@
text
@d1 1
a1 1
/* SEGYWRITE: $Revision: 1.35 $ ; $Date: 1995/09/18 13:38:51 $    */
d6 1
d10 14
a23 14
"                                                                       ",
" SEGYWRITE - write an SEG-Y tape                                       ",
"                                                                       ",
" segywrite <stdin tape=		                                ",
"                                                                       ",
" Required parameters:                                                  ",
"       tape=		tape device to use (see sudoc segyread)		",
"                                                                       ",
" Optional parameter:                                                   ",
"       verbose=0       silent operation                                ",
"                       =1 ; echo every 'vblock' traces                 ",
"       vblock=50       echo every 'vblock' traces under verbose option ",
"       buff=1          for buffered device (9-track reel tape drive)   ",
"                       =0 possibly useful for 8mm EXABYTE drive	",
d25 16
a40 16
"       hfile=header    ebcdic card image header file                   ",
"       bfile=binary    binary header file                              ",
"       trmin=1 first trace to write                                    ",
"       trmax=INT_MAX  last trace to write                             ",
"       endian=1        =0 for little-endian machines (PC's, DEC,etc...)",
"       errmax=0        allowable number of consecutive tape IO errors  ",
"                                                                       ",
" Note: The header files may be created with  'segyhdrs'.               ",
"                                                                       ",
"                                                                       ",
" Note: For buff=1 (default) tape is accessed with 'write', for buff=0  ",
"       tape is accessed with fwrite. Try the default setting of buff=1 ",
"       for all tape types.                                             ",
" Caveat: may be slow on an 8mm streaming (EXABYTE) tapedrive           ",
" Warning: segyread or segywrite to 8mm tape is fragile. Allow time     ",
"          between successive reads and writes.                         ",
d42 3
a44 3
"          tapefiles.                                                   ",
"                                                                       ",
" For more information, type:   sudoc <segywrite>                       ",
d49 5
a53 5
 *       intermittently when segyreading/segywriting to 8mm EXABYTE tape,
 *       even if actual segyread/segywrite is successful. However, this
 *       may indicate that your tape drive has been set to a fixed block
 *       size. Tape drives should be set to variable block size before reading
 *       or writing tapes in the SEG-Y format.
d57 3
a59 3
 *      SEP: Einar Kjartansson
 *      CWP: Jack, Brian, Chris
 *         : John Stockwell (added EXABYTE functionality)
d61 3
a63 3
 *      Brian's subroutine, float_to_ibm, for converting IEEE floating
 *      point to IBM floating point is NOT portable and must be
 *      altered for non-IEEE machines.  See the subroutine notes below.
d65 3
a67 3
 *      On machines where shorts are not 2 bytes and/or ints are not 
 *      4 bytes, routines to convert SEGY 16 bit and 32 bit integers 
 *      will be required.
d69 2
a70 2
 *      The program, segyhdrs, can be used to make the ascii and binary
 *      files required by this code.
d79 1
a79 1
        segy_to_tapesegy(const segy *trptr, tapesegy *tapetrptr, size_t nsegy); 
d86 1
d89 141
a229 141
        cwp_String tape;        /* name of raw tape device              */
        cwp_String hfile;       /* name of ebcdic header file           */
        cwp_String bfile;       /* name of binary header file           */

        FILE *pipefp;           /* file pointer for popen read          */
        FILE *tapefp;           /* file pointer for tape                */
        FILE *binaryfp;         /* file pointer for bfile               */

        int tapefd;             /* file discriptor for tape buff=0      */

        int i;                  /* counter                              */
        int ns;                 /* number of data samples               */
        size_t nsegy;           /* size of whole trace in bytes         */
        int itr;                /* current trace number                 */
        int trmax;              /* last trace to write                  */
        int trmin;              /* first trace to write                 */
        int verbose;            /* echo every ...                       */
        int vblock;             /* ... vblock traces with verbose=1     */
        int buff;               /* buffered or unbuffered device        */
        int endian;             /* =0 little endian; =1 big endian      */
        int conv;               /* =1 IBM format =0 don't convert	*/
        int errmax;             /* max consecutive tape io errors       */
        int errcount = 0;       /* counter for tape io errors           */
        char cmdbuf[BUFSIZ];    /* dd command buffer                    */
        char ebcbuf[EBCBYTES];  /* ebcdic data buffer                   */


        /* Initialize */
        initargs(argc, argv);
        requestdoc(1);


        /* Get parameters */
        MUSTGETPARSTRING("tape", &tape);
        if (!getparstring("hfile", &hfile))     hfile = "header";
        if (!getparstring("bfile", &bfile))     bfile = "binary";
        if (!getparint   ("trmin", &trmin))     trmin = 1;
        if (!getparint   ("trmax", &trmax))     trmax = INT_MAX;
        if (!getparint   ("verbose", &verbose)) verbose = 0;
        if (!getparint   ("vblock", &vblock))   vblock = 50;
        if (!getparint   ("buff", &buff))       buff = 1;
        if (!getparint   ("conv", &conv))       conv = 1;
        if (!getparint   ("endian", &endian))   endian = 1;
        if (!getparint   ("errmax", &errmax))   errmax = 0;
        
        /* Check parameters */
        if (trmin < 1 || trmax < 1 || trmax < trmin)
                err("bad trmin/trmax values, trmin = %d, trmax = %d",
                        trmin, trmax);

        /* Get first trace early to be sure that binary file is ready */
        gettr(&tr);

        /* Open files - first the tape */
        if (buff) tapefd = eopen(tape, O_WRONLY | O_CREAT | O_TRUNC, 0666);
        else tapefp = efopen(tape, "w");
        if (verbose) warn("tape opened successfully ");

        /* - binary header file */
        binaryfp = efopen(bfile, "r");
        if (verbose) warn("binary file opened successfully");

        /* Open pipe to use dd to convert ascii to ebcdic */
        sprintf(cmdbuf, "dd if=%s conv=ebcdic cbs=80 obs=3200", hfile);
        pipefp = epopen(cmdbuf, "r");

        /* Read ebcdic stream from pipe into buffer */
        efread(ebcbuf, 1, EBCBYTES, pipefp);

        /* Write ebcdic stream to tape */
        if (buff) {
                if (EBCBYTES != write(tapefd, ebcbuf, EBCBYTES)) {
                        if (verbose)
                                warn("tape write error on ebcdic header");
                        if (++errcount > errmax)
                                err("exceeded maximum io errors");
                } else { /* Reset counter on successful tape IO */
                        errcount = 0;
                }
        } else {
                 fwrite(ebcbuf, 1, EBCBYTES, tapefp);
                 if (ferror(tapefp)) {
                        if (verbose)
                                warn("tape write error on ebcdic header");
                        if (++errcount > errmax)
                                err("exceeded maximum io errors");
                        clearerr(tapefp);
                } else { /* Reset counter on successful tape IO */
                        errcount = 0;
                }
        }

        /* Read binary file into bh structure */
        efread((char *) &bh, 1, BNYBYTES, binaryfp);
        bh.format = 1;  /* indicate SEG-Y data  */
        bh.ntrpr  = 1;  /* one trace per record */

        /* Compute trace size (can't use HDRBYTES here!) */
        ns = bh.hns;
        if (!ns) err("bh.hns not set in binary header");
        nsegy = ns*4 + SEGY_HDRBYTES;

        /* if little endian (endian=0) swap bytes of binary header */
        if (endian==0) for (i = 0; i < BHED_NKEYS; ++i) swapbhval(&bh,i);

        /* Convert from ints/shorts to bytes */
        bhed_to_tapebhed(&bh, &tapebh);

        /* Write binary structure to tape */
        if (buff) {
                if (BNYBYTES != write(tapefd, (char *) &tapebh, BNYBYTES)) {
                        if (verbose)
                                warn("tape write error on binary header");
                        if (++errcount > errmax)
                                err("exceeded maximum io errors");
                } else { /* Reset counter on successful tape IO */
                        errcount = 0;
                }
        } else {
                 fwrite((char *) &tapebh, 1, BNYBYTES, tapefp);
                 if (ferror(tapefp)) {
                        if (verbose)
                                warn("tape write error on binary header");
                        if (++errcount > errmax)
                                err("exceeded maximum io errors");
                        clearerr(tapefp);
                } else { /* Reset counter on successful tape IO */
                        errcount = 0;
                }
        }


        /* Copy traces from stdin to tape */
        itr = 0;
        do {

                /* Set/check trace header words */
                tr.tracr = ++itr;
                if (tr.ns != ns)
                        err("conflict: tr.ns = %d, bh.ns = %d: trace %d",
                                        tr.ns, ns, itr);
d231 2
a232 2
                /* Convert and write desired traces */
                if (itr >= trmin) {
d234 2
a235 2
                
                        /* Convert internal floats to IBM floats */
d238 1
a238 1
                                                                ns, endian);
d240 7
a246 7
                       /* handle no ibm conversion for little endian case */
                       if (conv==0 && endian==0)
                                for (i = 0; i < ns ; ++i)
                                        swap_float_4(&tr.data[i]);
                        
                        /* if little endian, swap bytes in header */
                        if (endian==0)
d249 2
a250 2
                        /* Convert from ints/shorts to bytes */
                        segy_to_tapesegy(&tr, &tapetr, nsegy);
d252 35
a286 35
                        /* Write the trace to tape */
                        if (buff) {
                            if (nsegy !=
                               write(tapefd, (char *) &tapetr, nsegy)){
                                if (verbose)
                                    warn("tape write error on trace %d", itr);
                                if (++errcount > errmax)
                                    err("exceeded maximum io errors");
                            } else { /* Reset counter on successful tape IO */
                                errcount = 0;
                            }
                        } else {
                            fwrite((char *)&tapetr,1,nsegy,tapefp);
                            if (ferror(tapefp)) {
                                if (verbose)
                                    warn("tape write error on trace %d", itr);
                                if (++errcount > errmax)
                                    err("exceeded maximum io errors");
                                    clearerr(tapefp);
                            } else { /* Reset counter on successful tape IO */
                                errcount = 0;
                            }
                        }

                        /* Echo under verbose option */
                        if (verbose && itr % vblock == 0)
                                warn(" %d traces written to tape", itr);
                }
        } while (gettr(&tr) && itr < trmax);


        /* Clean up */
        (buff) ?  eclose(tapefd) :
                  efclose(tapefp);
        if (verbose) warn("tape closed successfully");
d288 2
a289 2
        efclose(binaryfp);
        if (verbose) warn("binary file closed successfully");
d291 1
a291 1
        epclose(pipefp);
d293 1
a293 1
        return EXIT_SUCCESS;
d302 3
a304 3
from       input vector
n          number of floats in vectors
endian     =0 for little endian machine, =1 for big endian machines
d307 1
a307 1
to         output vector, can be same as input vector
d324 10
a333 10
        fconv = from[i];
        if (fconv) {
            fmant = (0x007fffff & fconv) | 0x00800000;
            t = (int) ((0x7f800000 & fconv) >> 23) - 126;
            while (t & 0x3) { ++t; fmant >>= 1; }
            fconv = (0x80000000 & fconv) | (((t>>2) + 64) << 24) | fmant;
        }
        if(endian==0)
                fconv = (fconv<<24) | ((fconv>>24)&0xff) |
                        ((fconv&0xff00)<<8) | ((fconv&0xff0000)>>8);
d335 1
a335 1
        to[i] = fconv;
d361 3
a363 3
        register int i;
        Value val;
        
d365 4
a368 4
        for (i = 0; i < BHED_NKEYS; ++i) {
                getbhval(bhptr, i, &val);
                puttapebhval(tapebhptr, i, &val);
        }
d389 1
a389 1
would be needed on a machine not using this convention.  The float data
d396 3
a398 3
        register int i;
        Value val;
        
d400 5
a404 5
        for (i = 0; i < SEGY_NKEYS; ++i) {
                gethval(trptr, i, &val);
                puttapehval(tapetrptr, i, &val);
        }
        
d409 1
a409 1
        memcpy(tapetrptr->data, trptr->data, 4*SU_NFLTS);
@


1.35
log
@Preserve the optional fields in tapesegy_to_segy subroutine.
@
text
@d1 1
a1 1
/* SEGYWRITE: $Revision: 1.34 $ ; $Date: 1995/08/23 19:56:21 $    */
d27 1
a27 1
"       trmax=LONG_MAX  last trace to write                             ",
d124 1
a124 1
        if (!getparint   ("trmax", &trmax))     trmax = LONG_MAX;
@


1.34
log
@Tweaked self-doc.
@
text
@d1 1
a1 1
/* SEGYWRITE: $Revision: 1.33 $ ; $Date: 1995/08/23 19:54:09 $    */
d403 3
@


1.33
log
@Made tape= a required parameter.
@
text
@d1 1
a1 1
/* SEGYWRITE: $Revision: 1.32 $ ; $Date: 1995/04/26 14:03:48 $    */
d12 1
a12 1
" segywrite <stdin tape			                                ",
d15 1
a15 1
"       tape=		tape device to use (see notes)			",
@


1.32
log
@fixed bug in swapping
@
text
@d1 1
a1 1
/* SEGYWRITE: $Revision: 1.31 $ ; $Date: 94/10/28 10:21:29 $    */
d12 1
a12 1
" segywrite <stdin [tape=RMTDEVICE]                                     ",
d15 1
a15 1
"       none                                                            ",
a20 1
"       tape=RMTDEVICE  tape device to use, see suport.h                ",
d120 1
a120 1
        if (!getparstring("tape", &tape))       tape  = RMTDEVICE;
@


1.31
log
@added conv parameter to give user choice on IBM to float conversion
@
text
@d1 1
a1 1
/* SEGYWRITE: $Revision: 1.30 $ ; $Date: 94/10/10 10:48:28 $    */
d238 5
@


1.30
log
@updated documentation in internal subroutines.
@
text
@d1 1
a1 1
/* SEGYWRITE: $Revision: 1.29 $ ; $Date: 94/10/07 09:58:38 $    */
d24 1
d108 1
d129 1
d235 2
a236 1
                        float_to_ibm((int *) tr.data, (int *) tr.data,
@


1.29
log
@cosmetic
@
text
@d1 1
a1 1
/* SEGYWRITE: $Revision: 1.28 $ ; $Date: 94/10/07 09:55:19 $    */
d333 3
a335 1
 bhed_to_tapebhed - writes binary header vector to tape binary header vector
d344 3
a346 1
Assumes sizeof(short) == 2, sizeof(int) == 4
d354 1
d364 3
a366 1
segy_to_tapesegy - writes SU SEG-Y traces to TAPE SEGY-Y traces
d376 6
a381 6
The SU implementation of the SEG-Y type is machine dependent because
the size of floats, shorts, longs, and ints may vary between platforms.
The SEG-Y tape standard is not machine dependent in this way and
must kept separate.

Assumes sizeof(short) == 2, sizeof(int) == 4
d389 1
d395 1
@


1.28
log
@changed selfdoc information
@
text
@d1 1
a1 1
/* SEGYWRITE: $Revision: 1.27 $ ; $Date: 94/09/06 10:00:28 $    */
d356 2
a357 3
/* Assumes sizeof(short) == 2, sizeof(int) == 4 */
static void
segy_to_tapesegy(const segy *trptr, tapesegy *tapetrptr, size_t nsegy)
@


1.27
log
@Added the routines bhed_to_tapebhed, segy_to_tapesegy and the
include file tapesegy.h to support writing individual fields
in the trace and binary headers (both on tape and in diskfiles).  The idea
is to avoid alignment problems (i.e. don't want to create "gaps")
on non-conventional architectures.  This plan is not, however,
carried out 100% in this version.

No longer write out optional fields!  (So these local fields are lost!)
Eliminated includes hdr.h header.h

Replaced declaration: unsigned int nsegy; by size_t nsegy;
The routine swap_bhed() was replaced by a loop over the binary key words.
@
text
@d1 1
a1 1
/* SEGYWRITE: $Revision: 1.6 $ ; $Date: 94/09/01 14:57:13 $    */
d23 1
a23 1
"                       =0 for unbuffered device (8mm EXABYTE drive)    ",
d35 2
a36 1
"       tape is accessed with fwrite.                                   ",
d289 1
a289 1
* float_to_ibm - convert between 32 bit IBM and IEEE floating numbers
d291 8
a298 5
* input:
*    from      - input vector
*    to        - output vector, can be same as input vector
*    n         - number of floats in vectors
*    endian    - =0 for little endian machine, =1 for big endian machines
d300 7
a306 7
* Notes:
*      Up to 3 bits lost on IEEE -> IBM
*
*      IBM -> IEEE may overflow or underflow, taken care of by 
*      substituting large number or zero
*
*      Only integer shifting and masking are used.
d308 1
a308 2
* Credits:
*      CWP: Brian Sumner
a309 1

a330 1
/* Assumes sizeof(short) == 2, sizeof(int) == 4 */
d332 14
d359 20
@


1.26
log
@Removed copyright statement from codes that had it.
Moved self-doc line for sudoc.
@
text
@d1 1
a1 1
/* SEGYWRITE: $Revision: 1.25 $ ; $Date: 94/08/18 13:57:07 $    */
d5 1
a5 1
#include "header.h"
d10 1
a10 1
" SEGYWRITE - write an SEG-Y tape					",
d19 2
a20 2
"                       =1 ; echo every 'vblock' traces			",
"	vblock=50	echo every 'vblock' traces under verbose option	",
d22 2
a23 2
"       buff=1          for buffered device (9-track reel tape drive)	",
"                       =0 for unbuffered device (8mm EXABYTE drive)	",
d28 2
a29 2
"	endian=1	=0 for little-endian machines (PC's, DEC,etc...)",
"	errmax=0	allowable number of consecutive tape IO errors	",
a31 1
"		                                                        ",
d33 1
a35 1
" Caveat: tapes made with buff=0 may not be portable!			",
d37 2
a38 2
" Warning: segyread or segywrite to 8mm tape is fragile. Allow time	",
"          between successive reads and writes.                 	",
d40 1
a40 1
" 	   tapefiles.							",
d59 1
a59 1
 *      Brian's subroutine, float_to_ibm, which converts IEEE floating
d63 3
a65 3
 *      On machines where shorts are
 *      not 2 bytes and/or longs are not 4 bytes, routines to convert
 *      SEGY 16 bit and 32 bit integers will be required.
d75 3
a77 1
static void swap_bhed();
d79 2
d96 1
a96 1
	int i;			/* counter 				*/
d98 1
a98 1
        unsigned int nsegy;     /* size of whole trace in bytes         */
d102 2
a103 2
        int verbose;            /* echo every ...			*/
        int vblock;		/* ... vblock traces with verbose=1	*/
d105 3
a107 3
        int endian;		/* =0 little endian =1 big endian       */
	int errmax;		/* max consecutive tape io errors	*/
	int errcount = 0;	/* counter for tape io errors		*/
d118 1
a118 1
        if (!getparstring("tape", &tape))	tape  = RMTDEVICE;
d124 1
a124 1
        if (!getparint   ("vblock", &vblock))	vblock = 50;
d126 7
a132 2
        if (!getparint   ("endian", &endian))	endian = 1;
	if (!getparint   ("errmax", &errmax))	errmax = 0;
d134 2
a135 4
	/* Check parameters */
	if (trmin < 1 || trmax < 1 || trmax < trmin)
		err("bad trmin/trmax values, trmin = %d, trmax = %d",
			trmin, trmax);
a136 3
	/* Get first trace early to be sure that binary file is ready */
	gettr(&tr);

d143 2
a144 2
	binaryfp = efopen(bfile, "r");
	if (verbose) warn("binary file opened successfully");
d155 9
a163 9
		if (EBCBYTES != write(tapefd, ebcbuf, EBCBYTES)) {
			if (verbose)
				warn("tape write error on ebcdic header");
			if (++errcount > errmax)
				err("exceeded maximum io errors");
		} else { /* Reset counter on successful tape IO */
			errcount = 0;
		}
	} else {
d165 10
a174 10
		 if (ferror(tapefp)) {
			if (verbose)
				warn("tape write error on ebcdic header");
			if (++errcount > errmax)
				err("exceeded maximum io errors");
			clearerr(tapefp);
		} else { /* Reset counter on successful tape IO */
			errcount = 0;
		}
	}
d184 1
a184 1
        nsegy = ns*4 + 240;
d186 2
a187 2
	/* if little endian (endian=0) swap bytes of binary header */
	if (endian==0) swap_bhed();
d189 3
d194 20
a213 20
		if (BNYBYTES != write(tapefd, (char *) &bh, BNYBYTES)) {
			if (verbose)
				warn("tape write error on binary header");
			if (++errcount > errmax)
				err("exceeded maximum io errors");
		} else { /* Reset counter on successful tape IO */
			errcount = 0;
		}
	} else {
                 fwrite((char *) &bh, 1, BNYBYTES, tapefp);
		 if (ferror(tapefp)) {
			if (verbose)
				warn("tape write error on binary header");
			if (++errcount > errmax)
				err("exceeded maximum io errors");
			clearerr(tapefp);
		} else { /* Reset counter on successful tape IO */
			errcount = 0;
		}
	}
d229 1
a229 1
		
d232 1
a232 1
								ns, endian);
d234 3
a236 3
			/* if little endian(endian=0) swap bytes in header */
			if (endian==0) for (i = 0; i < SU_NKEYS; ++i)
						swaphval(&tr,i);
d238 3
d242 22
a263 21
			if (buff) {
			    if (nsegy != write(tapefd, (char *) &tr, nsegy)){
				if (verbose)
				    warn("tape write error on trace %d", itr);
				if (++errcount > errmax)
				    err("exceeded maximum io errors");
			    } else { /* Reset counter on successful tape IO */
				errcount = 0;
			    }
			} else {
			    fwrite((char *)&tr,1,nsegy,tapefp);
			    if (ferror(tapefp)) {
			        if (verbose)
				    warn("tape write error on trace %d", itr);
				if (++errcount > errmax)
				    err("exceeded maximum io errors");
				    clearerr(tapefp);
			    } else { /* Reset counter on successful tape IO */
				errcount = 0;
			    }
			}
d274 1
a274 1
        	  efclose(tapefp);
d312 2
a313 2
	fconv = from[i];
	if (fconv) {
d319 3
a321 2
	if(endian==0) fconv = (fconv<<24) | ((fconv>>24)&0xff) |
		((fconv&0xff00)<<8) | ((fconv&0xff0000)>>8);
d323 1
a323 1
	to[i] = fconv;
a327 4
static void swap_bhed()
/*******************************************************************
swap_bhed -  swap the bytes in the binary header
********************************************************************
d329 2
a330 3
********************************************************************
Author: Jens Hartmann 
********************************************************************/
d332 23
a354 26
  swap_int_4(&bh.jobid);
  swap_int_4(&bh.lino);
  swap_int_4(&bh.reno);
  swap_short_2(&bh.ntrpr);
  swap_short_2(&bh.nart);
  swap_short_2(&bh.hdt);
  swap_short_2(&bh.dto);
  swap_short_2(&bh.hns);
  swap_short_2(&bh.nso);
  swap_short_2(&bh.format);
  swap_short_2(&bh.fold);
  swap_short_2(&bh.tsort);
  swap_short_2(&bh.vscode);
  swap_short_2(&bh.hsfe);
  swap_short_2(&bh.hslen);
  swap_short_2(&bh.hstyp);
  swap_short_2(&bh.schn);
  swap_short_2(&bh.hstas);
  swap_short_2(&bh.hstae);
  swap_short_2(&bh.htatyp);
  swap_short_2(&bh.hcorr);
  swap_short_2(&bh.bgrcv);
  swap_short_2(&bh.rcvm);
  swap_short_2(&bh.mfeet);
  swap_short_2(&bh.polyt);
  swap_short_2(&bh.vpol);
@


1.25
log
@Added option to let user specify how often to echo traces read/write
instead of doing it at 50.
Added option of ignoring so many consecutive read/write errors to tape.
Added caveat that buff=0 makes tapes non-portable.
@
text
@d1 1
a1 1
/* SEGYWRITE: $Revision: 1.24 $ ; $Date: 94/08/15 12:39:06 $    */
@


1.24
log
@Replaced delay fudge with Stew Levin's early gettr ploy (to enable
piping into segywrite).
@
text
@d1 1
a1 1
/* SEGYWRITE: $Revision: 1.23 $ ; $Date: 94/08/02 14:41:19 $    */
d10 1
a10 1
" SEGYWRITE - write an SEG-Y tape                                       ",
d19 2
a20 1
"                       =1 ; echo every 20 traces                       ",
d29 1
d36 1
d99 2
a100 1
        int verbose;            /* echo every 20th trace                */
d103 2
d115 1
a115 1
        if (!getparstring("tape", &tape))       tape  = RMTDEVICE;
d121 1
d123 3
a125 2
        if (!getparint   ("endian", &endian))       endian = 1;
	
d151 21
a171 2
        (buff) ? ewrite(tapefd, ebcbuf, EBCBYTES) :
                 efwrite(ebcbuf, 1, EBCBYTES, tapefp);
d187 21
a207 2
        (buff) ? ewrite(tapefd, (char *) &bh, BNYBYTES) :
                 efwrite((char *) &bh,1, BNYBYTES,tapefp);
d233 21
a253 2
                        (buff) ? ewrite(tapefd, (char *) &tr, nsegy) :
				 efwrite((char *) &tr, 1, nsegy, tapefp);
d256 1
a256 1
                        if (verbose && itr % 50 == 0)
@


1.23
log
@Built in a delay in case of piped input. Hardwired 3 tries at
2 second intervals since 1 second seems to be enough.  Declared
subs "static".
@
text
@d1 1
a1 1
/* SEGYWRITE: $Revision: 1.22 $ ; $Date: 94/07/15 14:05:26 $    */
a83 3
        cwp_Bool ispipe;	/* Is stdin a pipe?		        */
	FileType ftypein;	/* filetype of stdin			*/

d117 5
d123 2
d131 3
a133 22
        /* - binary header file: on piped input make sure it's ready  */
	ftypein = filestat(STDIN);
	ispipe = (ftypein == PIPE || ftypein == FIFO) ? true : false;
	if (ispipe) { /* Expect file ready in 1 second, so hardwire delay */
		int ntries = 3;
		cwp_Bool succeed = false;
		while(ntries && !succeed) {
			sleep(2);
			if (NULL == (binaryfp = fopen(bfile, "r"))) {
		      		warn("waiting for binary file ...");
			} else {
				if (verbose)
				    warn("binary file opened successfully");
				succeed = true;
			}
			--ntries;
		}
		if (ntries == 0) err("couldn't open binary file");
	} else {
		binaryfp = efopen(bfile, "r");
        	if (verbose) warn("binary file opened successfully");
	}
a134 1

d166 1
a166 1
        while (gettr(&tr) && itr < trmax) {
d194 1
a194 1
        }
@


1.22
log
@cosmetic
@
text
@d1 1
a1 1
/* SEGYWRITE: $Revision: 1.21 $ ; $Date: 94/07/12 17:11:56 $    */
d72 2
a73 2
void float_to_ibm(int from[], int to[], int n, int endian);
void swap_bhed();
d84 3
d127 22
a148 3
        /* - binary header file */
        binaryfp = efopen(bfile, "r");
        if (verbose) warn("binary file opened successfully ");
d150 1
d195 2
a196 1
                        float_to_ibm((int *) tr.data, (int *) tr.data, ns, endian);
d198 1
a198 1
			/* if little endian(endian=0) swap bytes in tr header */
d227 1
a227 1
void float_to_ibm(int from[], int to[], int n, int endian)
d268 1
a268 1
void swap_bhed()
@


1.21
log
@changed swap_long_4 to swap_int_4 to reflect new segy.h convention
@
text
@d1 1
a1 1
/* SEGYWRITE: $Revision: 1.20 $ ; $Date: 94/03/30 11:07:05 $    */
a2 13
/*----------------------------------------------------------------------
 * Copyright (c) Colorado School of Mines, 1990.
 * All rights reserved.
 *
 * This code is part of SU.  SU stands for Seismic Unix, a processing line
 * developed at the Colorado School of Mines, partially based on Stanford
 * Exploration Project (SEP) software.  Inquiries should be addressed to:
 *
 *  Jack K. Cohen, Center for Wave Phenomena, Colorado School of Mines,
 *  Golden, CO 80401  (jkc@@dix.mines.colorado.edu)
 *----------------------------------------------------------------------
 */

d53 1
a53 1
 *      SEP: Einar
a66 2
 *      
 *      
@


1.20
log
@fixed big-endian little-endian error.
@
text
@d1 1
a1 1
/* SEGYWRITE: $Revision: 1.19 $ ; $Date: 94/03/25 09:56:50 $    */
d268 3
a270 3
  swap_long_4(&bh.jobid);
  swap_long_4(&bh.lino);
  swap_long_4(&bh.reno);
@


1.19
log
@put in byte-swapping.
@
text
@d1 1
a1 1
/* SEGYWRITE: $Revision: 1.18 $ ; $Date: 93/11/12 15:58:55 $    */
d131 1
d190 2
a191 1
			for (i = 0; i < SU_NKEYS; ++i) swaphval(&tr,i);
@


1.18
log
@*** empty log message ***
@
text
@d1 1
a1 1
/* SEGYWRITE: $Revision: 1.17 $ ; $Date: 93/11/12 15:57:48 $    */
d18 1
d40 1
d42 1
a42 1
" Note: The header files may be created with  'segyhdrs'      .         ",
d80 2
a81 1
 *
d87 2
a88 1
void float_to_ibm(int from[], int to[], int n);
d105 1
d113 1
d163 3
d184 1
d186 1
a186 1
                        float_to_ibm((int *) tr.data, (int *) tr.data, ns);
d188 3
d215 22
a237 31
/* float_to_ibm - convert between 32 bit IBM and IEEE floating numbers
 *
 * Credits:
 *      CWP: Brian
 *
 * Parameters:
 *    from      - input vector
 *    to        - output vector, can be same as input vector
 *    len       - number of floats in vectors
 *    type      - conversion type
 *
 * Notes:
 *      Up to 3 bits lost on IEEE -> IBM
 *
 *      IBM -> IEEE may overflow or underflow, taken care of by 
 *      substituting large number or zero
 *
 *      Only integer shifting and masking are used.
 *
 *      This routine assumes a big-endian machine.  If yours is little
 *      endian you will need to reverse the bytes in ibm_to_float
 *      with something like
 *
 *      fconv = from[i];
 *      fconv = (fconv<<24) | ((fconv>>24)&0xff) |
 *              ((fconv&0xff00)<<8) | ((fconv&0xff0000)>>8);
 *
 */

/* Assumes sizeof(int) == 4 */
void float_to_ibm(int from[], int to[], int n)
d242 2
a243 2
        fconv = from[i];
        if (fconv) {
d249 4
a252 1
        to[i] = fconv;
d256 37
@


1.17
log
@added additional notes.
@
text
@d1 1
a1 1
/* SEGYWRITE: $Revision: 1.16 $ ; $Date: 93/08/26 20:03:02 $    */
d49 1
a49 1
" 	   tapefiles.
@


1.16
log
@Eliminated bit version attempt at inserting portability stubs.
It probably caused some error in segywrite at the least.
Some cosmetics.
@
text
@d1 1
a1 1
/* SEGYWRITE: $Revision: 1.15 $ ; $Date: 93/08/26 13:46:12 $    */
d40 2
a41 1
" Note: The header files may be created with the segyhdrs code.         ",
a44 1
"                                                                       ",
d48 4
a51 3
" Bug: may return the error message \"efclose: fclose failed\"          ",
"       intermittently when segyreading/segywriting to 8mm EXABYTE tape,",
"       even if actual segyread/segywrite is successful.                ",
d53 9
@


1.15
log
@removed memcpy based subroutines
@
text
@d1 1
a1 1
/* SEGYWRITE: $Revision: 1.14 $ ; $Date: 93/08/24 08:57:42 $	*/
d21 30
a50 30
" 									",
" SEGYWRITE - write an SEG-Y tape					",
" 									",
" segywrite <stdin [tape=RMTDEVICE] 					",
" 									",
" Required parameters:							",
" 	none								",
" 									",
" Optional parameter:							",
" 	verbose=0	silent operation				",
" 			=1 ; echo every 20 traces			",
" 	tape=RMTDEVICE	tape device to use, see suport.h		",
" 	buff=1		for buffered device (standard 9-trac reel tape drive)",
" 			=0 for unbuffered device (8mm EXABYTE tape drive)",
" 	hfile=header	ebcdic card image header file			",
" 	bfile=binary	binary header file				",
" 	trmin=1	first trace to write					",
" 	trmax=LONG_MAX	last trace to write				",
" 									",
" Note: The header files may be created with the segyhdrs code.		",
" 									",
" Note: For buff=1 (default) tape is accessed with 'write', for buff=0	",
" 	tape is accessed with fwrite.					",
" 									",
" Caveat: may be slow on an 8mm streaming (EXABYTE) tapedrive		",
" Warning: segyread or segywrite to 8mm tape is fragile. Allow sufficient",
"	   time between successive reads and writes.			",
" Bug: may return the error message \"efclose: fclose failed\"		",
" 	intermittently when segyreading/segywriting to 8mm (EXABYTE) tape,",
"	even if actual segyread/segywrite is successful.		",
d54 3
a56 3
 *	SEP: Einar
 *	CWP: Jack, Brian, Chris
 *	   : John Stockwell (added EXABYTE functionality)
d58 3
a60 3
 *	Brian's subroutine, float_to_ibm, that converts IEEE floating
 *	point to IBM floating point is NOT portable and must be
 *	altered for non-IEEE machines.  See the subroutine notes below.
d63 2
a64 2
 *	not 2 bytes and/or longs are not 4 bytes, routines to convert
 *	SEGY 16 bit and 32 bit integers will be required.
d66 2
a67 2
 *	The program, segyhdrs, can be used to make the ascii and binary
 *	files required by this code.
d81 3
a83 3
	cwp_String tape;	/* name of raw tape device		*/
	cwp_String hfile;	/* name of ebcdic header file		*/
	cwp_String bfile;	/* name of binary header file		*/
d85 3
a87 3
	FILE *pipefp;		/* file pointer for popen read		*/
	FILE *tapefp;		/* file pointer for tape		*/
	FILE *binaryfp;		/* file pointer for bfile		*/
d89 1
a89 1
	int tapefd;		/* file discriptor for tape buff=0	*/
d91 9
a99 9
	int ns;			/* number of data samples		*/
	unsigned int nsegy;	/* size of whole trace in bytes		*/
	int itr;		/* current trace number			*/
	int trmax;		/* last trace to write			*/
	int trmin;		/* first trace to write			*/
	int verbose;		/* echo every 20th trace 		*/
	int buff;		/* buffered or unbuffered device 	*/
	char cmdbuf[BUFSIZ];	/* dd command buffer			*/
	char ebcbuf[EBCBYTES];	/* ebcdic data buffer			*/
d102 3
a104 3
	/* Initialize */
	initargs(argc, argv);
	requestdoc(1);
d107 8
a114 8
	/* Get parameters */
	if (!getparstring("tape", &tape))       tape  = RMTDEVICE;
	if (!getparstring("hfile", &hfile))     hfile = "header";
	if (!getparstring("bfile", &bfile))     bfile = "binary";
	if (!getparint   ("trmin", &trmin))     trmin = 1;
	if (!getparint   ("trmax", &trmax))     trmax = LONG_MAX;
	if (!getparint   ("verbose", &verbose)) verbose = 0;
	if (!getparint   ("buff", &buff)) 	buff = 1;
d117 4
a120 4
	/* Open files - first the tape */
	if (buff) tapefd = eopen(tape, O_WRONLY | O_CREAT | O_TRUNC, 0666);
	else tapefp = efopen(tape, "w");
	if (verbose) warn("tape opened successfully ");
d122 3
a124 3
	/* - binary header file */
	binaryfp = efopen(bfile, "r");
	if (verbose) warn("binary file opened successfully ");
d126 3
d130 2
a131 3
	/* Open pipe to use dd to convert ascii to ebcdic */
	sprintf(cmdbuf, "dd if=%s conv=ebcdic cbs=80 obs=3200", hfile);
	pipefp = epopen(cmdbuf, "r");
d133 3
a135 2
	/* Read ebcdic stream from pipe into buffer */
	efread(ebcbuf, 1, EBCBYTES, pipefp);
d137 4
a140 3
	/* Write ebcdic stream to tape */
	(buff) ? ewrite(tapefd, ebcbuf, EBCBYTES) :
		 efwrite(ebcbuf, 1, EBCBYTES, tapefp);
d142 4
a145 4
	/* Read binary file into bh structure */
	efread((char *) &bh, 1, BNYBYTES, binaryfp);
	bh.format = 1;	/* indicate SEG-Y data  */
	bh.ntrpr  = 1;  /* one trace per record */
d147 3
a149 4
	/* Compute trace size (can't use HDRBYTES here!) */
	ns = bh.hns;
	if (!ns) err("bh.hns not set in binary header");
	nsegy = ns*4 + 240;
a150 3
	/* Write binary structure to tape */
	(buff) ? ewrite(tapefd, (char *) &bh, BNYBYTES) :
		 efwrite((char *) &bh,1, BNYBYTES,tapefp);
d152 3
d156 5
a160 3
	/* Copy traces from stdin to tape */
	itr = 0;
	while (gettr(&tr) && itr < trmax) {
d162 2
a163 5
		/* Set/check trace header words */
		tr.tracr = ++itr;
		if (tr.ns != ns)
			err("conflict: tr.ns = %d, bh.ns = %d: trace %d",
					tr.ns, ns, itr);
d165 6
a170 2
		/* Convert and write desired traces */
		if (itr >= trmin) {
d172 5
a176 6
			/* Convert internal floats to IBM floats */
			float_to_ibm((int *) tr.data, (int *) tr.data, ns);
			
			/* Write the trace to tape */
			if (buff) ewrite(tapefd, (char *) &tr, nsegy);
		 	else efwrite((char *) &tr, 1, nsegy, tapefp);
a177 5
			/* Echo under verbose option */
			if (verbose && (itr % 50 == 0) )
				warn(" %d traces written to tape", itr);
		}
	}
d179 4
d184 2
a185 4
	/* Clean up */
	if (buff) eclose(tapefd);
	else efclose(tapefp);
	if (verbose) warn("tape closed successfully");
d187 1
a187 2
	efclose(binaryfp);
	if (verbose) warn("binary file closed successfully");
d189 1
a189 3
	epclose(pipefp);

	return EXIT_SUCCESS;
d196 1
a196 1
 *	CWP: Brian
d199 4
a202 4
 *    from	- input vector
 *    to	- output vector, can be same as input vector
 *    len	- number of floats in vectors
 *    type	- conversion type
d205 1
a205 1
 *	Up to 3 bits lost on IEEE -> IBM
d207 2
a208 2
 *	IBM -> IEEE may overflow or underflow, taken care of by 
 *	substituting large number or zero
d210 1
a210 1
 *	Only integer shifting and masking are used.
d212 3
a214 3
 *	This routine assumes a big-endian machine.  If yours is little
 *	endian you will need to reverse the bytes in ibm_to_float
 *	with something like
d216 3
a218 3
 *	fconv = from[i];
 *	fconv = (fconv<<24) | ((fconv>>24)&0xff) |
 *		((fconv&0xff00)<<8) | ((fconv&0xff0000)>>8);
d228 2
a229 2
	fconv = from[i];
	if (fconv) {
d235 1
a235 1
	to[i] = fconv;
@


1.14
log
@cosmetic change.
@
text
@d1 1
a1 1
/* SEGYWRITE: $Revision: 1.13 $ ; $Date: 93/08/09 15:18:53 $	*/
a17 1
#include "segytape.h"
a38 2
" 	buff=1		for buffered device (standard 9-trac reel tape drive)",
" 			=0 for unbuffered device (8mm EXABYTE tape drive)",
a51 1
/**************** end self doc ***********************************/
d62 1
a62 2
 *	The subroutines bhedsu_to_bhedtape and segysu_to_segytape are
 *	only stubs and are not portable.  On machines where shorts are
d71 2
a74 2
void bhedsu_to_bhedtape(void *bhptr, void *tapebhptr); 
void segysu_to_segytape(void *trptr, void *tapetrptr, int nsegy); 
a75 2
segytape tapetr;
bhedtape tapebh;
a147 3
	/* Convert from longs/shorts to bytes */
	bhedsu_to_bhedtape(&bh, &tapebh);

d149 1
a149 1
	(buff) ? ewrite(tapefd, (char *) &tapebh, BNYBYTES) :
a168 3
			/* Convert from longs/shorts to bytes*/
			segysu_to_segytape(&tr, &tapetr, nsegy);
		
d170 2
a171 2
			(buff) ? ewrite(tapefd, (char *) &tapetr, nsegy) :
				 efwrite((char *) &tapetr, 1, nsegy,tapefp);
d174 1
a174 1
			if (verbose && itr % 50 == 0 )
d181 2
a182 2
	(buff) ? eclose(tapefd) :
		 efclose(tapefp);
a189 1

a239 14


/* Next two routines are just stubs */

/* Assumes sizeof(short) == 2, sizeof(long) == 4 */
void bhedsu_to_bhedtape(void *bhptr, void *tapebhptr)
{
	memcpy(tapebhptr, bhptr, BNYBYTES);
} 
/* Assumes sizeof(short) == 2, sizeof(long) == 4 */
void segysu_to_segytape(void *trptr, void *tapetrptr, int nsegy)
{
	memcpy(tapetrptr, trptr, nsegy);
} 
@


1.13
log
@changed String to cwp_String
@
text
@d1 1
a1 1
/* SEGYWRITE: $Revision: 1.12 $ ; $Date: 92/11/17 10:33:39 $	*/
d88 3
a90 3
	cwp_String tape;		/* name of raw tape device		*/
	cwp_String hfile;		/* name of ebcdic header file		*/
	cwp_String bfile;		/* name of binary header file		*/
@


1.12
log
@Added stubs for 16-short, 32-long conversions.
Using conditionals for buff tests.
@
text
@d1 1
a1 1
/* SEGYWRITE: $Revision: 1.11 $ ; $Date: 92/11/06 08:30:04 $	*/
d88 3
a90 3
	String tape;		/* name of raw tape device		*/
	String hfile;		/* name of ebcdic header file		*/
	String bfile;		/* name of binary header file		*/
@


1.11
log
@added 8mm tape drive support
@
text
@d1 1
a1 1
/* SEGYWRITE: $Revision: 1.10 $ ; $Date: 92/10/22 16:33:43 $	*/
d18 1
a47 4
" Caveat: This program breaks if a \"short\" isn't 2 bytes or		",
"         a \"long\" isn't 4 bytes since the SEG-Y standard		",
"         demands this, but C doesn't impose these sizes.		",
" 									",
d62 3
a64 5
 *	The library subroutine, conv_float, that converts IEEE
 *	floating point to IBM floating point is NOT portable and must be
 *	altered for non-IEEE machines.  However, it has been written with
 *	an eye towards making that alteration rather painless once you
 *	know the byte order for the target machine.
d66 5
a73 1
 *
d76 4
d81 2
d96 1
a96 1
	int fdtape;		/* file discriptor for tape buff=0	*/
d125 2
a126 6
	if (buff) { /* use open */
		fdtape = eopen(tape, O_WRONLY | O_CREAT | O_TRUNC, 0666);
	} else { /* use fopen */
		tapefp = efopen(tape, "w");
	}

d142 2
a143 5
	if (buff) { /* use write */
		ewrite(fdtape, ebcbuf, EBCBYTES);
	} else { /* use fwrite */
		efwrite(ebcbuf, 1, EBCBYTES, tapefp);
	}
a149 1

d155 2
d159 2
a160 5
	if (buff) { /* use write */
		ewrite(fdtape, (char *) &bh, BNYBYTES);
	} else {
		efwrite( (char *) &bh,1, BNYBYTES,tapefp);
	}
d162 1
d178 4
a181 1

d183 2
a184 5
			if (buff) { /* use write */
				ewrite(fdtape, (char *) &tr, nsegy);
			} else { /* use fwrite */
				efwrite((char *) &tr,1, nsegy,tapefp);
			}
d187 1
a187 1
			if (verbose && itr % 20 == 0 )
d194 2
a195 5
	if (buff) { /* use close */
		eclose(fdtape);
	} else { /* use fclose */
		efclose(tapefp);
	}
d206 62
@


1.10
log
@new selfdoc installed
@
text
@d1 1
a1 1
/* SEGYWRITE: $Revision: 1.9 $ ; $Date: 92/06/15 13:04:58 $	*/
d21 36
a56 22
" 								",
" SEGYWRITE - write an SEG-Y tape				",
" 								",
" segywrite <stdin [tape=RMTDEVICE] 				",
" 								",
" Required parameters:						",
" 	none							",
" 								",
" Optional parameter:						",
" 	verbose=0	silent operation			",
" 			= 1 ; echo every 20 traces		",
" 	tape=RMTDEVICE	tape device to use, see suport.h	",
" 	hfile=header	ebcdic card image header file		",
" 	bfile=binary	binary header file			",
" 	trmin=1	first trace to write				",
" 	trmax=LONG_MAX	last trace to write			",
" 								",
" Note: The header files may be created with the segyhdrs code.	",
" 								",
" Caveat: This program breaks if a \"short\" isn't 2 bytes or	",
"         a \"long\" isn't 4 bytes since the SEG-Y standard	",
"         demands this, but C doesn't impose these sizes.	",
d63 1
a63 1
 *
d83 3
a85 15
	String tape;	/* name of raw tape device	*/
	String hfile;	/* name of ebcdic header file	*/
	String bfile;	/* name of binary header file	*/
	FILE *fp;	/* file pointer for popen read	*/
	int tfd;	/* file descriptor for tape	*/
	int bfd;	/* file descriptor for bfile	*/
	int ns;	        /* number of data samples	*/
	unsigned
	 int nsegy;	/* size of whole trace in bytes */
	int itr;	/* current trace number		*/
	int trmax;	/* last trace to write		*/
	int trmin;	/* first trace to write		*/
	int verbose;	/* echo every 20th trace 	*/
	char cmdbuf[BUFSIZ];	/* dd command buffer	*/
	char ebcbuf[EBCBYTES];	/* ebcdic data buffer	*/
d87 3
d91 13
d116 1
d120 5
a124 1
	tfd = eopen(tape, O_WRONLY | O_CREAT | O_TRUNC, 0666);
d126 2
d129 2
a130 1
	bfd = eopen(bfile, O_RDONLY, 0666);
d135 1
a135 1
	fp = epopen(cmdbuf, "r");
a136 1

d138 1
a138 1
	efread(ebcbuf, 1, EBCBYTES, fp);
a139 1

d141 5
a145 1
	ewrite(tfd, ebcbuf, EBCBYTES);
a146 1

d148 1
a148 1
	eread(bfd, (char *) &bh, BNYBYTES);
d160 5
a164 1
	ewrite(tfd, (char *) &bh, BNYBYTES);
a165 1

d183 5
a187 1
			ewrite(tfd, (char *) &tr, nsegy);
d197 11
a207 3
	eclose(tfd);
	eclose(bfd);
	epclose(fp);
@


1.9
log
@Now using new ibm_to_float and float_to_ibm routines.
@
text
@d1 1
a1 1
/* SEGYWRITE: $Revision: 1.8 $ ; $Date: 91/09/05 08:49:15 $	*/
d20 24
a43 25
String sdoc =
" 								\n"
" SEGYWRITE - write an SEG-Y tape				\n"
" 								\n"
" segywrite <stdin [tape=RMTDEVICE] 				\n"
" 								\n"
" Required parameters:						\n"
" 	none							\n"
" 								\n"
" Optional parameter:						\n"
" 	verbose=0	silent operation			\n"
" 			= 1 ; echo every 20 traces		\n"
" 	tape=RMTDEVICE	tape device to use, see suport.h	\n"
" 	hfile=header	ebcdic card image header file		\n"
" 	bfile=binary	binary header file			\n"
" 	trmin=1	first trace to write				\n"
" 	trmax=LONG_MAX	last trace to write			\n"
" 								\n"
" Note: The header files may be created with the segyhdrs code.	\n"
" 								\n"
" Caveat: This program breaks if a \"short\" isn't 2 bytes or	\n"
"         a \"long\" isn't 4 bytes since the SEG-Y standard	\n"
"         demands this, but C doesn't impose these sizes.	\n"
" 								\n"
;
d88 1
a88 1
	askdoc(1);
@


1.8
log
@string -> String and so forth
@
text
@d1 1
a1 1
/* SEGYWRITE: $Revision: 1.6 $ ; $Date: 90/12/18 14:13:07 $	*/
d41 1
a41 1
"         a \"long\" isn't 4 bytes since the the SEG-Y standard	\n"
d151 1
a151 1
			conv_float((char *) tr.data, (char *) tr.data, ns, 2);
@


1.7
log
@tweak self-doc
@
text
@d20 1
a20 1
string sdoc =
d24 1
a24 1
" segywrite <stdin [optional parameters]			\n"
d70 3
a72 3
	string tape;	/* name of raw tape device	*/
	string hfile;	/* name of ebcdic header file	*/
	string bfile;	/* name of binary header file	*/
d77 2
a78 1
	uint nsegy;	/* size of whole trace in bytes */
@


1.6
log
@Documented some machine dependencies in the self-doc.
@
text
@d1 1
a1 1
/* SEGYWRITE: $Revision: 1.5 $ ; $Date: 90/11/25 18:50:14 $	*/
d24 1
a24 1
" segywrite <stdin [tape=RMTDEVICE] 				\n"
@


1.5
log
@tweak
@
text
@d1 1
a1 1
/* SEGYWRITE: $Revision: 1.4 $ ; $Date: 90/11/25 18:43:33 $	*/
d39 4
@


1.4
log
@tweaks
@
text
@d1 1
a1 1
/* SEGYWRITE: $Revision: 1.3 $ ; $Date: 90/11/25 18:22:18 $	*/
d104 1
a104 1
	sprintf(cmdbuf, "/bin/dd if=%s conv=ebcdic cbs=80 obs=3200", hfile);
@


1.3
log
@Removed use of pfread; ansi c tweaks
@
text
@d1 1
a1 1
/* SEGYWRITE: $Revision: 1.2 $ ; $Date: 90/09/03 09:42:57 $	*/
d48 1
a48 1
 *	The library subroutine, conv_float, that converts Masscomp
d50 1
a50 1
 *	altered for other machines.  However, it has been written with
@


1.2
log
@ANSI C and syscalls changes--not checked!!
@
text
@d1 1
a1 1
/* SEGYWRITE: $Revision: 1.1 $ ; $Date: 90/04/15 17:52:52 $	*/
d20 21
a40 21
string sdoc = "\
								\n\
SEGYWRITE - write an SEG-Y tape					\n\
								\n\
segywrite <stdin [tape=RMTDEVICE] 				\n\
								\n\
Required parameters:						\n\
	none							\n\
								\n\
Optional parameter:						\n\
	verbose=0	silent operation			\n\
			= 1 ; echo every 20 traces		\n\
	tape=RMTDEVICE	tape device to use, see suport.h	\n\
	hfile=header	ebcdic card image header file		\n\
	bfile=binary	binary header file			\n\
	trmin=1	first trace to write				\n\
	trmax=LONG_MAX	last trace to write			\n\
								\n\
Note: The header files may be created with the segyhdrs code.	\n\
								\n\
";
a79 1
	void conv_float();	/* convert floats	*/
d88 6
a93 6
	if (!sgetpar("tape", &tape))       tape  = RMTDEVICE;
	if (!sgetpar("hfile", &hfile))     hfile = "header";
	if (!sgetpar("bfile", &bfile))     bfile = "binary";
	if (!igetpar("trmin", &trmin))     trmin = 1;
	if (!igetpar("trmax", &trmax))     trmax = LONG_MAX;
	if (!igetpar("verbose", &verbose)) verbose = 0;
d104 1
a104 2
	sprintf(cmdbuf,
		"/bin/dd if=%s conv=ebcdic cbs=80 obs=3200", hfile);
d109 1
a109 1
	pfread(ebcbuf, 1, EBCBYTES, fp);
d117 1
a117 1
	eread(bfd, &bh, BNYBYTES);
d129 1
a129 1
	ewrite(tfd, &bh, BNYBYTES);
d145 2
a146 2
			/* Convert Masscomp floats to IBM floats */
			conv_float(tr.data, tr.data, ns, 2);
d149 1
a149 1
			ewrite(tfd, &tr, nsegy);
d152 1
a152 1
			if (verbose && itr % 20 == 0 ) {
a153 1
			}
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/* SEGYWRITE: $Revision: 2.9 $ ; $Date: 89/11/04 14:50:02 $	*/
d4 1
a4 1
 * Copyright (c) Colorado School of Mines, 1989.
d12 1
a12 1
 *  Golden, CO 80401  (isis!csm9a!jkcohen)
d30 1
a30 1
	verbose = 0	silent operation			\n\
d32 5
a36 7
	tape 		the raw tape device to use, the default	\n\
			is the string RMTDEVICE defined in	\n\
			/portdefs.h			\n\
	hfile = header	ebcdic card image header file		\n\
	bfile = binary	binary header file			\n\
	trmin = 1	first trace to write			\n\
	trmax = INT_MAX	last trace to write			\n\
a59 5
/* Embed Revision Control System identifier strings */
static string progid =
	"   $Source: /src/su/src/RCS/segywrite.c,v $";
static string revid =
	"   $Revision: 2.9 $ ; $Date: 89/11/04 14:50:02 $";
a60 2


d64 1
a64 2
main(argc, argv)
int argc; char **argv;
d83 1
a83 1
	/* Initialize SU */
a84 5
	if (!igetpar("ID", &ID))	ID = 0;
	if (ID) {
		(void) fprintf(stderr, "%s\n", progid);
		(void) fprintf(stderr, "%s\n", revid);
	}
d93 1
a93 1
	if (!igetpar("trmax", &trmax))     trmax = INT_MAX;
d98 1
a98 4
	if (-1 == (tfd =
		open(tape, O_WRONLY | O_CREAT | O_TRUNC, 0666))) {
		syserr("can't open tape for output");
	}
d101 1
a101 3
	if (-1 == (bfd = open(bfile, O_RDONLY, 0666))) {
		syserr("can't open binary header file");
	}
d107 1
a107 3
	if (NULL == (fp = popen(cmdbuf, "r"))) {
		syserr("popen failed");
	}
a109 1

d119 1
a119 1
	eread(bfd, (char *) &bh, BNYBYTES);
d131 1
a131 1
	ewrite(tfd, (char *) &bh, BNYBYTES);
d148 1
a148 1
			conv_float((char *) tr.data, (char *) tr.data, ns, 2);
d151 1
a151 1
			ewrite(tfd, (char *) &tr, nsegy);
d162 3
a164 9
	if (-1 == close(tfd)) {
		syserr("close failed on tape");
	}
	if (-1 == close(bfd)) {
		syserr("close failed on binary header file");
	}
	if (-1 == pclose(fp)) {
		syserr("pclose failed");
	}
d167 1
a167 1
	return SUCCEED;
@
