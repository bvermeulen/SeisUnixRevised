head	1.20;
access;
symbols;
locks
	john:1.20; strict;
comment	@ * @;


1.20
date	2015.04.07.15.50.42;	author john;	state Exp;
branches;
next	1.19;

1.19
date	2011.11.16.23.16.23;	author john;	state Exp;
branches;
next	1.18;

1.18
date	2011.11.12.00.38.22;	author john;	state Exp;
branches;
next	1.17;

1.17
date	2010.02.04.18.37.18;	author john;	state Exp;
branches;
next	1.16;

1.16
date	2008.05.05.19.06.24;	author john;	state Exp;
branches;
next	1.15;

1.15
date	2006.11.07.22.58.42;	author john;	state Exp;
branches;
next	1.14;

1.14
date	2005.10.04.16.42.43;	author john;	state Exp;
branches;
next	1.13;

1.13
date	2004.12.24.00.01.45;	author john;	state Exp;
branches;
next	1.12;

1.12
date	2003.06.09.16.17.07;	author john;	state Exp;
branches;
next	1.11;

1.11
date	2001.06.22.16.18.40;	author john;	state Exp;
branches;
next	1.10;

1.10
date	98.01.15.22.55.39;	author john;	state Exp;
branches;
next	1.9;

1.9
date	97.05.05.17.37.57;	author john;	state Exp;
branches;
next	1.8;

1.8
date	97.03.11.20.31.40;	author john;	state Exp;
branches;
next	1.7;

1.7
date	96.08.19.21.55.51;	author jkc;	state Exp;
branches;
next	1.6;

1.6
date	96.02.05.19.48.52;	author jkc;	state Exp;
branches;
next	1.5;

1.5
date	95.09.28.21.20.34;	author jkc;	state Exp;
branches;
next	1.4;

1.4
date	95.07.12.10.25.27;	author john;	state Exp;
branches;
next	1.3;

1.3
date	95.01.19.11.44.18;	author john;	state Exp;
branches;
next	1.2;

1.2
date	94.08.25.15.00.46;	author jkc;	state Exp;
branches;
next	1.1;

1.1
date	94.02.02.11.49.31;	author john;	state Exp;
branches;
next	;


desc
@suresstat -- residual statics...
@


1.20
log
@Bitri Anand's change of mdt type to float
@
text
@/* Copyright (c) Colorado School of Mines, 2011.*/
/* All rights reserved.                       */

/* SURESSTAT: $Revision: 1.19 $ ; $Date: 2011/11/16 23:16:23 $		*/

#include "su.h"
#include "segy.h"
#include "header.h"

/*********************** self documentation ******************************/
char *sdoc[] = {
" 									",
" SURESSTAT - Surface consistent source and receiver statics calculation",
" 									",
"   suresstat <stdin [optional parameters]				",
" 									",
" Required parameters: 							",
" ssol=		output file source statics				",
" rsol=		output file receiver statics				",
" ntraces=	number of traces in input data set (must be correct!)	",
" 									",
" Optional parameters:							",
" ntpick=50 	maximum static shift (samples)         			",
" niter=5 	number of iterations					",
" nshot=240 	largest shot number (fldr=1 to nshot)			",
" nr=335 	largest receiver number (tracf=1 to nr)			",
" nc=574 	maximum number of cmp's (for array allocation)		",
" sfold=96 	maximum shot gather fold				",
" rfold=96 	maximum receiver gather fold				",
" cfold=48 	maximum cmp gather fold					",
" sub=0 	subtract super trace 1 from super trace 2 (=1)		",
" 		sub=0 strongly biases static to a value of 0		",
" mode=0 	use global maximum in cross-correllation window		",
"		=1 choose the peak perc=percent smaller than the global max.",
" perc=10. 	percent of global max (used only for mode=1)		",
" verbose=0 	print diagnostic output (verbose=1)                     ",
" 									",
" Notes:								",
" Estimates surface-consistent source and receiver statics, meaning that",
" there is one static correction value estimated for each shot and receiver",
" position.								",
" 									",
" The method employed here is based on the method of Ronen and Claerbout:",
" Geophysics 50, 2759-2767 (1985).					",
"  									",
" The output files are binary files containing the source and receiver	",
" statics, as a function of shot number (trace header fldr) and      	",
" receiver station number (trace header tracf). 			",
"  									",
" The code builds a supertrace1 and supertrace2, which are subsequently	",
" cross-correllated. The program then picks the time lag associated with",
" the largest peak in the cross-correllation according to two possible	",
" criteria set by the parameter \"mode\". If mode=0, the maximum of the	",
" cross-correllation window is chosen. If mode=1, the program will pick ",
" a peak which is up to perc=percent smaller than the global maximum, but",
" closer to zero lag than the global maximum.	(Choosing mode=0 is	",
" recommended.)								",
"  									",
" The geometry can be irregular: the program simply computes a static 	",
" correction for each shot record (fldr=1 to fldr=nshot), with any missing ",
" shots being assigned a static of 0.  A static correction for each    	",
" receiver station (tracf=1 to tracf=nr) is calculated, with missing    ",
" receivers again assigned a static of 0.                               ", 
"									",
" The ntracesces parameter must be equal to the number of prestack traces.",
" The ntpick parameter sets the maximum allowable shift desired (in	",
"   samples NOT time).							",
" The niter parameter sets the number of iterations desired.		",
" The nshot parameter must be equal to the maximum fldr number in	",
"     the data. Note that this number might be different from the actual",
"     number of shot records in the data (i.e., the maximum ep number).	",
"     For getting the correct maximum fldr number, you may use the surange",
"     command.								",
" The nr parameter must be equal to the largest number of receivers	",
"     per shot in the whole data.					",
" The nc parameter must be equal to the number of prestack traces in	",
"     the data.								",
" The sfold parameter must be equal to the nr parameter.		",
" The rfold parameter must be equal to the maximum ep number.		",
" The cfold parameter must be equal to the maximum CDP fold,		",
"     which is equal to the maximum number under the cdpt entry in the	",
"     output of the surange command.					",
"									",
" To apply the static corrections, use sustatic with hdrs=3		",
NULL};

/* Reference:
 *
 *  Ronen, J. and Claerbout, J., 1985, Surface-consistent residual statics
 *      estimation  by stack-power maximization: Geophysics, vol. 50,
 *      2759-2767.
 *
 * Credits:
 *	CWP: Timo Tjan, 4 October 1994
 *
 *      rewritten by Thomas Pratt, USGS, Feb. 2000.
 *
 * Trace header fields accessed: ns, dt, tracf, fldr, cdp
 */
/**************** end self doc *******************************************/


segy tr, tr2;

/* prototypes for functions defined and used below */
int max (float *trace, int mode, float perc, int nt);
void window (float *trace, int nt, int nnt, float *ntrace);

int
main(int argc, char **argv)
{
	int nt;			/* number of points on input traces*/
	float mdt;		/* sample rate in milliseconds*/
	int nt_super;		/* number of points on traces in supertrace*/
	int ntotal_super;	/* total number of points in supertrace*/
	int ntraces;		/* number of input traces*/
	int nshot, nc, nr;	/* number of shots, cmps and recs */
	int sfold, cfold, rfold;/* source, cmp and receiver fold */
	int n_o;		/* near offset */
	int ntcc;		/* nr. of points on c-c in traces */
	int ntpick;		/* nr. of points on trace for picking */
	int ntout;		/* nr. of points on c-c out traces */
	int nt_r;		/* nr. of points on resamp. c-c in traces */
	int resamp;		/* resampling rate */
	int ntr;		/* number of trace on input */
	int iter, niter;	/* iteration vars */
	register int ishot, ichan, irec, icmp;	/* gather counters */
	register int itrace;    /* gather counters */
	int icmpshift;			/* shift applied to icmp */
	register int it, i, j=0, k, l;	/* counters */
	int *cmpntr;		/* cmp selector */
	int *recntr;				/* receiver gather fold */
	int *shotntr;				/* shot gather fold */
	int **cmp_loc, **rec_loc, **shot_loc;	/* position arrays */
	int **header;
	int mode;			/* pick global(=0) or local(=1) max */
	int sub;			/* subtract or not */
	int tlag;			/* time lag of c-c trace */
	int verbose;			/* diagnostic output (=1) */
	int *sstat, *rstat;		/* shot and receiver static */
	float *tsstat, *trstat;		/* total shot and receiver static */
	float perc;			/* local max. witin perc. of global */
	float dt;			/* sampling rate */
	float **data, **model;		/* data arrays */
	float *g_trace;			/* trace arrays */
	float *t;			/* trace arrays */
	float *model_trace, *corr_trace;/* more trace arrays */
	float *filter, *cc_tr, *pick_tr;/* more trace arrays */
	float *filter_r, *cc_tr_r;	/* more trace arrays */
	FILE *fps, *fpr;		/* file pointers for output */
	int s;				/* local static shift */
	cwp_String ssol, rsol;


	/* Initialize */
	initargs(argc, argv);
	requestdoc(1);

	/* Get info from first trace and store first header */
	if (!(ntr = gettra(&tr, 0)))  err("can't get first trace");
	dt = ((double) tr.dt)/1000.0;   /* dt in milliseconds (microseconds in trace header */
	mdt = tr.dt/1000.0;
	if (!dt) getparfloat("dt", &dt);
	if (!dt) MUSTGETPARFLOAT("dt", &dt);
	nt = tr.ns;
	/* if (nt%2 == 0) err("nt must be odd"); */

	/* Get optional parameters */
	if (!getparint("ntcc",&ntcc)) ntcc=250; 
	if (!getparint("icmpshift",&icmpshift)) icmpshift=9; 
	if (ntcc%2 == 0) ++ntcc;
	if (!getparint("ntpick",&ntpick)) ntpick=50; 
	if (!getparint("ntraces",&ntraces)) ntraces=50; 
	if (!getparint("resamp",&resamp)) resamp=4; 
	if (!getparint("n_o",&n_o)) n_o=7; 
	if (!getparint("niter",&niter)) niter=5;
	if (!getparint("nshot",&nshot)) nshot=240; 
	if (!getparint("nr",&nr)) nr=335; 
	if (!getparint("nc",&nc)) nc=574; 
	if (!getparint("sfold",&sfold)) sfold=96; 
	if (!getparint("rfold",&rfold)) rfold=96; 
	if (!getparint("cfold",&cfold)) cfold=48; 
	if (!getparint("mode",&mode)) mode=0; 
	if (!getparint("sub",&sub)) sub=0; 
	if (!getparfloat("perc",&perc)) perc=10.; 
	if (!getparint("verbose",&verbose)) verbose=0; 

	if (!getparstring("ssol",&ssol))
		err("must specify a source statics output file");
	if (!getparstring("rsol",&rsol))
		err("must specify a receiver statics output file");

        checkpars();
	/* Compute time windowing parameters */
	nt_r = ntcc*resamp;
	if (verbose == 1) warn("nt_r=%i",nt_r);
	ntout = 2*ntpick + 1;
	nt_super = nt+(2*ntpick);  /*trace length plus buffer on each end*/
	i=(nr>nshot) ? nr : nshot;
	ntotal_super=nt_super*i;
	if (verbose == 1) warn("nt=%i, nt_super=%i, ntotal_super=%i",nt, nt_super, ntotal_super);

	/* Allocate space */
	cmpntr = alloc1int(nc+1);
	recntr = alloc1int(nr+1);
	shotntr = alloc1int(nshot+1);
	g_trace = alloc1float(ntotal_super);
	t = alloc1float(nt_r);

	if (verbose == 1) warn("nr=%i rfold=%i",nr,rfold);
	cmp_loc = alloc2int(cfold+1,nc+1);
	rec_loc = alloc2int(rfold+1,nr+1);
	shot_loc = alloc2int(sfold+1,nshot+1);
	header = alloc2int(3,ntraces+1);

	model = alloc2float(nt,nc+1);
	model_trace = alloc1float(ntotal_super);

	filter = alloc1float(ntcc+1);
	cc_tr = alloc1float(nt_r+1);
	filter_r = alloc1float(nt_r+1);
	cc_tr_r = alloc1float(ntcc+1);
	corr_trace = alloc1float(ntout);
	pick_tr = alloc1float(ntpick+1);

	data = alloc2float(nt,ntraces+1);

	tsstat = alloc1float(nshot+1);
	trstat = alloc1float(nr+1);
	sstat = alloc1int(nshot+1);
	rstat = alloc1int(nr+1);

	/* Zero out arrays */
	memset((void *) tsstat, 0 , (nshot+1)*FSIZE);
	memset((void *) sstat, 0 , (nshot+1)*FSIZE);
	memset((void *) trstat, 0 , (nr+1)*FSIZE);
	memset((void *) rstat, 0 , (nr+1)*FSIZE);
	memset((void *) data[0], 0 , (nr+1)*FSIZE);
	memset((void *) cmpntr, 0 , (nc+1)*ISIZE);
	memset((void *) recntr, 0 , (nr+1)*ISIZE);
	memset((void *) shotntr, 0 , (nshot+1)*ISIZE);

	/* Read rest of data */
	for (itrace=0; itrace<ntraces; itrace++){

	/* we already read the first trace, so just put it into the arrays */
			if(itrace>0) gettra(&tr,itrace);

			icmp = tr.cdp;     /*location of cdp number in header*/
			irec = tr.tracf;   /*location of receiver station in header*/
			ishot = tr.fldr;   /*location of shot number in header*/

			j = ++cmpntr[icmp];
			k = ++recntr[irec];
			l = ++shotntr[ishot];

			cmp_loc[icmp][j] = itrace+1;
			rec_loc[irec][k] = itrace+1;
			shot_loc[ishot][l] = itrace+1;
			header[itrace+1][1]=icmp;
			header[itrace+1][2]=irec;
			header[itrace+1][3]=ishot;

			for (it=1; it<=nt; it++)
				data[itrace+1][it] = tr.data[it];
	}

	/* start iterations */
	for (iter=1; iter<=niter; iter++) {

		if (verbose == 1) fprintf(stderr,"iteration #= %i\n", iter);

		/* construct CMP stack */
		if (verbose == 1) fprintf(stderr,"constructing CMP stack\n");
		for (i=1; i<=nc; i++){

			for (it=1; it<=nt; it++) model[i][it] = 0.;

			for (j=1; j<=cmpntr[i]; j++)
				for (it=1; it<=nt; it++)
					model[i][it] += data[cmp_loc[i][j]][it];

/* normalize - no, I cannot normalize the individual traces in the supertrace */
			/* j=(1>cmpntr[i]) ? 1 : cmpntr[i];	*/
			/* for (it=1; it<=nt; it++)		*/
			/*	model[i][it] = model[i][it]/j;	*/
		}


		/* Loop over shots */
		for (ishot=1; ishot<=nshot; ishot++){
		if (verbose == 1) fprintf(stderr,"\nstarting shot loop, shot=%i\n", ishot);
		if (shotntr[ishot] > 1) {

			/* construct shot and cmp super traces */
			if (verbose == 1) fprintf(stderr,"creating supertraces\n");
			for (it=1; it<=ntotal_super; it++) g_trace[it] = 0.;
			for (it=1; it<=ntotal_super; it++) model_trace[it] = 0.;

			for (ichan=1; ichan<=shotntr[ishot]; ichan++){
				j = (ichan-1)*nt_super + ntpick;
				l = header[shot_loc[ishot][ichan]][1];
				/* j=location in supertrace; l=cdp number */
					for (it=1; it<=nt; it++){
						g_trace[j+it] = data[shot_loc[ishot][ichan]][it];
						model_trace[j+it] = model[l][it];
				}
                        }

			/* subtract shot supertrace from cmp supertrace if desired */
			if (sub == 1 && verbose == 1) fprintf(stderr,"subtracting supertraces\n");
			if (sub == 1) for (it=1; it<=ntotal_super; it++) 
                                        model_trace[it] = model_trace[it] - g_trace[it];


			/* cross-correlate super trace 1 with super trace 2 */
			if (verbose == 1) fprintf(stderr,"crosscorrelating supertraces\n");

			for (i=1; i<=ntout; i++){
				corr_trace[i] = 0.0;
				tlag=i-ntpick-1;
				for (j=ntpick; j<=(ntotal_super-ntpick); j++){
					corr_trace[i] = corr_trace[i] + g_trace[j+tlag]*model_trace[j];
				}
			}

			/* for (i=1; i<=ntout; i++) fprintf(stderr,"i=%i, corr_trace(i)=%f\n",i,corr_trace[i]); */



			/* pick cross-correlation peak */ 
			/*window(corr_trace, ntout, ntpick, pick_tr);*/
			tlag = max(corr_trace, mode, perc, ntout);

			/* remember initial estimation and total correction */
			sstat[ishot] = tlag;
			tsstat[ishot] += tlag;
			if (verbose == 1) fprintf(stderr,"finished shot %i, sstat=%i, tsstat=%f (samples)\n", ishot,sstat[ishot],tsstat[ishot]);

		}
		}

		/* end shot statics loop */
		/* correct traces for shot statics (use g_trace as temp trace) */ 
		for (i=1; i<=ntraces; i++){
			ishot=header[i][3];
			for (it=1; it<=nt; it++) g_trace[it] = 0.0;
			s = sstat[ishot];
			for (it=1-(s>0?0:s); it<=nt-(s>0?s:0); it++) g_trace[it] = data[i][it+s];
			for (it=1; it<=nt; it++) data[i][it] = g_trace[it];
			}

		/* construct CMP stack of corrected traces */
		if (verbose == 1) fprintf(stderr,"constructing new CMP stack using shot-corrected traces\n");
		for (i=1; i<=nc; i++){

			for (it=1; it<=nt; it++) model[i][it] = 0.;

			for (j=1; j<=cmpntr[i]; j++)
				for (it=1; it<=nt; it++)
					model[i][it] += data[cmp_loc[i][j]][it];

	    		/* normalize - no, I cannot normalize the individual traces in the supertrace */
			/* j=(1>cmpntr[i]) ? 1 : cmpntr[i];	*/
			/* for (it=1; it<=nt; it++)		*/
			/*	model[i][it] = model[i][it]/j;	*/
		}



		/* Loop over receivers */
		if (verbose == 1) fprintf(stderr,"\n\nstarting reciever loop\n");
		for (irec=1; irec<=nr; irec++){
                if (recntr[irec] > 1) {

                        /* construct receiver and cmp super traces */
                        if (verbose == 1) fprintf(stderr,"creating supertraces\n");
                        for (it=1; it<=ntotal_super; it++) g_trace[it] = 0.;
                        for (it=1; it<=ntotal_super; it++) model_trace[it] = 0.;

                        for (ichan=1; ichan<=recntr[irec]; ichan++){
                                /* j=location in supertrace; l=cdp number */
                                j = (ichan-1)*nt_super + ntpick;
                                l = header[rec_loc[irec][ichan]][1];
                                        for (it=1; it<=nt; it++){
                                                g_trace[j+it] = data[rec_loc[irec][ichan]][it];
                                                model_trace[j+it] = model[l][it];
                                }
                        }
                        /* for (i=1; i<=nt; i++) fprintf(stderr,"i=%i, model_trace(i)=%f\n",i,model_trace[i]); */
                        /* for (i=1; i<=nt; i++) fprintf(stderr,"i=%i, g_trace(i)=%f\n",i,g_trace[i]); */


                        /* subtract receiver supertrace from cmp supertrace if desired */
                        if (sub == 1 && verbose == 1) fprintf(stderr,"subtracting supertraces\n");
                        if (sub == 1) for (it=1; it<=ntotal_super; it++) 
                                        model_trace[it] = model_trace[it] - g_trace[it];


                        /* cross-correlate super trace 1 with super trace 2 */
                        if (verbose == 1) fprintf(stderr,"crosscorrelating supertraces\n");

                        for (i=1; i<=ntout; i++){
                                corr_trace[i] = 0.0;
                                tlag=i-ntpick-1;
                                for (j=ntpick; j<=(ntotal_super-ntpick); j++)
					corr_trace[i] = corr_trace[i] + g_trace[j+tlag]*model_trace[j];
                        }

                        /* for (i=1; i<=ntout; i++) fprintf(stderr,"i=%i, corr_trace(i)=%f\n",i,corr_trace[i]); */



                        /* pick cross-correlation peak */
                        /*window(corr_trace, ntout, ntpick, pick_tr);*/
                        tlag = max(corr_trace, mode, perc, ntout);

                        /* remember initial estimation and total correction */
                        rstat[irec] = tlag;
                        trstat[irec] += tlag;
                        if (verbose == 1) fprintf(stderr,"finished receiver %i, rstat=%i, trstat=%f (samples)\n", irec,rstat[irec],trstat[irec]);

	if (verbose == 1) fprintf(stderr,"finished one receiver\n");

              }
                }

                /* end receiver statics loop */

                /* correct traces for receiver statics (use g_trace as temp trace) */
                for (i=1; i<=ntraces; i++){
                        irec=header[i][2];
                        for (it=1; it<=nt; it++) g_trace[it] = 0.0;
			s = rstat[irec];
			for (it=1-(s>0?0:s); it<=nt-(s>0?s:0); it++) g_trace[it] = data[i][it+s];
                        for (it=1; it<=nt; it++) data[i][it] = g_trace[it];
                        }

                /* construct CMP stack of corrected traces */
		if(iter<niter){
                if (verbose == 1) fprintf(stderr,"constructing new CMP stack using shot-corrected traces\n");
                for (i=1; i<=nc; i++){

                        for (it=1; it<=nt; it++) model[i][it] = 0.;

                        for (j=1; j<=cmpntr[i]; j++)
                                for (it=1; it<=nt; it++)
                                        model[i][it] += data[cmp_loc[i][j]][it];

                        /* normalize - no, I cannot normalize the individual traces in the supertrace */
                        /* j=(1>cmpntr[i]) ? 1 : cmpntr[i];     */
                        /* for (it=1; it<=nt; it++)             */
                        /*      model[i][it] = model[i][it]/j;  */
		}
                }
	}
	/* end iterations */

	/* output final statics */ 
	for (it=1; it<=nshot; it++) tsstat[it] = tsstat[it]*mdt;
        fps    = efopen(ssol,"wb");
	efwrite(tsstat,sizeof(float),nshot+1,fps);
        efclose(fps);

	for (it=1; it<=nr; it++) trstat[it] = trstat[it]*mdt;
        fpr    = efopen(rsol,"wb");
	efwrite(trstat,sizeof(float),nr+1,fpr);
        efclose(fpr);

	return(CWP_Exit());
}

void window (float *trace, int nt, int nnt, float *ntrace)
{
	int j;	
	int ft;	
	
	if (nnt%2 == 0) ++nnt;
	ft = (nt - 1)/2 - (nnt - 1)/2;
	for (j = 0; j < nnt; j++) {
		ntrace[j] = trace[j+ft];
	}
}

int max (float *trace, int mode, float perc, int nt)
{
	float maxamp = 0.;	/* max. amplitude sample rate */
	int globmax = 0;	/* sample of global max value */
	int locmax = 0;		/* sample of local max value */
	int zero; 		/* zero-lag sample */
	int lag = 0; 		/* lag picked */
	int j;			/* counter */

	/* Set parameters */
	if (nt%2 == 0) ++nt;
	zero = (nt+1)/2;
	globmax = (nt+1)/2;
	perc = 1.0-(perc/100);

	/* determine global max for each trace*/
	for (j = 1; j <= nt; j++) {
		if (trace[j] > maxamp) {
			maxamp = trace[j];
			globmax = j;
		}
	}
	if (mode == 1) {
	/* determine max within perc% of global max, but closer to zero lag*/
		for (j = 1; j <= nt; j++) {
			if ((trace[j] > perc*maxamp) && 
			  (ABS(j-zero) < ABS(locmax-zero))) 
				locmax = j;
		}
	}

	/* Output the result */
	switch(mode) {
		case 0:
			lag = globmax - zero;
			break;
		case 1:
			lag = locmax - zero;
			break;
	}
	return lag;
}
@


1.19
log
@added Reg Beardsley's checkpar()
@
text
@d4 1
a4 1
/* SURESSTAT: $Revision: 1.17 $ ; $Date: 2010/02/04 18:37:18 $		*/
d113 1
a113 1
	int mdt;		/* sample rate in milliseconds*/
d162 1
a162 1
	mdt = tr.dt/1000;
@


1.18
log
@copyright
@
text
@d193 1
@


1.17
log
@added a line to the selfdoc
@
text
@d1 4
a4 1
/* SURESSTAT: $Revision: 1.16 $ ; $Date: 2008/05/05 19:06:24 $		*/
@


1.16
log
@added comments as per Abdualltif's instructions.
@
text
@d1 1
a1 1
/* SURESSTAT: $Revision: 1.15 $ ; $Date: 2006/11/07 22:58:42 $		*/
a42 1
" The input consists of moveout-corrected SU data sorted in shot gathers.",
@


1.15
log
@changed    memset( .., (int) '\0',...) to memset( .., 0,..) as per suggestion of Marion Zhu and Reg Beardsley
@
text
@d1 1
a1 1
/* SURESSTAT: $Revision: 1.14 $ ; $Date: 2005/10/04 16:42:43 $		*/
d44 1
a44 1
" The output files are ascii files containing the source and receiver	",
d63 20
a82 1
" to apply the static corrections, use sustatic with hdrs=3		",
@


1.14
log
@4 Oct 2005
@
text
@d1 1
a1 1
/* SURESSTAT: $Revision: 1.13 $ ; $Date: 2004/12/24 00:01:45 $		*/
d212 8
a219 8
	memset((void *) tsstat, (float) '\0' , (nshot+1)*FSIZE);
	memset((void *) sstat, (int) '\0' , (nshot+1)*FSIZE);
	memset((void *) trstat, (float) '\0' , (nr+1)*FSIZE);
	memset((void *) rstat, (int) '\0' , (nr+1)*FSIZE);
	memset((void *) data[0], (int) '\0' , (nr+1)*FSIZE);
	memset((void *) cmpntr, (int) '\0' , (nc+1)*ISIZE);
	memset((void *) recntr, (int) '\0' , (nr+1)*ISIZE);
	memset((void *) shotntr, (int) '\0' , (nshot+1)*ISIZE);
@


1.13
log
@small changes
@
text
@d1 1
a1 1
/* SURESSTAT: $Revision: 1.11 $ ; $Date: 2001/06/22 16:18:40 $		*/
d17 1
a19 1
" ntraces	number of traces in input data set (must be correct!)	",
d22 1
a22 1
" ns=240 	largest shot number (fldr=1 to ns)			",
d58 1
a58 1
" correction for each shot record (fldr=1 to fldr=ns), with any missing ",
d96 1
a96 1
	int ns, nc, nr;		/* number of shots, cmps and recs */
d156 1
a156 1
	if (!getparint("ns",&ns)) ns=240; 
d177 1
a177 1
	i=(nr>ns) ? nr : ns;
d184 1
a184 1
	shotntr = alloc1int(ns+1);
d191 1
a191 1
	shot_loc = alloc2int(sfold+1,ns+1);
d206 1
a206 1
	tsstat = alloc1float(ns+1);
d208 1
a208 1
	sstat = alloc1int(ns+1);
d212 2
a213 2
	memset((void *) tsstat, (float) '\0' , (ns+1)*FSIZE);
	memset((void *) sstat, (int) '\0' , (ns+1)*FSIZE);
d219 1
a219 1
	memset((void *) shotntr, (int) '\0' , (ns+1)*ISIZE);
d269 1
a269 1
		for (ishot=1; ishot<=ns; ishot++){
d438 1
a438 1
	for (it=1; it<=ns; it++) tsstat[it] = tsstat[it]*mdt;
d440 1
a440 1
	efwrite(tsstat,sizeof(float),ns+1,fps);
@


1.12
log
@9 June 2003
@
text
@d33 1
d118 1
d130 1
d165 1
d174 1
a174 1
	fprintf(stderr,"nt_r=%i\n",nt_r);
d179 1
a179 1
	fprintf(stderr,"nt=%i, nt_super=%i, ntotal_super=%i\n",nt, nt_super, ntotal_super);
d188 1
a188 1
	fprintf(stderr,"nr=%i rfold=%i\n",nr,rfold);
d249 1
a249 1
		fprintf(stderr,"iteration #= %i\n", iter);
d252 1
a252 1
		fprintf(stderr,"constructing CMP stack\n");
d270 1
a270 1
		fprintf(stderr,"\nstarting shot loop, shot=%i\n", ishot);
d274 1
a274 1
			fprintf(stderr,"creating supertraces\n");
d289 1
a289 1
			if (sub == 1) fprintf(stderr,"subtracting supertraces\n");
d295 1
a295 1
			fprintf(stderr,"crosscorrelating supertraces\n");
d316 1
a316 1
			fprintf(stderr,"finished shot %i, sstat=%i, tsstat=%f (samples)\n", ishot,sstat[ishot],tsstat[ishot]);
a321 1

d326 2
a327 6
			if(sstat[ishot] > 0) {
				for (it=1; it<=(nt-sstat[nt]+1); it++) g_trace[it] = data[i][it+sstat[ishot]];
				}
			if(sstat[ishot] < 0) {
				for (it=(sstat[ishot]+1); it<=nt; it++) g_trace[it-sstat[ishot]] = data[i][it];
				}
d332 1
a332 1
		fprintf(stderr,"constructing new CMP stack using shot-corrected traces\n");
d350 1
a350 1
		fprintf(stderr,"\n\nstarting reciever loop\n");
d355 1
a355 1
                        fprintf(stderr,"creating supertraces\n");
d373 1
a373 1
                        if (sub == 1) fprintf(stderr,"subtracting supertraces\n");
d379 1
a379 1
                        fprintf(stderr,"crosscorrelating supertraces\n");
d399 1
a399 1
                        fprintf(stderr,"finished receiver %i, rstat=%i, trstat=%f (samples)\n", irec,rstat[irec],trstat[irec]);
d401 1
a401 1
	fprintf(stderr,"finished one receiver\n");
d412 2
a413 6
                        if(rstat[irec] > 0) {
                                for (it=1; it<=(nt-rstat[nt]+1); it++) g_trace[it] = data[i][it+rstat[irec]];
                                }
                        if(rstat[irec] < 0) {
                                for (it=(rstat[irec]+1); it<=nt; it++) g_trace[it-rstat[irec]] = data[i][it];
                                }
d419 1
a419 1
                fprintf(stderr,"constructing new CMP stack using shot-corrected traces\n");
d440 1
a440 1
	efwrite(tsstat,sizeof(float),ns,fps);
d443 1
a443 1
	for (it=1; it<=nr; it++) tsstat[it] = tsstat[it]*mdt;
d445 1
a445 1
	efwrite(trstat,sizeof(float),nr,fpr);
@


1.11
log
@Tom Pratt's new version
@
text
@d1 1
a1 1
/* SURESSTAT: $Revision: 1.10 $ ; $Date: 1998/01/15 22:55:39 $		*/
d453 1
a453 1
	return EXIT_SUCCESS;
@


1.10
log
@added caveat to selfdoc.
@
text
@d1 1
a1 1
/* SURESSTAT: $Revision: 1.9 $ ; $Date: 1997/05/05 17:37:57 $		*/
d19 2
a20 3
" ntcc=250 	number of samples in the cross-correlation window	",
" ntpick=50 	number of samples in the picking window			",
" n_o=7 	near-offset position relative to the shot		",
d22 6
a27 6
" ns=240 	number of shots						",
" nr=335 	number of receivers					",
" nc=574 	number of cmp's						",
" sfold=96 	shot gather fold					",
" rfold=96 	receiver gather fold					",
" cfold=48 	cmp gather fold						",
d29 1
a32 1
" icmpshift=9 	shift applied to icmp index				",
d44 2
a45 1
" statics, as a function of surface position sx and gx, respectively.	",
d56 7
a62 4
" Caveat: This program does not really work for general datasets. What	",
" is needed is for some person who understands residual statics to fix  ",
" the code, and email the fixed version to CWP so we can have a working	",
" version.								",
d74 3
a76 1
 * Trace header fields accessed: ns, dt
d90 8
a97 4
	int nt;				/* number of points on input traces*/
	int ns, nc, nr;			/* number of shots, cmps and recs */
	int sfold, cfold, rfold;	/* source, cmp and receiver fold */
	int n_o;			/* near offset */
a98 1
	int mint, maxt;		/* min. and max time in c-c */
d102 3
a104 3
	int resamp;			/* resampling rate */
	int ntr;			/* number of trace on input */
	int iter, niter;		/* iteration vars */
d106 8
a113 5
	int icmpshift;		/* shift applied to icmp */
	register int it, itr, i, j=0, k;	/* counters */
	int *cmpntr, cmp_max, cmp_min;	/* cmp selector */
	int *recntr;			/* receiver gather fold */
	int **rec_loc, **cmp_loc;	/* position arrays */
d118 1
a118 1
	int *tsstat, *trstat;		/* total shot and receiver static */
d124 2
a125 2
	float *model_trace, *corr_trace;	/* more trace arrays */
	float *filter, *cc_tr, *pick_tr;	/* more trace arrays */
d137 2
a138 1
	dt = ((double) tr.dt)/1000000.0;
d142 1
a142 1
	if (nt%2 == 0) err("nt must be odd");
d149 1
d171 5
a175 4
	ntout = 2*nt_r - 1;
	mint = (nt - 1)/2 - (ntcc - 1)/2 - ntpick/2;
	maxt = (nt - 1)/2 + (ntcc - 1)/2 + ntpick/2;
	fprintf(stderr,"mint=%i, maxt=%i\n",mint, maxt);
d180 2
a181 1
	g_trace = alloc1float(nt);
d184 2
d187 2
a188 1
	cmp_loc = alloc2int(cfold+1,nc+1);
d191 1
a191 1
	model_trace = alloc1float(nt);
d200 1
a200 1
	data = alloc2float(nt,ntr+1);
d202 2
a203 2
	tsstat = alloc1int(ns+1);
	trstat = alloc1int(nr+1);
d208 1
a208 1
	memset((void *) tsstat, (int) '\0' , (ns+1)*FSIZE);
d210 1
a210 1
	memset((void *) trstat, (int) '\0' , (nr+1)*FSIZE);
d214 2
a215 1
	memset((void *) recntr, (int) '\0' , (nc+1)*ISIZE);
d218 4
a221 5
	for (ishot=1; ishot<=ns; ishot++){
		for (ichan=1; ichan<=sfold; ichan++){
			icmp = 2*ishot + ichan + n_o - icmpshift;
			irec = ishot - 1  + ichan;
			itr = (ishot-1)*sfold + ichan;
d223 3
a225 1
			gettra(&tr,itr-1);
d229 1
a229 2
			cmp_loc[icmp][j] = tr.tracl;
			rec_loc[irec][k] = tr.tracl;
d231 9
a239 3
			for (it=0; it<nt; it++)
				data[tr.tracl][it] = tr.data[it];
		}
d243 1
a243 1
	for (iter=0; iter<niter; iter++) {
d248 1
d251 1
a251 1
			for (it=0; it<nt; it++) model[i][it] = 0.;
d254 1
a254 1
				for (it=mint; it<=maxt; it++)
d257 4
a260 3
	    		/* normalize */
			for (it=mint; it<=maxt; it++)
				model[i][it] = model[i][it]/cmpntr[i];
a262 1
		for (it=0; it<nt_r; ++it) t[it] = it*0.001;
d266 22
a288 27
			/* construct shot super trace 1 */
			for (it=0; it<nt; it++) g_trace[it] = 0.;
			for (ichan=1; ichan<=sfold; ichan++)
				j = (ishot - 1)*sfold + ichan;
					for (it=mint; it<=maxt; it++)
						g_trace[it] += data[j][it];

	  		for (it=mint; it<=maxt; it++)
					g_trace[it] = g_trace[it]/sfold;

			/* determine models involved with this shot and */
	   		/* construct super trace 2 */
			cmp_max = 2*ishot + sfold + n_o - icmpshift;
			cmp_min = 2*ishot + 1 + n_o - icmpshift;
	  		for (it=0; it<nt; it++) model_trace[it] = 0.;

			for (icmp=cmp_min; icmp<=cmp_max; icmp++)
				for (it=mint; it<=maxt; it++)
					model_trace[it]+=model[icmp][it];
	  
	  		for (it=mint; it<=maxt; it++)
		 		model_trace[it] = model_trace[it]/sfold;

			/* subtract super trace 1 from super trace 2 */
	  		if (sub == 1)
				for (it=mint; it<=maxt; it++)
					model_trace[it]-=g_trace[it];
d291 11
a301 2
	  		window(g_trace, nt, ntcc, cc_tr);
	  		window(model_trace, nt, ntcc, filter);
a302 2
			ints8r(ntcc,dt,0.0,cc_tr,0.0,0.0,nt_r,t,cc_tr_r);
			ints8r(ntcc,dt,0.0,filter,0.0,0.0,nt_r,t,filter_r);
a303 2
			xcor(nt_r, 0, cc_tr_r, nt_r, 0, filter_r,
                     		     ntout , -nt_r + 1, corr_trace);
d306 2
a307 2
			window(corr_trace, ntout, ntpick, pick_tr);
			tlag = max(pick_tr, mode, perc, ntpick);
d312 1
d315 1
d320 10
a329 11
		for (ishot=1; ishot<=ns; ishot++){
	  		for (ichan=1; ichan<=sfold; ichan++){
				itr = (ishot-1)*sfold + ichan;
				j = sstat[ishot];

				for (it=0; it<nt; ++it)
					t[it] = it*dt - j*0.001;
				ints8r(nt, dt, 0.0, data[itr], 
					0.0, 0.0, nt, t, g_trace);

				for (it=0; it<nt; it++) data[itr][it] = g_trace[it];
a330 1
		}
d332 2
a333 1
		/* CMP stack of corrected traces */
d335 2
a336 1
			for (it=0; it<nt; it++) model[i][it] = 0.;
d339 1
a339 1
				for (it=mint; it<=maxt; it++)
d342 4
a345 3
	    		/* normalize */
	    		for (it=mint; it<=maxt; it++)
					model[i][it] = model[i][it]/cmpntr[i];
d348 1
a348 1
		for (it=0; it<nt_r; ++it) t[it] = it*0.001;
d351 1
d353 1
d355 82
a436 69
			/* construct receiver super trace 1 */
	  		for (it=0; it<nt; it++) g_trace[it] = 0.;

			for (ichan=1; ichan<=recntr[irec]; ichan++)
				for (it=mint; it<=maxt; it++)
					g_trace[it] += data[rec_loc[irec][ichan]][it];

	  		for (it=mint; it<=maxt; it++)
				g_trace[it] = g_trace[it]/recntr[irec];

			/* determine part of stack involved with this */
			/* receiver & construct super trace 2 */
			if (irec <= rfold)
				cmp_min = irec ;
	  		else
				cmp_min = 2 * irec - rfold ;

			cmp_max = cmp_min + recntr[irec] - 1;

	  		for (it=0; it<nt; it++)
				model_trace[it] = 0.;

	  		for (icmp=cmp_min; icmp<=cmp_max; icmp++)
				for (it=mint; it<=maxt; it++)
					model_trace[it]+=model[icmp][it];
	  
	  		for (it=mint; it<=maxt; it++)
				model_trace[it] = model_trace[it]/recntr[irec];

			/* subtract super trace 1 from super trace 2 */
	  		if (sub == 1)
				for (it=mint; it<maxt; it++)
					model_trace[it]-=g_trace[it];

			/* cross-correlate super trace 1 with super trace 2 */
			window(g_trace, nt, ntcc, cc_tr);
	  		window(model_trace, nt, ntcc, filter);

	 		ints8r(ntcc,dt,0.0,cc_tr,0.0,0.0,nt_r,t,cc_tr_r);
	  		ints8r(ntcc,dt,0.0,filter,0.0,0.0,nt_r,t,filter_r);

	  		xcor(nt_r, 0, cc_tr_r, nt_r, 0, filter_r,
				ntout, -nt_r + 1, corr_trace);


			/* pick cross-correlation peak */ 
			window(corr_trace, ntout, ntpick, pick_tr);
	  		tlag = max(pick_tr, mode, perc, ntpick);

			/* remember the initial estimation and the total correction */
			rstat[irec] = tlag;
	 		trstat[irec] += tlag;

			}

			/* end shot receivers  loop */


			/* correct traces for receiver statics */ 
			for (ishot=1; ishot<=ns; ishot++){
	 		 for (ichan=1; ichan<=sfold; ichan++){
				itr = (ishot-1)*sfold + ichan;
				irec = ishot - 1  + ichan;
				j = rstat[irec];

				for (it=0; it<nt; ++it) t[it] = it*dt - j*0.001;
				ints8r(nt, dt, 0.0, data[itr], 0.0, 0.0, nt, t, g_trace);
				for (it=0; it<nt; it++) data[itr][it] = g_trace[it];
			}
d438 1
a438 1

d443 3
a445 2
        fps    = efopen(ssol,"w+");
        for (ishot=1; ishot<=ns; ishot++) fprintf(fps,"%i\n",tsstat[ishot]);
d448 3
a450 2
        fpr    = efopen(rsol,"w+");
        for (irec=1; irec<=nr; irec++) fprintf(fpr,"%i\n",trstat[irec]);
d479 2
a480 1
	zero = (nt-1)/2;
d484 1
a484 1
	for (j = 0; j < nt; j++) {
d492 1
a492 1
		for (j = 0; j < nt; j++) {
@


1.9
log
@largely cosmetic changes. This item still needs work.
@
text
@d1 1
a1 1
/* SURESSTAT: $Revision: 1.8 $ ; $Date: 1997/03/11 20:31:40 $		*/
d56 4
@


1.8
log
@added icmpshift parameter and fixed reference in sudoc
@
text
@d1 1
a1 1
/* SURESSTAT: $Revision: 1.7 $ ; $Date: 1996/08/19 21:55:51 $		*/
d95 1
a95 1
	register int it, itr, i, j, k;	/* counters */
d128 1
a128 1
	/* get optional parameters */
d151 1
d159 1
a159 1
	/* allocate space */
a183 2
	for (i=1; i<=ns; i++) tsstat[i] = 0;
	for (i=1; i<=nr; i++) trstat[i] = 0;
d185 10
a194 3
	/* put data into data matrix & set index matrices */
	for (i=1; i<=nc; i++) cmpntr[i] = 0;
	for (i=1; i<=nr; i++) recntr[i] = 0;
d196 15
a210 14
	  for (ichan=1; ichan<=sfold; ichan++){
		icmp = 2*ishot + ichan + n_o - icmpshift;
		irec = ishot - 1  + ichan;
		itr = (ishot-1)*sfold + ichan;

		gettra(&tr,itr-1);

		j = ++cmpntr[icmp];
		k = ++recntr[irec];
		cmp_loc[icmp][j] = tr.tracl;
		rec_loc[irec][k] = tr.tracl;

		for (it=0; it<nt; it++) data[tr.tracl][it] = tr.data[it];
	  }
a214 1
	fprintf(stderr,"iteration #= %i\n", iter);
d216 113
a328 11
	/* construct CMP stack */
	for (i=1; i<=nc; i++){
	    for (it=0; it<nt; it++) model[i][it] = 0.;
	    for (j=1; j<=cmpntr[i]; j++){
		for (it=mint; it<=maxt; it++)
			model[i][it] += data[cmp_loc[i][j]][it];
	    }
	    /* normalize */
	    for (it=mint; it<=maxt; it++)
		model[i][it] = model[i][it]/cmpntr[i];
	}
d330 6
a335 1
	for (it=0; it<nt_r; ++it) t[it] = it*0.001;
d337 1
a337 2
	/* Loop over shots */
	for (ishot=1; ishot<=ns; ishot++){
d339 2
a340 40
	/* construct shot super trace 1 */
	  for (it=0; it<nt; it++) g_trace[it] = 0.;
	  for (ichan=1; ichan<=sfold; ichan++) {
	    j = (ishot - 1)*sfold + ichan;
	    for (it=mint; it<=maxt; it++) g_trace[it] += data[j][it];
	  } 
	  for (it=mint; it<=maxt; it++) g_trace[it] = g_trace[it]/sfold;

	/* determine models involved with this shot and
	   construct super trace 2 */
	  cmp_max = 2*ishot + sfold + n_o - icmpshift;
	  cmp_min = 2*ishot + 1 + n_o - icmpshift;
	  for (it=0; it<nt; it++) model_trace[it] = 0.;
	  for (icmp=cmp_min; icmp<=cmp_max; icmp++) {
		for (it=mint; it<=maxt; it++) model_trace[it]+=model[icmp][it];
	  }
	  for (it=mint; it<=maxt; it++) model_trace[it] = model_trace[it]/sfold;

	/* subtract super trace 1 from super trace 2 */
	  if (sub == 1) {
		for (it=mint; it<=maxt; it++) model_trace[it]-=g_trace[it];
	  }

	/* cross-correlate super trace 1 with super trace 2 */
	  window(g_trace, nt, ntcc, cc_tr);
	  window(model_trace, nt, ntcc, filter);

	  ints8r(ntcc,dt,0.0,cc_tr,0.0,0.0,nt_r,t,cc_tr_r);
	  ints8r(ntcc,dt,0.0,filter,0.0,0.0,nt_r,t,filter_r);

	  xcor(nt_r, 0, cc_tr_r, nt_r, 0, filter_r,
                     	     ntout , -nt_r + 1, corr_trace);

	/* pick cross-correlation peak */ 
	  window(corr_trace, ntout, ntpick, pick_tr);
	  tlag = max(pick_tr, mode, perc, ntpick);

	/* remember initial estimation and total correction */
	  sstat[ishot] = tlag;
	  tsstat[ishot] += tlag;
d342 6
a347 1
	}
d349 4
a352 1
	/* end shot statics loop */
d354 3
a356 5
	/* correct traces for shot statics (use g_trace as temp trace) */ 
	for (ishot=1; ishot<=ns; ishot++){
	  for (ichan=1; ichan<=sfold; ichan++){
		itr = (ishot-1)*sfold + ichan;
		j = sstat[ishot];
d358 2
a359 2
		for (it=0; it<nt; ++it) t[it] = it*dt - j*0.001;
		ints8r(nt, dt, 0.0, data[itr], 0.0, 0.0, nt, t, g_trace);
d361 2
a362 3
		for (it=0; it<nt; it++) data[itr][it] = g_trace[it];
	  }
	}
a363 11
	/* CMP stack of corrected traces */
	for (i=1; i<=nc; i++){
	    for (it=0; it<nt; it++) model[i][it] = 0.;
	    for (j=1; j<=cmpntr[i]; j++){
		for (it=mint; it<=maxt; it++)
			model[i][it] += data[cmp_loc[i][j]][it];
	    }
	    /* normalize */
	    for (it=mint; it<=maxt; it++)
			model[i][it] = model[i][it]/cmpntr[i];
	}
d365 3
a367 1
	for (it=0; it<nt_r; ++it) t[it] = it*0.001;
d369 3
a371 2
	/* Loop over receivers */
	for (irec=1; irec<=nr; irec++){
d373 1
a373 49
	/* construct receiver super trace 1 */
	  for (it=0; it<nt; it++) g_trace[it] = 0.;
	  for (ichan=1; ichan<=recntr[irec]; ichan++) {
	    for (it=mint; it<=maxt; it++)
			g_trace[it] += data[rec_loc[irec][ichan]][it];
	  } 
	  for (it=mint; it<=maxt; it++)
		g_trace[it] = g_trace[it]/recntr[irec];

	/* determine part of stack involved with this */
	/* receiver & construct super trace 2 */
	  if (irec <= rfold) {
		cmp_min = irec ;
	  } else {
		cmp_min = 2 * irec - rfold ;
	  }
	  cmp_max = cmp_min + recntr[irec] - 1;

	  for (it=0; it<nt; it++) model_trace[it] = 0.;
	  for (icmp=cmp_min; icmp<=cmp_max; icmp++) {
		for (it=mint; it<=maxt; it++)
			model_trace[it]+=model[icmp][it];
	  }
	  for (it=mint; it<=maxt; it++)
		model_trace[it] = model_trace[it]/recntr[irec];

	/* subtract super trace 1 from super trace 2 */
	  if (sub == 1) {
		for (it=mint; it<maxt; it++) model_trace[it]-=g_trace[it];
	  }

	/* cross-correlate super trace 1 with super trace 2 */
	  window(g_trace, nt, ntcc, cc_tr);
	  window(model_trace, nt, ntcc, filter);

	  ints8r(ntcc,dt,0.0,cc_tr,0.0,0.0,nt_r,t,cc_tr_r);
	  ints8r(ntcc,dt,0.0,filter,0.0,0.0,nt_r,t,filter_r);

	  xcor(nt_r, 0, cc_tr_r, nt_r, 0, filter_r,
			ntout, -nt_r + 1, corr_trace);


	/* pick cross-correlation peak */ 
	  window(corr_trace, ntout, ntpick, pick_tr);
	  tlag = max(pick_tr, mode, perc, ntpick);

	/* remember the initial estimation and the total correction */
	  rstat[irec] = tlag;
	  trstat[irec] += tlag;
d375 1
a375 1
	}
a376 1
	/* end shot receivers  loop */
d378 6
d385 5
a389 12
	/* correct traces for receiver statics */ 
	for (ishot=1; ishot<=ns; ishot++){
	  for (ichan=1; ichan<=sfold; ichan++){
		itr = (ishot-1)*sfold + ichan;
		irec = ishot - 1  + ichan;
		j = rstat[irec];

		for (it=0; it<nt; ++it) t[it] = it*dt - j*0.001;
		ints8r(nt, dt, 0.0, data[itr], 0.0, 0.0, nt, t, g_trace);
		for (it=0; it<nt; it++) data[itr][it] = g_trace[it];
	  }
	}
@


1.7
log
@Fixed close->fclose (actually efclose) per Ekkehart Tessmer
@
text
@d1 1
a1 1
/* SURESSTAT: $Revision: 1.6 $ ; $Date: 1996/02/05 19:48:52 $		*/
d33 1
d41 1
a41 1
" Geophysics 50, 1267-1279 (1985).					",
d62 1
a62 1
 *      1267-1279.
d94 1
d130 1
d191 1
a191 1
		icmp = 2*ishot + ichan + n_o - 9; 	
d237 2
a238 2
	  cmp_max = 2*ishot + sfold + n_o - 9;
	  cmp_min = 2*ishot + 1 + n_o - 9;
@


1.6
log
@Deal with header words accessed/modified down to sudoc.
@
text
@d1 1
a1 1
/* SURESSTAT: $Revision: 1.5 $ ; $Date: 1995/09/28 21:20:34 $		*/
d77 1
a91 1
	int tracl;			/* trace number */
d371 1
a371 1
        fps    = fopen(ssol,"w+");
d373 1
a373 1
        k=close(fps);
d375 1
a375 1
        fpr    = fopen(rsol,"w+");
d377 1
a377 1
        k=close(fpr);
a396 1
	int max = 0;		/* sample of max value */
d400 1
a400 1
	int lag; 		/* lag picked */
@


1.5
log
@Did the Stew Levin cast on dt.
@
text
@d1 1
a1 1
/* SURESSTAT: $Revision: 1.4 $ ; $Date: 1995/07/12 10:25:27 $		*/
d43 2
a44 2
" The output files are ascii files containing the source and receiver statics,",
" as a function of surface position sx and gx, respectively.		",
d52 2
a53 1
" closer to zero lag than the global maximum. (Choosing mode=0 is recommended",
d65 2
d97 1
a97 1
	int mode;			/* pick global (=0) or local (=1) max */
d232 2
a233 1
	/* determine models involved with this shot & construct super trace 2 */
@


1.4
log
@Timo's version. This version works. The previous version did not.
@
text
@d1 1
a1 1
/* SURESSTAT: $Revision: 1.0 $ ; $Date: 94/10/07 $		*/
d117 1
a117 1
	dt = tr.dt/1000000.0;
@


1.3
log
@fixed unmached comments
@
text
@d1 1
a1 1
/* SURESSTAT: $Revision: 1.2 $ ; $Date: 94/08/25 15:00:46 $*/
d9 45
a53 20
"									",
" SURESSTAT - Residual static corrections				",
"									",
" suresstat <stdin >stdout  [optional parameters]	 		",
"									",
" Required parameters:							",
"	tmin=begining window time					",
"	tmax=ending window time						",
"      									",
"									",
"  Optional Parameters:							",
"	max=max shift per iteration = 5		  			",
"	itt=number of itterations = 3					",
"	gx=1 do receiver constant statics (or gx=0 do not do statics)   ", 
"	sx=1 do source constant statics (or sx=0 do not do statics)     ",
"									",
"									",
" Trace header fields accessed:  ns, dt, cdp, gx, sx,delrt 		",
"				 sstat,gstat,tstat			",
" Trace header fields modified:  sstat, gstat, tstat			",
d56 8
a63 6
/* Credits:
 *  SU Developement Group
 *  Bob Clapp
 *  Jack Oskay
 *  Jim Schauer
 *  Residual Statics Routine
d65 1
a65 1
/************************ end self doc ***********************************/
d68 1
a68 1
segy tr,temptr,stone,sttwo,sf1,sf2;
d70 4
d76 33
a108 37
	int nt;			/* number of samples on trace */
	float dt;		/* sample rate on trace */
	float *t;		/* array of output times	*/
	int nsegy;       	/* used for looping */
	long sx;         	/* source location x*/
	long gx;		/* receiver location x */
	long *cdp;  		/*cdp locations use */
	int tmin;       	/* minimin time */
	int tmax;       	/* maximin time */
	int max;        	/* maximin displacement */
	int cdpn = 1;		/*the current cdp value */
	FILE *hdr1fp;   	/* temporary file for header (1) */
	FILE *hdr2fp;	  	/* temporary file for header (2) */
	FILE *data1fp;		/*data file (1) */
	FILE *data2fp;		/*data file (2) */
	int ntr = 0;    	/* number of traces */
	int temp;       	/* temporary variable */
        double *source;  	/* source array for different sources */
	double *receiver;	/* receiver array for diffrent receivers*/
	int numsource = 0;	/* number of different sources */
	int numreceiver = 0;	/* number of different receivers */
	int a,b,k,d;		/* used as counters */
	int maxtime;		/* define as tmax + max */
	int mintime; 		/* define as tmin - max */
	int source_flag = 0; 	/* used for determing the next source */
        int receiver_flag = 0; 	/*used for determining the next receiver */
	float *corr;		/* correlation value */
        float maxshift; 	/* maxximum correlation value */
        float shift; 		/* shift associated with max. corr. */
        float first;		/* beging value for sinc function */
	float *xout;
	int tempcount;		/* counter for looping through traces  */
	int staticsx_flag;	/* flag for corrections to source location */
	int staticgx_flag;	/* flag for corrections to reciever location */
 	int itteration;		/* the number of iterations that */
				/* the correction should be done */
	int itteration_count;
d110 2
a111 1
	/* Hook up getpar */
d115 5
a119 31
	/* Get information from first trace */
	if (!gettr(&tr)) err("can't get first trace");
		
	/* Get parameters and error checking */
	if (!getparint("tmin", &tmin))
	  err("must enter tmin");
	if (!getparint("tmax", &tmax))   
	  err("must enter tmax");
	if (!getparint("max",&max))
	  		max=5;
	if (!getparint("itt",&itteration))
			itteration=3;
	if (!getparint("sx",&staticsx_flag))
			staticsx_flag=1;
	if (!getparint("gx",&staticgx_flag))
			staticgx_flag=1;

	/* Intilize the time values */

        maxtime = max + tmax;
        mintime = tmin - max; 
	
	/*  Check for valid input */

	if(mintime<=0)
	  err("tmin - max must not be =<0");
	if(tmax<=tmin)
	  err("tmax must be greater than tmin");

	/* Define the number of data points */
	/* Length of trace from the header */
d121 1
a121 2
	if((mintime)>nt)
	  err("tmax + max can not be greater than nt");
d123 16
a138 2
	/*    Allocate variable*/
	t = ealloc1float(maxtime-mintime+1);	/* time array */
d140 4
a143 5
	/* declare temp files */
	hdr1fp = etmpfile();
	hdr2fp = etmpfile();
	data1fp = etmpfile();
	data2fp = etmpfile();
d145 6
a150 5
	/*  Define time array for sinc function */
        dt=tr.dt;
        for(b=0;b<=(maxtime-mintime);b++) {
           t[b] = tmin+b*dt;
        }
d152 5
d158 2
a159 1
       /* save the entire file into a temp file for multiple axcess */
d161 2
a162 5
	do {
	  ++ntr;
	  efwrite(&tr,1,HDRBYTES,hdr1fp);
	  efwrite(tr.data,FSIZE,nt,data1fp);
	}while(gettr(&tr));
d164 6
a169 1
      /* rewind to the beggining */
d171 1
a171 3
	rewind(hdr1fp);
	rewind(data1fp);
/****************** End of Intialization ******************************/
d173 6
a178 2
/*******************************************************************/
/*********************** Source Corrections *************************/
d180 8
a187 1
	/*  Main Loop */
d189 1
a189 1
for(itteration_count=1; itteration_count<=itteration; itteration_count++){
d191 4
a194 1
/*printf("itt %d\n",itteration_count); */
d196 3
a198 2
	/* Check to see if source locations should be done */
	if(staticsx_flag){ 
d200 3
a202 1
/*printf("static_flag\n");*/
d204 11
a214 3
    /* Determin the different sources*/
	numsource = 0;
        source = ealloc1double(nt);/* array for different sources */
d216 1
a216 11
	for(tempcount=0;tempcount<ntr;tempcount++){
		for(a=0;a<=tempcount;a++){	
		/* Used to get to the correct trace */
			efread(&tr,1,HDRBYTES,hdr1fp);
	  		efread(tr.data,FSIZE,nt,data1fp);
		}	/*  Check for different source */
	  	for(k=0;k<numsource;k++){
			if(tr.sx==source[k]){
	      		source_flag = 1;
	    		}
	  	}
d218 2
a219 1
/******* Source correction if new or different source *******/
d221 7
a227 5
	  if(!source_flag){
/*printf("source_flag\n");*/
   	/* define a new source */
	    	source[numsource]=tr.sx;
            	numsource++;
d229 8
a236 3
/*printf("******************New Source *******\n");
printf("trsx %d numsource %d\n",tr.sx,numsource);
*/
d238 4
a241 6
	/* Intilize variables */
	    	sx = tr.sx;
            	cdpn=0;
            	cdp = malloc(sizeof(long)*nt);
	    	xout=ealloc1float(nt*6);
            	corr = ealloc1float(10*max);
d243 3
a245 2
	    	rewind(hdr1fp);
	    	rewind(data1fp);
d247 2
a248 8
	/* Clean up the variables */
		for(a=0;a<nt;a++){
			stone.data[a]=0.0;
			sttwo.data[a]=0.0;
			sf1.data[a] = 0.0;
			sf2.data[a] = 0.0;
			temptr.data[a]=0.0;
		}
d250 2
a251 1
    	/* Get the first trace */
d253 3
a255 2
		efread(&tr,1,HDRBYTES,hdr1fp);
		efread(tr.data,FSIZE,nt,data1fp);
d257 3
a259 1
	/* Check for common depth point and if so update super trace 1 */
d261 1
a261 17
		do{
	      		if(tr.sx == sx){
				cdp[cdpn++] = tr.cdp;
				for(a=mintime;a<=(maxtime);a++){
		  			stone.data[a]+=tr.data[a];/**   SUPER TRACE 1 **/
				}
	      		}
	    	}while(efread(&tr,1,HDRBYTES,hdr1fp)&&efread(tr.data,FSIZE,nt,data1fp));
for(a=0;a<64;a++){
if(stone.data[a]!=0.0){
/*printf("**********\n");
printf("a %d stone.data %f\n",a,stone.data[a]);
*/
}
}
		rewind(hdr1fp);
	    	rewind(data1fp);
d263 1
a263 1
	/*  Calculation of super trace 2   */
d265 5
a269 2
		efread(&tr,1,HDRBYTES,hdr1fp);
		efread(tr.data,FSIZE,nt,data1fp);
d271 2
a272 12
	    	do{
			if(tr.sx != sx){
				for(a=0;a<cdpn;a++){
		  			if(tr.cdp==cdp[a]){
		    				a = cdpn;
						for(b=mintime;b<=(maxtime);b++){
		      					sttwo.data[b] += tr.data[b];  /**   SUPER TRACE 2 **/
		    				}
		      			}
		  		}
			}
	      	}while(efread(&tr,1,HDRBYTES,hdr1fp)&&efread(tr.data,FSIZE,nt,data1fp));
d274 3
a276 9
for(b=0;b<64;b++){
if(sttwo.data[b]!=0.0){
/*printf("**********\n");
printf("b %d sttwo.data %f\n",b,sttwo.data[b]);
*/
}
}
	      	rewind(hdr1fp);
	      	rewind(data1fp);
d278 11
a288 6
	/* sinc functions */
		a = 5*nt+1;
		first = tr.delrt*1000;
		for (b=0;b<(nt*5+1);b++){
			xout[b]=first+dt*b*.2;
		}
d290 1
a290 3
	      	ints8r(nt,dt,first,stone.data,0.0,0.0,a,xout,sf1.data);
	      	ints8r(nt,dt,first,sttwo.data,0.0,0.0,a,xout,sf2.data);
		a=max;
d292 2
a293 1
	/** Calculation of the correlation **/
d295 8
a302 6
	      	for(b=0;b<=10*max;b++){
			for(d=tmin*5;d<=tmax*5;d++){
				/** CORRELATION **/
		  		corr[b] += sf1.data[d - a + b] * sf2.data[d];
			}
	      	}
d304 8
d313 7
a319 3
/*for(b=0;b<=10*max;b++){
printf("%f\n",corr[b]);
}
d321 4
a324 3
printf("************\n");	      
*/
	/* max shift calculation */
d326 3
a328 5
/*printf("**************************************************************\n");
printf("**************  MAXSHIFT AND CORROLATION ***************\n");
printf("**************************************************************\n");
*/	 
           	maxshift = shift = 0;
d330 2
a331 5
	      	for(b=0;b<=10*max;b++){
			if(maxshift<corr[b]){
		  		maxshift=corr[b];
		  		shift=((float)b)/5.0;
			}
d333 2
a334 3
/*printf("maxshift %f b %d corrb %f shift %f\n",maxshift,b,corr[b],shift);
*/
	      	}
a335 9
	      /* Corrections and output to a temp file */
	  
	      	while(efread(&tr,1,HDRBYTES,hdr1fp)&&efread(tr.data,FSIZE,nt,data1fp)){
			if(tr.sx==sx){
				first = tr.delrt*1000;
		  			for(a=0;a<nt;a++){
		    				xout[a]=first+dt*(a-((float)max)+(shift));
			  		}
		  		ints8r(nt,dt,first,tr.data,0.0,0.0,nt,xout,temptr.data);
d337 3
a339 3
			/*  Update the header */
				tr.tstat = tr.tstat + ((int)dt) * (((int)shift) - max);
				tr.sstat = tr.sstat + ((int)dt) * (((int)shift) - max);
d341 3
a343 2
				efwrite(&tr,1,HDRBYTES,hdr2fp);
				efwrite(temptr.data,FSIZE,nt,data2fp);
d345 1
a345 13
/*printf("***************************************************\n");
		for (a=0;a<64;a++){
			if(temptr.data[a]!=0.0){
			printf("a %d",a);
			printf("sx %ld",tr.sx);
			printf("cdp %ld",tr.cdp);
			printf("data %f\n",temptr.data[a]);
		}
	       } */
			}
			else{
				efwrite(&tr,1,HDRBYTES,hdr2fp);
				efwrite(tr.data,FSIZE,nt,data2fp);
d347 1
a347 1
/*printf("***************************************************\n");
a348 18
		for (a=0;a<64;a++){
		if(tr.data[a]!=0.0){
			printf("a %d",a);
			printf("sx %ld",tr.sx);
			printf("cdp %ld",tr.cdp);
			printf("data %f\n",tr.data[a]);
		}
		}
*/
	      		}
	    	}
	    
	    	rewind(hdr1fp);
	    	rewind(data1fp);
	    	rewind(hdr2fp);
	    	rewind(data2fp);
	   
	/* replace temp1 with temp2 */
d350 6
a355 6
		for(b=0;b<ntr;b++){
	      		efread(&tr,1,HDRBYTES,hdr2fp);
	      		efread(tr.data,FSIZE,nt,data2fp);
	      		efwrite(&tr,1,HDRBYTES,hdr1fp);
	      		efwrite(tr.data,FSIZE,nt,data1fp);
	    	}
d357 5
a361 4
            	free(cdp);
	    	free(corr);
            	free(xout);
	}  	/* End of source_flag if statement */
d363 2
a364 2
	    /* restart variables */
	    source_flag = 0;
d366 4
a369 5
            rewind(hdr1fp);
            rewind(data1fp);
            rewind(hdr2fp);
            rewind(data2fp);
	}	/* End of source loop */
d371 3
a373 3
	free(source);	
}     /* End of staticsx_flag if statement */
/******************* End of Source Correction Routine **********/
d375 1
a375 73
/**************************************************************/
/****************** Reciever Corrections ***********************/

	/*  Check for user wanting reciever corrections */

	if(staticgx_flag){ 
	numreceiver = 0;
	receiver = ealloc1double(nt);/* array for different recievers */

	/* Determin the different recievers */

	for(tempcount=0;tempcount<ntr;tempcount++){
		for(a=0;a<=tempcount;a++){
			efread(&tr,1,HDRBYTES,hdr1fp);
	  		efread(tr.data,FSIZE,nt,data1fp);
		}
	  	for(k=0;k<numreceiver;k++){
			if(tr.gx==receiver[k]){
	      		receiver_flag = 1;
	    		}
	  	}

/******* Reciever corrections ******/

	if(!receiver_flag){

	/* define a new reciever location */

		receiver[numreceiver]=tr.gx;
        	numreceiver++;
printf("******************New Receiver *******\n");
printf("trgx %d numreceiver %d\n",tr.gx, numreceiver);

		gx = tr.gx;
            	cdpn=0;
            	cdp = malloc(sizeof(long)*nt);
	    	xout=ealloc1float(nt*6);
            	corr = ealloc1float(10*max);

	    	rewind(hdr1fp);
	    	rewind(data1fp);
            	corr = ealloc1float(10*max);


	/* Clean up the variables */
		for(a=0;a<nt;a++){
			stone.data[a]=0.0;
			sttwo.data[a]=0.0;
			sf1.data[a] = 0.0;
			sf2.data[a] = 0.0;
			temptr.data[a]=0.0;
		}

	/* Get the first trace */

	    	efread(&tr,1,HDRBYTES,hdr1fp);
	    	efread(tr.data,FSIZE,nt,data1fp);

	/* Check for common depth point and if so update super trace 1 */

	    	do{
	      		if(tr.gx == gx){
				cdp[cdpn++] = tr.cdp;
				for(a=mintime;a<=(maxtime);a++){
		  			stone.data[a]+=tr.data[a];/** SUPER TRACE 1 **/
				}
	      		}
	    	}while(efread(&tr,1,HDRBYTES,hdr1fp)&&efread(tr.data,FSIZE,nt,data1fp));

for(a=0;a<64;a++){
if(stone.data[a]!=0.0){
printf("**********\n");
printf("a %d stone.data %f\n",a,stone.data[a]);
a376 3
}
	    	rewind(hdr1fp);
	   	 rewind(data1fp);
d378 10
a387 23
	/* super trace 2 */

	    	efread(&tr,1,HDRBYTES,hdr1fp);
	    	efread(tr.data,FSIZE,nt,data1fp);

	    	do{
	      		if(tr.gx != gx){
				for(a=0;a<cdpn;a++){
		 			if(tr.cdp==cdp[a]){
		    				a = cdpn;
		    				for(b=mintime;b<=(maxtime);b++){
							/**  SUPER TRACE 2  **/
		      					sttwo.data[b] += tr.data[b];
		    				}
		      			}
		  		}
			}
	      	}while(efread(&tr,1,HDRBYTES,hdr1fp)&&efread(tr.data,FSIZE,nt,data1fp));

for(b=0;b<64;b++){
if(sttwo.data[b]!=0.0){
printf("**********\n");
printf("b d% sttwo.data %f\n",b,sttwo.data[b]);
a388 3
}
	      	rewind(hdr1fp);
	      	rewind(data1fp);
d390 9
a398 9
	 /* sinc functions */
	      	a = 5*nt+1;
		first = tr.delrt*1000;
		for (b=0;b<(nt*5+1);b++){
			xout[b]=first+dt*b*.2;
		}
	      
		ints8r(nt,dt,first,stone.data,0.0,0.0,a,xout,sf1.data);
	      	ints8r(nt,dt,first,sttwo.data,0.0,0.0,a,xout,sf2.data);
d400 4
a403 6
		a=max;
	      	for(b=0;b<=10*max;b++){
			for(d=tmin*5;d<=tmax*5;d++){
		  		corr[b] += sf1.data[d - a + b] * sf2.data[d];
			}
	      	}
d405 5
a409 43

	      /* max shift calculated */
	 
              	maxshift = shift = 0;
printf("**************************************************************\n");
printf("**************  MAXSHIFT AND CORROLATION ***************\n");
printf("**************************************************************\n");
	      	for(b=0;b<=10*max;b++){
			if(maxshift<corr[b]){
		  		maxshift=corr[b];
		  		shift=((float)b)/5.0;
			}

printf("maxshift %f b %d corrb %f shift %f\n",maxshift,b,corr[b],shift);

	      	}

	      /* Corrections and output to a temp file */
	  
	      	while(efread(&tr,1,HDRBYTES,hdr1fp)&&efread(tr.data,FSIZE,nt,data1fp)){
			if(tr.gx==gx){
				first = tr.delrt*1000;

		  		for(a=0;a<nt;a++){
		    			xout[a]=first+dt*(a-((float)max)+(shift));
			  	}

		  		ints8r(nt,dt,first,tr.data,0.0,0.0,nt,xout,temptr.data);

				tr.tstat = tr.tstat + ((int)dt) * (((int)shift) - max);
				tr.sstat = tr.sstat + ((int)dt) * (((int)shift) - max);

				efwrite(&tr,1,HDRBYTES,hdr2fp);
				efwrite(temptr.data,FSIZE,nt,data2fp);

printf("***************************************************\n");

		for (a=0;a<64;a++){
			if(temptr.data[a]!=0.0){
			printf("a %d",a);
			printf("sx %ld",tr.sx);
			printf("cdp %ld",tr.cdp);
			printf("data %f\n",temptr.data[a]);
d411 7
d419 1
a419 4
			}
			else{
				efwrite(&tr,1,HDRBYTES,hdr2fp);
				efwrite(tr.data,FSIZE,nt,data2fp);
d421 8
a428 52
printf("***************************************************\n");

		for (a=0;a<64;a++){
		if(tr.data[a]!=0.0){
			printf("a %d",a);
			printf("sx %ld",tr.sx);
			printf("cdp %ld",tr.cdp);
			printf("data %f\n",tr.data[a]);
		}
		}

	      		}
	    	}   /*  End of while loop */
	    
	    	rewind(hdr1fp);
	    	rewind(data1fp);
	    	rewind(hdr2fp);
	    	rewind(data2fp);

	/* replace temp1 with temp2 */
	   	 for(b=0;b<ntr;b++){
	      		efread(&tr,1,HDRBYTES,hdr2fp);
	      		efread(tr.data,FSIZE,nt,data2fp);
	      		efwrite(&tr,1,HDRBYTES,hdr1fp);
	     		efwrite(tr.data,FSIZE,nt,data1fp);
		}

		
            	free(cdp);
	    	free(corr);
            	free(xout);

	}/* End of receiver_flag if statement */

	/* restart variables and files */
	receiver_flag = 0;
	rewind(hdr1fp);
	rewind(data1fp);
	rewind(hdr2fp);
       rewind(data2fp);
	
	}	/* End of reciever loop */
	free(receiver);
    }  /* End of staticgx_flag if statement */
  }/* End of Ittinerations */

/**********  Output  *************/
	
	for(a=0;a<ntr;a++){
		efread(&tr,1,HDRBYTES,hdr1fp);
		efread(tr.data,FSIZE,nt,data1fp);
		puttr(&tr);
d430 2
a431 3

	return EXIT_SUCCESS;
/*  *End of main* */}
@


1.2
log
@Removed copyright statement from codes that had it.
Moved self-doc line for sudoc.
@
text
@d1 1
a1 1
/* SURESSTAT: $Revision: 1.1 $ ; $Date: 94/02/02 11:49:31 $*/
d605 1
a605 1
  }/* End of Ittinerations
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/* SURESSTAT: $Revision: 1.1 $ ; $Date: 93/3/30 19:13:01 $*/
a2 20
/*----------------------------------------------------------------------
 * Copyright (c) Colorado School of Mines, 1992.
 * All rights reserved.
 *
 * This code is part of SU.  SU stands for Seismic Unix, a processing line
 * developed at the Colorado School of Mines, partially based on Stanford
 * Exploration Project (SEP) software.  Inquiries should be addressed to:
 *
 *  Jack K. Cohen, Center for Wave Phenomena, Colorado School of Mines,
 *  Golden, CO 80401  (jkc@@dix.mines.colorado)
 *----------------------------------------------------------------------
 *  SU Developement Group
 *  Bob Clapp
 *  Jack Oskay
 *  Jim Schauer
 *  Residual Statics Routine
 *  
 */
/* US */

a29 1
/************************ end self doc ***********************************/
d32 5
a36 1
 *	CWP: US
d38 1
@
