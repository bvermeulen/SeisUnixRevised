head	1.30;
access;
symbols;
locks
	john:1.30; strict;
comment	@ * @;


1.30
date	2015.06.02.20.15.23;	author john;	state Exp;
branches;
next	1.29;

1.29
date	2011.11.16.23.30.27;	author john;	state Exp;
branches;
next	1.28;

1.28
date	2011.11.12.00.40.42;	author john;	state Exp;
branches;
next	1.27;

1.27
date	2011.09.09.22.34.19;	author john;	state Exp;
branches;
next	1.26;

1.26
date	2010.02.04.18.44.43;	author john;	state Exp;
branches;
next	1.25;

1.25
date	2009.12.01.18.35.19;	author john;	state Exp;
branches;
next	1.24;

1.24
date	2009.02.27.17.51.56;	author john;	state Exp;
branches;
next	1.23;

1.23
date	2008.05.02.18.10.21;	author john;	state Exp;
branches;
next	1.22;

1.22
date	2008.04.29.18.30.27;	author john;	state Exp;
branches;
next	1.21;

1.21
date	2008.04.28.21.25.54;	author john;	state Exp;
branches;
next	1.20;

1.20
date	2008.04.08.17.03.33;	author john;	state Exp;
branches;
next	1.19;

1.19
date	2006.11.07.22.58.42;	author john;	state Exp;
branches;
next	1.18;

1.18
date	2006.06.29.16.30.47;	author john;	state Exp;
branches;
next	1.17;

1.17
date	2006.06.27.21.40.03;	author john;	state Exp;
branches;
next	1.16;

1.16
date	2006.03.10.20.43.09;	author john;	state Exp;
branches;
next	1.15;

1.15
date	2005.12.07.17.11.15;	author john;	state Exp;
branches;
next	1.14;

1.14
date	2005.10.24.19.46.50;	author john;	state Exp;
branches;
next	1.13;

1.13
date	2005.10.04.16.42.43;	author john;	state Exp;
branches;
next	1.12;

1.12
date	2005.03.11.22.47.10;	author john;	state Exp;
branches;
next	1.11;

1.11
date	2005.03.11.20.51.09;	author john;	state Exp;
branches;
next	1.10;

1.10
date	2004.12.23.22.43.28;	author john;	state Exp;
branches;
next	1.9;

1.9
date	2004.09.21.17.33.03;	author john;	state Exp;
branches;
next	1.8;

1.8
date	2003.11.10.16.35.13;	author john;	state Exp;
branches;
next	1.7;

1.7
date	2003.06.09.16.17.07;	author john;	state Exp;
branches;
next	1.6;

1.6
date	2001.10.24.18.18.45;	author john;	state Exp;
branches;
next	1.5;

1.5
date	2001.06.22.16.19.08;	author john;	state Exp;
branches;
next	1.4;

1.4
date	2001.02.26.22.28.14;	author john;	state Exp;
branches;
next	1.3;

1.3
date	2000.09.22.16.16.40;	author john;	state Exp;
branches;
next	1.2;

1.2
date	2000.05.23.16.04.35;	author john;	state Exp;
branches;
next	1.1;

1.1
date	99.09.07.21.57.26;	author john;	state Exp;
branches;
next	;


desc
@suea2df
@


1.30
log
@added NINT for dt -- Ekkehart Tessmer Uni-bremen
@
text
@/* Copyright (c) Colorado School of Mines, 2011.*/
/* All rights reserved.		       */

/* SUEA2DF: $Revision: 1.29 $ ; $Date: 2011/11/16 23:30:27 $		 */

#include "su.h"
#include "segy.h"
#include "header.h"

/*********************** self documentation **********************/
char *sdoc[] = {
"									",
" SUEA2DF - SU version of (an)elastic anisotropic 2D finite difference 	",
"		forward modeling, 4th order in space			",
"									",
" suea2df > outfile c11file= c55file  [optional parameters]		",
"									",
" Required Parameters:							",
" c11file=c11_file	c11 voigt elasticity parameter filename		",
" c55file=c55_file	c55 voigt elasticity parameter filename		",
"									",
" Optional Parameters:							",
" rhofile=rho_file	density filename				",
"			(if rhofile is not set, rho=1000 is assumed)	",
" Anisotropy parameters:						",
" aniso=0	 	 =1 - include anisotropy parameters		",
" mode=0		=0 output particle velocity, =1 output stresses ",
"			(snapshots only)				",
"									",
" ... the next 3 parameters become active only when aniso=1....		",
" c13file=c13_file	c13 voigt elasticity parameter filename		",
" c33file=c33_file	c33 voigt elasticity parameter filename		",
" c15file=c15_file	c15 voigt elasticity parameter filename		",
" c35file=c35_file	c35 voigt elasticity parameter filename		",
"									",
" Attenuation parameters:						 ",
" qsw=0		 switch to include attenuation =1 - include		",
" ... the next parameter becomes active only when qsw=1....	     	",
" qfile=Q_file	  Q parameter filename	    				",
"									",
" dt=0.001		time sampling interval (s)			",
" ft=0.0 		first time (s)				 	",
" lt=1.0 		last time (s)					",
"									",
" nx=200		number of values in slow (x-direction)		",
" dx=10.0	 	spatial sampling interval (m) x-coor		",
" fx=-1000		first x coor (m)				",
"									",
" nz=100		number of values in fast (z)-dimension		",
" dz=dx			spatial sampling interval (m) z-coor		",
" fz=0			firstz coor (m)  				",
"									",
" Source parameters:							",
" sx=0			source x position (m)				",
" sz=500		source location (m)  				",
" stype='p'		source type					",
"			  p: P-wave					",
"			  v: velocity					",
"			 pw: P plane-wave				",
" sang=0		for stype='pw': plane wave angle		",
" wtype='dg'		wave type					",
" 			 dg: Gaussian derivative 			",
" 			 ga: Gaussian		 			",
" 			 ri: Ricker					",
" 			 sp: spike, sp2: double spike   		",
" ts=0.05		source duration (s)				",
" favg=50		source average frequency			",
"									",
" Attenuation parameters:						",
" qsw=0		 	switch to include attenuation =1 - include	",
"									",
" Boundary condition parameters:					",
" bc=10,10,10,10 	Top,left,bottom,right boundary condition	",
" 			=0 none						",
" 			=1 symmetry 					",
" 			=2 free surface (top only)			",
" 			>2 absorbing (value indicates width of absorbing",
"			layer	 					",
" bc_a=0.95;		bc initial taper value for absorbing boundary  ",
" bc_r=0.;		bc exponential factor for absorbing boundary  	",
" 			variables are scaled by bc_a*pow(i,-bc_r)	",
"									",
" Optional output parameters:						",
" sofile=		name of source file				",
" snfile=		name of file containing for snapshots		",
" snaptime=		times of snapshots i.e. snaptime=0.1,0.2,0.3	",
"									",
" vsx=			x coordinate of vertical line of seismograms	",
" hsz=			z coordinate of horizontal line of seismograms	",
" vrslfile=\"vsp.su\"	output file for vertical line of seismograms[nz][nt]",
" hsfile=\"hs.su\" 	output file for horizontal line of seismograms[nx][nt]",
" tsw=0		 	switch to use shear stress only in non-fluid	",
"			media - may help reduce dispersion tsw=1. If	",
"			tsw=0 then standard calculation	  		",
" verbose=0		=1 to print progress on screen			",
"									",
" Notes:								",
" 1) The outfile contains information generated by the input parameters,",
"    such as memory allocation, stability, etc. If your input file does	",
"    not work, check this file first.					",
"									",
" The model is specified as binary files of stiffness parameters and    ",
" densities. These may be created any way the user desires. The program ",
" unif2 or makevel may be used to generate densities, and the program	",
" unif2aniso may be used to generate the stiffnesses. You will need to	",
" transpose these files (stiffnesses and densities), as the input	",
" format for suea2df assumes that the fast dimesion is the horizontal or ",
" the x-dimension. You may do this via					",
" 									",
"  transp n1=nz < c11_file > transp_c11_file				",
"									",
" If aniso=1 then the program will expect the additional stiffnesss files.",
"									",
" If qsw=1 unif2anis can be used to generate the Q values on a grid	",
" These value also need to be transposed, as with the stiffnesses.	",
"									",
"Output files (always generated)					",
"	hsfile								",
"	vrslfile							",
"	hsfile.chd - header for hsfile					",
"	vrslfile.chd - header for vrslfile				",
"	hsfile.mod - model file						",
"									",
" Output files (if requested)						",
"	sofile - ascii source file					",
"	snfile  - su format snapshots file				",
"									",
" Caveat:								",
" A common error in using this program is to compute stiffnesses with	",
" a specified density, but forget to specify this density as the rhofile.",
NULL};

/* 
 * Credits: UU GEOPHY Chris Juhlin 15 May 1999
 * Copyright (c) Uppsala University, 1998.
 * All rights reserved.			
 * Parts of program use Seismic Unix Package - CSM
 * Changes - C. Juhlin
 *
 * 1. Fixed upgrading of stresses. There was an error in the coding for
 * the Tzz term, c15 was being used instead of c35. This only caused
 * problems for dipping anisotropic layers
 *
 * 2. Added some header information for hutput of snapshots.
 *
 * 3. 2001-01-30: Added option to set absorbing bc constants bc_a and bc_r 
 *
 * 4. 2001-02-23: Corrected bug in outputting model boundaries to standard
 * output in 
 * routine get_econst
 *
 * 5. 2001-04-26: Added option for updating velocities to only use 
 * shear stress if material is non-fluid, this appears to reduce dispersion at 
 * near grazing angles for fluid-solid boundary. Set tsw=1 to invoke
 *
 * 6. 2001-05-14: Changed loop in free-surface boundary condition for velocties
 * Thanks goes to Mike Holzrichter for pointing out this problem and the wrong
 * scaling factor in the updating.
 *
 * 7. 2001-05-16: Changed set_layers function to avoid negative indexing.
 * Thanks goes to Mike Holzrichter for pointing out this problem
 *
 * 8. 2001-05-17: Modified make_seis to take into account VSP geometry
 * correctly and not store unnecessary data.
 *
 * 9. 2001-08-21: Fixed set_layers so mode fills properly in depth. Earlier
 * versions were accessing incorrect array locations at last defined depth.
 *
 * 10. 2003-04-21: Fixed boundary conditions.
 *
 * 11. 2003-05-02: Extended the model area by half the grid spacing on the RHS.
 * This makes the model area symmetric allowing a plane wave source to be
 * introduced into the model (stype=pw). The w, txx and tzz grids contain now
 * one more column than the u and txz grids.
 *
 * 12. 2003-05-02: Added routines to allow plane waves to be introduced at a 
 * specified angle (sang) into the model with functions add_pw_source_V and
 * add_pw_source_S.
 *
 * 13. 15 Oct 2005 -- tossed all the model building stuff. Read models
 *	from binary files made by  unif2aniso (CWP:John Stockwell)
 *
 * 14. 25 Feb 2008 -- Fixed attenutation option (qsw=1) so that Q values are
 *	from binary files made by makevel or similar program
 *
 * 15. 1 April 2010 -- Changed free surface velocity BC back to original.
 *	Someone had changed the scaling factor from 2.0 to 0.5 in fs4v_bc_top
 *
 * Algorithm based on Juhlin (1995, Geophys. Prosp.)
 *	and Levander (1988, Geophysics)
 * Attenuation included as in Graves (1996, BSSA)
 *
 */

/**************** end self doc ********************************/

#define	F1	1.125
#define	F2	-0.04166667

segy tr, trv, trh;

/* prototypes for functions defined and used below */
int get_source(float dt, float ts, float favg, char *wtype, float *source);
void update_vel(int ifx, int ilx, int jfz, int jlz,
	float **u, float **w, float **txx, float **tzz, float **txz,
	float **rho, float **c55, float dtx, float dtz);
void update_vel_tsw(int ifx, int ilx, int jfz, int jlz,
	float **u, float **w, float **txx, float **tzz, float **txz,
	float **rho, float **c55, float dtx, float dtz);
void update_stress_iso(int ifx, int ilx, int jfz, int jlz,
	float **u, float **w, float **txx, float **tzz, float **txz,
	float **c11, float **c55, float dtx, float dtz);
void update_stress_ani(int ifx, int ilx, int jfz, int jlz,
	float **u, float **w, float **txx, float **tzz, float **txz,
	float **c11, float **c55, float **c33, float **c13, 
	float **c15, float **c35, float dtx, float dtz);
void add_p_source(float **txx, float** tzz, float amp, int i, int j);

void add_v_source(float **u, float **w, float amp, int i, int j);

void add_pw_source_V(float **u, float **w, float **txx, 
			float **tzz, float **txz, float **c11, 
			float **c55, float *a, float sang, 
			int il, int ir, int jt, int jb, 
			int ns, int k, float dx, float dz,
			float dt, float *vl, float *vb, 
			float *vr, float *ttl, float *ttb, float *ttr);
void add_pw_source_S(float **u, float **w, float **txx, 
			float **tzz, float **txz, float **c11,
			float **c55, float *a, float sang,
			int il, int ir, int jt, int jb,
			int ns, int k, float dx, float dz,
			float dt, float *vl, float *vb,
			float *vr, float *ttl, float *ttb, float *ttr);
void make_snap(float **u, float **w, float sx, float sz, float dx, float dz,
			int nxpadded, int nzpadded, int nx, int nz, int k,
			float t, float fx, float fz, segy tr, FILE *sneisfp,
			int *wbc);
void make_seis(float **ut, float **wt, float sx, float sz, float dn, float dt,
			int nn, int nt, float dd, float fx, float fz, segy tr, 
			FILE *fp, int b1, int b2, int ivh, 
			int verbose, float favg);
void abs_bc_top(float **u, float **w, float **txx, float **tzz,
			float **txz, int nxpadded, int nzpadded, 
			float *r, int *bc, int *wbc, int ifx, int ilx);
void abs_bc_left(float **u, float **w, float **txx, float **tzz, 
			float **txz, int nxpadded, int nzpadded, 
			float *r, int *bc, int *wbc, int jfz, int jlz);
void abs_bc_bot(float **u, float **w, float **txx, float **tzz, float **txz,
	  		int nxpadded, int nzpadded, float *r, int *bc,
			int *wbc, int ifx, int ilx);
void abs_bc_right(float **u, float **w, float **txx, float **tzz, float **txz,
			int nxpadded, int nzpadded, float *r, int *bc,
			int *wbc, int jfz, int jlz);
void fs4s_bc_top(float **txx, float **tzz, float **txz, int nxpadded,
			int nzpadded);
void fs4v_bc_top(float **u, float **w, float **c11, float **c55, 
			int nxpadded, int nzpadded);
void sym4s_bc_top(float **txx, float **tzz, float **txz, int nxpadded,
			int nzpadded);
void sym4v_bc_top(float **u, float **w, int nxpadded, int nzpadded);
void sym4s_bc_left(float **txx, float **tzz, float **txz, int nxpadded,
			int nzpadded);
void sym4v_bc_left(float **u, float **w, int nxpadded, int nzpadded);
void sym4s_bc_bot(float **txx, float **tzz, float **txz, int nxpadded,
			int nzpadded);
void sym4v_bc_bot(float **u, float **w, int nxpadded, int nzpadded);
void sym4s_bc_right(float **txx, float **tzz, float **txz, int nxpadded,
			int nzpadded);
void sym4v_bc_right(float **u, float **w, int nxpadded, int nzpadded);

void calc_area(float vmax, float dtx, float dtz, int *limits, int i,
			int j, int k, int nxpadded, int nzpadded);
void write_chd(int nxpadded, int nzpadded, int nt, float dx, float dz, float dt,
			float fx, float xmax, float fz, float zmax,
			float sx, float sz, float favg, float ts, 
			char *wtype, char *stype, int *bc, int qsw, 
			int aniso, float xz, FILE *fp, int comp, char *mfile);
int fwrite_chd(FILE *fp, char *s, int k);
void write_grid(float **u, float **w, float **txx, float **tzz, 
			float **txz, int is, int js);
void make_stress_snap(float **txx, float **tzz, float **txz, float sx,
			float sz, float dx, float dz, int nxpadded,
			int nzpadded, int k, float t, float fx, float fz,
			segy tr, FILE *sneisfp, int *wbc);
void pad_float_2D(int n1, int n2, int *padval, float **in , float **out); 
		
/* the main program */
int
main (int argc, char **argv)
{
	float dt;		/* time sampling interval 	*/
	float ft;		/* first time sample		*/
	float lt;		/* last time sample		*/

	float dx;		/* spatial sampling interval x 	*/
	float dz;		/* spatial sampling interval z	*/
	float fx;		/* min x coor		 	*/

	float xmax;		/* max x coor		 	*/
	float fz;		/* min z coor		 	*/
	float zmax;		/* max z coor		 	*/

	char *stype=NULL;	/* source type			*/
	char *wtype=NULL;	/* wave type			*/
	float sang;		/* plane wave angle (deg)	*/

	float ts;		/* source length (s)		*/
	float favg;		/* source average frequency (Hz)*/
	float sx,sz;		/* current source location (m)	*/

	int nsnap;		/* number of snapshots		*/
	float *snaptime=NULL;	/* snapshot times		*/
	int *isnap=NULL;	/* snapshot samples		*/

	int nt=0;		/* number of time samples 	*/
	int nz=0;		/* number of z samples of model */
	int nx=0;		/* number of x samples of model	*/
	int nzpadded=0;		/* nz padded by bc		*/
	int nxpadded=0;		/* nx padded by bc		*/

	int nbytes;		/* number of bytes allocated	*/
	int ngrids;		/* number of bytes allocated	*/
	int i,j,k,ix,iz;	/* loop counters 		*/

	float **c11=NULL;	/* elastic constant c11(x,z)	*/
	float **c11temp=NULL;	/* ...related temporary array	*/
	float **c55=NULL;	/* elastic constant c55(x,z)	*/
	float **c55temp=NULL;	/* ...related temporary array	*/
	float **rho=NULL;	/* density rho(x,z), initially	*/
				/* ... later rho(x,z)=1/density	*/
	float **rhotemp=NULL;	/* ...related temporary array	*/
	float **q=NULL;		/* Q-factor q(x,z)		*/
	float **qtemp=NULL;     /* ...associated temp file	*/

	float rhomin=0.0;	/* minimum density		*/
	float rhomax=0.0;	/* maximum density		*/
	float c11min=0.0;	/* minimum c11			*/
	float c11max=0.0;	/* maximum c11			*/
	float c55min=0.0;	/* minimum c55			*/
	float c55max=0.0;	/* maximum c55			*/

	float c13min=0.0;	/* minimum c13			*/
	float c13max=0.0;	/* maximum c13			*/
	float c33min=0.0;	/* minimum c33			*/
	float c33max=0.0;	/* maximum c33			*/
	float c15min=0.0;	/* minimum c15			*/
	float c15max=0.0;	/* maximum c15			*/
	float c35min=0.0;	/* minimum c35			*/
	float c35max=0.0;	/* maximum c35			*/

	float qmin=0.0;	 /* minimum q		    */
	float qmax=0.0;	 /* maximum q		    */

	int qsw;		/* switch to include attenuation*/

	int aniso;		/* switch to include anisotropy */
	float **c13=NULL;	/* elastic constant c13(x,z)	*/
	float **c13temp=NULL;	/* ...associated temp file	*/
	float **c33=NULL;	/* elastic constant c33(x,z)	*/
	float **c33temp=NULL;	/* ...associated temp file	*/
	float **c15=NULL;	/* elastic constant c13(x,z)	*/
	float **c15temp=NULL;	/* ...associated temp file	*/
	float **c35=NULL;	/* elastic constant c35(x,z)	*/
	float **c35temp=NULL;	/* ...associated temp file	*/

	float **u=NULL,**w=NULL;	/* particle velocities		*/
	float **txx=NULL,**tzz=NULL;	/* normal stresses		*/
	float **txz=NULL;		/* shear stress			*/
	float **ut=NULL,**wt=NULL;	/* time sections 		*/

	int tsw;		/* switch for shear stress updating */

	float *source=NULL;	/* source waveform		*/
	float pfac;		/* P-wave source scaling factor	*/
	int ns;			/* number of samples in source	*/

	float energy,efac;	/* energy in model		*/
	float dtx,dtz;		/* fd factors			*/
	int ifx,ilx,jfz,jlz;	/* grid area for operators	*/
	int is,js;		/* source location in grid	*/
	float vlim[2];		/* min and max velocity in grid	*/
	int *limits=NULL;	/* calculation area in grid	*/

	int verbose;		/* is verbose? 			*/

	int vs2;		/* depth in samples of horiz rec line */
	int hs1;		/* horiz sample of vert rec line */
	float hsz;		/* z position of horiz receiver line */
	float vsx;		/* x position of vertical receiver line */

	int bc[4];		/* boundary condition flags 	*/
	int wbc[4];		/* boundary width	 	*/
	int nbc;		/* number of values given 	*/
	float *bc0=NULL;	/* taper at top boundary 	*/
	float *bc1=NULL;	/* taper at left boundary 	*/
	float *bc2=NULL;	/* taper at bottom boundary 	*/
	float *bc3=NULL;	/* taper at right boundary 	*/
	float bc_a;		/* bc initial taper value 	*/
	float bc_r;		/* bc exponential factor 	*/
	float *vl=NULL,*vr=NULL,*vb=NULL;/* velocity at boundaries 	*/
	float *ttl=NULL,*ttr=NULL,*ttb=NULL;/* traveltimes at boundaries */

	float t;		/* current time of propagation	*/


	char *sofile="";	/* source filename		*/
	FILE *soeisfp=NULL;	/* ... its file pointer  */

	char *snfile="";	/* snapshot filename		*/
	FILE *sneisfp=NULL;	/* ... its file pointer  */

	char *mfile=NULL;	/* model filename*/
	FILE *mfp=NULL;		/* ... its file pointer   */
	char *vrslfile="";	/* vert receiver seismogram line file  name */
	FILE *vseisfp=NULL;	/* ... its file pointer  */
	char *vrshfile=NULL;	/* vert receiver seismogram header filename*/
	FILE *vchdfp=NULL;	/* ... its file pointer  */

	char *hsfile="";	/* horiz receiver seismogram line filename*/
	FILE *hseisfp=NULL;	/* ... its file pointer  */
	char *hcfile=NULL;	/* horiz receiver seismogram header filename*/
	FILE *hchdfp=NULL;	/* ... its file pointer   */
	char tfile[256];	/* temporary filename*/

	char *rhofile="";	/* density filename*/
	FILE *rhofilefp=NULL;	/* ... its file pointer */
	char *c11file="";	/* c11 stiffness filename */
	FILE *c11filefp=NULL;	/* ... its file pointer */
	char *c55file="";	/* c55 stiffness filename */
	FILE *c55filefp=NULL;	/* ... its file pointer */
	char *c13file="";	/* c13 stiffness filename */
	FILE *c13filefp=NULL;	/* ... its file pointer */
	char *c15file="";	/* c15 stiffness filename */
	FILE *c15filefp=NULL;	/* ... its file pointer */
	char *c33file="";	/* c33 stiffness filename */
	FILE *c33filefp=NULL;	/* ... its file pointer */
	char *c35file="";	/* c35 stiffness filename */
	FILE *c35filefp=NULL;	/* ... its file pointer */
	char *qfile="";	 /* Q filename*/
	FILE *qfilefp=NULL;     /* ... its file pointer */


	float sa,ca,p;

	int mode;		/* output mode =0 for particle velocity */
				/* =1 for stresses */

	/* hook up getpar to handle the parameters */
	initargs(argc,argv);
	requestdoc(0);

	/* get optional parameters */
	if (!getparfloat("dt",&dt)) dt = 0.001;
	if (!getparfloat("ft",&ft)) ft = 0.0;
	if (!getparfloat("lt",&lt)) lt = 1.0;

	/* get model size in slow direction */
	if (!getparint("nx",&nx)) nx = 200;
	if (!getparfloat("dx",&dx)) dx = 10;
	if (!getparfloat("fx",&fx)) fx = -1000;

	/* get model size in fast direction */
	if (!getparint("nz",&nz)) nz = 100;
	if (!getparfloat("dz",&dz)) dz = dx;
	if (!getparfloat("fz",&fz)) fz = 0;

	/* calculate maximum model coordinates */
	xmax = fx + dx*nx;
	zmax = fz + dz*nz;

	/* get source location */
	if (!getparfloat("sx",&sx)) sx = (fx+xmax)/2;
	if (!getparfloat("sz",&sz)) sz = (fz+zmax)/2;

	/* get source type, angle */	
	if (!getparstring("stype",&stype)) stype="p";
	if (!getparfloat("sang",&sang)) sang = 0;

	/* get wavelet type, source time length, average frequency */
	if (!getparstring("wtype",&wtype)) wtype="ri";
	if (!getparfloat("ts",&ts)) ts = 0.05;
	if (!getparfloat("favg",&favg)) favg = 50;

	if (!getparint("qsw",&qsw)) qsw = 0;
	if (!getparint("aniso",&aniso)) aniso = 0;
	if (!getparint("tsw",&tsw)) tsw = 0;
	if (!getparint("verbose",&verbose)) verbose = 0;
	if (!getparint("mode",&mode)) mode = 0;

	/***...begin......... shapshot and source files....... */
	/* get name of output snapshot, source files */ 
	getparstring("snfile",&snfile);
	getparstring("sofile",&sofile);

	/* determine snapshots times and sample numbers */
	nsnap = countparval("snaptime");
	if (nsnap!=0){
		snaptime = alloc1float(nsnap);
		isnap = alloc1int(nsnap);
		getparfloat("snaptime",snaptime);
		warn("nsnap=%d \n",nsnap);
		for (i=0; i<nsnap; i++) isnap[i]=NINT(snaptime[i]/dt);
	}
	/* if requested, open file for snapshots */
	if (*snfile!='\0') {
		if((sneisfp=fopen(snfile,"w"))==NULL)
			err("cannot open snfile=%s\n",snfile);
	}

	/* if requested, open file for source */
	if (*sofile!='\0') {
		if((soeisfp=fopen(sofile,"w"))==NULL)
			err("cannot open sofile=%s\n",sofile);
	}
	/***...end......... shapshot and source files....... */


	/**** begin ....... stiffnesses  .... */
	/* Must have stiffnesses c11 and c55 */
	if (!getparstring("c11file",&c11file)) 	c11file="c11_file";
	if (!getparstring("c55file",&c55file)) 	c55file="c55_file";

	/*.. open file for C11 */
	if((c11filefp=fopen(c11file,"r"))==NULL)
			err("cannot open c11file=%s\n",c11file);
	/*.. open file for C55 */
	if((c55filefp=fopen(c55file,"r"))==NULL)
			err("cannot open c55file=%s\n",c55file);


	if (aniso==1) { 
		/* Must have these additional stiffnesses for anisotropy */
		if (!getparstring("c13file",&c13file))	c13file="c13_file";
		if (!getparstring("c35file",&c35file))	c35file="c35_file";
		if (!getparstring("c33file",&c33file))	c33file="c33_file";
		if (!getparstring("c15file",&c15file))	c15file="c15_file";

		/*.. open file for C13 */
		if((c13filefp=fopen(c13file,"r"))==NULL)
				err("cannot open c13file=%s\n",c13file);

		/*.. open file for C35 */
		if((c35filefp=fopen(c35file,"r"))==NULL)
				err("cannot open c35file=%s\n",c35file);

		/*.. open file for C33 */
		if((c33filefp=fopen(c33file,"r"))==NULL)
				err("cannot open c33file=%s\n",c33file);

		/*.. open file for C15 */
		if((c15filefp=fopen(c15file,"r"))==NULL)
				err("cannot open c15file=%s\n",c15file);
	}
	/**** end ....... stiffnesses .... */

	/**** start ..... attenuation .... */
	if (qsw==1) {
		/* Must have these values for attenuation */
		if (!getparstring("qfile",&qfile))	qfile="q_file";

		/*.. open file for Q */
		if((qfilefp=fopen(qfile,"r"))==NULL)
				err("cannot open qfile=%s\n",qfile);
	}
	/**** end ....... attenuation .... */

	
	/**** begin ..... boundary conditions .... */
	/* get boundary conditions */
	nbc = countparval("bc");
	if (nbc==4) {
		getparint("bc", bc);	
	} else {
		bc[0] = 10;
		bc[1] = 10;
		bc[2] = 10;
		bc[3] = 10;

		if (!((nbc==4) || (nbc==0)) ) 
			warn("Number of bc %d, using bc=10,10,10,10",bc);
	}
	if (!getparfloat("bc_a",&bc_a)) bc_a = 0.95;
	if (!getparfloat("bc_r",&bc_r)) bc_r = 0;
	warn("%f bc_a  %f bc_r\n",bc_a,bc_r);

	for(i=0; i<4; i++) {
		wbc[i]=2;
		if(bc[i]>2)wbc[i]=bc[i];
	}

	bc0=alloc1float(bc[0]);
	bc0[0]=bc_a;
	bc1=alloc1float(bc[1]);
	bc1[0]=bc_a;
	bc2=alloc1float(bc[2]);
	bc2[0]=bc_a;
	bc3=alloc1float(bc[3]);
	bc3[0]=bc_a;

	for(j=1; j<bc[0]; j++) bc0[j]=bc0[j-1]*bc_a*pow(j,-bc_r);
	for(j=1; j<bc[1]; j++) bc1[j]=bc1[j-1]*bc_a*pow(j,-bc_r);
	for(j=1; j<bc[2]; j++) bc2[j]=bc2[j-1]*bc_a*pow(j,-bc_r);
	for(j=1; j<bc[3]; j++) bc3[j]=bc3[j-1]*bc_a*pow(j,-bc_r);

		/*warn("%d %f\n",j,bc0[j]);*/

 	for(j=0; j<bc[3]; j++) warn(" %d %f\n",j,bc3[j]);
	
	warn("bc=%d %d %d %d",bc[0],bc[1],bc[2],bc[3]);
	warn("wbc=%d %d %d %d",wbc[0],wbc[1],wbc[2],wbc[3]);
	/**** end ..... boundary conditions .... */
	
	/***** begin .... seismogram files .... */
	/* determine seismogram recording lines */
	if (!getparfloat("hsz",&hsz)) hsz = 0.0;
	hs1 = NINT( (hsz - fz)/dz )+wbc[0];		/*horizontal line*/
	if (!getparfloat("vsx",&vsx)) vsx = 0.0;
	vs2 = NINT((vsx - fx)/dx )+wbc[1];		/*vertical line*/
	if (!getparint("verbose",&verbose)) verbose = 0;
	if (!getparstring("hsfile",&hsfile)) hsfile="hs.su";
	if (!getparstring("vrslfile",&vrslfile)) vrslfile="vsp.su";
	warn("hs1=%d vs2=%d \n",hs1, vs2);
	

	/* open files for seismograms */
	if((hseisfp=fopen(hsfile,"w+"))==NULL) 
		err("cannot open hsfile=%s\n",hsfile);
	if((vseisfp=fopen(vrslfile,"w+"))==NULL)
		err("cannot open vrslfile=%s\n",vrslfile);
	/***** end .... seismogram files .... */
		
	/* pad the nx and nz dimensions for boundary condition layers */
	nxpadded=nx+wbc[1]+wbc[3];		
	nzpadded=nz+wbc[0]+wbc[2];

	nt=NINT((lt-ft)/dt)+1;
	warn("dx=%f dz=%f dt=%f",dx,dz,dt);
	warn("nxpadded=%d nzpadded=%d nt=%d",nxpadded,nzpadded,nt);
	warn("array sizes");

	/* set grid parameters*/
	limits = alloc1int(4);
	 	dtx=dt/dx; dtz=dt/dz;
	 	energy=0;efac=1000000000000000000./((nxpadded-4)*(nzpadded-4));
	 	pfac=1./(dx*dz);
	 	is=NINT((-fx+sx)/dx)+wbc[1]; js=NINT((-fz+sz)/dz)+wbc[0];
 	warn("is=%d js=%d\n",is,js);

	/* check to se if source is inside the model */
 	if((sx<fx) || (sx>xmax))
		err("sx=%f source must lie within model \n",sx);
 	if((sz<fz) || (sz>zmax))
		err("sz=%f source must lie within model \n",sz);
		
	/* allocate space for model*/
	c11 = alloc2float(nxpadded,nzpadded);
	c11temp = alloc2float(nx,nz);
	c55 = alloc2float(nxpadded,nzpadded);
	c55temp = alloc2float(nx,nz);
	rho = alloc2float(nxpadded,nzpadded);
	rhotemp = alloc2float(nx,nz);
	ngrids=3;

	/* if attenuation is desired allocate space for q values */
	if(qsw==1) {
		q = alloc2float(nxpadded,nzpadded);
		qtemp = alloc2float(nx,nz);
		++ngrids; /* bump ngrids up by one */
	}

	/* calculate the number of bytes in grids */
	nbytes=ngrids*nxpadded*nzpadded*FSIZE;

	/* if anisotropy is desired allocate space for anisotropy params */
	if(aniso==1) {
		c33 = alloc2float(nxpadded,nzpadded);
		c33temp = alloc2float(nx,nz);
		c13 = alloc2float(nxpadded,nzpadded);
		c13temp = alloc2float(nx,nz);
		c15 = alloc2float(nxpadded,nzpadded);
		c15temp = alloc2float(nx,nz);
		c35 = alloc2float(nxpadded,nzpadded);
		c35temp = alloc2float(nx,nz);
		ngrids+=4;
	}

	/* calculate the number of bytes in all the grids */
	nbytes=ngrids*nxpadded*nzpadded*FSIZE;
	warn("%d grids allocated for model",ngrids);
	warn("%f MBytes allocated for model",0.000001*nbytes);

	/* set e_*/
	strcpy(tfile,hsfile);
	mfile=strcat(tfile,".mod");

	/* open mfile */	
	if((mfp=fopen(mfile,"w+"))==NULL)
		err("cannot open mfile=%s\n",mfile);

	/***** get density and stiffnesses from input files ***********/
	/* ... densities optional */
	getparstring("rhofile",&rhofile);

 	/*** begin density **/
	/* if specified, read density rho */
	if (*rhofile!='\0') {
		if((rhofilefp=fopen(rhofile,"r"))==NULL)
			err("cannot open rhofile=%s\n",rhofile);
		if (fread(rhotemp[0],sizeof(float),nx*nz,rhofilefp)!=nx*nz)
			err("error reading rhofile=%s\n",rhofile);
		fclose(rhofilefp);

		/* pad the density */
		pad_float_2D(nx,nz,wbc,rhotemp,rho); 
		free2float(rhotemp);



		/* we need to invert density */
		/* find min and max of 1/density */
		rhomin = rhomax = 1/rho[0][0];
		for (iz=0; iz<nzpadded; ++iz) {
			for (ix=0; ix<nxpadded; ++ix) {

					/* rho = 1/rho */
					rho[iz][ix] = 1/rho[iz][ix];

					rhomin= MIN(rhomin,rho[iz][ix]);
					rhomax = MAX(rhomax,rho[iz][ix]);
			}
		}
			
	 }

	/* if densities not specified  make densities = 10^{-3} */
	if (*rhofile=='\0' ) {
		err("!!!rhofile= not set!!!");
	  /* if (verbose) warn("!!!rhofile= not set, assuming density=1000!!!");
		  for (iz=0; iz<nzpadded; ++iz)
			   for (ix=0; ix<nxpadded; ++ix)
				    rho[iz][ix] = .001;
		  rhomin = rhomax = .001 ;
	  */
	}
	if (verbose) warn(" 1/density:  max = %f  min=%f",rhomax,rhomin);
 	/** end density **/


	/***** begin c11  */
	if((c11filefp=fopen(c11file,"r"))==NULL)
		err("cannot open c11file=%s\n",c11file);
	if (fread(c11temp[0],sizeof(float),nx*nz,c11filefp)!=nx*nz)
		err("error reading c11file=%s\n",c11file);
	fclose(c11filefp);

	/* pad the c11 */
	pad_float_2D(nx,nz,wbc,c11temp,c11); 
	free2float(c11temp);

	/* find min and max of c11 */
	c11min = c11max = c11[0][0];
	for (iz=0; iz<nzpadded; ++iz) {
		for (ix=0; ix<nxpadded; ++ix) {
			    c11min = MIN(c11min,c11[iz][ix]);
			    c11max = MAX(c11max,c11[iz][ix]);
		}
	}
	if (verbose)  warn(" c11max=%f  c11min=%f",c11max,c11min);
			
 	/**** end ....... c11 **/

	/***** begin ...........c55  */
	if((c55filefp=fopen(c55file,"r"))==NULL)
		err("cannot open c55file=%s\n",c55file);
	if (fread(c55temp[0],sizeof(float),nx*nz,c55filefp)!=nx*nz)
		err("error reading c55file=%s\n",c55file);
	fclose(c55filefp);

	/* pad the c55 */
	pad_float_2D(nx,nz,wbc,c55temp,c55); 
	free2float(c55temp);

	/* find min and max of c55 */
	c55min = c55max = c55[0][0];
	for (iz=0; iz<nzpadded; ++iz) {
		for (ix=0; ix<nxpadded; ++ix) {
			    c55min = MIN(c55min,c55[iz][ix]);
			    c55max = MAX(c55max,c55[iz][ix]);
		}
	}
	if (verbose) warn(" c55max=%f  c55min=%f",c55max,c55min);

			
 	/**** end ....... c55 **/

	if (aniso==1) {  /* if anisotropy */

		/***** begin ...........c13  */
		if((c13filefp=fopen(c13file,"r"))==NULL)
			err("cannot open c13file=%s\n",c13file);
		if (fread(c13temp[0],sizeof(float),nx*nz,c13filefp)!=nx*nz)
			err("error reading c13file=%s\n",c13file);
		fclose(c13filefp);

		/* pad the c13 */
		pad_float_2D(nx,nz,wbc,c13temp,c13); 
		free2float(c13temp);

		/* find min and max of c13 */
		c13min = c13max = c13[0][0];
		for (iz=0; iz<nzpadded; ++iz) {
			for (ix=0; ix<nxpadded; ++ix) {
				    c13min = MIN(c13min,c13[iz][ix]);
				    c13max = MAX(c13max,c13[iz][ix]);
			}
		}
			
 		/**** end ....... c13 **/

		/***** begin ...........c33  */
		if((c33filefp=fopen(c33file,"r"))==NULL)
			err("cannot open c33file=%s\n",c33file);
		if (fread(c33temp[0],sizeof(float),nx*nz,c33filefp)!=nx*nz)
			err("error reading c33file=%s\n",c33file);
		fclose(c33filefp);

		/* pad the c33 */
		pad_float_2D(nx,nz,wbc,c33temp,c33); 
		free2float(c33temp);

		/* find min and max of c33 */
		c33min = c33max = c33[0][0];
		for (iz=0; iz<nzpadded; ++iz) {
			for (ix=0; ix<nxpadded; ++ix) {
				    c33min = MIN(c33min,c33[iz][ix]);
				    c33max = MAX(c33max,c33[iz][ix]);
			}
		}
			
 		/**** end ....... c33 **/

		/***** begin ...........c15  */
		if((c15filefp=fopen(c15file,"r"))==NULL)
			err("cannot open c15file=%s\n",c15file);
		if (fread(c15temp[0],sizeof(float),nx*nz,c15filefp)!=nx*nz)
			err("error reading c15file=%s\n",c15file);
		fclose(c15filefp);

		/* pad the c15 */
		pad_float_2D(nx,nz,wbc,c15temp,c15); 
		free2float(c15temp);

		/* find min and max of c15 */
		c15min = c15max = c15[0][0];
		for (iz=0; iz<nzpadded; ++iz) {
			for (ix=0; ix<nxpadded; ++ix) {
				    c15min = MIN(c15min,c15[iz][ix]);
				    c15max = MAX(c15max,c15[iz][ix]);
			}
		}
 		/**** end ....... c15 **/

		/***** begin ...........c35  */
		if((c35filefp=fopen(c35file,"r"))==NULL)
			err("cannot open c35file=%s\n",c35file);
		if (fread(c35temp[0],sizeof(float),nx*nz,c35filefp)!=nx*nz)
			err("error reading c35file=%s\n",c35file);
		fclose(c35filefp);

		/* pad the c35 */
		pad_float_2D(nx,nz,wbc,c35temp,c35); 
		free2float(c35temp);

		/* find min and max of c35 */
		c35min = c35max = c35[0][0];
		for (iz=0; iz<nzpadded; ++iz) {
			for (ix=0; ix<nxpadded; ++ix) {
				    c35min = MIN(c35min,c35[iz][ix]);
				    c35max = MAX(c35max,c35[iz][ix]);
			}
		}
			
 		/**** end ....... c35 **/
	}

	if (qsw==1) {  /* if attenuation */

		if((qfilefp=fopen(qfile,"r"))==NULL)
			err("cannot open qfile=%s\n",qfile);
		if (fread(qtemp[0],sizeof(float),nx*nz,qfilefp)!=nx*nz)
			err("error reading qfile=%s\n",qfile);
		fclose(qfilefp);

		/* pad q */
		pad_float_2D(nx,nz,wbc,qtemp,q);
		free2float(qtemp);

		/* find min and max of q */
		qmin = qmax = q[0][0];
		for (iz=0; iz<nzpadded; ++iz) {
			for (ix=0; ix<nxpadded; ++ix) {
				    qmin = MIN(qmin,q[iz][ix]);
				    qmax = MAX(qmax,q[iz][ix]);
			}
		}
		if (verbose) warn(" qmax=%f  qmin=%f",qmax,qmin);
	}


	if (verbose) warn(" c11max=%f  c11min=%f",c11max,c11min);
	if (verbose) warn(" rhomax=%f  rhomin=%f",rhomax,rhomin);
	if (verbose) warn(" wbc[0]=%d  wbc[1]=%d wbc[2]=%d wbc[3]=%d",
			wbc[0],wbc[1],wbc[2],wbc[3]);

	vlim[0] = sqrt(c11min*rhomax);
	vlim[1] = sqrt(c11max*rhomin);


	/* close mfile */
	fclose(mfp);

	/* set arrays for plane boundary conditions */
	ttl = alloc1float(nzpadded); 
	ttb = alloc1float(nxpadded);
	ttr = alloc1float(nzpadded);
	vl = alloc1float(nzpadded);
	vb = alloc1float(nxpadded);
	vr = alloc1float(nzpadded);

	/* note that rho = 1/density now */
	 for (j=0; j<nzpadded; ++j) {
		vl[j]=sqrt(c11[j][wbc[1]]*rho[j][wbc[1]]);
		vr[j]=sqrt(c11[j][nxpadded-wbc[3]-1]*rho[j][nxpadded-wbc[3]-1]);
	}
	 	for (i=0; i<nxpadded; ++i) {
		vb[i]=sqrt(c11[nzpadded-wbc[2]-1][i]*rho[nzpadded-wbc[2]-1][i]);
	}

	/* ttb: traveltime from source to location on bottom */
	sa=sin(PI*sang/180.);ca=cos(PI*sang/180.);

	if(sang>=0&&sang<90){
		ttb[0]=(-wbc[1])*sa*dx/vb[wbc[1]];
	 		for (i=1; i<nxpadded; ++i) {
			ttb[i]=ttb[i-1]+dx*sa/vb[i];
		}
	}

	if(sang>-90&&sang<0){
		ttb[nxpadded-1]=-(-wbc[3])*sa*dx/vl[nxpadded-wbc[3]-1];
	 		for (i=nxpadded-1; i>0; --i) {
			ttb[i-1]=ttb[i]-dx*sa/vb[i];
		}
	}

	/* ttl, ttr: traveltimes from source to location on LHS, RHS */
	sa=sin(PI*sang/180.);
	ca=cos(PI*sang/180.);
	p=sin(sang*PI/180.)/vl[nzpadded-wbc[2]-1];

	ttl[nzpadded-1]=(-wbc[2])*ca*dz/vl[nzpadded-wbc[2]-1];
	 	for (j=nzpadded-1; j>0; --j) {
		sa=sin(asin(p*vl[j]));
		ca=cos(asin(p*vl[j]));
		ttl[j-1]=ttl[j]+dz*ca/vl[j];
	}

	sa=sin(PI*sang/180.);
	ca=cos(PI*sang/180.);
	p=sin(sang*PI/180.)/vr[nzpadded-wbc[2]-1];
	ttr[nzpadded-1]=(-wbc[2])*ca*dz/vr[nzpadded-wbc[2]-1];

	 	for (j=nzpadded-1; j>0; --j) {
		sa=sin(asin(p*vr[j]));
		ca=cos(asin(p*vr[j]));
		ttr[j-1]=ttr[j]+dz*ca/vr[j];
	}

	warn("vmin=%f vmax=%f",vlim[0],vlim[1]);
	warn("model set");
	
	/* calculate stability and dispersion */
	warn("for stablity dt should be < %f: x-dir and %f: z-dir",
		0.6*dx/vlim[1],0.6*dz/vlim[1]);
	warn("for low dispersion fmax should be < %f ",
		vlim[0]/(5*dx));
	
		
	/* get source function */
	ns=NINT(ts/dt)+1;
	source = alloc1float(ns);
	i=get_source(dt,ts,favg,wtype,source);
	warn("source set");
	if (*sofile!='\0') {
		fprintf(soeisfp,"%s %s %d %d %f %f\n",wtype,stype,ns,i,favg,ts);
		for (i=0; i<ns; i++)
			fprintf(soeisfp,"%f %f\n",i*dt,source[i]);
 	}

	pfac=1.;
	for (i=0; i<ns; i++) source[i]*=pfac;

 	warn("%s %s %d %d %f %f",wtype,stype,ns,i,favg,ts);
	
	/* allocate space for variables*/
	/*  CJ: ADJUSTMENT MADE 030502 - txx,tzz and w extended for symmetry */
	nbytes=ngrids*nxpadded*nzpadded*FSIZE;
	u = alloc2float(nxpadded,nzpadded);
	nbytes=nbytes+nxpadded*nzpadded*FSIZE;
	w = alloc2float(nxpadded+1,nzpadded);
	nbytes=nbytes+(nxpadded+1)*nzpadded*FSIZE;
	txx = alloc2float(nxpadded+1,nzpadded);
	nbytes=nbytes+(nxpadded+1)*nzpadded*FSIZE;
	tzz = alloc2float(nxpadded+1,nzpadded);
	nbytes=nbytes+(nxpadded+1)*nzpadded*FSIZE;
	txz = alloc2float(nxpadded,nzpadded);
	nbytes=nbytes+nxpadded*nzpadded*FSIZE;
	ngrids+=5;
	
	warn("%f MBytes allocated for model + variables\n",
			0.000001*nbytes);

	/* scale Q-factor */
	if(qsw==1) {
		for (i=0; i<nxpadded; i++){
			for (j=0; j<nzpadded; j++) {
				q[j][i]=exp(-PI*dt*favg/q[j][i]); 
			}
		}	
	}
	
	/* zero arrays */
	for (i=0; i<nxpadded; i++){
		for (j=0; j<nzpadded; j++) {
			u[j][i]=0;
			w[j][i]=0;
			txx[j][i]=0;
			tzz[j][i]=0;
			txz[j][i]=0;
		}
	}

	/* write character headers */
	strcpy(tfile,hsfile);
	hcfile=strcat(tfile,".chd");
	if((hchdfp=fopen(hcfile,"w+"))==NULL)
		err("cannot open hcfile=%s\n",hcfile);
	write_chd(nxpadded,nzpadded,nt,dx,dz,dt,fx,xmax,fz,zmax,
			sx,sz,favg,ts,wtype,stype,
			bc,qsw,aniso,hsz,hchdfp,1,mfile);
	fclose(hchdfp);

	strcpy(tfile,vrslfile);vrshfile=strcat(tfile,".chd");
	if((vchdfp=fopen(vrshfile,"w+"))==NULL)
		err("cannot open vrshfile=%s\n",vrshfile);
	write_chd(nxpadded,nzpadded,nt,dx,dz,dt,fx,xmax,fz,zmax,
			sx,sz,favg,ts,wtype,stype,
			bc,qsw,aniso,vsx,vchdfp,2,mfile);
	fclose(vchdfp);

	/* begin wave propagation */
	k=0;
	for (t=ft; t<=lt; t=t+dt) {

		/* calculate area for active grid */
		calc_area(vlim[1],dtx,dtz,limits,is,js,k,nxpadded,nzpadded);

		ifx=limits[0];
		ilx=limits[1];
		jfz=limits[2];
		jlz=limits[3];

		if (strcmp(stype,"pw")==0){
			ifx=2;
			ilx=nxpadded-3;
			jfz=2;
			jlz=nzpadded-3;
		}

		/* introduce velocity source */
		if (k<ns) {
			if (strcmp(stype,"v")==0)
				add_v_source(u,w,dt*source[k],is,js);
		}

		/* update velocities */
		if(tsw==0)
			update_vel(ifx,ilx,jfz,jlz,u,w,txx,tzz,txz,
					rho,c55,dtx,dtz);
		if(tsw==1)
			update_vel_tsw(ifx,ilx,jfz,jlz,u,w,txx,tzz,
					txz,rho,c55,dtx,dtz);
	
		/* introduce plane wave velocity source */
		if (strcmp(stype,"pw")==0){
		  		add_pw_source_V(u,w,txx,tzz,txz,c11,c55,
						source,sang,wbc[1],
						nxpadded-wbc[3]-1,
						wbc[0],nzpadded-wbc[2]-1,
						ns,k,dx,dz,dt,vl,vb,vr,
						ttl,ttb,ttr);
		}

		/* apply free surface bc for velocities */
		if(bc[0]==2) fs4v_bc_top(u,w,c11,c55,nxpadded,nzpadded);
	
		/* apply symmetry bc for velocities */
		if(bc[0]==1) sym4v_bc_top(u,w,nxpadded,nzpadded);
		if(bc[1]==1) sym4v_bc_left(u,w,nxpadded,nzpadded);
		if(bc[2]==1) sym4v_bc_bot(u,w,nxpadded,nzpadded);
		if(bc[3]==1) sym4v_bc_right(u,w,nxpadded,nzpadded);
	
		/* introduce stress source */
		if (k<ns) {
	  		if (strcmp(stype,"p")==0)
				add_p_source(txx,tzz,dt*source[k],is,js);
		}
	
		/* update stresses */
		if(!aniso) {  /* isotropic */
			update_stress_iso(ifx,ilx,jfz,jlz,u,w,txx,tzz,txz,
						c11,c55,dtx,dtz);
		} else {
			update_stress_ani(ifx,ilx,jfz,jlz,u,w,txx,tzz,txz,
						c11,c55,c33,c13,c15,c35,
						dtx,dtz);
		}

		/* introduce plane wave stress source */
		if (strcmp(stype,"pw")==0) {
			add_pw_source_S(u,w,txx,tzz,txz,c11,c55,
						source,sang,wbc[1],
						nxpadded-wbc[3]-1,wbc[0],
						nzpadded-wbc[2]-1,ns,k,
						dx,dz,dt,vl,vb,vr,ttl,
						ttb,ttr);
		}

		/* apply free surface bc for stresses */
		if(bc[0]==2) fs4s_bc_top(txx,tzz,txz,nxpadded,nzpadded);

		/* apply symmetry bc for stresses */
		if(bc[0]==1) sym4s_bc_top(txx,tzz,txz,nxpadded,nzpadded);
		if(bc[1]==1) sym4s_bc_left(txx,tzz,txz,nxpadded,nzpadded);
		if(bc[2]==1) sym4s_bc_bot(txx,tzz,txz,nxpadded,nzpadded);
		if(bc[3]==1) sym4s_bc_right(txx,tzz,txz,nxpadded,nzpadded);

		/* apply absorbing bc */
		if(bc[0]>2)
			abs_bc_top(u,w,txx,tzz,txz,nxpadded,nzpadded,
					bc0,bc,wbc,ifx,ilx);
		if(bc[1]>2)
			abs_bc_left(u,w,txx,tzz,txz,nxpadded,nzpadded,
					bc1,bc,wbc,jfz,jlz);
		if(bc[2]>2)
			abs_bc_bot(u,w,txx,tzz,txz,nxpadded,nzpadded,
					bc2,bc,wbc,ifx,ilx);
		if(bc[3]>2)
			abs_bc_right(u,w,txx,tzz,txz,nxpadded,nzpadded,
					bc3,bc,wbc,jfz,jlz);

		/* attenuation */
		if(qsw==1) {
			for (j=jfz-2; j<jlz+2; j++){
				for (i=ifx-2; i<ilx+2; i++) {
			 		u[j][i]*=q[j][i];
					w[j][i]*=q[j][i];
			 		txx[j][i]*=q[j][i];
					tzz[j][i]*=q[j][i];
					txz[j][i]*=q[j][i];
				}
			}	
		}
	
		/* "energy" */
		energy=0;
		for (i=ifx; i<ilx; i++){
			for (j=jfz; j<jlz; j++) {
				energy=energy+u[j][i]*u[j][i]+w[j][i]*w[j][i]; 
			}
		}
	
		/* store wave motion on file (seismograms) */
		for (i=0 ; i < nxpadded ; ++i)
			fwrite(&u[hs1][i], 4, 1, hseisfp);
		for (i=0 ; i < nxpadded ; ++i) 
			fwrite(&w[hs1][i], 4, 1, hseisfp);
		for (j=0 ; j < nzpadded ; ++j) 
			fwrite(&u[j][vs2], 4, 1, vseisfp);
		for (j=0 ; j < nzpadded ; ++j) 
			fwrite(&w[j][vs2], 4, 1, vseisfp);
				
		/* make snapshot */
		for (i=0; i<nsnap; i++) {
			if (!mode) {
				if(k==isnap[i] && *snfile!='\0') {
					make_snap(u,w,sx,sz,dx,dz,
							nxpadded,nzpadded,
							nx,nz,
							k,t,fx,fz,tr,
							sneisfp,wbc);
		 		} 
			} else {
				if(k==isnap[i] && *snfile!='\0') {
		  			make_stress_snap(txx,tzz,txz,sx, sz,
								dx, dz,
								nxpadded, 
								nzpadded,
								k,t,fx,fz,tr,
								sneisfp,wbc);
				}
		 	}
	 	}

		if((verbose==1) && (k%50==0))
			fprintf(stderr,"%d %f %f %d %d %d %d \n",
 				k,t,energy*efac,ifx,ilx,jfz,jlz);


		k=k+1;
	}

	warn("propagation completed\n");

	/* free space */
	free2float(u);
	free2float(w);
	free2float(txx);
	free2float(tzz);
	free2float(txz);
	warn("propagation space freed\n");
	
	/* read in wave motion from file and make seismograms */
	rewind(hseisfp);	/*horizontal line*/ 

	ut = alloc2float(nxpadded,nt); 
	wt = alloc2float(nxpadded,nt);

	for (k=0 ; k < nt ; ++k){
		for (i=0 ; i < nxpadded ; ++i) 
			fread(&ut[k][i], 4, 1, hseisfp);
		for (i=0 ; i < nxpadded ; ++i)
			fread(&wt[k][i], 4, 1, hseisfp);
	}
	fclose(hseisfp);
	hseisfp=fopen(hsfile,"w");

	make_seis(ut,wt,sx,sz,dx,dt,nxpadded,nt,hsz,fx,fz,
			trh,hseisfp,wbc[1],wbc[3],1,verbose,favg);
	fclose(hseisfp);
	free2float(ut);
	free2float(wt);
	warn("u time section output\n");
	
	rewind(vseisfp);	/*vertical line*/
	ut = alloc2float(nzpadded,nt); wt = alloc2float(nzpadded,nt);
	for (k=0 ; k < nt ; ++k){
	  for (j=0 ; j < nzpadded ; ++j) fread(&ut[k][j], 4, 1, vseisfp);
	  for (j=0 ; j < nzpadded ; ++j) fread(&wt[k][j], 4, 1, vseisfp);
	}
	fclose(vseisfp); vseisfp=fopen(vrslfile,"w");

	make_seis(ut,wt,sx,sz,dz,dt,nzpadded,nt,vsx,fx,fz,
			trv,vseisfp,wbc[0],wbc[2],2,verbose,favg);

	fclose(vseisfp); free2float(ut); free2float(wt);
	warn("w time section output\n");

	if (mode!=0) fclose(sneisfp);

	return(CWP_Exit());
}

int get_source(float dt, float ts, float favg, char *wtype, float *source)
{
	int i,ns; float t,x,xx,pi2;
	i=0; t=0; pi2=PI*PI;
	ns=NINT(ts/dt)+1;
	while (i<ns) {
	  if(strcmp(wtype,"ri")==0){ /*Ricker*/
		x=favg*(t-ts/2);xx=x*x;
		source[i]=(1-2*pi2*(xx))*exp(-pi2*xx);
	  } 							  
	  if(strcmp(wtype,"dg")==0){ /*Derivative of Gaussian*/
		x=-4*favg*favg*pi2/log(0.1);
		source[i]=-2*pi2*(t-ts/2)*exp(-x*(t-ts/2)*(t-ts/2));
	  } 							  
	  if(strcmp(wtype,"ga")==0){ /*Gaussian favg is 10% level for fmax*/
		x=-favg*favg*pi2/log(0.1);
		source[i]=exp(-x*(t-ts/2)*(t-ts/2));
	  } 							  
	  if(strcmp(wtype,"sp")==0){ /*spike*/
		source[0]=1;
	  } 						
	  if(strcmp(wtype,"sp2")==0){ /*spike*/
		source[0]=1;
		source[1]=1;
	  } 						
 	  /*warn("%d %f %f\n",i,t,source[i]);*/
	  t=t+dt; i=i+1;
	}
	return(i);
}

void update_vel(int ifx, int ilx, int jfz, int jlz,
	float **u, float **w, float **txx, float **tzz, float **txz,
	float **rho, float **c55, float dtx, float dtz)
{
	int i,j;
	float dtxx=0,dtzz=0,dtxz=0,dtzx=0;
	 	for (j=jfz; j<=jlz; ++j) {
	 	  for (i=ifx; i<=ilx; ++i) {
	 		dtxx = F1*(txx[j][i+1]-txx[j][i])
		 +F2*(txx[j][i+2]-txx[j][i-1]);
		dtxz = F1*(txz[j+1][i]-txz[j][i])
	 		+F2*(txz[j+2][i]-txz[j-1][i]);
			u[j][i] = u[j][i] + ( dtx*dtxx + dtz*dtxz ) * rho[j][i];
	 	  }
	 	  for (i=ifx; i<=ilx+1; ++i) {
			dtzz = F1*(tzz[j][i]-tzz[j-1][i])
	 		+F2*(tzz[j+1][i]-tzz[j-2][i]);
	 		dtzx = F1*(txz[j][i]-txz[j][i-1])
	 		+F2*(txz[j][i+1]-txz[j][i-2]);
	 		w[j][i] = w[j][i] + ( dtx*dtzx + dtz*dtzz ) * rho[j][i];
	 	  }
	 	}
}
void update_vel_tsw(int ifx, int ilx, int jfz, int jlz,
	float **u, float **w, float **txx, float **tzz, float **txz,
	float **rho, float **c55, float dtx, float dtz)
{
	int i,j;
	float dtxx=0,dtzz=0,dtxz=0,dtzx=0;
	 	for (j=jfz; j<=jlz; ++j) {
	 	  for (i=ifx; i<=ilx; ++i) {
	 		dtxx = F1*(txx[j][i+1]-txx[j][i])
		 +F2*(txx[j][i+2]-txx[j][i-1]);
/*  		Only use 4th order shear stress derivatives if material is non-fluid, otherwise problems occur at grazing angles near fluid-solid boundary */
	 		if(c55[j][i]>0) { 
		 dtxz = F1*(txz[j+1][i]-txz[j][i])
	 		+F2*(txz[j+2][i]-txz[j-1][i]);
		}
		else{
		 dtxz = (txz[j+1][i]-txz[j][i]);
		}
	 		u[j][i] = u[j][i] + ( dtx*dtxx + dtz*dtxz ) * rho[j][i];
	 	  }
	 	  for (i=ifx; i<=ilx+1; ++i) {
	 		dtzz = F1*(tzz[j][i]-tzz[j-1][i])
	 		+F2*(tzz[j+1][i]-tzz[j-2][i]);
/*  		Only use 4th order shear stress derivatives if material is non-fluid, otherwise problems occur at grazing angles near fluid-solid boundary */
	 		if(c55[j][i]>0) { 
	 		dtzx = F1*(txz[j][i]-txz[j][i-1])
	 		+F2*(txz[j][i+1]-txz[j][i-2]);
		}
		else{
	 		dtzx = (txz[j][i]-txz[j][i-1]);
		}
	 		w[j][i] = w[j][i] + ( dtx*dtzx + dtz*dtzz ) * rho[j][i];
	 	  }
	 	}
}


void update_stress_iso(int ifx, int ilx, int jfz, int jlz,
	float **u, float **w, float **txx, float **tzz, float **txz,
	float **c11, float **c55, float dtx, float dtz)
{
	int i,j;
	float dux,duz,dwz,dwx;
	 	for (j=jfz; j<=jlz; ++j) {
	 	  for (i=ifx; i<=ilx+1; ++i) {
	 		dwz = F1*(w[j+1][i]-w[j][i])
	 		+F2*(w[j+2][i]-w[j-1][i]);
	 		dux = F1*(u[j][i]-u[j][i-1])
	 		+F2*(u[j][i+1]-u[j][i-2]);
	 		txx[j][i] = txx[j][i] +
	 		c11[j][i]*dtx*dux + (c11[j][i]-2*c55[j][i])*dtz*dwz;
	 		tzz[j][i] = tzz[j][i] +
	 		c11[j][i]*dtz*dwz + (c11[j][i]-2*c55[j][i])*dtx*dux;
	 	  }
	 	  for (i=ifx; i<=ilx; ++i) {
	 		dwx = F1*(w[j][i+1]-w[j][i])
		 +F2*(w[j][i+2]-w[j][i-1]);
	 		duz = F1*(u[j][i]-u[j-1][i])
	 		+F2*(u[j+1][i]-u[j-2][i]);
	 		txz[j][i] = txz[j][i] +
	 		c55[j][i]*(dtz*duz + dtx*dwx);
	 	  }
	 	}
}

void update_stress_ani(int ifx, int ilx, int jfz, int jlz,
	float **u, float **w, float **txx, float **tzz, float **txz,
	float **c11, float **c55, float **c33, float **c13, 
	float **c15, float **c35, float dtx, float dtz)
{
	int i,j;
	float dux,duz,dwz,dwx;

 	for (j=jfz; j<=jlz; ++j) {
		for (i=ifx; i<=ilx; ++i) {

			dwx = F1*(w[j][i+1]-w[j][i])
				+F2*(w[j][i+2]-w[j][i-1]);

			duz = F1*(u[j][i]-u[j-1][i])
	 					+F2*(u[j+1][i]-u[j-2][i]);

	 				dwz = F1*(w[j+1][i]-w[j][i])
	 					+F2*(w[j+2][i]-w[j-1][i]);

					dux = F1*(u[j][i]-u[j][i-1])
			 		+F2*(u[j][i+1]-u[j][i-2]);

			txx[j][i] = txx[j][i] 
					+ c11[j][i]*dtx*dux 
					+ c13[j][i]*dtz*dwz 
					+ c15[j][i]*(dtz*duz + dtx*dwx);

					tzz[j][i] = tzz[j][i] 
					+ c33[j][i]*dtz*dwz 
					+ c13[j][i]*dtx*dux 
					+ c35[j][i]*(dtz*duz + dtx*dwx); 

			txz[j][i] = txz[j][i] 
					+ c15[j][i]*dtx*dux 
					+ c35[j][i]*dtz*dwz 
					+ c55[j][i]*(dtz*duz + dtx*dwx);
	 	  	}
		i=ilx+1;

		dwx = F1*(w[j][i+1]-w[j][i])
		 		+ F2*(w[j][i+2]-w[j][i-1]);

		duz = F1*(u[j][i]-u[j-1][i])
	 				+ F2*(u[j+1][i]-u[j-2][i]);

	 			dwz = F1*(w[j+1][i]-w[j][i])
			+ F2*(w[j+2][i]-w[j-1][i]);

	 			dux = F1*(u[j][i]-u[j][i-1])
			+ F2*(u[j][i+1]-u[j][i-2]);

		txx[j][i] = txx[j][i] 
			+ c11[j][i]*dtx*dux 
			+ c13[j][i]*dtz*dwz 
			+ c15[j][i]*(dtz*duz + dtx*dwx);

	 			tzz[j][i] = tzz[j][i] 
			+ c33[j][i]*dtz*dwz 
			+ c13[j][i]*dtx*dux 
			+ c35[j][i]*(dtz*duz + dtx*dwx); 
	}
}


void add_p_source(float **txx, float **tzz, float amp, int i, int j)
{
	txx[j][i] = txx[j][i] + amp;
	tzz[j][i] = tzz[j][i] + amp;
}

void add_v_source(float **u, float **w, float amp, int i, int j)
{
	w[j][i] = w[j][i] + amp*0.000001;
}


void add_pw_source_V(float **u, float **w, float **txx, float **tzz, 
	float **txz, float **c11, float **c55, float *a, float sang,
	int il, int ir, int jt, int jb, int ns, int k, float dx,
	float dz, float dt, float *vl, float *vb, float *vr,
	float *ttl, float *ttb, float *ttr)
{
	int i,j;
	float sa, ca, ak, p;
	float tw=0, tu=0, tiw, tiu, tt;
	int ksw, ksu;
	double pi=D_PI;

	/* sang = direction of wave propagation relative to vertical */
	tt=k*dt;

	/* introduce plane wave on left boundary */
	p=sin(sang*pi/180.)/vl[jb];
	for (j=jb+2; j>=jt; --j) {
		sa=sin(asin(p*vl[j]));
		ca=cos(asin(p*vl[j]));

		for (i=il-2; i<il; ++i) {
			if(sang>=0&&sang<90) { 
				tw=tt-ttl[j]-(dx*(i-il+0.75)*sa 
					+ dz*(-0.25)*ca)/vl[j];
				tu=tt-ttl[j]-(dx*(i-il+1.25)*sa 
					+ dz*(-0.75)*ca)/vl[j];
	   		}
	   		if(sang>-90&&sang<0) { 
					tw=tt-ttl[j]-(dx*(i-ir-1.75)*sa 
					+ dz*(-0.25)*ca)/vl[j];
					tu=tt-ttl[j]-(dx*(i-ir-1.25)*sa 
					+ dz*(-0.75)*ca)/vl[j];
	   		}
	   		ksw=floor(tw/dt);
			tiw=fmod(tw,dt)/dt;
	   		ksu=floor(tu/dt);
			tiu=fmod(tu,dt)/dt;
				if (ksw>=0 && ksw <ns-1) {
					ak=(1-tiw)*a[ksw]+tiw*a[ksw+1];
				w[j][i]=-vl[j]*ak*ca;
			} 

			if (ksu>=0 && ksu <ns-1) {
				ak=(1-tiu)*a[ksu]+tiu*a[ksu+1];
				u[j][i]=vl[j]*ak*sa;
			}
		}
	}

	/* introduce plane wave on right boundary */
	p=sin(sang*pi/180.)/vr[jb];
	for (j=jb+2; j>=jt; --j) {
		sa=sin(asin(p*vr[j]));
		ca=cos(asin(p*vr[j]));

		for (i=ir+1; i<ir+3; ++i) {
			if(sang>=0&&sang<90) { 
				tw=tt-ttr[j]-(dx*(i-il+1.75)*sa 
					+ dz*(-0.25)*ca)/vr[j];
				tu=tt-ttr[j]-(dx*(i-il+1.25)*sa 
					+ dz*(-0.75)*ca)/vr[j];
			}
			if(sang>-90&&sang<0) { 
				tw=tt-ttr[j]-(dx*(i-ir-0.75)*sa 
					+ dz*(-0.25)*ca)/vr[j];
				tu=tt-ttr[j]-(dx*(i-ir-1.25)*sa 
					+ dz*(-0.75)*ca)/vr[j];
		   	}
			ksw=floor(tw/dt);
			tiw=fmod(tw,dt)/dt;
			ksu=floor(tu/dt);
			tiu=fmod(tu,dt)/dt;

			if (ksw>=0 && ksw <ns-1) {
				ak=(1-tiw)*a[ksw]+tiw*a[ksw+1];
				w[j][i+1]=-vr[j]*ak*ca;
			}

			if (ksu>=0 && ksu <ns-1) {
				ak=(1-tiu)*a[ksu]+tiu*a[ksu+1];
				u[j][i]=vr[j]*ak*sa;
			}
		}
	}
	 
	/* introduce plane wave on bottom boundary */
	 if(sang>=0&&sang<90) p=sin(sang*pi/180.)/vb[il];
	 if(sang>-90&&sang<0) p=sin(sang*pi/180.)/vb[ir];
	 for (i=il; i<ir+2; ++i){
		sa=sin(asin(p*vb[i]));
		ca=cos(asin(p*vb[i]));

	  	for (j=jb-1; j<jb+3; ++j) {
			if(sang>=0&&sang<90) { 
					tw=tt-ttb[i]-(dx*(+0.75)*sa 
					+ dz*(jb-j-0.25)*ca)/vb[i];
					tu=tt-ttb[i]-(dx*(+1.25)*sa 
					+ dz*(jb-j-0.75)*ca)/vb[i];
	   		}
	   		if(sang>-90&&sang<0) { 
					tw=tt-ttb[i]-(dx*(-1.75)*sa 
					+ dz*(jb-j-0.25)*ca)/vb[i];
					tu=tt-ttb[i]-(dx*(-1.25)*sa 
					+ dz*(jb-j-0.75)*ca)/vb[i];
	   		}
	   		ksw=floor(tw/dt);
			tiw=fmod(tw,dt)/dt;
			ksu=floor(tu/dt);
			tiu=fmod(tu,dt)/dt;

			if (ksw>=0 && ksw <ns-1) {
					ak=(1-tiw)*a[ksw]+tiw*a[ksw+1];
				w[j][i]=-vb[i]*ak*ca;
	   		}
			if (ksu>=0 && ksu <ns-1) {
				ak=(1-tiu)*a[ksu]+tiu*a[ksu+1];
				u[j][i]=vb[i]*ak*sa;
	   		}
		}	
	}

}

void add_pw_source_S(float **u, float **w, float **txx, float **tzz,
	float **txz, float **c11, float **c55, float *a, float sang,
	int il, int ir, int jt, int jb, int ns, int k, float dx,
	float dz, float dt, float *vl, float *vb, float *vr,
	float *ttl, float *ttb, float *ttr)
{
	int i,j;
	float sa, ca, ak, p;
	float tw=0, tu=0, tiw, tiu, tt;
	int ksw, ksu;
	double pi=D_PI;

	/* sang = direction of wave propagation relative to vertical */
	tt=k*dt;

	/* introduce plane wave on left boundary */
	p=sin(sang*pi/180.)/vl[jb];
	for (j=jb+2; j>=jt; --j) {
		sa=sin(asin(p*vl[j]));
		ca=cos(asin(p*vl[j]));

		for (i=il-2; i<il; ++i) {
			if(sang>=0&&sang<90) { 
				tw=tt-ttl[j]-(dx*(i-il+0.75)*sa 
					+ dz*(-0.75)*ca)/vl[j];
				tu=tt-ttl[j]-(dx*(i-il+1.25)*sa 
					+ dz*(-0.25)*ca)/vl[j];
	   		}
			if(sang>-90&&sang<0) { 
				tw=tt-ttl[j]-(dx*(i-ir-1.75)*sa 
					+ dz*(-0.75)*ca)/vl[j];
				tu=tt-ttl[j]-(dx*(i-ir-1.25)*sa 
					+ dz*(-0.25)*ca)/vl[j];
	   		}
	   		ksw=floor(tw/dt);
			tiw=fmod(tw,dt)/dt;
			ksu=floor(tu/dt);
			tiu=fmod(tu,dt)/dt;

			if (ksw>=0 && ksw <ns-1) {
				ak=(1-tiw)*a[ksw]+tiw*a[ksw+1];
				txx[j][i]=(c11[j][i]*sa*sa 
					   +(c11[j][i]-2*c55[j][i])*ca*ca)*ak;
				tzz[j][i]=(c11[j][i]*ca*ca
					   +(c11[j][i]-2*c55[j][i])*sa*sa)*ak;
	   		}
			if (ksu>=0 && ksu <ns-1) {
				ak=(1-tiu)*a[ksu]+tiu*a[ksu+1];
				txz[j][i]=c55[j][i]*(2*ca*sa)*ak;
	   		}
		}	
	}

	/* introduce plane wave on right boundary */
	 p=sin(sang*pi/180.)/vr[jb];

	for (j=jb+2; j>=jt; --j) {
		sa=sin(asin(p*vr[j]));
		ca=cos(asin(p*vr[j]));
		for (i=ir+1; i<ir+3; ++i) {
			if(sang>=0&&sang<90) { 
				tw=tt-ttr[j]-(dx*(i-il+1.75)*sa 
					+ dz*(-0.75)*ca)/vr[j];
				tu=tt-ttr[j]-(dx*(i-il+1.25)*sa 
					+ dz*(-0.25)*ca)/vr[j];
	   		}
			if(sang>-90&&sang<0) { 
				tw=tt-ttr[j]-(dx*(i-ir-0.75)*sa 
					+ dz*(-0.75)*ca)/vr[j];
				tu=tt-ttr[j]-(dx*(i-ir-1.25)*sa 
					+ dz*(-0.25)*ca)/vr[j];
	   		}
			ksw=floor(tw/dt);
			tiw=fmod(tw,dt)/dt;

			ksu=floor(tu/dt);
			tiu=fmod(tu,dt)/dt;

			if (ksw>=0 && ksw <ns-1) {
				ak=(1-tiw)*a[ksw]+tiw*a[ksw+1];
					txx[j][i+1]=(c11[j][i]*sa*sa
							+(c11[j][i]
							-2*c55[j][i])*ca*ca)*ak;
					tzz[j][i+1]=(c11[j][i]*ca*ca
							+(c11[j][i]
							-2*c55[j][i])*sa*sa)*ak;
			} else  {
				txx[j][i+1]=0;
				tzz[j][i+1]=0;
			}

			if (ksu>=0 && ksu <ns-1) {
				ak=(1-tiu)*a[ksu]+tiu*a[ksu+1];
				txz[j][i]=c55[j][i]*(2*ca*sa)*ak;
			} else {
				txz[j][i]=0;
			}
		}
	}
	 
	/* introduce plane wave on bottom boundary */
	p=sin(sang*pi/180.)/vb[il];
	for (i=il; i<ir+2; ++i){
		sa=sin(asin(p*vb[i])); ca=cos(asin(p*vb[i]));
		for (j=jb-1; j<jb+3; ++j) {
			if(sang>=0&&sang<90) { 
				tw=tt-ttb[i]-(dx*(+0.75)*sa 
					+ dz*(jb-j-0.75)*ca)/vb[i];
				tu=tt-ttb[i]-(dx*(+1.25)*sa 
					+ dz*(jb-j-0.25)*ca)/vb[i];
			}
			if(sang>-90&&sang<0) { 
				tw=tt-ttb[i]-(dx*(-1.75)*sa 
					+ dz*(jb-j-0.75)*ca)/vb[i];
				tu=tt-ttb[i]-(dx*(-1.25)*sa 
					+ dz*(jb-j-0.25)*ca)/vb[i];
	   		}
			ksw=floor(tw/dt);
			tiw=fmod(tw,dt)/dt;
			ksu=floor(tu/dt);
			tiu=fmod(tu,dt)/dt;
			if (ksw>=0 && ksw <ns-1) {
				ak=(1-tiw)*a[ksw]+tiw*a[ksw+1];
				txx[j][i]=(c11[j][i]*sa*sa
						+(c11[j][i]
							-2*c55[j][i])*ca*ca)*ak;
				tzz[j][i]=(c11[j][i]*ca*ca
						+(c11[j][i]
							-2*c55[j][i])*sa*sa)*ak;
	   		}

			if (ksu>=0 && ksu <ns-1) {
				ak=(1-tiu)*a[ksu]+tiu*a[ksu+1];
				txz[j][i]=c55[j][i]*(2*ca*sa)*ak;
	   		}
		}	
	}

}

void make_snap(float **u, float **w, float sx, float sz, 
		float dx, float dz, int nxpadded, int nzpadded,
		int nx, int nz, int k, float t, float fx, float fz,
		segy tr, FILE *sneisfp, int *wbc)
{
	
	/* SEGY fields */
	long tracl=0;		/* trace number within a line */
	long tracr;		/* trace number within a reel */
	int i,j;
	
	tr.sx = sx;
	tr.selev = -sz;
	tr.trid = 1;
	tr.fldr = k;
	tr.ns = nz;
	tr.dt = NINT(1000 * dz);
	tr.d2 = dx ;
	tr.f1 = fz ;
	tr.f2 = fx ;
	tr.delrt = t; /* store time of snapshot */

	if(&tracl==NULL) tracl = 0;
	tracr = 0;
	tr.trid = TINLIN; /* inline particle velocity component*/
	for (i=0 ; i < nxpadded-wbc[3]-wbc[1] ; ++i){
		++tracl;
		++tracr;			

		tr.gx = fx+dx*(i-wbc[1]);
		tr.tracl = tracl;
		tr.tracr = tracr;
		tr.offset = tr.gx-tr.sx ;

		for(j=0; j<nzpadded-wbc[2]-wbc[0]; ++j){
			tr.data[j] = u[j+wbc[0]][i+wbc[1]];
		}
		fputtr(sneisfp , &tr);
	}
	tr.trid = TVERT ; /* vertical particle velocity component */
	for (i=0 ; i < nxpadded-wbc[3]-wbc[1] ; ++i){
		++tracl;
		++tracr;

		tr.gx = fx+dx*(i-wbc[1]);
		tr.offset = tr.gx-tr.sx ;
		tr.tracl = tracl;
		tr.tracr = tracr;

		for(j=0; j<nzpadded-wbc[2]-wbc[0]; ++j){
			tr.data[j] = w[j+wbc[0]][i+wbc[1]];
		}
		fputtr(sneisfp , &tr);
	}
}

void make_stress_snap(float **txx, float **tzz, float **txz, 
	float sx, float sz, 
	float dx, float dz, int nxpadded, int nzpadded, int k, float t,
	float fx, float fz,
	segy tr, FILE *sneisfp, int *wbc)
{
	
	/* SEGY fields */
	long tracl=0;		/* trace number within a line */
	long tracr=0;		/* trace number within a reel */
	int i,j;
	
	tr.sx = sx;
	tr.selev = -sz;
	tr.trid = 1;
	tr.fldr = k;
	tr.ns = nzpadded ;
	tr.dt = NINT(1000 * dz);
	tr.d2 = dx ;
	tr.f1 = fz ;
	tr.f2 = fx ;
	tr.delrt = t ; /* store time of snapshot */

	if(&tracl==NULL) tracl = 0;
	tracr = 0;
	tr.trid = TINLIN ; /*txx-component in line component*/
	for (i=0 ; i < nzpadded-wbc[3] ; ++i){
		++tracl;
		++tracr;			

		tr.gx = fx+dx*(i-wbc[1]);
		tr.tracl = tracl;
		tr.tracr = tracr;
		tr.offset = tr.gx-tr.sx ;

		for(j=0; j<nxpadded-wbc[2]; ++j){
			tr.data[j] = txx[j+wbc[0]][i+wbc[1]];
		}
		fputtr(sneisfp , &tr);
	}
	tr.trid = TVERT ; /*tzz-component*/
	for (i=0 ; i < nzpadded-wbc[3] ; ++i){
		++tracl;
		++tracr;			

		tr.gx = fx+dx*(i-wbc[1]);
		tr.offset = tr.gx-tr.sx ;
		tr.tracl = tracl; tr.tracr = tracr;

		for(j=0; j<nxpadded-wbc[2]; ++j){
			tr.data[j] = tzz[j+wbc[0]][i+wbc[1]];
		}
		fputtr(sneisfp , &tr);
	}
	tr.duse = TXLIN ; /* txz-component using crossline label */
	for (i=0 ; i < nzpadded-wbc[3] ; ++i){
		++tracl;
		++tracr;			

		tr.gx = fx+dx*(i-wbc[1]);
		tr.tracl = tracl;
		tr.tracr = tracr;
		tr.offset = tr.gx-tr.sx ;

		for(j=0; j<nxpadded-wbc[2]; ++j){
			tr.data[j] = txz[j+wbc[0]][i+wbc[1]];
		}
		fputtr(sneisfp , &tr);
	}
}


void make_seis(float **ut, float **wt, float sx, float sz, 
	float dn, float dt, int nn, int nt, float dd,
	 float fx, float fz,
	segy tr, FILE *fp, int b1, int b2, int ivh, int verbose, float favg)
{
	
	/* SEGY fields */
	long tracl=0;		/* trace number within a line */
	long tracr=0;		/* trace number within a reel */
	int i,j,k;
	

	tr.sdepth = 0;
	tr.sx = sx;
	tr.selev = -sz ;
	tr.ns = nt ;
	tr.d2 = dn ;
	tr.dt = NINT(dt * 1000000.0) ;
	tr.ntr = 2*(nn-b2-b1);
	tr.delrt = -NINT(1000.0/(2*favg)) ;
	
	if (verbose) warn("%d %d %d %d %f",tr.ns,tr.tracl,tr.tracr,tr.ntr);

	if(ivh==1) {  /* surface seismic */
		tr.gelev = -dd ;
		tr.f2 = fx ;
	}
	if(ivh==2) {  /* VSP seismic */
	  tr.gx = dd ;
	  tr.f2 = fz ;
	}
	
	tracl = tracr = 0; k=0;
	tr.duse = 2 ; /*u-component*/
	for (i=b1 ; i < nn-b2 ; ++i){
		++tracl; ++tracr;			
		tr.tracl = tracl; tr.tracr = tracr; tr.tracf=i;
		if(ivh==1) {  /* surface seismic */
		  tr.gx = fx+dn*k ;
		  tr.offset = tr.gx-tr.sx ;
		}
		if(ivh==2) {  /* VSP seismic */
		  tr.gelev = fz-dn*k ;
		  tr.offset = tr.sx-tr.gelev ;
		}
		 for(j=0; j<nt; ++j){tr.data[j] = ut[j][i];}
		fputtr(fp , &tr); k++;
	}
	k=0;
	tr.duse = 1 ; /*w-component*/
	for (i=b1 ; i < nn-b2 ; ++i){
		++tracl; ++tracr;			
		tr.tracl = tracl; tr.tracr = tracr; tr.tracf=i;

		if(ivh==1) {  /* surface seismic */
			tr.gx = fx+dn*k ;
			tr.offset = tr.gx-tr.sx ;
		}
		if(ivh==2) {  /* VSP seismic */
			tr.gelev = fz-dn*k ;
			tr.offset = tr.sx-tr.gelev ;
		}
		for(j=0; j<nt; ++j){
			tr.data[j] = wt[j][i];
		}

		fputtr(fp , &tr);
		k++;
	}
}


/* absorbing bc for top*/	
void abs_bc_top(float **u, float **w, float **txx, float **tzz,
			float **txz, int nxpadded, int nzpadded, float *r,
			int *bc, int *wbc, int ifx, int ilx)
{
	int i,j; float fac;
		
	for (j=0; j<wbc[0]; ++j){
		fac=r[(wbc[0]-j-1)];
		for (i=ifx; i<ilx; ++i){
				u[j][i]*=fac;
			w[j][i]*=fac;
				txx[j][i]*=fac;
			tzz[j][i]*=fac;
			txz[j][i]*=fac;
		}
	}
}

/* absorbing bc for left side*/	
void abs_bc_left(float **u, float **w, float **txx, float **tzz,
			float **txz, int nxpadded, int nzpadded, float *r,
			int *bc, int *wbc, int jfz, int jlz)
{
	int i,j;
	float fac;
		
	for (j=jfz; j<jlz; ++j){
		for (i=0; i<wbc[1]; ++i){
			fac=r[(wbc[1]-i-1)];
				u[j][i]*=fac;
			w[j][i]*=fac;
				txx[j][i]*=fac;
			tzz[j][i]*=fac;
			txz[j][i]*=fac;
		}
	}
}

/* absorbing bc for bottom*/	
void abs_bc_bot(float **u, float **w, float **txx, float **tzz,
			float **txz, int nxpadded, int nzpadded, float *r,
			int *bc, int *wbc, int ifx, int ilx)
{
	int i,j;
	float fac;
		
	for (j=nzpadded-wbc[2]; j<nzpadded; ++j){
		fac=r[(j-nzpadded+wbc[2])];
	  	for (i=ifx; i<ilx; ++i){
				u[j][i]*=fac;
			w[j][i]*=fac;
				txx[j][i]*=fac;
			tzz[j][i]*=fac;
			txz[j][i]*=fac;
		}
	}		
}

/* absorbing bc for right side*/	
void abs_bc_right(float **u, float **w, float **txx, float **tzz,
			float **txz, int nxpadded, int nzpadded, float *r, 
			int *bc, int *wbc, int jfz, int jlz)
{
	int i,j;
	float fac;
		
	for (j=jfz; j<jlz; ++j){
		for (i=nxpadded-wbc[3]; i<nxpadded; ++i){
				fac=r[(i-nxpadded+wbc[3])];
				u[j][i]*=fac;
			w[j][i+1]*=fac;
				txx[j][i+1]*=fac;
			tzz[j][i+1]*=fac;
			txz[j][i]*=fac;
		}
	}
}
	
/* Free surface boundary condition where stresses are set to zero
   for the order 4 FD operater on a staggered grid */
void fs4s_bc_top(float **txx, float **tzz, float **txz, int nxpadded, int nzpadded)
{
	int i;
		
	for (i=2; i<nxpadded-2; ++i){
	 		txz[1][i]=0.; txz[0][i]=0.; txz[2][i]=0.;
	}
	for (i=2; i<nxpadded-1; ++i){
	 		txx[1][i]=0.; txx[0][i]=0.; 
	 		tzz[1][i]=-tzz[2][i]; tzz[0][i]=-tzz[3][i];
	}
}

/* Free surface boundary condition where velocities satisfy stress free
  surface for the order 4 FD operater on a staggered grid

** requires anisotropy symmetry parallel to free surface in 
** current implementation */

void fs4v_bc_top(float **u, float **w, float **c11,
			float **c55, int nxpadded, int nzpadded)
{
	int i;
	
	/*  	010514-split loop into two four parts as it was 
		in original FORTRAN CODE, previous versions 
		were calculating all vaulues at once	 */

	for (i=2; i<nxpadded-2; ++i){
		u[0][i]=u[2][i]
			+ 2*( F1*(w[2][i+1]-w[2][i]) 
			+ F2*(w[2][i+2]-w[2][i-1]) );
	}

	for (i=2; i<nxpadded-1; ++i){
		w[0][i]=w[2][i]
			+ 2*(1-2*(c55[2][i]/c11[2][i]))
			*( F1*(u[0][i]-u[0][i-1]) 
			+ F2*(u[0][i+1]-u[0][i-2]) );
	}
	for (i=2; i<nxpadded-2; ++i){
		u[1][i]=u[0][i]
			+ 2*( F1*(w[2][i+1]-w[2][i])
				+ F2*(w[2][i+2]-w[2][i-1]) );
	}
	for (i=2; i<nxpadded-1; ++i){
		w[1][i]=w[0][i]
			+ 2*(1-2*(c55[2][i]/c11[2][i]))
			*( F1*(u[1][i]-u[1][i-1]) 
				+ F2*(u[1][i+1]-u[1][i-2]) );
	}
}

void sym4s_bc_top(float **txx, float **tzz, float **txz, int nxpadded, int nzpadded)
/* Stress symmetry boundary condition for the TOP boundary
   for the order 4 FD operater on a staggered grid */
{
	int i;
		
	for (i=2; i<nxpadded-2; ++i){
	 		txx[1][i]=txx[2][i];  txx[0][i]=txx[3][i]; 
	 		tzz[1][i]=tzz[2][i];  tzz[0][i]=tzz[3][i];
	 		txz[1][i]=-txz[3][i]; txz[0][i]=-txz[4][i];
	}
}

void sym4v_bc_top(float **u, float **w, int nxpadded, int nzpadded)
/* Velocity symmetry boundary condition for the TOP boundary
   for the order 4 FD operater on a staggered grid */
{
	int i;
		
	for (i=2; i<nxpadded-2; ++i){
	 		u[1][i]=u[2][i];  u[0][i]=u[3][i]; 
	 		w[1][i]=-w[3][i]; w[0][i]=-w[4][i];
	}
}

void sym4s_bc_right(float **txx, float **tzz, float **txz, int nxpadded, int nzpadded)
/* Stress symmetry boundary condition for the RHS boundary
   for the order 4 FD operater on a staggered grid */
{
	int j;
		
	for (j=0; j<nzpadded; ++j){
	 		txx[j][nxpadded]=txx[j][nxpadded-4]; txx[j][nxpadded-1]=txx[j][nxpadded-3]; 
	 		tzz[j][nxpadded]=tzz[j][nxpadded-4]; tzz[j][nxpadded-1]=tzz[j][nxpadded-3];
	 		txz[j][nxpadded-1]=-txz[j][nxpadded-4]; txz[j][nxpadded-2]=-txz[j][nxpadded-3];
	}
}

void sym4v_bc_right(float **u, float **w, int nxpadded, int nzpadded)
/* Velocity symmetry boundary condition for the RHS boundary
   for the order 4 FD operater on a staggered grid */
{
	int j;
		
	for (j=0; j<nzpadded; ++j){
	 		u[j][nxpadded-1]=-u[j][nxpadded-4]; u[j][nxpadded-2]=-u[j][nxpadded-3]; 
	 		w[j][nxpadded]=w[j][nxpadded-4]; w[j][nxpadded-1]=w[j][nxpadded-3];
	}
}

void sym4s_bc_left(float **txx, float **tzz, float **txz, int nxpadded, int nzpadded)
/* Stress symmetry boundary condition for the LHS boundary
   for the order 4 FD operater on a staggered grid */
{
	int j;
		
	for (j=0; j<nzpadded; ++j){
	 		txx[j][1]=txx[j][3]; txx[j][0]=txx[j][4]; 
	 		tzz[j][1]=tzz[j][3];  tzz[j][0]=tzz[j][4];
	 		txz[j][1]=-txz[j][2]; txz[j][0]=-txz[j][3];
	}
}

void sym4v_bc_left(float **u, float **w, int nxpadded, int nzpadded)
/* Velocity symmetry boundary condition for the LHS boundary
   for the order 4 FD operater on a staggered grid */
{
	int j;
		
	for (j=0; j<nzpadded; ++j){
	 		u[j][1]=-u[j][2]; u[j][0]=-u[j][3]; 
	 		w[j][1]=w[j][3]; w[j][0]=w[j][4];
	}
}

void sym4s_bc_bot(float **txx, float **tzz, float **txz, int nxpadded, int nzpadded)
/* Stress symmetry boundary condition for the BOTTOM boundary
   for the order 4 FD operater on a staggered grid */
{
	int i;
		
	for (i=2; i<nxpadded-2; ++i){
/*	 		txx[nzpadded-2][i]=txx[nzpadded-4][i];  txx[nzpadded-1][i]=txx[nzpadded-5][i];  */
/*	 		tzz[nzpadded-2][i]=-tzz[nzpadded-4][i]; tzz[nzpadded-1][i]=-tzz[nzpadded-5][i]; */
/*	 		txz[nzpadded-2][i]=-txz[nzpadded-3][i]; txz[nzpadded-1][i]=-txz[nzpadded-4][i];} */
	 		txx[nzpadded-2][i]=txx[nzpadded-4][i];  txx[nzpadded-1][i]=txx[nzpadded-5][i]; 
	 		tzz[nzpadded-2][i]=tzz[nzpadded-4][i]; tzz[nzpadded-1][i]=tzz[nzpadded-5][i];
	 		txz[nzpadded-2][i]=-txz[nzpadded-3][i]; txz[nzpadded-1][i]=-txz[nzpadded-4][i];
	}
}

void sym4v_bc_bot(float **u, float **w, int nxpadded, int nzpadded)
/* Velocity symmetry boundary condition for the BOTTOM boundary
   for the order 4 FD operater on a staggered grid */
{
	int i;
		
	for (i=2; i<nxpadded-2; ++i){
/*	 		u[nzpadded-2][i]=u[nzpadded-4][i]; u[nzpadded-1][i]=u[nzpadded-5][i];  */
/*	 		w[nzpadded-2][i]=-w[nzpadded-3][i];w[nzpadded-1][i]=-w[nzpadded-4][i];} */
	 		u[nzpadded-2][i]=u[nzpadded-4][i]; u[nzpadded-1][i]=u[nzpadded-5][i]; 
	 		w[nzpadded-2][i]=-w[nzpadded-3][i]; w[nzpadded-1][i]=-w[nzpadded-4][i];
	}
}

void calc_area(float vmax, float dtx, float dtz, 
		int *limits, int i, int j, int k, int nxpadded, int nzpadded)
{
	 limits[0] = i - NINT(vmax*k*dtx) - 10;
	 limits[1] = i + NINT(vmax*k*dtx) + 10;
	 limits[2] = j - NINT(vmax*k*dtz) - 10;
	 limits[3] = j + NINT(vmax*k*dtz) + 10;

	 if (limits[0] < 2) limits[0] = 2;

	 if (limits[1] > nxpadded-3) limits[1] = nxpadded-3;

	 if (limits[2] < 2) limits[2] = 2;

	 if (limits[3] > nzpadded-3) limits[3] = nzpadded-3;	 
}



void write_chd(int nxpadded, int nzpadded, int nt, float dx, float dz, float dt,
	float fx, float xmax, float fz, float zmax,
	float sx, float sz, float favg, float ts, char *wtype, char *stype,
	int *bc, int qsw, int aniso, float xz,
	FILE *fp, int comp, char *mfile)
{
	int k=1;
	char s[80];
	k=fwrite_chd(fp,"SUEA2DF",k); 
	k=fwrite_chd(fp,"Department of Earth Sciences",k);
	k=fwrite_chd(fp,"Uppsala University",k);
	k=fwrite_chd(fp,"Date:",k);
	k=fwrite_chd(fp," ",k);

	if(comp==1) {
		sprintf(s,"Horizontal line recording at z=%f",xz);
		k=fwrite_chd(fp,s,k);
	}

	if(comp==2) {
		sprintf(s,"Vertical line recording at x=%f",xz);
	  	k=fwrite_chd(fp,s,k);
	}
	sprintf(s,"nxpadded=%d nzpadded=%d nt=%d dx=%f dz=%f dt=%f",nxpadded,nzpadded,nt,dx,dz,dt);
	  k=fwrite_chd(fp,s,k);
	sprintf(s,"fx=%f xmax=%f fz=%f zmax=%f",fx,xmax,fz,zmax);
	  k=fwrite_chd(fp,s,k);
	sprintf(s,"sx=%f sz=%f favg=%f ts=%f",sx,sz,favg,ts);
	  k=fwrite_chd(fp,s,k);
	sprintf(s,"wtype=%s stype=%s",wtype,stype);
	  k=fwrite_chd(fp,s,k);
	sprintf(s,"bc=%d,%d,%d,%d",bc[0],bc[1],bc[2],bc[3]);
	  k=fwrite_chd(fp,s,k);
	k=fwrite_chd(fp," ",k);
	k=fwrite_chd(fp,"Model file:",k);

	sprintf(s," %s",mfile);

	k=fwrite_chd(fp,s,k);

	k=fwrite_chd(fp," ",k);

	if(qsw==1) k=fwrite_chd(fp,"Attenuation included",k);

	if(aniso==1) k=fwrite_chd(fp,"Anisotropy included",k);

	while(k<=40) k=fwrite_chd(fp," ",k);
}	
	
int fwrite_chd(FILE *fp, char *s, int k)
{
	int i,n;	

	n=fprintf(fp,"C %s",s);

	for(i=1; i<80-n-1; ++i) fputs(" ",fp); 

	fprintf(fp,"%s\n"," ");

	return(k+1);
}


void write_grid(float **u, float **w, float **txx, float **tzz,
			float **txz, int is, int js)
{
	int i,j;
		
	for (i=is-2; i<is+3; ++i){
		fprintf(stderr,"%d ",i);
	}

	fprintf(stderr,"\n");

	for (j=js-2; j<js+3; ++j){
	   	for (i=is-2; i<is+3; ++i){
			fprintf(stderr,"%e ",u[j][i]);
		}
		fprintf(stderr,"%d \n",j);
	}

	fprintf(stderr,"w \n");

	for (j=js-2; j<js+3; ++j){
		for (i=is-2; i<is+3; ++i){
			fprintf(stderr,"%e ",w[j][i]);
		}
		fprintf(stderr,"%d \n",j);
	}

	fprintf(stderr,"txx \n");

	for (j=js-2; j<js+3; ++j){
		for (i=is-2; i<is+3; ++i){
			fprintf(stderr,"%e ",txx[j][i]);
		}
		fprintf(stderr,"%d \n",j);
	}

	fprintf(stderr,"tzz \n");

	for (j=js-2; j<js+3; ++j){
		for (i=is-2; i<is+3; ++i){
			fprintf(stderr,"%e ",tzz[j][i]);
		}
		fprintf(stderr,"%d \n",j);
	}

	fprintf(stderr,"txz \n");

	for (j=js-2; j<js+3; ++j){
		for (i=is-2; i<is+3; ++i){
			fprintf(stderr,"%e ",txz[j][i]);
		}
		fprintf(stderr,"%d \n",j);
	}

}

void pad_float_2D(int n1, int n2, int *padval, float **in, float **out) 
{
/*************************************************************************
pad_float_2D - padd a 2D array of floats
**************************************************************************

Input:
n1		size of the 1 (fast) dimension
n2		size of the 2 (slow) dimension
padval[4]	paddings  	padval[0] beginning pad in dimension 1 
				padval[1] beginning pad in dimension 2
				padval[2] ending pad in dimension 1
				padval[3] ending pad in dimension 2
in[][]		n1 by n2 array of input floats
Output:
out[][]		n1padded by n2padded array of input floats
		where the padded sizes are given by
		n1padded = n1 + padval[1] + padval[3]
		n2padded = n2 + padval[0] + padval[2]
**************************************************************************
Notes:
**************************************************************************
Author: CWP: John Stockwell, 2005
**************************************************************************/

	int ix1;	/* counter in dimension 1 */
	int ix2;	/* counter in dimension 2 */
	int n1padded;	/* size of dimension 1 for padded array */
	int n2padded;	/* size of dimension 2 for padded array */

	/* calculate padded six2es */
	n1padded = n1 + padval[1] + padval[3];
	n2padded = n2 + padval[0] + padval[2];

	/* zero out the out[][] array */
	memset((void *) out[0], 0, n1padded*n2padded*FSIZE);

	/* copy in[][] into out[][]  */
	for (ix2=padval[0]; ix2 < n2; ++ix2) 
	  	for (ix1=padval[1]; ix1<n1; ++ix1) 
			out[ix2][ix1]=in[ix2-padval[0]][ix1-padval[1]];

	/* pad upper left corner */
	for (ix2=0; ix2 < padval[0]; ++ix2) 
	  	for (ix1=0; ix1< padval[1]; ++ix1) 
			out[ix2][ix1]=in[0][0];

	/* pad upper side */
	for (ix2=padval[0]; ix2 < n2; ++ix2) 
	  	for (ix1=0; ix1< padval[1]; ++ix1) 
			out[ix2][ix1]=in[ix2-padval[0]][0];

	/* pad upper right corner */
	for (ix2=0; ix2 < padval[0]+padval[2]; ++ix2) 
	  	for (ix1=0; ix1< padval[1]; ++ix1) 
			out[ix2+n2][ix1]=in[n2-1][0];

	/* pad left side */
	for (ix2=0; ix2 < padval[0]; ++ix2) 
	  	for (ix1=padval[1]; ix1< n1 ; ++ix1) 
			out[ix2][ix1]=in[ix2][ix1-padval[1]];

	/* lower left corner */
	for (ix2=0; ix2 < padval[0]; ++ix2) 
	  	for (ix1=n1; ix1< n1+padval[1]+padval[3] ; ++ix1) 
			out[ix2][ix1]=in[n2-1][n1-1];

	/* pad lower side */
	for (ix2=padval[0]; ix2 < n2; ++ix2) 
	  	for (ix1=n1; ix1< n1+padval[1]+padval[3]; ++ix1) 
			out[ix2][ix1]=in[ix2-padval[0]][n1-1];

	/* pad right side */
	for (ix2=n2; ix2 < n2+padval[0]+padval[2]; ++ix2) 
	  	for (ix1=padval[1]; ix1< n1 ; ++ix1) 
			out[ix2][ix1]=in[n2-1][ix1-padval[1]];

	/* pad lower right corner */
	for (ix2=n2; ix2 < n2+padval[0]+padval[2]; ++ix2) 
	  	for (ix1=n1; ix1< n1+padval[1]+padval[3] ; ++ix1) 
			out[ix2][ix1]=in[n2-1][n1-1];

}
@


1.29
log
@added Reg Beardsley's checkpar()
@
text
@d4 1
a4 1
/* SUEA2DF: $Revision: 1.28 $ ; $Date: 2011/11/12 00:40:42 $		 */
d1751 1
a1751 1
	tr.dt = 1000 * dz;
d1808 1
a1808 1
	tr.dt = 1000 * dz;
d1880 1
a1880 1
	tr.dt = dt * 1000000.0 ;
@


1.28
log
@copyright
@
text
@d2 1
a2 1
/* All rights reserved.                       */
d4 1
a4 4
/* Copyright (c) Colorado School of Mines, 2010.*/
/* All rights reserved.                       */

/* SUEA2DF: $Revision: 1.27 $ ; $Date: 2011/09/09 22:34:19 $		 */
@


1.27
log
@*** empty log message ***
@
text
@d1 3
d7 1
a7 1
/* SUEA2DF: $Revision: 1.27 $ ; $Date: 2010/04/01 18:44:43 $		 */
@


1.26
log
@selfdoc modification
@
text
@d1 4
a4 1
/* SUEA2DF: $Revision: 1.25 $ ; $Date: 2009/12/01 18:35:19 $		 */
d186 3
d2046 1
a2046 1
			+ 0.5*( F1*(w[2][i+1]-w[2][i]) 
d2052 1
a2052 1
			+ 0.5*(1-2*(c55[2][i]/c11[2][i]))
d2058 1
a2058 1
			+ 0.5*( F1*(w[2][i+1]-w[2][i])
d2063 1
a2063 1
			+ 0.5*(1-2*(c55[2][i]/c11[2][i]))
@


1.25
log
@added a caveat to the selfdoc
@
text
@d1 1
a1 1
/* SUEA2DF: $Revision: 1.24 $ ; $Date: 2009/02/27 17:51:56 $		 */
d103 3
a105 2
" transpose these files, as the input format for suea2df assumes that the",
" fast dimesion is the horizontal or the x-dimension. You may do this via",
@


1.24
log
@added time shift to get delrt right for the wavelet
@
text
@d1 1
a1 1
/* SUEA2DF: $Revision: 1.23 $ ; $Date: 2008/05/02 18:10:21 $		 */
d11 1
a11 2
"		forward modeling					",
"									",
d34 3
a36 3
" qsw=0		 switch to include attenuation =1 - include	",
" ... the next parameter becomes active only when qsw=1....	     ",
" qfile=Q_file	  Q parameter filename	    		",
d124 3
a126 1
"									",
d731 2
a732 1
	   if (verbose) warn("!!!rhofile= not set, assuming density=1000!!!");
d737 1
@


1.23
log
@some cosmetics
@
text
@d1 1
a1 1
/* SUEA2DF: $Revision: 1.22 $ ; $Date: 2008/04/29 18:30:27 $		 */
d233 2
a234 1
			FILE *fp, int b1, int b2, int ivh, int verbose);
d1240 1
a1240 1
			trh,hseisfp,wbc[1],wbc[3],1,verbose);
d1255 1
a1255 1
			trv,vseisfp,wbc[0],wbc[2],2,verbose);
d1745 1
d1802 1
a1802 1
	tr.delrt = t ;	/*store time of snapshot*/
d1856 1
a1856 1
	segy tr, FILE *fp, int b1, int b2, int ivh, int verbose)
a1863 1
	if (verbose) warn("%d %d %d %d",tr.ns,tr.tracl,tr.tracr,tr.ntr);
d1872 3
@


1.22
log
@Chris Juhlin's rho fix and additional q-file input
@
text
@d1 1
a1 1
/* SUEA2DF: $Revision: 1.21 $ ; $Date: 2008/04/28 21:25:54 $		 */
d22 1
a22 1
"									",
a67 1
" ql=		 	model q at xl,zl				",
d111 1
a111 1
" If qsw=1 unif2 can be used to generate the Q values on a grid		",
a113 4
" The epl and dsl are epsilon and delstar in Thomson (1986, Geophys.)	",
" anl is the angle the anisotropy makes with the horizontal.		",
" 									",
"									",
a723 1
	if (verbose) warn(" V rhomax=%f  rhomin=%f",rhomax,rhomin);
d727 3
a729 2
	 /* if densities not specified  make densities = 10^{-3} */
	 if (*rhofile=='\0' ) {
d734 2
a735 2
	if (verbose) warn(" C rhomax=%f  rhomin=%f",rhomax,rhomin);
	 }
@


1.21
log
@28 April version
@
text
@d1 1
a1 1
/* SUEA2DF: $Revision: 1.20 $ ; $Date: 2008/04/08 17:03:33 $		 */
d34 5
d110 1
a110 2
" If qsw=1 a ql array specifies the values of the quality factor Q, to	",
" specify the attenuation of the medium.				",
d112 2
a113 1
" If aniso=1 then the program will expect the additional stiffnesss files.",
d181 1
a181 1
 *      from binary files made by  unif2aniso
d183 4
a186 1
 * Alogrithm based on Juhlin (1995, Geophys. Prosp.)
d330 1
d348 3
d436 3
d552 12
d664 2
a665 1
		ngrids+=1;
d729 1
d733 2
a734 2
	 /* if densities not specified or constant, make densities = 10^{-3} */
	 if (*rhofile=='\0' || rhomin==rhomax ) {
d739 1
d763 1
d786 2
d881 27
a907 3
	warn(" c11max=%f  c11min=%f",c11max,c11min);
	warn(" rhomax=%f  rhomin=%f",rhomax,rhomin);
	warn(" wbc[0]=%d  wbc[1]=%d wbc[2]=%d wbc[3]=%d",
@


1.20
log
@if snapshots not requested don't close the sneisfp file
@
text
@d1 1
a1 1
/* SUEA2DF: $Revision: 1.19 $ ; $Date: 2006/11/07 22:58:42 $		 */
d77 1
a77 1
" Output parameters:							",
@


1.19
log
@changed    memset( .., (int) '\0',...) to memset( .., 0,..) as per suggestion of Marion Zhu and Reg Beardsley
@
text
@d1 1
a1 1
/* SUEA2DF: $Revision: 1.18 $ ; $Date: 2006/06/29 16:30:47 $		 */
d1207 1
a1207 1
	fclose(sneisfp);
@


1.18
log
@28 Jul version, fixed output snaps and fixed pad_float_2D
@
text
@d1 1
a1 1
/* SUEA2DF: $Revision: 1.17 $ ; $Date: 2006/06/27 21:40:03 $		 */
d516 1
a516 1
		if (!getparstring("c35file",&c13file))	c35file="c35_file";
d646 1
d648 1
d650 1
d652 1
d789 3
a791 3
		/* pad the c13 */
		pad_float_2D(nx,nz,wbc,c13temp,c13); 
		free2float(c13temp);
d2281 1
a2281 1
	memset((void *) out[0], (int) '0', n1padded*n2padded*FSIZE);
@


1.17
log
@fixed skew in movie
@
text
@d1 1
a1 1
/* SUEA2DF: $Revision: 1.16 $ ; $Date: 2006/03/10 20:43:09 $		 */
d1675 1
a1675 1
	long tracl;		/* trace number within a line */
d1731 2
a1732 2
	long tracl;		/* trace number within a line */
	long tracr;		/* trace number within a reel */
d2276 3
d2285 3
a2287 3
	for (ix2=0; ix2 < padval[1]; ++ix2) 
	  	for (ix1=0; ix1< padval[0]; ++ix1) 
			out[ix2][ix1]=in[padval[0]][padval[1]];
d2290 3
a2292 3
	for (ix2=padval[1]; ix2 < n2; ++ix2) 
	  	for (ix1=0; ix1< padval[0]; ++ix1) 
			out[ix2][ix1]=in[ix2-padval[1]][padval[0]];
d2295 3
a2297 3
	for (ix2=n2; ix2 < n2+padval[1]+padval[3]; ++ix2) 
	  	for (ix1=0; ix1< padval[0]; ++ix1) 
			out[ix2][ix1]=in[n2-1][padval[0]];
d2300 3
a2302 3
	for (ix2=0; ix2 < padval[1]; ++ix2) 
	  	for (ix1=padval[0]; ix1< n1 ; ++ix1) 
			out[ix2][ix1]=in[ix2][padval[1]];
d2305 3
a2307 3
	for (ix2=0; ix2 < padval[1]; ++ix2) 
	  	for (ix1=n1; ix1< n1+padval[0]+padval[2] ; ++ix1) 
			out[ix2][ix1]=in[padval[1]][n1-1];
d2310 3
a2312 3
	for (ix2=padval[1]; ix2 < n2; ++ix2) 
	  	for (ix1=n1; ix1< n1+padval[0]+padval[2]; ++ix1) 
			out[ix2][ix1]=in[ix2-padval[1]][n1-1];
d2315 3
a2317 3
	for (ix2=n2; ix2 < n2+padval[1]+padval[3]; ++ix2) 
	  	for (ix1=padval[0]; ix1< n1 ; ++ix1) 
			out[ix2][ix1]=in[n2-1][ix1];
d2320 2
a2321 2
	for (ix2=n2; ix2 < n2+padval[1]+padval[3]; ++ix2) 
	  	for (ix1=n1; ix1< n1+padval[0]+padval[2] ; ++ix1) 
@


1.16
log
@changed EXIT_SUCCESS to return(CWP_E
@
text
@d1 1
a1 1
/* SUEA2DF: $Revision: 1.15 $ ; $Date: 2005/12/07 17:11:15 $		 */
d1692 1
a1692 1
	for (i=wbc[1] ; i < nxpadded-wbc[3] ; ++i){
d1701 2
a1702 2
		for(j=wbc[0]; j<nzpadded-wbc[2]; ++j){
			tr.data[j] = u[j][i];
d1707 1
a1707 1
	for (i=wbc[1] ; i < nxpadded-wbc[3] ; ++i){
d1716 2
a1717 2
		for(j=wbc[0]; j<nzpadded-wbc[2]; ++j){
			tr.data[j] = w[j][i];
d1749 1
a1749 1
	for (i=wbc[1] ; i < nxpadded-wbc[3] ; ++i){
d1758 2
a1759 2
		for(j=wbc[0]; j<nzpadded-wbc[2]; ++j){
			tr.data[j] = txx[j][i];
d1764 1
a1764 1
	for (i=wbc[1] ; i < nxpadded-wbc[3] ; ++i){
d1772 2
a1773 2
		for(j=wbc[0]; j<nzpadded-wbc[2]; ++j){
			tr.data[j] = tzz[j][i];
d1778 1
a1778 1
	for (i=wbc[1] ; i < nxpadded-wbc[3] ; ++i){
d1787 2
a1788 2
		for(j=wbc[0]; j<nzpadded-wbc[2]; ++j){
			tr.data[j] = txz[j][i];
@


1.15
log
@7 Dec 2005 version
@
text
@d1 1
a1 1
/* SUEA2DF: $Revision: 1.14 $ ; $Date: 2005/10/24 19:46:50 $		 */
d1205 1
a1205 1
	return EXIT_SUCCESS;
@


1.14
log
@major change. Removed the internal model building. Now takes input
from stiffness parameter files
@
text
@d1 1
a1 1
/* SUEA2DF: $Revision: 1.1 $ ; $Date: 2005/10/14 20:23:43 $		 */
d39 1
a39 1
" dx=10.0	 		spatial sampling intrval (m) x-coor	",
d323 2
a324 2
	float rhomin;		/* minimum density		*/
	float rhomax;		/* maximum density		*/
d590 1
a590 1
	if (!getparstring("hsfile",&hsfile)) hsfile="ss.su";
@


1.13
log
@4 Oct 2005
@
text
@d1 1
a1 1
/* SUEA2DF: $Revision: 1.12 $ ; $Date: 2005/03/11 22:47:10 $		*/
d14 1
a14 1
" suea2df > outfile nxl= xl= zl= rhol= vpl= vsl= [optional parameters]	",
d17 2
a18 6
" nxl=			number of locations to define model		",
" xl=		 	model locations	in horizontal direction		",
" zl=		 	model depths					",
" rhol=		 	model rho at xl,zl				",
" vpl=		 	model vp at xl,zl				",
" vsl=		 	model vs at xl,zl				",
d21 13
d38 4
a45 4
" nx=200		number of values in slow (x-direction)		",
" dx=10.0	 		spatial sampling intrval (m) x-coor	",
" fx=-1000		first x coor (m)				",
"									",
a65 10
" Anisotropy parameters:						",
" epl=		 	anisotropy ep at xl,zl				",
" dsl=		 	anisotropy ds at xl,zl				",
" anl=		 	anisotropy angle at xl,zl			",
" asw=0		 	switch to include anisotropy =1 - include	",
" msw=0			model type (=0 - field; =1 - layer)		",
"									",
" mode=0		=0 output particle velocity, =1 output stresses ",
"			(snapshots only)				",
"									",
a78 1
" efile=	 	name of file to output model to if desired	",
d84 2
a85 2
" vrslfile='vsp.su'	output file for vertical line of seismograms[nz][nt]",
" hsfile='ss.su' 	output file for horizontal line of seismograms[nx][nt]",
d92 12
a103 10
" The outfile contains information generated by the input parameters, 	",
" such as memory allocation, stability, etc. If your input file does	",
" not work, check this file first.					",
"									",
" There are two ways of specifying the model.				",
" The zl,vpl,vsl,rhol specify elastic constants as function of depth. 	",
" Linear interpolation and constant extrapolation is used to determine	",
" constants at depths not specified.  Values specified in depth		",
" must increase monotonically. The values of these parameters are specified",
" as arrays, values separated by commas, eg.  zl=zl1,zl2,... 		",
d108 2
a109 1
" If asw=1 epl,dsl and anl arrays must be specified to specify anisotropy.",
d112 1
d121 1
a121 1
"Output files (if requested)						",
a122 1
"	efile  - binary elastic constants file				",
d136 1
a136 1
 * the Tzz term, e15 was being used instead of e35. This only caused
d139 1
a139 1
 * 2. Added some header information for output of snapshots.
d175 2
d183 1
a192 2
static void interpovv (int nt, int ncdp, float *cdp, float **ovv, 
	float cdpt, float *ovvt);
d195 1
a195 1
	float **rho, float **e55, float dtx, float dtz);
d198 1
a198 1
	float **rho, float **e55, float dtx, float dtz);
d201 1
a201 1
	float **e11, float **e55, float dtx, float dtz);
d204 2
a205 2
	float **e11, float **e55, float **e33, float **e13, 
	float **e15, float **e35, float dtx, float dtz);
d211 2
a212 2
			float **tzz, float **txz, float **e11, 
			float **e55, float *a, float sang, 
d218 2
a219 2
			float **tzz, float **txz, float **e11,
			float **e55, float *a, float sang,
d224 7
a230 12
void make_snap(float **u, float **w, float sx, float sz, 
	float dx, float dz, int nxpadded, int nzpadded, int nx, int nz,
	int k, float t, float fx, float fz, segy tr, FILE *sneisfp, int *wbc);
void make_seis(float **ut, float **wt, float sx, float sz, 
	float dn, float dt, int nn, int nt, float dd,
	float fx, float fz,
	segy tr, FILE *fp, int b1, int b2, int ivh, int verbose);
void get_econst(float **rho, float **e11, float **e55, float **q, int qsw, 
	float **e33, float **e13, float **e15, float **e35, int asw, 
	float dx, float dz, int nxpadded, int nzpadded,
	float fx, float fz,
	float *vlim, int msw, FILE *efp,  FILE *mfp);
d245 1
a245 1
void fs4v_bc_top(float **u, float **w, float **e11, float **e55, 
a261 5
void rotate(float *e11, float *e33, float *e13, float *e55,
			float *e15, float *e35, float angle);
void set_layers(int nxpadded, int nzpadded, float *tmp, int nxl, int nzl, 
			float **pl, float **zl, float *xl, float x, float dz,
			float fx, float fz, int msw);
d266 1
a266 1
			int asw, float xz, FILE *fp, int comp, char *mfile);
d274 1
d283 1
d287 1
d291 3
a293 1
	char *stype,*wtype;	/* source, wave type		*/
d295 1
d299 1
a302 2
	char *snfile="";	/* snapshot file name 		*/
	char *sofile="";	/* source file name 		*/
d312 1
a312 1
	int i,j,k;		/* loop counters 		*/
d314 7
a320 4
	int msw;		/* model type */
	float **e11=NULL;	/* elastic constant c11(x,z)	*/
	float **e55=NULL;	/* elastic constant c55(x,z)	*/
	float **rho=NULL;	/* density rho(x,z)		*/
d322 17
d341 9
a349 5
	int asw;		/* switch to include anisotropy */
	float **e33=NULL;	/* elastic constant c33(x,z)	*/
	float **e13=NULL;	/* elastic constant c13(x,z)	*/
	float **e15=NULL;	/* elastic constant c13(x,z)	*/
	float **e35=NULL;	/* elastic constant c35(x,z)	*/
d355 1
d357 1
d361 1
d366 1
a366 1
	float *vlim=NULL;	/* min and max velocity in grid	*/
a374 6
	char *vrslfile="";	/* vert receiver seismogram line file  name */
	char *vrshfile=NULL;	/* vert receiver seismogram header file name */
	char *hsfile="";	/* horiz receiver seismogram line file name */
	char *hcfile=NULL;	/* horiz receiver seismogram header file name */
	char *mfile=NULL;	/* model file name */
	char tfile[256];	/* temporary file name */
a389 1
	char *efile="";		/* name of file containing constants */
d391 34
a424 9
	FILE *soeisfp=NULL;	/* pointer to source file  */
	FILE *sneisfp=NULL;	/* pointer to snapshot file  */
	FILE *efp=NULL;		/* constants file pointer 	*/
	FILE *hseisfp=NULL;	/* pointer to output horiz rec line file  */
	FILE *vseisfp=NULL;	/* pointer to output vert rec line file  */
	FILE *hchdfp=NULL;	/* pointer to output horiz header file  */
	FILE *vchdfp=NULL;	/* pointer to output vert header file  */
	FILE *mfp=NULL;		/* pointer to model file  */
	
d432 1
a432 1
	requestdoc(1);
d467 1
a467 2
	if (!getparint("asw",&asw)) asw = 0;
	if (!getparint("msw",&msw)) msw = 0;
d472 2
a473 1
	/* get name of output snapshot and source files */ 
a476 1
		
d483 1
a483 1
		fprintf(stdout,"nsnap=%d \n",nsnap);
a485 3
	
	warn("input");
	
d497 26
d524 3
d528 11
d554 15
a568 1
	fprintf(stdout,"%f bc_a  %f bc_r\n",bc_a,bc_r);
a569 5
	for(i=0; i<4; i++){wbc[i]=2; if(bc[i]>2) wbc[i]=bc[i];}
	bc0=alloc1float(bc[0]); bc0[0]=bc_a;
	bc1=alloc1float(bc[1]); bc1[0]=bc_a;
	bc2=alloc1float(bc[2]); bc2[0]=bc_a;
	bc3=alloc1float(bc[3]); bc3[0]=bc_a;
d574 4
a577 2
		/*fprintf(stdout,"%d %f\n",j,bc0[j]);*/
 	for(j=0; j<bc[3]; j++) fprintf(stdout," %d %f\n",j,bc3[j]);
d579 3
a581 2
	fprintf(stdout,"bc=%d %d %d %d\n",bc[0],bc[1],bc[2],bc[3]);
	fprintf(stdout,"wbc=%d %d %d %d\n",wbc[0],wbc[1],wbc[2],wbc[3]);
d583 1
d592 1
a592 1
	fprintf(stdout,"hs1=%d vs2=%d \n",hs1, vs2);
d594 1
d600 1
d607 3
a609 3
	fprintf(stdout,"dx=%f dz=%f dt=%f\n",dx,dz,dt);
	fprintf(stdout,"nxpadded=%d nzpadded=%d nt=%d\n",nxpadded,nzpadded,nt);
	fprintf(stdout,"array sizes\n");
d617 1
a617 1
 	fprintf(stdout,"is=%d js=%d\n",is,js);
d626 4
a629 2
	e11 = alloc2float(nxpadded,nzpadded);
	e55 = alloc2float(nxpadded,nzpadded);
d631 1
d643 6
a648 6
	/* if annisotropy is desired allocate space for anisotropy params */
	if(asw==1) {
		e33 = alloc2float(nxpadded,nzpadded);
		e13 = alloc2float(nxpadded,nzpadded);
		e15 = alloc2float(nxpadded,nzpadded);
		e35 = alloc2float(nxpadded,nzpadded);
d654 2
a655 9
	fprintf(stdout,"%d grids allocated for model\n",ngrids);
	fprintf(stdout,"%f MBytes allocated for model\n",0.000001*nbytes);
	
	/* open file for model output */
	getparstring("efile",&efile);
	if (*efile!='\0') {
		if((efp=fopen(efile,"w+"))==NULL)
			err("cannot open efile=%s\n",efile);
	}
a657 1
	vlim = alloc1float(2);
d665 155
a819 4
	/* get elastic constants from input parameters */
	get_econst(rho,e11,e55,q,qsw,e33,e13, e15,e35,asw,
			dx,dz,nxpadded,nzpadded,fx-wbc[1]*dx,
			fz-wbc[0]*dz,vlim,msw,efp,mfp);
d821 33
a853 2
	/* close efile and mfile */
	fclose(efp);
d864 4
a867 4
	/* since rho=1/rho now */
	 	for (j=0; j<nzpadded; ++j) {
		vl[j]=sqrt(e11[j][wbc[1]]*rho[j][wbc[1]]);
		vr[j]=sqrt(e11[j][nxpadded-wbc[3]-1]*rho[j][nxpadded-wbc[3]-1]);
d870 1
a870 1
		vb[i]=sqrt(e11[nzpadded-wbc[2]-1][i]*rho[nzpadded-wbc[2]-1][i]);
d913 2
a914 2
	fprintf(stdout,"vmin=%f vmax=%f \n",vlim[0],vlim[1]);
	fprintf(stdout,"model set\n");
d917 1
a917 1
	fprintf(stdout,"for stablity dt should be < %f: x-dir and %f: z-dir \n",
d919 1
a919 1
	fprintf(stdout,"for low dispersion fmax should be < %f \n",
d927 1
a927 1
	fprintf(stdout,"source set\n");
d937 1
a937 1
 	fprintf(stdout,"%s %s %d %d %f %f\n",wtype,stype,ns,i,favg,ts);
d954 1
a954 1
	fprintf(stdout,"%f MBytes allocated for model + variables\n",
d984 1
a984 1
			bc,qsw,asw,hsz,hchdfp,1,mfile);
d992 1
a992 1
			bc,qsw,asw,vsx,vchdfp,2,mfile);
d1023 1
a1023 1
					rho,e55,dtx,dtz);
d1026 1
a1026 1
					txz,rho,e55,dtx,dtz);
d1030 1
a1030 1
		  		add_pw_source_V(u,w,txx,tzz,txz,e11,e55,
d1039 1
a1039 1
		if(bc[0]==2) fs4v_bc_top(u,w,e11,e55,nxpadded,nzpadded);
d1054 1
a1054 1
		if(!asw) {  /* isotropic */
d1056 1
a1056 1
						e11,e55,dtx,dtz);
d1059 1
a1059 1
						e11,e55,e33,e13,e15,e35,
d1065 1
a1065 1
			add_pw_source_S(u,w,txx,tzz,txz,e11,e55,
d1157 1
a1157 1
	fprintf(stdout,"propagation completed\n");
d1165 1
a1165 1
	fprintf(stdout,"propagation space freed\n");
d1187 1
a1187 1
	fprintf(stdout,"u time section output\n");
d1201 1
a1201 1
	fprintf(stdout,"w time section output\n");
d1233 1
a1233 1
 	  /*fprintf(stdout,"%d %f %f\n",i,t,source[i]);*/
d1241 1
a1241 1
	float **rho, float **e55, float dtx, float dtz)
d1264 1
a1264 1
	float **rho, float **e55, float dtx, float dtz)
d1273 1
a1273 1
	 		if(e55[j][i]>0) { 
d1286 1
a1286 1
	 		if(e55[j][i]>0) { 
d1301 1
a1301 1
	float **e11, float **e55, float dtx, float dtz)
d1312 1
a1312 1
	 		e11[j][i]*dtx*dux + (e11[j][i]-2*e55[j][i])*dtz*dwz;
d1314 1
a1314 1
	 		e11[j][i]*dtz*dwz + (e11[j][i]-2*e55[j][i])*dtx*dux;
d1322 1
a1322 1
	 		e55[j][i]*(dtz*duz + dtx*dwx);
d1329 2
a1330 2
	float **e11, float **e55, float **e33, float **e13, 
	float **e15, float **e35, float dtx, float dtz)
d1351 3
a1353 3
					+ e11[j][i]*dtx*dux 
					+ e13[j][i]*dtz*dwz 
					+ e15[j][i]*(dtz*duz + dtx*dwx);
d1356 3
a1358 3
					+ e33[j][i]*dtz*dwz 
					+ e13[j][i]*dtx*dux 
					+ e35[j][i]*(dtz*duz + dtx*dwx); 
d1361 3
a1363 3
					+ e15[j][i]*dtx*dux 
					+ e35[j][i]*dtz*dwz 
					+ e55[j][i]*(dtz*duz + dtx*dwx);
d1380 3
a1382 3
			+ e11[j][i]*dtx*dux 
			+ e13[j][i]*dtz*dwz 
			+ e15[j][i]*(dtz*duz + dtx*dwx);
d1385 3
a1387 3
			+ e33[j][i]*dtz*dwz 
			+ e13[j][i]*dtx*dux 
			+ e35[j][i]*(dtz*duz + dtx*dwx); 
d1405 1
a1405 1
	float **txz, float **e11, float **e55, float *a, float sang,
d1529 1
a1529 1
	float **txz, float **e11, float **e55, float *a, float sang,
d1569 4
a1572 4
				txx[j][i]=(e11[j][i]*sa*sa 
					   +(e11[j][i]-2*e55[j][i])*ca*ca)*ak;
				tzz[j][i]=(e11[j][i]*ca*ca
					   +(e11[j][i]-2*e55[j][i])*sa*sa)*ak;
d1576 1
a1576 1
				txz[j][i]=e55[j][i]*(2*ca*sa)*ak;
d1608 6
a1613 6
					txx[j][i+1]=(e11[j][i]*sa*sa
							+(e11[j][i]
							-2*e55[j][i])*ca*ca)*ak;
					tzz[j][i+1]=(e11[j][i]*ca*ca
							+(e11[j][i]
							-2*e55[j][i])*sa*sa)*ak;
d1621 1
a1621 1
				txz[j][i]=e55[j][i]*(2*ca*sa)*ak;
d1651 6
a1656 6
				txx[j][i]=(e11[j][i]*sa*sa
						+(e11[j][i]
							-2*e55[j][i])*ca*ca)*ak;
				tzz[j][i]=(e11[j][i]*ca*ca
						+(e11[j][i]
							-2*e55[j][i])*sa*sa)*ak;
d1661 1
a1661 1
				txz[j][i]=e55[j][i]*(2*ca*sa)*ak;
a1863 426
void get_econst(float **rho, float **e11, float **e55, float **q, int qsw,
	float **e33, float **e13, float **e15, float **e35, int asw, 
	float dx, float dz, int nxpadded, int nzpadded, float fx, float fz,
	float *vlim, int msw, FILE *efp, FILE *mfp)
{
		
	int nxl=0;		/* number of locations to define model	*/
	int nzl=0;		/* number of zl specified 		*/
	float *xl=NULL;		/* model locations			*/
	float **zl=NULL;	/* model depths				*/
	float **rhol=NULL;	/* model rho at xl,zl			*/
	float **vpl=NULL;	/* model vp at xl,zl sloths		*/
	float **vsl=NULL;	/* model vs at xl,zl sloths		*/
	float **ql=NULL;	/* model Q at xl,zl sloths		*/
	float **epl=NULL;	/* model (c11-c33)/2c33 at xl,zl sloths	*/
	float **dsl=NULL;	/* model del* at xl,zl sloths		*/
	float **anl=NULL;	/* model anisotropy angle at xl,zl sloths*/
	float **rhoo=NULL;	/* model rho at xl,z sloths		*/
	float **vpo=NULL;	/* model vp at xl,z			*/
	float **vso=NULL;	/* model vs at xl,z			*/
	float **qo=NULL;	/* model Q at xl,z			*/
	float **epo=NULL;	/* model (c11-c33)/2c33 at xl,z		*/
	float **dso=NULL;	/* model del* at xl,z			*/
	float **ano=NULL;	/* model anisotropy angle at xl,z	*/
	float **tmp=NULL;	/* temporary work array			*/
	float *tmp1=NULL, *tmp2=NULL;	/* temporary work arrays	*/

	int nvpl;		/* number of vpl specified 	*/
	int nvsl;		/* number of vsl specified 	*/
	int nrhol;		/* number of rhol specified 	*/
	int nql;		/* number of ql specified 	*/
	int nepl;		/* number of epl specified 	*/
	int ndsl;		/* number of dsl specified 	*/
	int nanl;		/* number of anl specified 	*/
	float zint;		/* interpolated depth 		*/
	float pint;		/* interpolated constant 	*/
	float x;		/* x surface location		*/
	int i,j;
	float b,c;		/* temporary work variables	*/
	float vmin,vmax;
	float pi;

	pi=PI;
	vmin=10000000;vmax=0;
	
	/* check input format */
	nxl = countparval("xl");
	fprintf(stdout,"nxl=%d\n",nxl);
	if (nxl>0) {
		if (countparname("zl")!=nxl)
			err("a zl array must be specified for each xl");
		if (countparname("vpl")!=nxl)
			err("a rhol array must be specified for each xl");
		if (countparname("vpl")!=nxl)
			err("a vpl array must be specified for each xl");
		if (countparname("vsl")!=nxl)
			err("a vsl array must be specified for each xl");
		if(qsw==1){
		  if (countparname("ql")!=nxl)
			err("a ql array must be specified for each xl");}
		if(asw==1){
		  if (countparname("epl")!=nxl)
			err("an epl array must be specified for each xl");
		  if (countparname("dsl")!=nxl)
			err("a dsl array must be specified for each xl");
		  if (countparname("anl")!=nxl)
			err("an anl array must be specified for each xl");
		}
	} else {
		err("xl, zl + model parameters must be specified");
	}

	xl = ealloc1float(nxl);
	getparfloat("xl",xl);
	for (i=1; i<nxl; ++i) {
		fprintf(stdout,"%f  \n",xl[i]);
		if (xl[i]<=xl[i-1])
		err("xl values must increase monotonically");
	}

	/* get model constants linearly interpolated in depth*/
	vpo = alloc2float(nzpadded,nxl);
	vso = alloc2float(nzpadded,nxl);
	rhoo = alloc2float(nzpadded,nxl);
	if(qsw==1) qo = alloc2float(nzpadded,nxl);
	if(asw==1) {
		epo = alloc2float(nzpadded,nxl);
		dso = alloc2float(nzpadded,nxl);
		ano = alloc2float(nzpadded,nxl);
	}
	fprintf(stdout,"start getting model\n");
	fprintf(mfp,"msw=%d\n",msw);
	for (i=0; i<nxl; ++i) {
		nzl = countnparval(i+1,"zl");
		nvpl = countnparval(i+1,"vpl");
		nvsl = countnparval(i+1,"vsl");
		nrhol = countnparval(i+1,"rhol");
		nql = countnparval(i+1,"ql");
		nepl = countnparval(i+1,"epl");
		ndsl = countnparval(i+1,"dsl");
		nanl = countnparval(i+1,"anl");
		fprintf(stdout,"%d %d %d %d %d %d %d %d nzl nvpl nvsl nrhol nql nepl ndsl nanl\n", nzl, nvpl, nvsl, nrhol, nql, nepl, ndsl, nanl);
		fprintf(mfp,"%f %d xl i\n",xl[i],i);

		if(i==0){
		   zl = ealloc2float(nzl,nxl);
			rhol = ealloc2float(nzl,nxl);
			vpl = ealloc2float(nzl,nxl); 
			vsl = ealloc2float(nzl,nxl); 
			if(qsw==1) ql = ealloc2float(nzl,nxl); 
			if(asw==1) epl = ealloc2float(nzl,nxl); 
			if(asw==1) dsl = ealloc2float(nzl,nxl); 
			if(asw==1) anl = ealloc2float(nzl,nxl); 
			tmp1 = ealloc1float(nzl);
			tmp2 = ealloc1float(nzl);
		}

		getnparfloat(i+1,"zl",tmp1);
		for (j=0;j<nzl;++j) zl[i][j]=tmp1[j];

		for (j=1; j<nzl; ++j) {
		  if (zl[i][j]<=zl[i][j-1])
			err("zl must increase monotonically");}

		if (nrhol!=nzl)
			err("number of rhol and zl values must be equal");
		getnparfloat(i+1,"rhol",tmp2);

		for (j=0;j<nzl;++j) rhol[i][j]=tmp2[j];

		for (j=0,zint=fz; j<nzpadded; ++j,zint+=dz) {
		  	intlin(nzl,tmp1,tmp2,rhol[i][0],
				rhol[i][nzl-1],1,&zint,&pint);
				rhoo[i][j]=pint;
		}

		if (nvpl!=nzl)
			err("number of vpl and zl values must be equal");
		getnparfloat(i+1,"vpl",tmp2);
		for (j=0;j<nzl;++j) vpl[i][j]=tmp2[j];

		for (j=0,zint=fz; j<nzpadded; ++j,zint+=dz) {
		  		intlin(nzl,tmp1,tmp2,vpl[i][0],
					vpl[i][nzl-1],1,&zint,&pint);
				vpo[i][j]=pint;
		}

		if (nvsl!=nzl)
			err("number of vsl and zl values must be equal");
		getnparfloat(i+1,"vsl",tmp2);
		for (j=0;j<nzl;++j) vsl[i][j]=tmp2[j];

		for (j=0,zint=fz; j<nzpadded; ++j,zint+=dz) {
			intlin(nzl,tmp1,tmp2,vsl[i][0],vsl[i][nzl-1],
				1,&zint,&pint);
			vso[i][j]=pint;
		}

		if(qsw==1) {
			if (nql!=nzl)
				err("number of ql and zl values must be equal");

			getnparfloat(i+1,"ql",tmp2);
			for (j=0;j<nzl;++j) ql[i][j]=tmp2[j];
			for (j=0,zint=fz; j<nzpadded; ++j,zint+=dz){
		  		intlin(nzl,tmp1,tmp2,ql[i][0],
					ql[i][nzl-1],1,&zint,&pint);
				qo[i][j]=pint;
			}
		}
		
		for (j=0; j<nzl; ++j) {
			b=0;
			if(qsw==1) b=ql[i][j];
		  	fprintf(mfp,"%d %f %f %f %f %f\n",j+1,
					zl[i][j],rhol[i][j],
					vpl[i][j],vsl[i][j],b);
		}

		if(asw==1) {
			if (nepl!=nzl)
				err("number of epl and zl values must be equal");
			getnparfloat(i+1,"epl",tmp2);
			for (j=0;j<nzl;++j) epl[i][j]=tmp2[j];

			for (j=0,zint=fz; j<nzpadded; ++j,zint+=dz) {
				intlin(nzl,tmp1,tmp2,epl[i][0],
					epl[i][nzl-1],1,&zint,&pint);
					epo[i][j]=pint;
			}

			if (ndsl!=nzl)
				err("number of dsl and zl values must be equal");
			getnparfloat(i+1,"dsl",tmp2);
			for (j=0;j<nzl;++j) dsl[i][j]=tmp2[j];

			for (j=0,zint=fz; j<nzpadded; ++j,zint+=dz) {
				intlin(nzl,tmp1,tmp2,dsl[i][0],
					dsl[i][nzl-1],1,&zint,&pint);
				dso[i][j]=pint;
			}

			if (nanl!=nzl)
				err("number of anl and zl values must be equal");
			getnparfloat(i+1,"anl",tmp2);
				for (j=0;j<nzl;++j) anl[i][j]=tmp2[j];
				for (j=0,zint=fz; j<nzpadded; ++j,zint+=dz) {
		  			intlin(nzl,tmp1,tmp2,anl[i][0],
						anl[i][nzl-1],1,&zint,&pint);
					ano[i][j]=pint;
				}

			for (j=0; j<nzl; ++j){
		  		fprintf(mfp,"%d %f %f %f %f \n",j+1,zl[i][j],epl[i][j],dsl[i][j],anl[i][j]);
		  		anl[i][j]=anl[i][j]*pi/180.0;
			}
		}
		
		for(j=0; j<nzl; j++){
			if(vpl[i][j]>vmax) vmax=vpl[i][j];
			if(asw==1) {
				if(vpl[i][j]*(1+epl[i][j])>vmax) {
				  	vmax=vpl[i][j]*(1+epl[i][j]);
				}
			}
			if(vsl[i][j]<vmin) vmin=vsl[i][j];
		}
	}
	vlim[0]=vmin;vlim[1]=vmax;

	/* write model boundaries  */
	fprintf(stdout,"model boundaries\n");
	for (j=0; j<nzl; ++j) {
		fprintf(stdout,"& && %d\n",j+1);
	  	if(asw==0) for (i=0; i<nxl; ++i){
	   		fprintf(stdout,"& %f %f %f %f %f \n",
					xl[i],zl[i][j],vpl[i][j],
		   			vsl[i][j],rhol[i][j]);
	   	}
	}
	/*  	  CJ: CORRECTION MADE 010223 - DID NOT CHECK THIS 
		WHEN I MADE UTILITY TO WRITE OUT MODEL BOUNDARIES - SORRY */
	/*  	  if(asw==1)
			for (j=0; j<nzl; ++j) */

	  if(asw==1)
		for (i=0; i<nxl; ++i){
	   		fprintf(stdout,"& %f %f %f %f %f %f %f %f\n",
				xl[i],zl[i][j],vpl[i][j],
				vsl[i][j],rhol[i][j],epl[i][j],
				dsl[i][j],anl[i][j]);
	   	}
		
	
	/* interpolate model laterally (z,x) */
	tmp = alloc2float(nzpadded,nxpadded);
	fprintf(stdout,"start interpolating model laterally\n");
	
	vmin=10000000;vmax=0;
	for (i=0, x=fx; i<nxpadded; i++, x+=dx) {
		if(msw==0) interpovv(nzpadded,nxl,xl,rhoo,x,tmp[i]);
		if(msw!=0) set_layers(nxpadded,nzpadded,tmp[i],nxl,
				nzl,rhol,zl,xl,x,dz,fx,fz,msw);
		for (j=0; j<nzpadded; ++j)
			fwrite(&tmp[i][j], 4, 1, efp);
	  	for (j=0; j<nzpadded; j++) {
			rho[j][i]=tmp[i][j];
	  		if(tmp[i][j]>vmax) vmax=tmp[i][j];
	  		if(tmp[i][j]<vmin) vmin=tmp[i][j];
		}
	}
	fprintf(stdout,"rho %f %f\n",vmin,vmax);

	vmin=10000000;vmax=0;
	for (i=0, x=fx; i<nxpadded; i++, x+=dx) {
		if(msw==0) interpovv(nzpadded,nxl,xl,vpo,x,tmp[i]);
		if(msw!=0) set_layers(nxpadded,nzpadded,tmp[i],nxl,nzl,vpl,
					zl,xl,x,dz,fx,fz,msw);
	  	for (j=0; j<nzpadded; ++j) fwrite(&tmp[i][j], 4, 1, efp);
	  	for (j=0; j<nzpadded; j++) {
			e11[j][i]=tmp[i][j]*tmp[i][j]*rho[j][i];
	  		if(tmp[i][j]>vmax) vmax=tmp[i][j];
	  		if(tmp[i][j]<vmin) vmin=tmp[i][j];
		}
	}
	fprintf(stdout,"vp %f %f\n",vmin,vmax);
	vmin=10000000;vmax=0;
	for (i=0, x=fx; i<nxpadded; i++, x+=dx) {
		if(msw==0) interpovv(nzpadded,nxl,xl,vso,x,tmp[i]);
	  	if(msw!=0) set_layers(nxpadded,nzpadded,tmp[i],nxl,nzl,vsl,
					zl,xl,x,dz,fx,fz,msw);
	  	for (j=0; j<nzpadded; ++j) fwrite(&tmp[i][j], 4, 1, efp);

		for (j=0; j<nzpadded; j++) {
			e55[j][i]=tmp[i][j]*tmp[i][j]*rho[j][i];
	  		if(tmp[i][j]>vmax) vmax=tmp[i][j];
	  		if(tmp[i][j]<vmin) vmin=tmp[i][j];
		}
	}
	fprintf(stdout,"vs %f %f\n",vmin,vmax);
	for (i=0, x=fx; i<nxpadded; i++, x+=dx) {
		for (j=0; j<nzpadded; j++) rho[j][i]=1/rho[j][i];
	}
	  
	if(qsw==1){
		vmin=10000000;vmax=0;
	  	for (i=0, x=fx; i<nxpadded; i++, x+=dx) {
				if(msw==0) interpovv(nzpadded,nxl,xl,
							qo,x,tmp[i]);
				if(msw!=0) set_layers(nxpadded,nzpadded,
							tmp[i],nxl, nzl,ql,
							zl,xl,x, dz,fx,fz,msw);
				for (j=0; j<nzpadded; ++j) 
					fwrite(&tmp[i][j], 4, 1, efp);
				for (j=0; j<nzpadded; j++) {
					q[j][i]=tmp[i][j];
	  				if(tmp[i][j]>vmax) vmax=tmp[i][j];
	  				if(tmp[i][j]<vmin) vmin=tmp[i][j];
				}
		}
			fprintf(stdout,"q %f %f\n",vmin,vmax);
	}
		
	if(asw==1){
		vmin=10000000;vmax=-100000000;
		for (i=0, x=fx; i<nxpadded; i++, x+=dx) {
			if(msw==0) interpovv(nzpadded,nxl,xl,epo,x,tmp[i]);
			if(msw!=0)
				set_layers(nxpadded,nzpadded,tmp[i],nxl,nzl,epl,
						zl,xl,x,dz,fx,fz,msw);
				for (j=0; j<nzpadded; ++j) fwrite(&tmp[i][j], 4, 1, efp);
				for (j=0; j<nzpadded; j++) e33[j][i]=e11[j][i];
				for (j=0; j<nzpadded; j++) {
				e11[j][i]=e33[j][i]*(1+2*tmp[i][j]);
	  			if(tmp[i][j]>vmax) vmax=tmp[i][j];
	  			if(tmp[i][j]<vmin) vmin=tmp[i][j];
			}
		}
			fprintf(stdout,"ep %f %f\n",vmin,vmax);
	  	vmin=10000000;vmax=-100000000;
	  	for (i=0, x=fx; i<nxpadded; i++, x+=dx) {
				if(msw==0) interpovv(nzpadded,nxl,xl,dso,x,tmp[i]);
				if(msw!=0) set_layers(nxpadded,nzpadded,tmp[i],nxl,nzl,
						dsl,zl,xl,x,dz,fx,
						fz,msw);
				for (j=0; j<nzpadded; ++j) fwrite(&tmp[i][j], 4, 1, efp);
				for (j=0; j<nzpadded; j++) {
		 			b=2*e55[j][i];
		 			c=e55[j][i]*e55[j][i]
					-tmp[i][j]*e33[j][i]*e33[j][i]
					-0.5*(e33[j][i]-e55[j][i])
					*(e11[j][i]+e33[j][i]-2*e55[j][i]);
				e13[j][i]=0.5*(-b+sqrt(b*b-4*c));
		 			if(tmp[i][j]>vmax) vmax=tmp[i][j];
		 			if(tmp[i][j]<vmin) vmin=tmp[i][j];}}

					fprintf(stdout,"ds %f %f\n",vmin,vmax);
	  			vmin=10000000;vmax=-100000000;
		for (i=0, x=fx; i<nxpadded; i++, x+=dx) {
			if(msw==0) interpovv(nzpadded,nxl,xl,ano,x,tmp[i]);
			if(msw!=0) set_layers(nxpadded,nzpadded,tmp[i],nxl,nzl,anl,
					zl,xl,x,dz,fx,fz,msw);
				for (j=0; j<nzpadded; ++j) fwrite(&tmp[i][j], 4, 1, efp);
				for (j=0; j<nzpadded; j++) {
				e15[j][i]=0.0;
				e35[j][i]=0.0;
				rotate(&e11[j][i],&e33[j][i],&e13[j][i],
					&e55[j][i],&e15[j][i],&e35[j][i],
					tmp[i][j]);
		 			if(tmp[i][j]>vmax) vmax=tmp[i][j];
				if(tmp[i][j]<vmin) vmin=tmp[i][j];
			}
		}
		fprintf(stdout,"an %f %f\n",vmin,vmax);
		
	}

	free2float(zl);
	free2float(vpl);
	free2float(vsl);
	free2float(rhol);
	if(qsw==1) free2float(ql);
	if(asw==1) free2float(epl);
	if(asw==1) free2float(dsl);
	if(asw==1) free2float(anl);
	
	free2float(vpo);
	free2float(vso);
	free2float(rhoo);
	if(qsw==1) free2float(qo);
	if(asw==1) free2float(epo);
	if(asw==1) free2float(dso);
	if(asw==1) free2float(ano);
	free2float(tmp);
	free1float(tmp1);
	free1float(tmp2);
}

/* linearly interpolate/extrapolate sloth between model points (x,t) */
static void interpovv (int nt, int ncdp, float *cdp, float **ovv, 
			float cdpt, float *ovvt)
{

	static int index=0;
	int it;
	float a1,a2;

	/* if before first cdp, constant extrapolate */
	if (cdpt<=cdp[0]) {
		for (it=0; it<nt; ++it)
			ovvt[it] = ovv[0][it];
	
	/* else if beyond last cdp, constant extrapolate */
	} else if (cdpt>=cdp[ncdp-1]) {
		for (it=0; it<nt; ++it)
			ovvt[it] = ovv[ncdp-1][it];
	
	/* else, linearly interpolate */
	} else {
		xindex(ncdp,cdp,cdpt,&index);
		a1 = (cdp[index+1]-cdpt)/(cdp[index+1]-cdp[index]);
		a2 = (cdpt-cdp[index])/(cdp[index+1]-cdp[index]);
		for (it=0; it<nt; ++it)
			ovvt[it] = a1*ovv[index][it]+a2*ovv[index+1][it];
	}
}
d1965 2
a1966 2
void fs4v_bc_top(float **u, float **w, float **e11,
			float **e55, int nxpadded, int nzpadded)
d1982 1
a1982 1
			+ 0.5*(1-2*(e55[2][i]/e11[2][i]))
d1993 1
a1993 1
			+ 0.5*(1-2*(e55[2][i]/e11[2][i]))
a2121 101
void rotate(float *e11, float *e33, float *e13,
		float *e55, float *e15, float *e35, float angle)
{
	float e11p,e33p,e13p,e55p,e15p,e35p;
	float c,s;
	
	if(angle!=0.0){
		
		c=cos(angle); s=sin(angle);
	
		e11p= c*c*c*c*(*e11) 
			+ c*c*s*s*(2*(*e13)+4*(*e55)) + s*s*s*s*(*e33);

		e33p= c*c*c*c*(*e33) 
			+ c*c*s*s*(2*(*e13)+4*(*e55)) + s*s*s*s*(*e11);

		e13p= c*c*c*c*(*e13) 
			+ c*c*s*s*(*e11+*e33-4*(*e55)) + s*s*s*s*(*e13);

		e55p= c*c*c*c*(*e55) 
			+ c*c*s*s*(*e11+*e33-2*(*e55)-2*(*e13)) 
			+ s*s*s*s*(*e55);

		e15p= c*c*c*s*(-*e11+*e13+2*(*e55)) 
			+ c*s*s*s*(*e33-*e13-2*(*e55));

		e35p= c*s*s*s*(-*e11+*e13+2*(*e55)) 
			+ c*c*c*s*(*e33-*e13-2*(*e55));
	 
		*e11=e11p;
		*e33=e33p;
		*e13=e13p;
		*e55=e55p;
		*e15=e15p;
		*e35=e35p;
	}
}

void set_layers(int i, int nzpadded, float *tmp, int nxl, int nzl, 
	float **pl, float **zl, float *xl, float x, float dz,
	float fx, float fz, int msw)
{
	int j,i1,j1,j2,jl;
	float z=0.0,x1=0.0,x2=0.0,p=0.0;
	static int il;
	
/*  	if(NINT(x)%100==0)
	fprintf(stdout,"msw %d %d %d %f \n",msw,nzl,nxl,x); 
*/

	j1=0; i1=0;
	
	/* CJ - 010812: changed line below to fill model properly in depth*/
/*  	  for (jl=0; jl<=nzl; ++jl)
 */
	  for (jl=0; jl<nzl; ++jl){
	  
		/* if before first location, constant extrapolate */
		if (x<=xl[0]) {
			z=zl[0][jl];
			p = pl [0][jl];
		
			/* else if beyond last location constant extrapolate */
			} else if (x>=xl[nxl-1]) {
			z=zl[nxl-1][jl];
			p = pl [nxl-1][jl];
		
				/* else, linearly interpolate */
				/* if ( x>xl[0] & x<xl[nxl-1] ) */
		} else {
			xindex(nxl,xl,x,&il);
			x1 = (xl[il+1]-x)/(xl[il+1]-xl[il]);
			x2 = (x-xl[il])/(xl[il+1]-xl[il]);
			if(jl<nzl) z = x1*zl[il][jl]+x2*zl[il+1][jl];

				/* choose constant layer velocity */
			if(msw==1) p = pl[il][jl];

				/* interpolate laterally layer velocity */
			if(msw==2) p = x1*pl[il][jl]+x2*pl[il+1][jl];
		}  

	/*CJ - 010812: changed line below to fill model properly in depth*/	
/*  		j2=NINT((z-fz)/dz); if(jl==nzl) j2=nzpadded; */

		j2=NINT((z-fz)/dz);
		if(jl==nzl-1) j2=nzpadded;
		if(j2>nzpadded) j2=nzpadded;
		if(j2<0) j2=0;
		
		for (j=j1; j<j2; ++j) tmp[j]=p;
		/*  	if(NINT(x)%100==0) 
				fprintf(stdout,"%d %d %d %d %f %f %f %f\n",
					il,jl,j1,j2,z,p,tmp[j2-1],tmp[nzpadded]); 
		*/

			j1=j2;

	  }
}

d2126 1
a2126 1
	int *bc, int qsw, int asw, float xz,
d2167 1
a2167 1
	if(asw==1) k=fwrite_chd(fp,"Anisotropy included",k);
d2242 80
@


1.12
log
@further updates
@
text
@d1 1
a1 1
/* SUEA2DF: $Revision: 1.10 $ ; $Date: 2004/12/23 22:43:28 $		*/
a23 5
" ...or specify input data from files					",
" rhofile=								",
" vpfile=								",
" vsfile=								",
"									",
a104 6
" Alternatively the user may specfiy the model via the input files:	",
" rhofile, vpfile, and vsfile. These files are nz by nx arrays of	",
" unformated C-style binary floating point numbers. Such model files	",
" may be created using the programs unif2 or makevel. The value of nz  ",
" represents the number of samples in the fast (depth) dimesion.	",
"									",
a387 10
	/* input file names */
	char *rhofile="";	/* input density file name */
	char *vpfile="";	/* input P wavespeed file name */
	char *vsfile="";	/* input S wavespeed file name */

	/* input file pointers */
	FILE *rhofp=NULL;	/* pointer to input density file  */
	FILE *vpfp=NULL;	/* pointer to input P wavespeed file */
	FILE *vsfp=NULL;	/* pointer to input S wavespeed file */

a434 4
	/* get names of input density, P and S wavespeeds */
	getparstring("rhofile",&rhofile);
	getparstring("vpfile",&vpfile);
	getparstring("vsfile",&vsfile);
a459 17
	/* if requested, open file for input density */
	if (*rhofile!='\0') {
		if((rhofp=fopen(rhofile,"w"))==NULL)
			err("cannot open rhofile=%s\n",rhofile);
	}

	/*** input files ***/ 
	/* if requested, open file for input P wavespeed  */
	if (*vpfile!='\0') {
		if((vpfp=fopen(vpfile,"w"))==NULL)
			err("cannot open vpfile=%s\n",vpfile);
	}
	/* if requested, open file for input S wavespeed  */
	if (*vsfile!='\0') {
		if((vsfp=fopen(vsfile,"w"))==NULL)
			err("cannot open vsfile=%s\n",vsfile);
	}
@


1.11
log
@changed input parameters and nx and nz
@
text
@d1 1
a1 1
/* SUEA2DF: $Revision: 1.10 $ ; $Date: 2004/12/23 22:43:28 $	    */
d11 1
a11 1
"	    forward modeling						",
d39 1
a39 1
" dx=10.0      		spatial sampling intrval (m) x-coor		",
d52 1
a52 1
" 			 ga: Gaussian	      				",
d93 1
a93 1
" tsw=0		 	switch to use shear stress only in non-fluid    ",
d110 2
a111 2
" Alternatively the user may specfiy the model via the input files:     ",
" rhofile, vpfile, and vsfile. These files are nz by nx arrays of     ",
d141 1
a141 1
 * All rights reserved.		     
d147 1
a147 1
 * probelms for dipping anisotropic layers
d234 2
a235 3
	float dx, float dz, int nxpadded, int nzpadded, int k, float t,
	float fx, float fz,
	segy tr, FILE *sneisfp, int *wbc);
d239 1
a239 1
	segy tr, FILE *fp, int b1, int b2, int ivh);
d245 6
a250 4
void abs_bc_top(float **u, float **w, float **txx, float **tzz, float **txz,
	  int nxpadded, int nzpadded, float *r, int *bc, int *wbc, int ifx, int ilx);
void abs_bc_left(float **u, float **w, float **txx, float **tzz, float **txz,
	  int nxpadded, int nzpadded, float *r, int *bc, int *wbc, int jfz, int jlz);
d252 2
a253 1
	  int nxpadded, int nzpadded, float *r, int *bc, int *wbc, int ifx, int ilx);
d255 8
a262 4
	  int nxpadded, int nzpadded, float *r, int *bc, int *wbc, int jfz, int jlz);
void fs4s_bc_top(float **txx, float **tzz, float **txz, int nxpadded, int nzpadded);
void fs4v_bc_top(float **u, float **w, float **e11, float **e55, int nxpadded, int nzpadded);
void sym4s_bc_top(float **txx, float **tzz, float **txz, int nxpadded, int nzpadded);
d264 2
a265 1
void sym4s_bc_left(float **txx, float **tzz, float **txz, int nxpadded, int nzpadded);
d267 2
a268 1
void sym4s_bc_bot(float **txx, float **tzz, float **txz, int nxpadded, int nzpadded);
d270 2
a271 1
void sym4s_bc_right(float **txx, float **tzz, float **txz, int nxpadded, int nzpadded);
d274 2
a275 2
void calc_area(float vmax, float dtx, float dtz, 
	int *limits, int i, int j, int k, int nxpadded, int nzpadded);
d277 1
a277 1
	float *e15, float *e35, float angle);
d279 2
a280 2
	float **pl, float **zl, float *xl, float x, float dz,
	float fx, float fz, int msw);
d282 4
a285 4
	float fx, float xmax, float fz, float zmax,
	float sx, float sz, float favg, float ts, char *wtype, char *stype,
	int *bc, int qsw, int asw, float xz,
	FILE *fp, int comp, char *mfile);
d287 2
a288 1
void write_grid(float **u, float **w, float **txx, float **tzz, float **txz, int is, int js);
d290 3
a292 3
	float sz, float dx, float dz, int nxpadded, int nzpadded, int k, float t,
	float fx, float fz,
	segy tr, FILE *sneisfp, int *wbc);
d457 1
a457 1
        getparstring("rhofile",&rhofile);
d551 3
a553 7
/* calculate array sizes*/
/*  	nx=NINT((xmax-fx)/dx)+1; */
/*  	nz=NINT((zmax-fz)/dz)+1; */
/*  	  CJ: ADJUSTMENT MADE 030502 - model size reduced to match limits */
/*	nx=NINT((xmax-fx)/dx); */	/*model size*/
/*	nz=NINT((zmax-fz)/dz); */
/*   we now getpar nx and nz, JWS 11 Mar 2005 */ 
a554 2
	nxpadded=nx+wbc[1]+wbc[3];		/*grid size including bc*/
	nzpadded=nz+wbc[0]+wbc[2];
d562 4
a565 4
      	dtx=dt/dx; dtz=dt/dz;
      	energy=0;efac=1000000000000000000./((nxpadded-4)*(nzpadded-4));
      	pfac=1./(dx*dz);
      	is=NINT((-fx+sx)/dx)+wbc[1]; js=NINT((-fz+sz)/dz)+wbc[0];
d568 1
d573 1
a573 1
    	
d580 1
d586 2
a587 1
	nbytes=ngrids*nxpadded*nzpadded*4;
d589 1
d597 3
a599 1
	nbytes=ngrids*nxpadded*nzpadded*4;
d615 1
d619 8
a626 4
	get_econst(rho,e11,e55,q,qsw,e33,e13,e15,e35,asw,
	  dx,dz,nxpadded,nzpadded,fx-wbc[1]*dx,fz-wbc[0]*dz,vlim,msw,efp,mfp);

	fclose(efp); fclose(mfp);
d637 3
a639 3
      	for (j=0; j<nzpadded; ++j) {
	  vl[j]=sqrt(e11[j][wbc[1]]*rho[j][wbc[1]]);
	  vr[j]=sqrt(e11[j][nxpadded-wbc[3]-1]*rho[j][nxpadded-wbc[3]-1]);
d641 2
a642 2
      	for (i=0; i<nxpadded; ++i) {
	  vb[i]=sqrt(e11[nzpadded-wbc[2]-1][i]*rho[nzpadded-wbc[2]-1][i]);
d647 1
d649 6
a654 4
	ttb[0]=(-wbc[1])*sa*dx/vb[wbc[1]];
      	for (i=1; i<nxpadded; ++i) {
	  ttb[i]=ttb[i-1]+dx*sa/vb[i];
	}}
d656 5
a660 4
	ttb[nxpadded-1]=-(-wbc[3])*sa*dx/vl[nxpadded-wbc[3]-1];
      	for (i=nxpadded-1; i>0; --i) {
	  ttb[i-1]=ttb[i]-dx*sa/vb[i];
	}}
d663 4
a666 2
	sa=sin(PI*sang/180.);ca=cos(PI*sang/180.);
	 p=sin(sang*PI/180.)/vl[nzpadded-wbc[2]-1];
d668 4
a671 3
      	for (j=nzpadded-1; j>0; --j) {
	   sa=sin(asin(p*vl[j])); ca=cos(asin(p*vl[j]));
	  ttl[j-1]=ttl[j]+dz*ca/vl[j];
d673 4
a676 2
	sa=sin(PI*sang/180.);ca=cos(PI*sang/180.);
	 p=sin(sang*PI/180.)/vr[nzpadded-wbc[2]-1];
d678 6
a683 20
      	for (j=nzpadded-1; j>0; --j) {
	   sa=sin(asin(p*vr[j])); ca=cos(asin(p*vr[j]));
	  ttr[j-1]=ttr[j]+dz*ca/vr[j];
	}

/*	 	for (j=nzpadded-1; j>=0; --j) { */
/*  	  fprintf(stderr,"%d %f %f %f %f %f\n",j,vl[j],vr[j],ttl[j],ttr[j],ttb[	   j]);} */

/*  	if (*efile!='\0') { */
/*  	  if((efp=fopen(efile,"w+"))==NULL) err("cannot open efile=%s\n",efile);} */
/*  	for (i=0, xmax=fx; i<nxpadded; i++, xmax+=dx) { */
/*  	  for (j=0; j<nzpadded; ++j) fwrite(&e11[j][i], 4, 1, efp);} */
/*  	for (i=0, xmax=fx; i<nxpadded; i++, xmax+=dx) { */
/*  	  for (j=0; j<nzpadded; ++j) fwrite(&e33[j][i], 4, 1, efp);} */
/*  	for (i=0, xmax=fx; i<nxpadded; i++, xmax+=dx) { */
/*  	  for (j=0; j<nzpadded; ++j) fwrite(&e55[j][i], 4, 1, efp);} */
/*  	for (i=0, xmax=fx; i<nxpadded; i++, xmax+=dx) { */
/*  	  for (j=0; j<nzpadded; ++j) fwrite(&e13[j][i], 4, 1, efp);} */
	
/*  	fclose(efp); */
d691 2
a692 1
	fprintf(stdout,"for low dispersion fmax should be < %f \n",vlim[0]/(5*dx));
d701 3
a703 2
 	  fprintf(soeisfp,"%s %s %d %d %f %f\n",wtype,stype,ns,i,favg,ts);
 	  for (i=0; i<ns; i++)fprintf(soeisfp,"%f %f\n",i*dt,source[i]);
d705 4
a708 1
	pfac=1.; for (i=0; i<ns; i++) source[i]*=pfac;
d713 11
a723 6
	nbytes=ngrids*nxpadded*nzpadded*4;
	u = alloc2float(nxpadded,nzpadded); nbytes=nbytes+nxpadded*nzpadded*4;
	w = alloc2float(nxpadded+1,nzpadded); nbytes=nbytes+(nxpadded+1)*nzpadded*4;
	txx = alloc2float(nxpadded+1,nzpadded); nbytes=nbytes+(nxpadded+1)*nzpadded*4;
	tzz = alloc2float(nxpadded+1,nzpadded); nbytes=nbytes+(nxpadded+1)*nzpadded*4;
	txz = alloc2float(nxpadded,nzpadded); nbytes=nbytes+nxpadded*nzpadded*4;
d726 2
a727 1
	fprintf(stdout,"%f MBytes allocated for model + variables\n",0.000001*nbytes);
d731 5
a735 3
	  for (i=0; i<nxpadded; i++){ for (j=0; j<nzpadded; j++) {
		q[j][i]=exp(-PI*dt*favg/q[j][i]); }
	  }	
d739 9
a747 3
	for (i=0; i<nxpadded; i++){ for (j=0; j<nzpadded; j++) {
		u[j][i]=0;w[j][i]=0;txx[j][i]=0;tzz[j][i]=0;txz[j][i]=0; }
	}	
d750 4
a753 2
	strcpy(tfile,hsfile);hcfile=strcat(tfile,".chd");
	if((hchdfp=fopen(hcfile,"w+"))==NULL) err("cannot open hcfile=%s\n",hcfile);
d755 2
a756 2
		sx,sz,favg,ts,wtype,stype,
		bc,qsw,asw,hsz,hchdfp,1,mfile);
d758 1
d760 2
a761 1
	if((vchdfp=fopen(vrshfile,"w+"))==NULL) err("cannot open vrshfile=%s\n",vrshfile);
d763 2
a764 2
		sx,sz,favg,ts,wtype,stype,
		bc,qsw,asw,vsx,vchdfp,2,mfile);
d770 1
d773 12
a784 2
		ifx=limits[0]; ilx=limits[1]; jfz=limits[2]; jlz=limits[3];
		if (strcmp(stype,"pw")==0) {ifx=2;ilx=nxpadded-3;jfz=2; jlz=nzpadded-3;}
d788 2
a789 1
		  if (strcmp(stype,"v")==0) add_v_source(u,w,dt*source[k],is,js);
d794 2
a795 1
			update_vel(ifx,ilx,jfz,jlz,u,w,txx,tzz,txz,rho,e55,dtx,dtz);
d797 2
a798 1
			update_vel_tsw(ifx,ilx,jfz,jlz,u,w,txx,tzz,txz,rho,e55,dtx,dtz);
d801 8
a808 2
		if (strcmp(stype,"pw")==0) {
		  add_pw_source_V(u,w,txx,tzz,txz,e11,e55,source,sang,wbc[1],nxpadded-wbc[3]-1,wbc[0],nzpadded-wbc[2]-1,ns,k,dx,dz,dt,vl,vb,vr,ttl,ttb,ttr);}
d813 21
a833 35
	/* apply symmetry bc for velocities */
	if(bc[0]==1) sym4v_bc_top(u,w,nxpadded,nzpadded);
	if(bc[1]==1) sym4v_bc_left(u,w,nxpadded,nzpadded);
	if(bc[2]==1) sym4v_bc_bot(u,w,nxpadded,nzpadded);
	if(bc[3]==1) sym4v_bc_right(u,w,nxpadded,nzpadded);
	
/* introduce stress source */
	if (k<ns) {
	  if (strcmp(stype,"p")==0) add_p_source(txx,tzz,dt*source[k],is,js);
	}
	
/* update stresses */
	if(asw!=1) update_stress_iso(ifx,ilx,jfz,jlz,u,w,txx,tzz,txz,e11,e55,
		  dtx,dtz);
	if(asw==1) update_stress_ani(ifx,ilx,jfz,jlz,u,w,txx,tzz,txz,
		e11,e55,e33,e13,e15,e35,dtx,dtz);

/* introduce plane wave stress source */
	if (strcmp(stype,"pw")==0) {
	  add_pw_source_S(u,w,txx,tzz,txz,e11,e55,source,sang,wbc[1],nxpadded-wbc[3]-1,wbc[0],nzpadded-wbc[2]-1,ns,k,dx,dz,dt,vl,vb,vr,ttl,ttb,ttr);}

/* apply free surface bc for stresses */
	if(bc[0]==2) fs4s_bc_top(txx,tzz,txz,nxpadded,nzpadded);

/* apply symmetry bc for stresses */
	if(bc[0]==1) sym4s_bc_top(txx,tzz,txz,nxpadded,nzpadded);
	if(bc[1]==1) sym4s_bc_left(txx,tzz,txz,nxpadded,nzpadded);
	if(bc[2]==1) sym4s_bc_bot(txx,tzz,txz,nxpadded,nzpadded);
	if(bc[3]==1) sym4s_bc_right(txx,tzz,txz,nxpadded,nzpadded);

/* apply absorbing bc */
	if(bc[0]>2) abs_bc_top(u,w,txx,tzz,txz,nxpadded,nzpadded,bc0,bc,wbc,ifx,ilx);
	if(bc[1]>2) abs_bc_left(u,w,txx,tzz,txz,nxpadded,nzpadded,bc1,bc,wbc,jfz,jlz);
	if(bc[2]>2) abs_bc_bot(u,w,txx,tzz,txz,nxpadded,nzpadded,bc2,bc,wbc,ifx,ilx);
	if(bc[3]>2) abs_bc_right(u,w,txx,tzz,txz,nxpadded,nzpadded,bc3,bc,wbc,jfz,jlz);
d835 63
a897 18
/* attenuation */
	if(qsw==1) {
	for (j=jfz-2; j<jlz+2; j++){ for (i=ifx-2; i<ilx+2; i++) {
		 u[j][i]*=q[j][i]; w[j][i]*=q[j][i];
		 txx[j][i]*=q[j][i]; tzz[j][i]*=q[j][i]; txz[j][i]*=q[j][i];}
	}}
	
/* "energy" */
	energy=0;
	for (i=ifx; i<ilx; i++){ for (j=jfz; j<jlz; j++) {
		energy=energy+u[j][i]*u[j][i]+w[j][i]*w[j][i]; }
	}
	
/* store wave motion on file (seismograms) */
	for (i=0 ; i < nxpadded ; ++i) fwrite(&u[hs1][i], 4, 1, hseisfp);
	for (i=0 ; i < nxpadded ; ++i) fwrite(&w[hs1][i], 4, 1, hseisfp);
	for (j=0 ; j < nzpadded ; ++j) fwrite(&u[j][vs2], 4, 1, vseisfp);
	for (j=0 ; j < nzpadded ; ++j) fwrite(&w[j][vs2], 4, 1, vseisfp);
d899 25
a923 12
	/* make snapshot */
	for (i=0; i<nsnap; i++) {
		if (!mode) {
			if(k==isnap[i] && *snfile!='\0') {
				make_snap(u,w,sx,sz,dx,dz,nxpadded,nzpadded,k,t,fx,fz,tr,sneisfp,wbc);
		 	} 
		} else {
			if(k==isnap[i] && *snfile!='\0') {
		  		make_stress_snap(txx,tzz,txz,sx,sz,dx,dz,nxpadded,nzpadded,k,t,fx,fz,tr,sneisfp,wbc);
			}
		 }
	 }
a924 3
 	if((verbose==1) && (k%50==0))
		fprintf(stderr,"%d %f %f %d %d %d %d \n",
 			k,t,energy*efac,ifx,ilx,jfz,jlz);
d926 2
a928 4
/*  	if (k>=00 && k<5) write_grid(u, w, txx, tzz, txz, 2, 2); */
/*  	if (k>=00 && k<5) write_grid(u, w, txx, tzz, txz, nxpadded-3, 2); */
	k=k+1;
}		
d931 1
a931 1
/* free space */
d939 1
a939 1
/* read in wave motion from file and make seismograms */
d941 4
a944 1
	ut = alloc2float(nxpadded,nt); wt = alloc2float(nxpadded,nt);
d946 4
a949 4
	for (i=0 ; i < nxpadded ; ++i) 
		fread(&ut[k][i], 4, 1, hseisfp);
	  for (i=0 ; i < nxpadded ; ++i)
		fread(&wt[k][i], 4, 1, hseisfp);
d955 1
a955 1
			trh,hseisfp,wbc[1],wbc[3],1);
d968 4
a971 1
	make_seis(ut,wt,sx,sz,dz,dt,nzpadded,nt,vsx,fx,fz,trv,vseisfp,wbc[0],wbc[2],2);
d987 2
a988 2
	    x=favg*(t-ts/2);xx=x*x;
	    source[i]=(1-2*pi2*(xx))*exp(-pi2*xx);
d991 2
a992 2
	    x=-4*favg*favg*pi2/log(0.1);
	    source[i]=-2*pi2*(t-ts/2)*exp(-x*(t-ts/2)*(t-ts/2));
d995 2
a996 2
	    x=-favg*favg*pi2/log(0.1);
	    source[i]=exp(-x*(t-ts/2)*(t-ts/2));
d999 1
a999 1
	    source[0]=1;
d1002 2
a1003 2
	    source[0]=1;
	    source[1]=1;
d1017 16
a1032 16
      	for (j=jfz; j<=jlz; ++j) {
      	  for (i=ifx; i<=ilx; ++i) {
      	    dtxx = F1*(txx[j][i+1]-txx[j][i])
	      +F2*(txx[j][i+2]-txx[j][i-1]);
	     dtxz = F1*(txz[j+1][i]-txz[j][i])
      	     +F2*(txz[j+2][i]-txz[j-1][i]);
     	    u[j][i] = u[j][i] + ( dtx*dtxx + dtz*dtxz ) * rho[j][i];
      	  }
      	  for (i=ifx; i<=ilx+1; ++i) {
     	    dtzz = F1*(tzz[j][i]-tzz[j-1][i])
      	     +F2*(tzz[j+1][i]-tzz[j-2][i]);
      	    dtzx = F1*(txz[j][i]-txz[j][i-1])
      	     +F2*(txz[j][i+1]-txz[j][i-2]);
      	    w[j][i] = w[j][i] + ( dtx*dtzx + dtz*dtzz ) * rho[j][i];
      	  }
      	}
d1040 28
a1067 28
      	for (j=jfz; j<=jlz; ++j) {
      	  for (i=ifx; i<=ilx; ++i) {
      	    dtxx = F1*(txx[j][i+1]-txx[j][i])
	      +F2*(txx[j][i+2]-txx[j][i-1]);
/*  	    Only use 4th order shear stress derivatives if material is non-fluid, otherwise problems occur at grazing angles near fluid-solid boundary */
      	    if(e55[j][i]>0) { 
	      dtxz = F1*(txz[j+1][i]-txz[j][i])
      	     +F2*(txz[j+2][i]-txz[j-1][i]);
	     }
	    else{
	      dtxz = (txz[j+1][i]-txz[j][i]);
	    }
      	    u[j][i] = u[j][i] + ( dtx*dtxx + dtz*dtxz ) * rho[j][i];
      	  }
      	  for (i=ifx; i<=ilx+1; ++i) {
      	    dtzz = F1*(tzz[j][i]-tzz[j-1][i])
      	     +F2*(tzz[j+1][i]-tzz[j-2][i]);
/*  	    Only use 4th order shear stress derivatives if material is non-fluid, otherwise problems occur at grazing angles near fluid-solid boundary */
      	    if(e55[j][i]>0) { 
      	     dtzx = F1*(txz[j][i]-txz[j][i-1])
      	     +F2*(txz[j][i+1]-txz[j][i-2]);
	     }
	    else{
      	     dtzx = (txz[j][i]-txz[j][i-1]);
	    }
      	    w[j][i] = w[j][i] + ( dtx*dtzx + dtz*dtzz ) * rho[j][i];
      	  }
      	}
d1077 20
a1096 20
      	for (j=jfz; j<=jlz; ++j) {
      	  for (i=ifx; i<=ilx+1; ++i) {
      	    dwz = F1*(w[j+1][i]-w[j][i])
      	     +F2*(w[j+2][i]-w[j-1][i]);
      	    dux = F1*(u[j][i]-u[j][i-1])
      	     +F2*(u[j][i+1]-u[j][i-2]);
      	    txx[j][i] = txx[j][i] +
      	     e11[j][i]*dtx*dux + (e11[j][i]-2*e55[j][i])*dtz*dwz;
      	    tzz[j][i] = tzz[j][i] +
      	     e11[j][i]*dtz*dwz + (e11[j][i]-2*e55[j][i])*dtx*dux;
      	  }
      	  for (i=ifx; i<=ilx; ++i) {
      	    dwx = F1*(w[j][i+1]-w[j][i])
	      +F2*(w[j][i+2]-w[j][i-1]);
      	    duz = F1*(u[j][i]-u[j-1][i])
      	     +F2*(u[j+1][i]-u[j-2][i]);
      	    txz[j][i] = txz[j][i] +
      	     e55[j][i]*(dtz*duz + dtx*dwx);
      	  }
      	}
d1106 1
d1108 53
a1160 35
      	  for (i=ifx; i<=ilx; ++i) {
      	    dwx = F1*(w[j][i+1]-w[j][i])
	      +F2*(w[j][i+2]-w[j][i-1]);
      	    duz = F1*(u[j][i]-u[j-1][i])
      	     +F2*(u[j+1][i]-u[j-2][i]);
      	    dwz = F1*(w[j+1][i]-w[j][i])
      	     +F2*(w[j+2][i]-w[j-1][i]);
      	    dux = F1*(u[j][i]-u[j][i-1])
      	     +F2*(u[j][i+1]-u[j][i-2]);
      	    txx[j][i] = txx[j][i] +
      	     e11[j][i]*dtx*dux + e13[j][i]*dtz*dwz +
	 	     e15[j][i]*(dtz*duz + dtx*dwx);
      	    tzz[j][i] = tzz[j][i] +
      	     e33[j][i]*dtz*dwz + e13[j][i]*dtx*dux +
	 	     e35[j][i]*(dtz*duz + dtx*dwx); 
      	    txz[j][i] = txz[j][i] +
      	     e15[j][i]*dtx*dux + e35[j][i]*dtz*dwz +
      	     e55[j][i]*(dtz*duz + dtx*dwx);
      	  }
	  i=ilx+1;
      	    dwx = F1*(w[j][i+1]-w[j][i])
	      +F2*(w[j][i+2]-w[j][i-1]);
      	    duz = F1*(u[j][i]-u[j-1][i])
      	     +F2*(u[j+1][i]-u[j-2][i]);
      	    dwz = F1*(w[j+1][i]-w[j][i])
      	     +F2*(w[j+2][i]-w[j-1][i]);
      	    dux = F1*(u[j][i]-u[j][i-1])
      	     +F2*(u[j][i+1]-u[j][i-2]);
      	    txx[j][i] = txx[j][i] +
      	     e11[j][i]*dtx*dux + e13[j][i]*dtz*dwz +
	 	     e15[j][i]*(dtz*duz + dtx*dwx);
      	    tzz[j][i] = tzz[j][i] +
      	     e33[j][i]*dtz*dwz + e13[j][i]*dtx*dux +
	 	     e35[j][i]*(dtz*duz + dtx*dwx); 
		}
d1166 2
a1167 2
      txx[j][i] = txx[j][i] + amp;
      tzz[j][i] = tzz[j][i] + amp;
d1172 1
a1172 1
      w[j][i] = w[j][i] + amp*0.000001;
d1182 43
a1224 32
      int i,j;
      float sa, ca, ak, p;
      float tw=0, tu=0, tiw, tiu, tt;
      int ksw, ksu;
      double pi;
      pi=2*acos(0.);
      /* sang = direction of wave propagation relative to vertical */
      
      tt=k*dt;

      /* introduce plane wave on left boundary */
	 p=sin(sang*pi/180.)/vl[jb];
	 for (j=jb+2; j>=jt; --j) {
	   sa=sin(asin(p*vl[j])); ca=cos(asin(p*vl[j]));
	  for (i=il-2; i<il; ++i) {
	   if(sang>=0&&sang<90) { 
	     tw=tt-ttl[j]-(dx*(i-il+0.75)*sa + dz*(-0.25)*ca)/vl[j];
	     tu=tt-ttl[j]-(dx*(i-il+1.25)*sa + dz*(-0.75)*ca)/vl[j];
	   }
	   if(sang>-90&&sang<0) { 
	     tw=tt-ttl[j]-(dx*(i-ir-1.75)*sa + dz*(-0.25)*ca)/vl[j];
	     tu=tt-ttl[j]-(dx*(i-ir-1.25)*sa + dz*(-0.75)*ca)/vl[j];
	   }
	   ksw=floor(tw/dt); tiw=fmod(tw,dt)/dt;
	   ksu=floor(tu/dt); tiu=fmod(tu,dt)/dt;
	    if (ksw>=0 && ksw <ns-1) {
	     ak=(1-tiw)*a[ksw]+tiw*a[ksw+1];w[j][i]=-vl[j]*ak*ca;
	   } 
	    if (ksu>=0 && ksu <ns-1) {
	     ak=(1-tiu)*a[ksu]+tiu*a[ksu+1];u[j][i]=vl[j]*ak*sa;
	   }  
	}}
d1227 35
a1261 22
	 p=sin(sang*pi/180.)/vr[jb];
	 for (j=jb+2; j>=jt; --j) {
	   sa=sin(asin(p*vr[j])); ca=cos(asin(p*vr[j]));
	  for (i=ir+1; i<ir+3; ++i) {
	   if(sang>=0&&sang<90) { 
	     tw=tt-ttr[j]-(dx*(i-il+1.75)*sa + dz*(-0.25)*ca)/vr[j];
	     tu=tt-ttr[j]-(dx*(i-il+1.25)*sa + dz*(-0.75)*ca)/vr[j];
	   }
	   if(sang>-90&&sang<0) { 
	     tw=tt-ttr[j]-(dx*(i-ir-0.75)*sa + dz*(-0.25)*ca)/vr[j];
	     tu=tt-ttr[j]-(dx*(i-ir-1.25)*sa + dz*(-0.75)*ca)/vr[j];
	   } 
	   ksw=floor(tw/dt); tiw=fmod(tw,dt)/dt;
	   ksu=floor(tu/dt); tiu=fmod(tu,dt)/dt;
	    if (ksw>=0 && ksw <ns-1) {
	     ak=(1-tiw)*a[ksw]+tiw*a[ksw+1];w[j][i+1]=-vr[j]*ak*ca;
	   }
	    if (ksu>=0 && ksu <ns-1) {
	     ak=(1-tiu)*a[ksu]+tiu*a[ksu+1];u[j][i]=vr[j]*ak*sa;
	   }
	}}
      
d1266 31
a1296 19
	   sa=sin(asin(p*vb[i])); ca=cos(asin(p*vb[i]));
	  for (j=jb-1; j<jb+3; ++j) {
	   if(sang>=0&&sang<90) { 
	     tw=tt-ttb[i]-(dx*(+0.75)*sa + dz*(jb-j-0.25)*ca)/vb[i];
	     tu=tt-ttb[i]-(dx*(+1.25)*sa + dz*(jb-j-0.75)*ca)/vb[i];
	   }
	   if(sang>-90&&sang<0) { 
	     tw=tt-ttb[i]-(dx*(-1.75)*sa + dz*(jb-j-0.25)*ca)/vb[i];
	     tu=tt-ttb[i]-(dx*(-1.25)*sa + dz*(jb-j-0.75)*ca)/vb[i];
	   }
	   ksw=floor(tw/dt); tiw=fmod(tw,dt)/dt;
	   ksu=floor(tu/dt); tiu=fmod(tu,dt)/dt;
	    if (ksw>=0 && ksw <ns-1) {
	     ak=(1-tiw)*a[ksw]+tiw*a[ksw+1]; w[j][i]=-vb[i]*ak*ca;
	   }
	    if (ksu>=0 && ksu <ns-1) {
	     ak=(1-tiu)*a[ksu]+tiu*a[ksu+1]; u[j][i]=vb[i]*ak*sa;
	   }	   
	}}
d1306 46
a1351 35
      int i,j;
      float sa, ca, ak, p;
      float tw=0, tu=0, tiw, tiu, tt;
      int ksw, ksu;
      double pi;
      pi=2*acos(0.);
      /* sang = direction of wave propagation relative to vertical */
      
      tt=k*dt;

      /* introduce plane wave on left boundary */
	 p=sin(sang*pi/180.)/vl[jb];
	 for (j=jb+2; j>=jt; --j) {
	   sa=sin(asin(p*vl[j])); ca=cos(asin(p*vl[j]));
	  for (i=il-2; i<il; ++i) {
	   if(sang>=0&&sang<90) { 
	     tw=tt-ttl[j]-(dx*(i-il+0.75)*sa + dz*(-0.75)*ca)/vl[j];
	     tu=tt-ttl[j]-(dx*(i-il+1.25)*sa + dz*(-0.25)*ca)/vl[j];
	   }
	   if(sang>-90&&sang<0) { 
	     tw=tt-ttl[j]-(dx*(i-ir-1.75)*sa + dz*(-0.75)*ca)/vl[j];
	     tu=tt-ttl[j]-(dx*(i-ir-1.25)*sa + dz*(-0.25)*ca)/vl[j];
	   }
	   ksw=floor(tw/dt); tiw=fmod(tw,dt)/dt;
	   ksu=floor(tu/dt); tiu=fmod(tu,dt)/dt;
	    if (ksw>=0 && ksw <ns-1) {
	     ak=(1-tiw)*a[ksw]+tiw*a[ksw+1];
	     txx[j][i]=(e11[j][i]*sa*sa+(e11[j][i]-2*e55[j][i])*ca*ca)*ak;
	     tzz[j][i]=(e11[j][i]*ca*ca+(e11[j][i]-2*e55[j][i])*sa*sa)*ak;
	   }
	    if (ksu>=0 && ksu <ns-1) {
	     ak=(1-tiu)*a[ksu]+tiu*a[ksu+1];
	     txz[j][i]=e55[j][i]*(2*ca*sa)*ak;
	   }
	}}
d1355 45
a1399 24
	 for (j=jb+2; j>=jt; --j) {
	   sa=sin(asin(p*vr[j])); ca=cos(asin(p*vr[j]));
	  for (i=ir+1; i<ir+3; ++i) {
	   if(sang>=0&&sang<90) { 
	     tw=tt-ttr[j]-(dx*(i-il+1.75)*sa + dz*(-0.75)*ca)/vr[j];
	     tu=tt-ttr[j]-(dx*(i-il+1.25)*sa + dz*(-0.25)*ca)/vr[j];
	   }
	   if(sang>-90&&sang<0) { 
	     tw=tt-ttr[j]-(dx*(i-ir-0.75)*sa + dz*(-0.75)*ca)/vr[j];
	     tu=tt-ttr[j]-(dx*(i-ir-1.25)*sa + dz*(-0.25)*ca)/vr[j];
	   }
	   ksw=floor(tw/dt); tiw=fmod(tw,dt)/dt;
	   ksu=floor(tu/dt); tiu=fmod(tu,dt)/dt;
	    if (ksw>=0 && ksw <ns-1) {
	     ak=(1-tiw)*a[ksw]+tiw*a[ksw+1];
	     txx[j][i+1]=(e11[j][i]*sa*sa+(e11[j][i]-2*e55[j][i])*ca*ca)*ak;
	     tzz[j][i+1]=(e11[j][i]*ca*ca+(e11[j][i]-2*e55[j][i])*sa*sa)*ak;
	   } else  {txx[j][i+1]=0; tzz[j][i+1]=0; }
	    if (ksu>=0 && ksu <ns-1) {
	     ak=(1-tiu)*a[ksu]+tiu*a[ksu+1];
	     txz[j][i]=e55[j][i]*(2*ca*sa)*ak;
	   } else  {txz[j][i]=0; }
	}}
      
d1401 37
a1437 30
	 p=sin(sang*pi/180.)/vb[il];
	 for (i=il; i<ir+2; ++i){
	   sa=sin(asin(p*vb[i])); ca=cos(asin(p*vb[i]));
	  for (j=jb-1; j<jb+3; ++j) {
	   if(sang>=0&&sang<90) { 
	     tw=tt-ttb[i]-(dx*(+0.75)*sa + dz*(jb-j-0.75)*ca)/vb[i];
	     tu=tt-ttb[i]-(dx*(+1.25)*sa + dz*(jb-j-0.25)*ca)/vb[i];
	   }
	   if(sang>-90&&sang<0) { 
	     tw=tt-ttb[i]-(dx*(-1.75)*sa + dz*(jb-j-0.75)*ca)/vb[i];
	     tu=tt-ttb[i]-(dx*(-1.25)*sa + dz*(jb-j-0.25)*ca)/vb[i];
	   }
	   ksw=floor(tw/dt); tiw=fmod(tw,dt)/dt;
	   ksu=floor(tu/dt); tiu=fmod(tu,dt)/dt;
	    if (ksw>=0 && ksw <ns-1) {
	     ak=(1-tiw)*a[ksw]+tiw*a[ksw+1];
	     txx[j][i]=(e11[j][i]*sa*sa+(e11[j][i]-2*e55[j][i])*ca*ca)*ak;
	     tzz[j][i]=(e11[j][i]*ca*ca+(e11[j][i]-2*e55[j][i])*sa*sa)*ak;
	   } 
	    if (ksu>=0 && ksu <ns-1) {
	     ak=(1-tiu)*a[ksu]+tiu*a[ksu+1];
	     txz[j][i]=e55[j][i]*(2*ca*sa)*ak;
	   }	   
	}}

/*  	if (k>=00 && k<9) write_grid(u, w, txx, tzz, txz, il, jb-2); */
/*  	if (k>=00 && k<9) write_grid(u, w, txx, tzz, txz, ir, jb-2); */
/*  	if (k>=165 && k<180) write_grid(u, w, txx, tzz, txz, il, jb); */
/*  	if (k>=155 && k<170) write_grid(u, w, txx, tzz, txz, il, 80); */
/*  	if (k>=205 && k<215) write_grid(u, w, txx, tzz, txz, ir, jb); */
d1441 3
a1443 3
	float dx, float dz, int nxpadded, int nzpadded, int k, float t,
	float fx, float fz,
	segy tr, FILE *sneisfp, int *wbc)
d1455 1
a1455 1
	tr.ns = nzpadded ;
a1459 1
	tr.delrt = t ;	/*store time of snapshot*/
d1463 1
a1463 1
	tr.duse = 2 ; /*u-component*/
d1465 3
a1467 1
		++tracl; ++tracr;			
d1469 2
a1470 1
		tr.tracl = tracl; tr.tracr = tracr;
d1472 4
a1475 1
		for(j=wbc[0]; j<nzpadded-wbc[2]; ++j){tr.data[j] = u[j][i];}
d1478 1
a1478 1
	tr.duse = 1 ; /*w-component*/
d1480 3
a1482 1
		++tracl; ++tracr;			
d1485 6
a1490 2
		tr.tracl = tracl; tr.tracr = tracr;
		for(j=wbc[0]; j<nzpadded-wbc[2]; ++j){tr.data[j] = w[j][i];}
d1520 1
a1520 1
	tr.duse = 2 ; /*txx-component*/
d1522 3
a1524 1
		++tracl; ++tracr;			
d1526 2
a1527 1
		tr.tracl = tracl; tr.tracr = tracr;
d1529 4
a1532 1
		for(j=wbc[0]; j<nzpadded-wbc[2]; ++j){tr.data[j] = txx[j][i];}
d1535 1
a1535 1
	tr.duse = 1 ; /*tzz-component*/
d1537 3
a1539 1
		++tracl; ++tracr;			
d1543 4
a1546 1
		for(j=wbc[0]; j<nzpadded-wbc[2]; ++j){tr.data[j] = tzz[j][i];}
d1549 1
a1549 1
	tr.duse = 3 ; /*txz-component*/
d1551 3
a1553 1
		++tracl; ++tracr;			
d1555 2
a1556 1
		tr.tracl = tracl; tr.tracr = tracr;
d1558 4
a1561 1
		for(j=wbc[0]; j<nzpadded-wbc[2]; ++j){tr.data[j] = txz[j][i];}
d1570 1
a1570 1
	segy tr, FILE *fp, int b1, int b2, int ivh)
d1578 1
a1578 1
	fprintf(stderr,"%d %d %d %d\n",tr.ns,tr.tracl,tr.tracr,tr.ntr);
d1587 1
d1589 2
a1590 2
	   tr.gelev = -dd ;
	  tr.f2 = fx ;
d1630 3
a1632 1
		fputtr(fp , &tr); k++;
d1678 1
a1678 1
	pi=2*acos(0.0);
d1681 1
a1681 1
/* check input format */
d1716 1
a1716 1
/* get model constants linearly interpolated in depth*/
d1742 9
a1750 9
		    rhol = ealloc2float(nzl,nxl);
		    vpl = ealloc2float(nzl,nxl); 
		    vsl = ealloc2float(nzl,nxl); 
		    if(qsw==1) ql = ealloc2float(nzl,nxl); 
		    if(asw==1) epl = ealloc2float(nzl,nxl); 
		    if(asw==1) dsl = ealloc2float(nzl,nxl); 
		    if(asw==1) anl = ealloc2float(nzl,nxl); 
		    tmp1 = ealloc1float(nzl);
		    tmp2 = ealloc1float(nzl);
d1866 1
a1866 1
/* write model boundaries  */
d1876 4
a1879 3
/*  	  CJ: CORRECTION MADE 010223 - DID NOT CHECK THIS WHEN I MADE UTILITY TO WRITE OUT MODEL BOUNDARIES - SORRY */
/*  	  if(asw==1)
		for (j=0; j<nzl; ++j) */
d1890 1
a1890 1
/* interpolate model laterally (z,x) */
d1897 2
a1898 1
		if(msw!=0) set_layers(nxpadded,nzpadded,tmp[i],nxl,nzl,rhol,zl,xl,x,dz,fx,fz,msw);
d1943 12
a1954 9
	    		if(msw==0) interpovv(nzpadded,nxl,xl,qo,x,tmp[i]);
	    		if(msw!=0) set_layers(nxpadded,nzpadded,tmp[i],nxl,
						nzl,ql,zl,xl,x,
						dz,fx,fz,msw);
	    		for (j=0; j<nzpadded; ++j) 
				fwrite(&tmp[i][j], 4, 1, efp);
	    		for (j=0; j<nzpadded; j++) {q[j][i]=tmp[i][j];
	  		if(tmp[i][j]>vmax) vmax=tmp[i][j];
	  		if(tmp[i][j]<vmin) vmin=tmp[i][j];}
d1956 1
a1956 1
	    	fprintf(stdout,"q %f %f\n",vmin,vmax);
d1958 1
a1958 1
	    
d1966 3
a1968 3
	    		for (j=0; j<nzpadded; ++j) fwrite(&tmp[i][j], 4, 1, efp);
	    		for (j=0; j<nzpadded; j++) e33[j][i]=e11[j][i];
	    		for (j=0; j<nzpadded; j++) {
d1974 1
a1974 1
	    	fprintf(stdout,"ep %f %f\n",vmin,vmax);
d1977 2
a1978 2
	    		if(msw==0) interpovv(nzpadded,nxl,xl,dso,x,tmp[i]);
	    		if(msw!=0) set_layers(nxpadded,nzpadded,tmp[i],nxl,nzl,
d1981 4
a1984 4
	    		for (j=0; j<nzpadded; ++j) fwrite(&tmp[i][j], 4, 1, efp);
	    		for (j=0; j<nzpadded; j++) {
	      			b=2*e55[j][i];
	      			c=e55[j][i]*e55[j][i]
d1989 2
a1990 2
	      			if(tmp[i][j]>vmax) vmax=tmp[i][j];
	      			if(tmp[i][j]<vmin) vmin=tmp[i][j];}}
d1992 1
a1992 1
	    			fprintf(stdout,"ds %f %f\n",vmin,vmax);
d1998 2
a1999 2
	    		for (j=0; j<nzpadded; ++j) fwrite(&tmp[i][j], 4, 1, efp);
	    		for (j=0; j<nzpadded; j++) {
d2005 1
a2005 1
	      			if(tmp[i][j]>vmax) vmax=tmp[i][j];
d2010 1
a2010 1
	    
d2073 1
a2073 1
	    		u[j][i]*=fac;
d2075 1
a2075 1
	    		txx[j][i]*=fac;
d2093 1
a2093 1
	    		u[j][i]*=fac;
d2095 1
a2095 1
	    		txx[j][i]*=fac;
d2113 1
a2113 1
	    		u[j][i]*=fac;
d2115 1
a2115 1
	    		txx[j][i]*=fac;
d2119 1
a2119 1
	}	    
d2132 2
a2133 2
	    		fac=r[(i-nxpadded+wbc[3])];
	    		u[j][i]*=fac;
d2135 1
a2135 1
	    		txx[j][i+1]*=fac;
d2149 1
a2149 1
      		txz[1][i]=0.; txz[0][i]=0.; txz[2][i]=0.;
d2152 2
a2153 2
      		txx[1][i]=0.; txx[0][i]=0.; 
      		tzz[1][i]=-tzz[2][i]; tzz[0][i]=-tzz[3][i];
d2204 3
a2206 3
      		txx[1][i]=txx[2][i];  txx[0][i]=txx[3][i]; 
      		tzz[1][i]=tzz[2][i];  tzz[0][i]=tzz[3][i];
      		txz[1][i]=-txz[3][i]; txz[0][i]=-txz[4][i];
d2217 2
a2218 2
      		u[1][i]=u[2][i];  u[0][i]=u[3][i]; 
      		w[1][i]=-w[3][i]; w[0][i]=-w[4][i];
d2229 3
a2231 3
      		txx[j][nxpadded]=txx[j][nxpadded-4]; txx[j][nxpadded-1]=txx[j][nxpadded-3]; 
      		tzz[j][nxpadded]=tzz[j][nxpadded-4]; tzz[j][nxpadded-1]=tzz[j][nxpadded-3];
      		txz[j][nxpadded-1]=-txz[j][nxpadded-4]; txz[j][nxpadded-2]=-txz[j][nxpadded-3];
d2242 2
a2243 2
      		u[j][nxpadded-1]=-u[j][nxpadded-4]; u[j][nxpadded-2]=-u[j][nxpadded-3]; 
      		w[j][nxpadded]=w[j][nxpadded-4]; w[j][nxpadded-1]=w[j][nxpadded-3];
d2254 3
a2256 3
      		txx[j][1]=txx[j][3]; txx[j][0]=txx[j][4]; 
      		tzz[j][1]=tzz[j][3];  tzz[j][0]=tzz[j][4];
      		txz[j][1]=-txz[j][2]; txz[j][0]=-txz[j][3];
d2267 2
a2268 2
      		u[j][1]=-u[j][2]; u[j][0]=-u[j][3]; 
      		w[j][1]=w[j][3]; w[j][0]=w[j][4];
d2279 6
a2284 6
/*	 	     txx[nzpadded-2][i]=txx[nzpadded-4][i];  txx[nzpadded-1][i]=txx[nzpadded-5][i];  */
/*	 	     tzz[nzpadded-2][i]=-tzz[nzpadded-4][i]; tzz[nzpadded-1][i]=-tzz[nzpadded-5][i]; */
/*	 	     txz[nzpadded-2][i]=-txz[nzpadded-3][i]; txz[nzpadded-1][i]=-txz[nzpadded-4][i];} */
      		txx[nzpadded-2][i]=txx[nzpadded-4][i];  txx[nzpadded-1][i]=txx[nzpadded-5][i]; 
      		tzz[nzpadded-2][i]=tzz[nzpadded-4][i]; tzz[nzpadded-1][i]=tzz[nzpadded-5][i];
      		txz[nzpadded-2][i]=-txz[nzpadded-3][i]; txz[nzpadded-1][i]=-txz[nzpadded-4][i];
d2297 2
a2298 2
      		u[nzpadded-2][i]=u[nzpadded-4][i]; u[nzpadded-1][i]=u[nzpadded-5][i]; 
      		w[nzpadded-2][i]=-w[nzpadded-3][i]; w[nzpadded-1][i]=-w[nzpadded-4][i];
d2305 4
a2308 4
      limits[0] = i - NINT(vmax*k*dtx) - 10;
      limits[1] = i + NINT(vmax*k*dtx) + 10;
      limits[2] = j - NINT(vmax*k*dtz) - 10;
      limits[3] = j + NINT(vmax*k*dtz) + 10;
d2310 1
a2310 1
      if (limits[0] < 2) limits[0] = 2;
d2312 1
a2312 1
      if (limits[1] > nxpadded-3) limits[1] = nxpadded-3;
d2314 1
a2314 1
      if (limits[2] < 2) limits[2] = 2;
d2316 1
a2316 1
      if (limits[3] > nzpadded-3) limits[3] = nzpadded-3;      
d2381 3
a2383 3
	    
	    	/* else if beyond last location constant extrapolate */
	    	} else if (x>=xl[nxl-1]) {
d2386 3
a2388 3
	    
	    		/* else, linearly interpolate */
	    		/* if ( x>xl[0] & x<xl[nxl-1] ) */
d2395 1
a2395 1
	    		/* choose constant layer velocity */
d2398 1
a2398 1
	    		/* interpolate laterally layer velocity */
d2402 2
a2403 2
	/*CJ - 010812: changed line below to fill model properly in depth*/    
/*  	    j2=NINT((z-fz)/dz); if(jl==nzl) j2=nzpadded; */
d2409 1
a2409 1
	    
d2416 1
a2416 1
	    	j1=j2;
@


1.10
log
@put in a factor of dt so that amplitudes are scaled correctly
@
text
@d1 1
a1 1
/* SUEA2DF: $Revision: 1.9 $ ; $Date: 2004/09/21 17:33:03 $	    */
d24 5
d31 8
a38 2
" ft=0.0 		first time (s)			        	",
" lt=1.0 		last time (s)				        ",
d40 1
a40 1
" dz=dx			spatial sampling intrval (m) z-coor		",
d42 3
a44 5
" xmin=-1000		first x coor (m)				",
" xmax=1000		last x coor (m)					",
" zmin=0	 	top z coor (m)  				",
" zmax=1000		bottom z coor (m)		       		",
" sx=0,sz=500		source location (m)  			        ",
d46 4
a49 2
"                       p: P-wave, v: velocity, pw: P plane-wave        ",
" sang=0                for stype='pw': plane wave angle                ",
d51 6
a56 5
" 		        dg: Gaussian derivative 		       	",
" 		        ga: Gaussian             		       	",
" 		        ri: Ricker              		       	",
" 		        sp: spike, sp2: double spike   		       	",
" ts=0.05		source length (s)				",
d58 1
a58 1
" favg=50		source average frequency			",
d61 2
d72 12
d91 1
a91 1
" vsfile='vsp.su'	output file for vertical line of seismograms[nz][nt]",
a92 9
" bc=10,10,10,10 	Top,left,bottom,right boundary condition	",
" 			=0 none						",
" 			=1 symmetry 					",
" 			=2 free surface (top only)			",
" 			>2 absorbing (value indicates width of absorbing",
"			layer	 					",
" bc_a=0.95;	        bc initial taper value for absorbing boundary   ",
" bc_r=0.;	        bc exponential factor for absorbing boundary  	",
" 		        variables are scaled by bc_a*pow(i,-bc_r)       ",
d94 2
a95 2
"                       media - may help reduce dispersion tsw=1. If	",
"                       tsw=0 then standard calculation         	",
d98 1
a98 1
"									",
d101 1
a101 2
" not work, check this file first.		       			",
"									",
d103 1
d107 8
a114 1
" must increase monotonically.						",
d116 2
a117 1
" If qsw=1 a ql array must be specified					",
d119 3
a121 3
" If asw=1 epl,dsl and anl arrays must be specified			",
"	epl and dsl are epsilon and delstar in Thomson (1986, Geophys.) ",
"	anl is the angle the anisotropy makes with the horizontal	",
d125 1
a125 1
"	vsfile								",
d127 1
a127 1
"	vsfile.chd - header for vsfile					",
d141 1
a141 1
 * All rights reserved.                   
d187 1
a187 1
 *       and Levander (1988, Geophysics)
d234 2
a235 2
	float dx, float dz, int nx, int nz, int k, float t,
	float xmin, float zmin,
d239 1
a239 1
	float xmin, float zmin,
d243 2
a244 2
	float dx, float dz, int nx, int nz,
	float xmin, float zmin,
d247 1
a247 1
	  int nx, int nz, float *r, int *bc, int *wbc, int ifx, int ilx);
d249 1
a249 1
	  int nx, int nz, float *r, int *bc, int *wbc, int jfz, int jlz);
d251 1
a251 1
	  int nx, int nz, float *r, int *bc, int *wbc, int ifx, int ilx);
d253 11
a263 11
	  int nx, int nz, float *r, int *bc, int *wbc, int jfz, int jlz);
void fs4s_bc_top(float **txx, float **tzz, float **txz, int nx, int nz);
void fs4v_bc_top(float **u, float **w, float **e11, float **e55, int nx, int nz);
void sym4s_bc_top(float **txx, float **tzz, float **txz, int nx, int nz);
void sym4v_bc_top(float **u, float **w, int nx, int nz);
void sym4s_bc_left(float **txx, float **tzz, float **txz, int nx, int nz);
void sym4v_bc_left(float **u, float **w, int nx, int nz);
void sym4s_bc_bot(float **txx, float **tzz, float **txz, int nx, int nz);
void sym4v_bc_bot(float **u, float **w, int nx, int nz);
void sym4s_bc_right(float **txx, float **tzz, float **txz, int nx, int nz);
void sym4v_bc_right(float **u, float **w, int nx, int nz);
d266 1
a266 1
	int *limits, int i, int j, int k, int nx, int nz);
d269 1
a269 1
void set_layers(int nx, int nz, float *tmp, int nxl, int nzl, 
d271 3
a273 3
	float xmin, float zmin, int msw);
void write_chd(int nx, int nz, int nt, float dx, float dz, float dt,
	float xmin, float xmax, float zmin, float zmax,
d280 2
a281 2
	float sz, float dx, float dz, int nx, int nz, int k, float t,
	float xmin, float zmin,
d293 1
a293 1
	float xmin;		/* min x coor		 	*/
d295 1
a295 1
	float zmin;		/* min z coor		 	*/
d308 5
a312 5
	int nt;			/* number of time samples 	*/
	int nz;			/* number of z samples m+bc	*/
	int nx;			/* number of x samples m+bc	*/
	int nzm;		/* number of z samples of model */
	int nxm;		/* number of x samples of model	*/
d317 1
d324 2
d330 1
a330 1
	int asw;		/* switch to include anisotropy */
a339 1
	int verbose;		/* is verbose? 			*/
d346 2
d352 2
a353 2
	char *vsfile="";	/* vert receiver seismogram line file  name */
	char *vcfile=NULL;	/* vert receiver seismogram header file name */
d389 9
d407 3
d411 4
d416 5
d422 5
a426 6
	if (!getparfloat("xmin",&xmin)) xmin = -1000;
	if (!getparfloat("xmax",&xmax)) xmax = 1000;
	if (!getparfloat("zmin",&zmin)) zmin = 0;
	if (!getparfloat("zmax",&zmax)) zmax = 1000;
	if (!getparfloat("sx",&sx)) sx = (xmin+xmax)/2;
	if (!getparfloat("sz",&sz)) sz = (zmin+zmax)/2;
d429 2
d434 1
d442 1
d445 5
d461 1
a461 1
	fprintf(stdout,"input\n");
d475 18
d527 1
a527 1
	hs1 = NINT( (hsz - zmin)/dz )+wbc[0];		/*horizontal line*/
d529 1
a529 1
	vs2 = NINT((vsx - xmin)/dx )+wbc[1];		/*vertical line*/
d532 1
a532 1
	if (!getparstring("vsfile",&vsfile)) vsfile="vsp.su";
d536 4
a539 2
	if((hseisfp=fopen(hsfile,"w+"))==NULL) err("cannot open hsfile=%s\n",hsfile);
	if((vseisfp=fopen(vsfile,"w+"))==NULL) err("cannot open vsfile=%s\n",vsfile);
d542 2
a543 2
/*  	nxm=NINT((xmax-xmin)/dx)+1; */
/*  	nzm=NINT((zmax-zmin)/dz)+1; */
d545 6
a550 4
	nxm=NINT((xmax-xmin)/dx);	/*model size*/
	nzm=NINT((zmax-zmin)/dz);
	nx=nxm+wbc[1]+wbc[3];		/*grid size including bc*/
	nz=nzm+wbc[0]+wbc[2];
d553 1
a553 1
	fprintf(stdout,"nx=%d nz=%d nt=%d\n",nx,nz,nt);
d559 1
a559 1
      	energy=0;efac=1000000000000000000./((nx-4)*(nz-4));
d561 1
a561 1
      	is=NINT((-xmin+sx)/dx)+wbc[1]; js=NINT((-zmin+sz)/dz)+wbc[0];
d563 2
a564 1
 	if((sx<xmin) || (sx>xmax))
d566 1
a566 1
 	if((sz<zmin) || (sz>zmax))
d570 3
a572 3
	e11 = alloc2float(nx,nz);
	e55 = alloc2float(nx,nz);
	rho = alloc2float(nx,nz);
d574 8
a581 2
	if(qsw==1) {q = alloc2float(nx,nz); ngrids+=1;}
	nbytes=ngrids*nx*nz*4;
d583 4
a586 4
		e33 = alloc2float(nx,nz);
		e13 = alloc2float(nx,nz);
		e15 = alloc2float(nx,nz);
		e35 = alloc2float(nx,nz);
d589 1
a589 1
	nbytes=ngrids*nx*nz*4;
d596 2
a597 1
		if((efp=fopen(efile,"w+"))==NULL) err("cannot open efile=%s\n",efile);
d602 6
a607 2
	strcpy(tfile,hsfile);;mfile=strcat(tfile,".mod");
	if((mfp=fopen(mfile,"w+"))==NULL) err("cannot open mfile=%s\n",mfile);
d609 2
a610 1
	  dx,dz,nx,nz,xmin-wbc[1]*dx,zmin-wbc[0]*dz,vlim,msw,efp,mfp);
d614 6
a619 6
	ttl = alloc1float(nz); 
	ttb = alloc1float(nx);
	ttr = alloc1float(nz);
	vl = alloc1float(nz);
	vb = alloc1float(nx);
	vr = alloc1float(nz);
d622 1
a622 1
      	for (j=0; j<nz; ++j) {
d624 1
a624 1
	  vr[j]=sqrt(e11[j][nx-wbc[3]-1]*rho[j][nx-wbc[3]-1]);
d626 2
a627 2
      	for (i=0; i<nx; ++i) {
	  vb[i]=sqrt(e11[nz-wbc[2]-1][i]*rho[nz-wbc[2]-1][i]);
d634 1
a634 1
      	for (i=1; i<nx; ++i) {
d638 2
a639 2
	ttb[nx-1]=-(-wbc[3])*sa*dx/vl[nx-wbc[3]-1];
      	for (i=nx-1; i>0; --i) {
d645 4
a648 4
        p=sin(sang*PI/180.)/vl[nz-wbc[2]-1];
	ttl[nz-1]=(-wbc[2])*ca*dz/vl[nz-wbc[2]-1];
      	for (j=nz-1; j>0; --j) {
          sa=sin(asin(p*vl[j])); ca=cos(asin(p*vl[j]));
d652 4
a655 4
        p=sin(sang*PI/180.)/vr[nz-wbc[2]-1];
	ttr[nz-1]=(-wbc[2])*ca*dz/vr[nz-wbc[2]-1];
      	for (j=nz-1; j>0; --j) {
          sa=sin(asin(p*vr[j])); ca=cos(asin(p*vr[j]));
d659 2
a660 2
/*        	for (j=nz-1; j>=0; --j) { */
/*  	  fprintf(stderr,"%d %f %f %f %f %f\n",j,vl[j],vr[j],ttl[j],ttr[j],ttb[          j]);} */
d664 8
a671 8
/*  	for (i=0, xmax=xmin; i<nx; i++, xmax+=dx) { */
/*  	  for (j=0; j<nz; ++j) fwrite(&e11[j][i], 4, 1, efp);} */
/*  	for (i=0, xmax=xmin; i<nx; i++, xmax+=dx) { */
/*  	  for (j=0; j<nz; ++j) fwrite(&e33[j][i], 4, 1, efp);} */
/*  	for (i=0, xmax=xmin; i<nx; i++, xmax+=dx) { */
/*  	  for (j=0; j<nz; ++j) fwrite(&e55[j][i], 4, 1, efp);} */
/*  	for (i=0, xmax=xmin; i<nx; i++, xmax+=dx) { */
/*  	  for (j=0; j<nz; ++j) fwrite(&e13[j][i], 4, 1, efp);} */
d698 6
a703 6
	nbytes=ngrids*nx*nz*4;
	u = alloc2float(nx,nz); nbytes=nbytes+nx*nz*4;
	w = alloc2float(nx+1,nz); nbytes=nbytes+(nx+1)*nz*4;
	txx = alloc2float(nx+1,nz); nbytes=nbytes+(nx+1)*nz*4;
	tzz = alloc2float(nx+1,nz); nbytes=nbytes+(nx+1)*nz*4;
	txz = alloc2float(nx,nz); nbytes=nbytes+nx*nz*4;
d710 1
a710 1
	  for (i=0; i<nx; i++){ for (j=0; j<nz; j++) {
d716 1
a716 1
	for (i=0; i<nx; i++){ for (j=0; j<nz; j++) {
d723 1
a723 1
	write_chd(nx,nz,nt,dx,dz,dt,xmin,xmax,zmin,zmax,
d727 3
a729 3
	strcpy(tfile,vsfile);vcfile=strcat(tfile,".chd");
	if((vchdfp=fopen(vcfile,"w+"))==NULL) err("cannot open vcfile=%s\n",vcfile);
	write_chd(nx,nz,nt,dx,dz,dt,xmin,xmax,zmin,zmax,
d738 1
a738 1
		calc_area(vlim[1],dtx,dtz,limits,is,js,k,nx,nz);
d740 1
a740 1
		if (strcmp(stype,"pw")==0) {ifx=2;ilx=nx-3;jfz=2; jlz=nz-3;}
d755 1
a755 1
		  add_pw_source_V(u,w,txx,tzz,txz,e11,e55,source,sang,wbc[1],nx-wbc[3]-1,wbc[0],nz-wbc[2]-1,ns,k,dx,dz,dt,vl,vb,vr,ttl,ttb,ttr);}
d758 1
a758 1
		if(bc[0]==2) fs4v_bc_top(u,w,e11,e55,nx,nz);
d761 4
a764 4
	if(bc[0]==1) sym4v_bc_top(u,w,nx,nz);
	if(bc[1]==1) sym4v_bc_left(u,w,nx,nz);
	if(bc[2]==1) sym4v_bc_bot(u,w,nx,nz);
	if(bc[3]==1) sym4v_bc_right(u,w,nx,nz);
d773 1
a773 1
                dtx,dtz);
d779 1
a779 1
	  add_pw_source_S(u,w,txx,tzz,txz,e11,e55,source,sang,wbc[1],nx-wbc[3]-1,wbc[0],nz-wbc[2]-1,ns,k,dx,dz,dt,vl,vb,vr,ttl,ttb,ttr);}
d782 1
a782 1
	if(bc[0]==2) fs4s_bc_top(txx,tzz,txz,nx,nz);
d785 4
a788 4
	if(bc[0]==1) sym4s_bc_top(txx,tzz,txz,nx,nz);
	if(bc[1]==1) sym4s_bc_left(txx,tzz,txz,nx,nz);
	if(bc[2]==1) sym4s_bc_bot(txx,tzz,txz,nx,nz);
	if(bc[3]==1) sym4s_bc_right(txx,tzz,txz,nx,nz);
d791 4
a794 4
	if(bc[0]>2) abs_bc_top(u,w,txx,tzz,txz,nx,nz,bc0,bc,wbc,ifx,ilx);
	if(bc[1]>2) abs_bc_left(u,w,txx,tzz,txz,nx,nz,bc1,bc,wbc,jfz,jlz);
	if(bc[2]>2) abs_bc_bot(u,w,txx,tzz,txz,nx,nz,bc2,bc,wbc,ifx,ilx);
	if(bc[3]>2) abs_bc_right(u,w,txx,tzz,txz,nx,nz,bc3,bc,wbc,jfz,jlz);
d810 4
a813 4
	for (i=0 ; i < nx ; ++i) fwrite(&u[hs1][i], 4, 1, hseisfp);
	for (i=0 ; i < nx ; ++i) fwrite(&w[hs1][i], 4, 1, hseisfp);
	for (j=0 ; j < nz ; ++j) fwrite(&u[j][vs2], 4, 1, vseisfp);
	for (j=0 ; j < nz ; ++j) fwrite(&w[j][vs2], 4, 1, vseisfp);
d819 1
a819 1
				make_snap(u,w,sx,sz,dx,dz,nx,nz,k,t,xmin,zmin,tr,sneisfp,wbc);
d823 1
a823 1
		  		make_stress_snap(txx,tzz,txz,sx,sz,dx,dz,nx,nz,k,t,xmin,zmin,tr,sneisfp,wbc);
d834 1
a834 1
/*  	if (k>=00 && k<5) write_grid(u, w, txx, tzz, txz, nx-3, 2); */
d849 1
a849 1
	ut = alloc2float(nx,nt); wt = alloc2float(nx,nt);
d851 13
a863 6
	  for (i=0 ; i < nx ; ++i) fread(&ut[k][i], 4, 1, hseisfp);
	  for (i=0 ; i < nx ; ++i) fread(&wt[k][i], 4, 1, hseisfp);
	}
	fclose(hseisfp); hseisfp=fopen(hsfile,"w");
	make_seis(ut,wt,sx,sz,dx,dt,nx,nt,hsz,xmin,zmin,trh,hseisfp,wbc[1],wbc[3],1);
	fclose(hseisfp); free2float(ut); free2float(wt);
d867 1
a867 1
	ut = alloc2float(nz,nt); wt = alloc2float(nz,nt);
d869 2
a870 2
	  for (j=0 ; j < nz ; ++j) fread(&ut[k][j], 4, 1, vseisfp);
	  for (j=0 ; j < nz ; ++j) fread(&wt[k][j], 4, 1, vseisfp);
d872 2
a873 2
	fclose(vseisfp); vseisfp=fopen(vsfile,"w");
	make_seis(ut,wt,sx,sz,dz,dt,nz,nt,vsx,xmin,zmin,trv,vseisfp,wbc[0],wbc[2],2);
d887 1
a887 2
	while (i<ns)
	{
d922 2
a923 2
             +F2*(txx[j][i+2]-txx[j][i-1]);
            dtxz = F1*(txz[j+1][i]-txz[j][i])
d945 1
a945 1
             +F2*(txx[j][i+2]-txx[j][i-1]);
d948 1
a948 1
             dtxz = F1*(txz[j+1][i]-txz[j][i])
d950 1
a950 1
            }
d952 1
a952 1
             dtxz = (txz[j+1][i]-txz[j][i]);
d963 1
a963 1
            }
d992 1
a992 1
             +F2*(w[j][i+2]-w[j][i-1]);
d1011 1
a1011 1
             +F2*(w[j][i+2]-w[j][i-1]);
d1020 1
a1020 1
        	     e15[j][i]*(dtz*duz + dtx*dwx);
d1023 1
a1023 1
        	     e35[j][i]*(dtz*duz + dtx*dwx); 
d1030 1
a1030 1
             +F2*(w[j][i+2]-w[j][i-1]);
d1039 1
a1039 1
        	     e15[j][i]*(dtz*duz + dtx*dwx);
d1042 2
a1043 2
        	     e35[j][i]*(dtz*duz + dtx*dwx); 
       	}
d1059 5
a1063 1
void add_pw_source_V(float **u, float **w, float **txx, float **tzz, float **txz, float **e11, float **e55, float *a, float sang, int il, int ir, int jt, int jb, int ns, int k, float dx, float dz, float dt, float *vl, float *vb, float *vr, float *ttl, float *ttb, float *ttr)
d1076 3
a1078 3
        p=sin(sang*pi/180.)/vl[jb];
        for (j=jb+2; j>=jt; --j) {
          sa=sin(asin(p*vl[j])); ca=cos(asin(p*vl[j]));
d1090 1
a1090 1
           if (ksw>=0 && ksw <ns-1) {
d1093 1
a1093 1
           if (ksu>=0 && ksu <ns-1) {
d1099 3
a1101 3
        p=sin(sang*pi/180.)/vr[jb];
        for (j=jb+2; j>=jt; --j) {
          sa=sin(asin(p*vr[j])); ca=cos(asin(p*vr[j]));
d1113 1
a1113 1
           if (ksw>=0 && ksw <ns-1) {
d1116 1
a1116 1
           if (ksu>=0 && ksu <ns-1) {
d1122 4
a1125 4
        if(sang>=0&&sang<90) p=sin(sang*pi/180.)/vb[il];
        if(sang>-90&&sang<0) p=sin(sang*pi/180.)/vb[ir];
        for (i=il; i<ir+2; ++i){
          sa=sin(asin(p*vb[i])); ca=cos(asin(p*vb[i]));
d1137 1
a1137 1
           if (ksw>=0 && ksw <ns-1) {
d1140 1
a1140 1
           if (ksu>=0 && ksu <ns-1) {
d1143 1
a1143 1
       }}
d1147 5
a1151 1
void add_pw_source_S(float **u, float **w, float **txx, float **tzz, float **txz, float **e11, float **e55, float *a, float sang, int il, int ir, int jt, int jb, int ns, int k, float dx, float dz, float dt, float *vl, float *vb, float *vr, float *ttl, float *ttb, float *ttr)
d1164 3
a1166 3
        p=sin(sang*pi/180.)/vl[jb];
        for (j=jb+2; j>=jt; --j) {
          sa=sin(asin(p*vl[j])); ca=cos(asin(p*vl[j]));
d1178 1
a1178 1
           if (ksw>=0 && ksw <ns-1) {
d1183 1
a1183 1
           if (ksu>=0 && ksu <ns-1) {
d1190 3
a1192 3
        p=sin(sang*pi/180.)/vr[jb];
        for (j=jb+2; j>=jt; --j) {
          sa=sin(asin(p*vr[j])); ca=cos(asin(p*vr[j]));
d1204 1
a1204 1
           if (ksw>=0 && ksw <ns-1) {
d1209 1
a1209 1
           if (ksu>=0 && ksu <ns-1) {
d1216 3
a1218 3
        p=sin(sang*pi/180.)/vb[il];
        for (i=il; i<ir+2; ++i){
          sa=sin(asin(p*vb[i])); ca=cos(asin(p*vb[i]));
d1230 1
a1230 1
           if (ksw>=0 && ksw <ns-1) {
d1235 1
a1235 1
           if (ksu>=0 && ksu <ns-1) {
d1239 1
a1239 1
       }}
d1249 4
a1252 3
	float dx, float dz, int nx, int nz, int k, float t,
	float xmin, float zmin,
	segy tr, FILE *sneisfp, int *wbc){
d1263 1
a1263 1
	tr.ns = nz ;
d1266 2
a1267 2
	tr.f1 = zmin ;
	tr.f2 = xmin ;
d1273 1
a1273 1
	for (i=wbc[1] ; i < nx-wbc[3] ; ++i){
d1275 1
a1275 1
		tr.gx = xmin+dx*(i-wbc[1]);
d1278 1
a1278 1
		for(j=wbc[0]; j<nz-wbc[2]; ++j){tr.data[j] = u[j][i];}
d1282 1
a1282 1
	for (i=wbc[1] ; i < nx-wbc[3] ; ++i){
d1284 1
a1284 1
		tr.gx = xmin+dx*(i-wbc[1]);
d1287 1
a1287 1
		for(j=wbc[0]; j<nz-wbc[2]; ++j){tr.data[j] = w[j][i];}
d1294 4
a1297 3
	float dx, float dz, int nx, int nz, int k, float t,
	float xmin, float zmin,
	segy tr, FILE *sneisfp, int *wbc){
d1308 1
a1308 1
	tr.ns = nz ;
d1311 2
a1312 2
	tr.f1 = zmin ;
	tr.f2 = xmin ;
d1318 1
a1318 1
	for (i=wbc[1] ; i < nx-wbc[3] ; ++i){
d1320 1
a1320 1
		tr.gx = xmin+dx*(i-wbc[1]);
d1323 1
a1323 1
		for(j=wbc[0]; j<nz-wbc[2]; ++j){tr.data[j] = txx[j][i];}
d1327 1
a1327 1
	for (i=wbc[1] ; i < nx-wbc[3] ; ++i){
d1329 1
a1329 1
		tr.gx = xmin+dx*(i-wbc[1]);
d1332 1
a1332 1
		for(j=wbc[0]; j<nz-wbc[2]; ++j){tr.data[j] = tzz[j][i];}
d1336 1
a1336 1
	for (i=wbc[1] ; i < nx-wbc[3] ; ++i){
d1338 1
a1338 1
		tr.gx = xmin+dx*(i-wbc[1]);
d1341 1
a1341 1
		for(j=wbc[0]; j<nz-wbc[2]; ++j){tr.data[j] = txz[j][i];}
d1349 3
a1351 2
        float xmin, float zmin,
	segy tr, FILE *fp, int b1, int b2, int ivh){
d1358 2
a1359 1
        fprintf(stderr,"%d %d %d %d\n",tr.ns,tr.tracl,tr.tracr,tr.ntr);
d1368 2
a1369 2
          tr.gelev = -dd ;
	  tr.f2 = xmin ;
d1373 1
a1373 1
	  tr.f2 = zmin ;
d1382 1
a1382 1
		  tr.gx = xmin+dn*k ;
d1386 1
a1386 1
		  tr.gelev = zmin-dn*k ;
d1389 1
a1389 1
	        for(j=0; j<nt; ++j){tr.data[j] = ut[j][i];}
d1397 1
d1399 2
a1400 2
		  tr.gx = xmin+dn*k ;
		  tr.offset = tr.gx-tr.sx ;
d1403 5
a1407 2
		  tr.gelev = zmin-dn*k ;
		  tr.offset = tr.sx-tr.gelev ;
a1408 1
		for(j=0; j<nt; ++j){tr.data[j] = wt[j][i];}
d1415 3
a1417 3
	float dx, float dz, int nx, int nz,
	float xmin, float zmin,
	float *vlim, int msw, FILE *efp, FILE *mfp){
d1494 4
a1497 4
	vpo = alloc2float(nz,nxl);
	vso = alloc2float(nz,nxl);
	rhoo = alloc2float(nz,nxl);
	if(qsw==1) qo = alloc2float(nz,nxl);
d1499 3
a1501 3
		epo = alloc2float(nz,nxl);
		dso = alloc2float(nz,nxl);
		ano = alloc2float(nz,nxl);
d1514 1
a1514 2
		fprintf(stdout,"%d %d %d %d %d %d %d %d nzl nvpl nvsl nrhol nql nepl ndsl nanl\n",
		  nzl, nvpl, nvsl, nrhol, nql, nepl, ndsl, nanl);
d1518 10
a1527 10
		 zl = ealloc2float(nzl,nxl);	
		 rhol = ealloc2float(nzl,nxl);
		 vpl = ealloc2float(nzl,nxl); 
		 vsl = ealloc2float(nzl,nxl); 
		 if(qsw==1) ql = ealloc2float(nzl,nxl); 
		 if(asw==1) epl = ealloc2float(nzl,nxl); 
		 if(asw==1) dsl = ealloc2float(nzl,nxl); 
		 if(asw==1) anl = ealloc2float(nzl,nxl); 
		 tmp1 = ealloc1float(nzl);
		 tmp2 = ealloc1float(nzl);
d1530 3
a1532 1
		getnparfloat(i+1,"zl",tmp1); for (j=0;j<nzl;++j) zl[i][j]=tmp1[j];
d1534 2
a1535 1
		  if (zl[i][j]<=zl[i][j-1]) err("zl must increase monotonically");}
d1537 33
a1569 14
		if (nrhol!=nzl) err("number of rhol and zl values must be equal");
		getnparfloat(i+1,"rhol",tmp2); for (j=0;j<nzl;++j) rhol[i][j]=tmp2[j];
		for (j=0,zint=zmin; j<nz; ++j,zint+=dz) {
		  intlin(nzl,tmp1,tmp2,rhol[i][0],rhol[i][nzl-1],1,&zint,&pint); rhoo[i][j]=pint;}

		if (nvpl!=nzl) err("number of vpl and zl values must be equal");
		getnparfloat(i+1,"vpl",tmp2); for (j=0;j<nzl;++j) vpl[i][j]=tmp2[j];
		for (j=0,zint=zmin; j<nz; ++j,zint+=dz) {
		  intlin(nzl,tmp1,tmp2,vpl[i][0],vpl[i][nzl-1],1,&zint,&pint); vpo[i][j]=pint;}

		if (nvsl!=nzl) err("number of vsl and zl values must be equal");
		getnparfloat(i+1,"vsl",tmp2); for (j=0;j<nzl;++j) vsl[i][j]=tmp2[j];
		for (j=0,zint=zmin; j<nz; ++j,zint+=dz) {
		  intlin(nzl,tmp1,tmp2,vsl[i][0],vsl[i][nzl-1],1,&zint,&pint); vso[i][j]=pint;}
d1572 10
a1581 4
		if (nql!=nzl) err("number of ql and zl values must be equal");
		getnparfloat(i+1,"ql",tmp2); for (j=0;j<nzl;++j) ql[i][j]=tmp2[j];
		for (j=0,zint=zmin; j<nz; ++j,zint+=dz) {
		  intlin(nzl,tmp1,tmp2,ql[i][0],ql[i][nzl-1],1,&zint,&pint); qo[i][j]=pint;}
d1585 6
a1590 2
		  b=0; if(qsw==1) b=ql[i][j];
		  fprintf(mfp,"%d %f %f %f %f %f\n",j+1,zl[i][j],rhol[i][j],vpl[i][j],vsl[i][j],b);}
d1593 36
a1628 18
		if (nepl!=nzl) err("number of epl and zl values must be equal");
		getnparfloat(i+1,"epl",tmp2); for (j=0;j<nzl;++j) epl[i][j]=tmp2[j];
		for (j=0,zint=zmin; j<nz; ++j,zint+=dz) {
		  intlin(nzl,tmp1,tmp2,epl[i][0],epl[i][nzl-1],1,&zint,&pint); epo[i][j]=pint;}

		if (ndsl!=nzl) err("number of dsl and zl values must be equal");
		getnparfloat(i+1,"dsl",tmp2); for (j=0;j<nzl;++j) dsl[i][j]=tmp2[j];
		for (j=0,zint=zmin; j<nz; ++j,zint+=dz) {
		  intlin(nzl,tmp1,tmp2,dsl[i][0],dsl[i][nzl-1],1,&zint,&pint); dso[i][j]=pint;}

		if (nanl!=nzl) err("number of anl and zl values must be equal");
		getnparfloat(i+1,"anl",tmp2); for (j=0;j<nzl;++j) anl[i][j]=tmp2[j];
		for (j=0,zint=zmin; j<nz; ++j,zint+=dz) {
		  intlin(nzl,tmp1,tmp2,anl[i][0],anl[i][nzl-1],1,&zint,&pint); ano[i][j]=pint;}

		for (j=0; j<nzl; ++j){
		  fprintf(mfp,"%d %f %f %f %f \n",j+1,zl[i][j],epl[i][j],dsl[i][j],anl[i][j]);
		  anl[i][j]=anl[i][j]*pi/180.0;}
d1634 6
a1639 3
			  if(vpl[i][j]*(1+epl[i][j])>vmax){
			  vmax=vpl[i][j]*(1+epl[i][j]);}}
			if(vsl[i][j]<vmin) vmin=vsl[i][j];}
d1646 7
a1652 5
	  fprintf(stdout,"& && %d\n",j+1);
	  if(asw==0) for (i=0; i<nxl; ++i){
	   fprintf(stdout,"& %f %f %f %f %f \n",xl[i],zl[i][j],vpl[i][j],
		   vsl[i][j],rhol[i][j]);
          }
d1654 11
a1664 6
/*  	  if(asw==1) for (j=0; j<nzl; ++j){ */
	  if(asw==1) for (i=0; i<nxl; ++i){
	   fprintf(stdout,"& %f %f %f %f %f %f %f %f\n",xl[i],zl[i][j]
	     ,vpl[i][j],vsl[i][j],rhol[i][j],epl[i][j],dsl[i][j],anl[i][j]);
          }
	}
d1667 1
a1667 1
	tmp = alloc2float(nz,nx);
d1671 13
a1683 8
	for (i=0, x=xmin; i<nx; i++, x+=dx) {
	  if(msw==0) interpovv(nz,nxl,xl,rhoo,x,tmp[i]);
	  if(msw!=0) set_layers(nx,nz,tmp[i],nxl,nzl,rhol,zl,xl,x,dz,xmin,zmin,msw);
	  for (j=0; j<nz; ++j) fwrite(&tmp[i][j], 4, 1, efp);
	  for (j=0; j<nz; j++) {rho[j][i]=tmp[i][j];
	  	if(tmp[i][j]>vmax) vmax=tmp[i][j];
	  	if(tmp[i][j]<vmin) vmin=tmp[i][j];}}
	  fprintf(stdout,"rho %f %f\n",vmin,vmax);
d1685 12
a1696 8
	for (i=0, x=xmin; i<nx; i++, x+=dx) {
	  if(msw==0) interpovv(nz,nxl,xl,vpo,x,tmp[i]);
	  if(msw!=0) set_layers(nx,nz,tmp[i],nxl,nzl,vpl,zl,xl,x,dz,xmin,zmin,msw);
	  for (j=0; j<nz; ++j) fwrite(&tmp[i][j], 4, 1, efp);
	  for (j=0; j<nz; j++) {e11[j][i]=tmp[i][j]*tmp[i][j]*rho[j][i];
	  	if(tmp[i][j]>vmax) vmax=tmp[i][j];
	  	if(tmp[i][j]<vmin) vmin=tmp[i][j];}}
	  fprintf(stdout,"vp %f %f\n",vmin,vmax);
d1698 16
a1713 10
	for (i=0, x=xmin; i<nx; i++, x+=dx) {
	  if(msw==0) interpovv(nz,nxl,xl,vso,x,tmp[i]);
	  if(msw!=0) set_layers(nx,nz,tmp[i],nxl,nzl,vsl,zl,xl,x,dz,xmin,zmin,msw);
	  for (j=0; j<nz; ++j) fwrite(&tmp[i][j], 4, 1, efp);
	  for (j=0; j<nz; j++) {e55[j][i]=tmp[i][j]*tmp[i][j]*rho[j][i];
	  	if(tmp[i][j]>vmax) vmax=tmp[i][j];
	  	if(tmp[i][j]<vmin) vmin=tmp[i][j];}}
	  fprintf(stdout,"vs %f %f\n",vmin,vmax);
	for (i=0, x=xmin; i<nx; i++, x+=dx) {
	  for (j=0; j<nz; j++) rho[j][i]=1/rho[j][i];}
d1716 13
a1728 9
	  vmin=10000000;vmax=0;
	  for (i=0, x=xmin; i<nx; i++, x+=dx) {
	    if(msw==0) interpovv(nz,nxl,xl,qo,x,tmp[i]);
	    if(msw!=0) set_layers(nx,nz,tmp[i],nxl,nzl,ql,zl,xl,x,dz,xmin,zmin,msw);
	    for (j=0; j<nz; ++j) fwrite(&tmp[i][j], 4, 1, efp);
	    for (j=0; j<nz; j++) {q[j][i]=tmp[i][j];
	  	if(tmp[i][j]>vmax) vmax=tmp[i][j];
	  	if(tmp[i][j]<vmin) vmin=tmp[i][j];}}
	    fprintf(stdout,"q %f %f\n",vmin,vmax);
d1732 50
a1781 41
	  vmin=10000000;vmax=-100000000;
	  for (i=0, x=xmin; i<nx; i++, x+=dx)
	  {
	    if(msw==0) interpovv(nz,nxl,xl,epo,x,tmp[i]);
	    if(msw!=0) set_layers(nx,nz,tmp[i],nxl,nzl,epl,zl,xl,x,dz,xmin,zmin,msw);
	    for (j=0; j<nz; ++j) fwrite(&tmp[i][j], 4, 1, efp);
	    for (j=0; j<nz; j++) e33[j][i]=e11[j][i];
	    for (j=0; j<nz; j++) {e11[j][i]=e33[j][i]*(1+2*tmp[i][j]);
	  	if(tmp[i][j]>vmax) vmax=tmp[i][j];
	  	if(tmp[i][j]<vmin) vmin=tmp[i][j];}}
	    fprintf(stdout,"ep %f %f\n",vmin,vmax);
	  vmin=10000000;vmax=-100000000;
	  for (i=0, x=xmin; i<nx; i++, x+=dx)
	  {
	    if(msw==0) interpovv(nz,nxl,xl,dso,x,tmp[i]);
	    if(msw!=0) set_layers(nx,nz,tmp[i],nxl,nzl,dsl,zl,xl,x,dz,xmin,zmin,msw);
	    for (j=0; j<nz; ++j) fwrite(&tmp[i][j], 4, 1, efp);
	    for (j=0; j<nz; j++)
	    {
	      b=2*e55[j][i];
	      c=e55[j][i]*e55[j][i]-tmp[i][j]*e33[j][i]*e33[j][i]-
	        0.5*(e33[j][i]-e55[j][i])*(e11[j][i]+e33[j][i]-2*e55[j][i]);
	      e13[j][i]=0.5*(-b+sqrt(b*b-4*c));
	      if(tmp[i][j]>vmax) vmax=tmp[i][j];
	      if(tmp[i][j]<vmin) vmin=tmp[i][j];}}
	    fprintf(stdout,"ds %f %f\n",vmin,vmax);
	  vmin=10000000;vmax=-100000000;
	  for (i=0, x=xmin; i<nx; i++, x+=dx)
	  {
	    if(msw==0) interpovv(nz,nxl,xl,ano,x,tmp[i]);
	    if(msw!=0) set_layers(nx,nz,tmp[i],nxl,nzl,anl,zl,xl,x,dz,xmin,zmin,msw);
	    for (j=0; j<nz; ++j) fwrite(&tmp[i][j], 4, 1, efp);
	    for (j=0; j<nz; j++)
	    {
	      e15[j][i]=0.0;
	      e35[j][i]=0.0;
	      rotate(&e11[j][i],&e33[j][i],&e13[j][i],&e55[j][i],&e15[j][i]
	        ,&e35[j][i],tmp[i][j]);
	      if(tmp[i][j]>vmax) vmax=tmp[i][j];
	      if(tmp[i][j]<vmin) vmin=tmp[i][j];}}
	    fprintf(stdout,"an %f %f\n",vmin,vmax);
d1804 1
a1804 1
	}
d1807 3
a1809 2
	static void interpovv (int nt, int ncdp, float *cdp, float **ovv, 
	float cdpt, float *ovvt){
d1833 1
a1833 1
	}
d1836 4
a1839 3
void abs_bc_top(float **u, float **w, float **txx, float **tzz, float **txz,
	  int nx, int nz, float *r, int *bc, int *wbc, int ifx, int ilx)
	{
d1843 8
a1850 4
	  fac=r[(wbc[0]-j-1)];
	  for (i=ifx; i<ilx; ++i){
	    u[j][i]*=fac; w[j][i]*=fac;
	    txx[j][i]*=fac; tzz[j][i]*=fac; txz[j][i]*=fac;}}
d1852 1
d1855 6
a1860 4
void abs_bc_left(float **u, float **w, float **txx, float **tzz, float **txz,
	int nx, int nz, float *r, int *bc, int *wbc, int jfz, int jlz)
	{
	int i,j; float fac;
d1863 8
a1870 4
	  for (i=0; i<wbc[1]; ++i){
	    fac=r[(wbc[1]-i-1)];
	    u[j][i]*=fac; w[j][i]*=fac;
	    txx[j][i]*=fac; tzz[j][i]*=fac; txz[j][i]*=fac;}}
d1872 1
d1875 6
a1880 4
void abs_bc_bot(float **u, float **w, float **txx, float **tzz, float **txz,
	int nx, int nz, float *r, int *bc, int *wbc, int ifx, int ilx)
	{
	int i,j; float fac;
d1882 11
a1892 6
	for (j=nz-wbc[2]; j<nz; ++j){
	  fac=r[(j-nz+wbc[2])];
	  for (i=ifx; i<ilx; ++i){
	    u[j][i]*=fac; w[j][i]*=fac;
	    txx[j][i]*=fac; tzz[j][i]*=fac; txz[j][i]*=fac;}}	    
	}
d1895 6
a1900 4
void abs_bc_right(float **u, float **w, float **txx, float **tzz, float **txz,
	int nx, int nz, float *r, int *bc, int *wbc, int jfz, int jlz)
	{
	int i,j; float fac;
d1903 8
a1910 4
	  for (i=nx-wbc[3]; i<nx; ++i){
	    fac=r[(i-nx+wbc[3])];
	    u[j][i]*=fac; w[j][i+1]*=fac;
	    txx[j][i+1]*=fac; tzz[j][i+1]*=fac; txz[j][i]*=fac;}}
d1912 1
d1916 2
a1917 2
void fs4s_bc_top(float **txx, float **tzz, float **txz, int nx, int nz)
	{
d1920 1
a1920 1
	for (i=2; i<nx-2; ++i){
d1923 1
a1923 1
	for (i=2; i<nx-1; ++i){
d1925 1
a1925 1
      		tzz[1][i]=-tzz[2][i]; tzz[0][i]=-tzz[3][i];}
d1927 1
d1930 1
a1930 1
   surface for the order 4 FD operater on a staggered grid
d1932 2
a1933 2
  ** requires anisotropy symmetry parallel to free surface in 
  ** current implementation */
d1935 3
a1937 2
void fs4v_bc_top(float **u, float **w, float **e11, float **e55, int nx, int nz)
	{
d1940 26
a1965 19
/*  	010514-split loop into two four parts as it was in original FORTRAN CODE, previous versions were calculating all vaulues at once	 */
	for (i=2; i<nx-2; ++i){
	  u[0][i]=u[2][i]+
	    0.5*( F1*(w[2][i+1]-w[2][i]) + F2*(w[2][i+2]-w[2][i-1]) );
	  }
	for (i=2; i<nx-1; ++i){
	  w[0][i]=w[2][i]+
	    0.5*(1-2*(e55[2][i]/e11[2][i]))*	
	    ( F1*(u[0][i]-u[0][i-1]) + F2*(u[0][i+1]-u[0][i-2]) );
	  }
	for (i=2; i<nx-2; ++i){
	  u[1][i]=u[0][i]+
	    0.5*( F1*(w[2][i+1]-w[2][i]) + F2*(w[2][i+2]-w[2][i-1]) );
	  }
	for (i=2; i<nx-1; ++i){
	  w[1][i]=w[0][i]+
	    0.5*(1-2*(e55[2][i]/e11[2][i]))*	
	    ( F1*(u[1][i]-u[1][i-1]) + F2*(u[1][i+1]-u[1][i-2]) );
	  }
d1967 1
d1969 1
d1972 1
a1972 2
void sym4s_bc_top(float **txx, float **tzz, float **txz, int nx, int nz)
	{
d1975 1
a1975 1
	for (i=2; i<nx-2; ++i){
d1978 1
a1978 1
      		txz[1][i]=-txz[3][i]; txz[0][i]=-txz[4][i];}
d1980 1
d1982 1
d1985 1
a1985 2
void sym4v_bc_top(float **u, float **w, int nx, int nz)
	{
d1988 1
a1988 1
	for (i=2; i<nx-2; ++i){
d1990 1
a1990 1
      		w[1][i]=-w[3][i]; w[0][i]=-w[4][i];}
d1992 1
d1994 1
d1997 1
a1997 2
void sym4s_bc_right(float **txx, float **tzz, float **txz, int nx, int nz)
	{
d2000 4
a2003 4
	for (j=0; j<nz; ++j){
      		txx[j][nx]=txx[j][nx-4]; txx[j][nx-1]=txx[j][nx-3]; 
      		tzz[j][nx]=tzz[j][nx-4]; tzz[j][nx-1]=tzz[j][nx-3];
      		txz[j][nx-1]=-txz[j][nx-4]; txz[j][nx-2]=-txz[j][nx-3];}
d2005 1
d2007 1
d2010 1
a2010 2
void sym4v_bc_right(float **u, float **w, int nx, int nz)
	{
d2013 3
a2015 3
	for (j=0; j<nz; ++j){
      		u[j][nx-1]=-u[j][nx-4]; u[j][nx-2]=-u[j][nx-3]; 
      		w[j][nx]=w[j][nx-4]; w[j][nx-1]=w[j][nx-3];}
d2017 1
d2019 1
d2022 1
a2022 2
void sym4s_bc_left(float **txx, float **tzz, float **txz, int nx, int nz)
	{
d2025 1
a2025 1
	for (j=0; j<nz; ++j){
d2028 1
a2028 1
      		txz[j][1]=-txz[j][2]; txz[j][0]=-txz[j][3];}
d2030 1
d2032 1
d2035 1
a2035 2
void sym4v_bc_left(float **u, float **w, int nx, int nz)
	{
d2038 1
a2038 1
	for (j=0; j<nz; ++j){
d2040 1
a2040 1
      		w[j][1]=w[j][3]; w[j][0]=w[j][4];}
d2042 1
d2044 1
d2047 1
a2047 2
void sym4s_bc_bot(float **txx, float **tzz, float **txz, int nx, int nz)
	{
d2050 7
a2056 7
	for (i=2; i<nx-2; ++i){
/*        	     txx[nz-2][i]=txx[nz-4][i];  txx[nz-1][i]=txx[nz-5][i];  */
/*        	     tzz[nz-2][i]=-tzz[nz-4][i]; tzz[nz-1][i]=-tzz[nz-5][i]; */
/*        	     txz[nz-2][i]=-txz[nz-3][i]; txz[nz-1][i]=-txz[nz-4][i];} */
      		txx[nz-2][i]=txx[nz-4][i];  txx[nz-1][i]=txx[nz-5][i]; 
      		tzz[nz-2][i]=tzz[nz-4][i]; tzz[nz-1][i]=tzz[nz-5][i];
      		txz[nz-2][i]=-txz[nz-3][i]; txz[nz-1][i]=-txz[nz-4][i];}
d2058 1
d2060 1
d2063 1
a2063 2
void sym4v_bc_bot(float **u, float **w, int nx, int nz)
	{
d2066 5
a2070 5
	for (i=2; i<nx-2; ++i){
/*        		u[nz-2][i]=u[nz-4][i]; u[nz-1][i]=u[nz-5][i];  */
/*        		w[nz-2][i]=-w[nz-3][i];w[nz-1][i]=-w[nz-4][i];} */
      		u[nz-2][i]=u[nz-4][i]; u[nz-1][i]=u[nz-5][i]; 
      		w[nz-2][i]=-w[nz-3][i]; w[nz-1][i]=-w[nz-4][i];}
d2072 1
d2075 1
a2075 1
	int *limits, int i, int j, int k, int nx, int nz)
d2081 1
d2083 3
a2085 1
      if (limits[1] > nx-3) limits[1] = nx-3;
d2087 2
a2088 1
      if (limits[3] > nz-3) limits[3] = nz-3;      
d2092 2
a2093 2
void rotate(float *e11, float *e33, float *e13, float *e55,
	float *e15, float *e35, float angle)
d2100 1
a2100 1
	c=cos(angle); s=sin(angle);
d2102 18
a2119 6
	e11p= c*c*c*c*(*e11) + c*c*s*s*(2*(*e13)+4*(*e55)) + s*s*s*s*(*e33);
	e33p= c*c*c*c*(*e33) + c*c*s*s*(2*(*e13)+4*(*e55)) + s*s*s*s*(*e11);
	e13p= c*c*c*c*(*e13) + c*c*s*s*(*e11+*e33-4*(*e55)) + s*s*s*s*(*e13);
	e55p= c*c*c*c*(*e55) + c*c*s*s*(*e11+*e33-2*(*e55)-2*(*e13)) + s*s*s*s*(*e55);
	e15p= c*c*c*s*(-*e11+*e13+2*(*e55)) + c*s*s*s*(*e33-*e13-2*(*e55));
	e35p= c*s*s*s*(-*e11+*e13+2*(*e55)) + c*c*c*s*(*e33-*e13-2*(*e55));
d2121 6
a2126 6
	*e11=e11p;
	*e33=e33p;
	*e13=e13p;
	*e55=e55p;
	*e15=e15p;
	*e35=e35p;
d2130 1
a2130 1
void set_layers(int i, int nz, float *tmp, int nxl, int nzl, 
d2132 1
a2132 1
	float xmin, float zmin, int msw)
d2138 3
a2140 1
/*  	if(NINT(x)%100==0) fprintf(stdout,"msw %d %d %d %f \n",msw,nzl,nxl,x); */
d2144 3
a2146 2
	/*CJ - 010812: changed line below to fill model properly in depth*/
/*  	  for (jl=0; jl<=nzl; ++jl){ */
d2149 4
a2152 2
	    /* if before first location, constant extrapolate */
	    if (x<=xl[0]) {z=zl[0][jl];  p = pl [0][jl];
d2154 4
a2157 2
	    /* else if beyond last location constant extrapolate */
	    } else if (x>=xl[nxl-1]) {z=zl[nxl-1][jl]; p = pl [nxl-1][jl];
d2159 14
a2172 12
	    /* else, linearly interpolate */
	    /*if ( x>xl[0] & x<xl[nxl-1] ) {*/
	    } else {
	      xindex(nxl,xl,x,&il);
	      x1 = (xl[il+1]-x)/(xl[il+1]-xl[il]);
	      x2 = (x-xl[il])/(xl[il+1]-xl[il]);
	      if(jl<nzl) z = x1*zl[il][jl]+x2*zl[il+1][jl];
	    /* choose constant layer velocity */
              if(msw==1) p = pl[il][jl];
	    /* interpolate laterally layer velocity */
              if(msw==2) p = x1*pl[il][jl]+x2*pl[il+1][jl];
	    }  
d2175 6
a2180 4
/*  	    j2=NINT((z-zmin)/dz); if(jl==nzl) j2=nz; */
	    j2=NINT((z-zmin)/dz); if(jl==nzl-1) j2=nz;
	    if(j2>nz) j2=nz;
	    if(j2<0) j2=0;
d2182 8
a2189 3
	    for (j=j1; j<j2; ++j) tmp[j]=p;
/*  	if(NINT(x)%100==0) fprintf(stdout,"%d %d %d %d %f %f %f %f\n",il,jl,j1,j2,z,p,tmp[j2-1],tmp[nz]); */
	    j1=j2;
d2194 2
a2195 2
void write_chd(int nx, int nz, int nt, float dx, float dz, float dt,
	float xmin, float xmax, float zmin, float zmax,
d2207 11
a2217 5
	if(comp==1) {sprintf(s,"Horizontal line recording at z=%f",xz);
	  k=fwrite_chd(fp,s,k);}
	if(comp==2) {sprintf(s,"Vertical line recording at x=%f",xz);
	  k=fwrite_chd(fp,s,k);}
	sprintf(s,"nx=%d nz=%d nt=%d dx=%f dz=%f dt=%f",nx,nz,nt,dx,dz,dt);
d2219 1
a2219 1
	sprintf(s,"xmin=%f xmax=%f zmin=%f zmax=%f",xmin,xmax,zmin,zmax);
d2229 1
d2231 3
a2233 1
	  k=fwrite_chd(fp,s,k);
d2235 1
d2237 1
d2239 1
d2246 1
d2248 1
d2250 1
d2252 1
d2257 3
a2259 2
void write_grid(float **u, float **w, float **txx, float **tzz, float **txz, int is, int js)
	{
d2262 4
a2265 1
	for (i=is-2; i<is+3; ++i){fprintf(stderr,"%d ",i);}
d2267 1
d2269 6
a2274 2
	   for (i=is-2; i<is+3; ++i){fprintf(stderr,"%e ",u[j][i]);}
	   fprintf(stderr,"%d \n",j);}
d2276 1
d2278 6
a2283 2
	   for (i=is-2; i<is+3; ++i){fprintf(stderr,"%e ",w[j][i]);}
	   fprintf(stderr,"%d \n",j);}
d2285 1
d2287 6
a2292 2
	   for (i=is-2; i<is+3; ++i){fprintf(stderr,"%e ",txx[j][i]);}
	   fprintf(stderr,"%d \n",j);}
d2294 1
d2296 6
a2301 2
	   for (i=is-2; i<is+3; ++i){fprintf(stderr,"%e ",tzz[j][i]);}
	   fprintf(stderr,"%d \n",j);}
d2303 1
d2305 5
a2309 2
	   for (i=is-2; i<is+3; ++i){fprintf(stderr,"%e ",txz[j][i]);}
	   fprintf(stderr,"%d \n",j);}
d2311 1
a2311 1
	}
@


1.9
log
@added Wouter Kimman's stress field output option (snapshots only)
@
text
@d1 1
a1 1
/* SUEA2DF: $Revision: 1.8 $ ; $Date: 2003/11/10 16:35:13 $	    */
d194 14
a207 3
void add_pw_source_V(float **u, float **w, float **txx, float **tzz, float **txz, float **e11, float **e55, float *a, float sang, int il, int ir, int jt, int jb, int ns, int k, float dx, float dz, float dt, float *vl, float *vb, float *vr, float *ttl, float *ttb, float *ttr);
void add_pw_source_S(float **u, float **w, float **txx, float **tzz, float **txz, float **e11, float **e55, float *a, float sang, int il, int ir, int jt, int jb, int ns, int k, float dx, float dz, float dt, float *vl, float *vb, float *vr, float *ttl, float *ttb, float *ttr);

d303 4
a306 4
	float **u,**w;		/* particle velocities		*/
	float **txx,**tzz;	/* normal stresses		*/
	float **txz;		/* shear stress			*/
	float **ut,**wt;	/* time sections 		*/
d308 1
a308 1
	float *source;		/* source waveform		*/
d316 2
a317 2
	float *vlim;		/* min and max velocity in grid	*/
	int *limits;		/* calculation area in grid	*/
d324 1
a324 1
	char *vcfile;		/* vert receiver seismogram header file name */
d326 2
a327 2
	char *hcfile;		/* horiz receiver seismogram header file name */
	char *mfile;		/* model file name */
d333 4
a336 4
	float *bc0;		/* taper at top boundary 	*/
	float *bc1;		/* taper at left boundary 	*/
	float *bc2;		/* taper at bottom boundary 	*/
	float *bc3;		/* taper at right boundary 	*/
d339 2
a340 2
	float *vl,*vr,*vb;	/* velocity at boundaries 	*/
	float *ttl,*ttr,*ttb;	/* traveltimes at boundaries 	*/
d361 1
a361 1
/* hook up getpar to handle the parameters */
d365 1
a365 1
/* get optional parameters */
d393 1
a393 1
/* determine snapshots times and sample numbers */
d405 1
a405 1
/* if requested, open file for snapshots */
d411 1
a411 1
/* if requested, open file for source */
d417 1
a417 1
/* get boundary conditions */
d449 1
a449 1
/* determine seismogram recording lines */
d459 1
a459 1
/* open files for seismograms */
d476 1
a476 1
/* set grid parameters*/
d488 1
a488 1
/* allocate space for model*/
d506 1
a506 1
/* open file for model output */
d512 1
a512 1
/* set e_*/
d520 1
a520 1
/* set arrays for plane boundary conditions */
d585 1
a585 1
/* calculate stability and dispersion */
d591 1
a591 1
/* get source function */
d603 2
a604 2
/* allocate space for variables*/
/*  	  CJ: ADJUSTMENT MADE 030502 - txx,tzz and w extended for symmetry */
d615 1
a615 1
/* scale Q-factor */
d622 1
a622 1
/* zero arrays */
d627 1
a627 1
/* write character headers */
d641 1
a641 1
/* begin wave propagation */
d643 20
a662 19
	for (t=ft; t<=lt; t=t+dt)
{
/* calculate area for active grid */
	calc_area(vlim[1],dtx,dtz,limits,is,js,k,nx,nz);
	ifx=limits[0]; ilx=limits[1]; jfz=limits[2]; jlz=limits[3];
	if (strcmp(stype,"pw")==0) {ifx=2;ilx=nx-3;jfz=2; jlz=nz-3;}

/* introduce velocity source */
	if (k<ns) {
	  if (strcmp(stype,"v")==0) add_v_source(u,w,source[k],is,js);
	}

/* update velocities */
	if(tsw==0) update_vel(ifx,ilx,jfz,jlz,u,w,txx,tzz,txz,rho,e55,dtx,dtz);
	if(tsw==1) update_vel_tsw(ifx,ilx,jfz,jlz,u,w,txx,tzz,txz,rho,e55,dtx,dtz);
	
/* introduce plane wave velocity source */
	if (strcmp(stype,"pw")==0) {
	  add_pw_source_V(u,w,txx,tzz,txz,e11,e55,source,sang,wbc[1],nx-wbc[3]-1,wbc[0],nz-wbc[2]-1,ns,k,dx,dz,dt,vl,vb,vr,ttl,ttb,ttr);}
d664 2
a665 2
/* apply free surface bc for velocities */
	if(bc[0]==2) fs4v_bc_top(u,w,e11,e55,nx,nz);
d667 1
a667 1
/* apply symmetry bc for velocities */
d675 1
a675 1
	  if (strcmp(stype,"p")==0) add_p_source(txx,tzz,source[k],is,js);
@


1.8
log
@Chris Juhlin's latest version, changes to boundary conditions, additional options.
@
text
@d1 1
a1 1
/* SUEA2DF: $Revision: 1.8 $ ; $Date: 2003/11/10 09:50:40 $	    */
d30 1
d45 1
d54 4
d62 1
d243 4
d277 1
d346 4
d360 1
d377 1
d710 12
a721 3
/* make snapshot */
	for (i=0; i<nsnap; i++) if(k==isnap[i] && *snfile!='\0')
		make_snap(u,w,sx,sz,dx,dz,nx,nz,k,t,xmin,zmin,tr,sneisfp,wbc);
d1172 55
a1226 2
void make_seis
(float **ut, float **wt, float sx, float sz, 
@


1.7
log
@9 June 2003
@
text
@d1 1
a1 1
/* SUEA2DF: $Revision: 1.6 $ ; $Date: 2001/10/24 18:18:45 $	    */
d36 2
d39 4
d142 12
d157 1
d184 1
a184 1
void add_lp_source(float **txx, float** tzz, float amp, int i, int j, int jfz, int jlz);
d186 4
d213 2
d219 3
d235 1
d251 1
d316 2
d332 1
a332 1
	char *ri;
a333 3
	ri="ri";

	
d351 1
d435 5
a439 2
	nxm=NINT((xmax-xmin)/dx)+1;	/*model size*/
	nzm=NINT((zmax-zmin)/dz)+1;
d491 49
d575 7
a581 5
	u = alloc2float(nx,nz);
	w = alloc2float(nx,nz);
	txx = alloc2float(nx,nz);
	tzz = alloc2float(nx,nz);
	txz = alloc2float(nx,nz);
d583 1
a583 1
	nbytes=ngrids*nx*nz*4;
d619 1
a619 1
	if (strcmp(stype,"lp")==0) {jfz=2; jlz=nz-3;}
d630 4
d638 2
a639 1
	if(bc[0]==1) sym4v_bc_left(u,w,nx,nz);
d641 1
a645 1
	  if (strcmp(stype,"lp")==0) add_lp_source(txx,tzz,source[k],is,js,jfz,jlz);
d649 2
a650 1
	if(asw!=1) update_stress_iso(ifx,ilx,jfz,jlz,u,w,txx,tzz,txz,e11,e55,dtx,dtz);
d654 4
d661 3
a663 2
/* apply symmetry bc for velocities */
	if(bc[0]==1) sym4s_bc_left(txx,tzz,txz,nx,nz);
d665 1
d672 1
a672 1
	
d699 4
d740 1
a740 1
	return(CWP_Exit());
d765 4
d785 6
a790 1
      	    dtzz = F1*(tzz[j][i]-tzz[j-1][i])
d792 1
a792 3
             dtxz = F1*(txz[j+1][i]-txz[j][i])
      	     +F2*(txz[j+2][i]-txz[j-1][i]);
      	     dtzx = F1*(txz[j][i]-txz[j][i-1])
a793 1
     	    u[j][i] = u[j][i] + ( dtx*dtxx + dtz*dtxz ) * rho[j][i];
d808 11
a822 2
             dtxz = F1*(txz[j+1][i]-txz[j][i])
      	     +F2*(txz[j+2][i]-txz[j-1][i]);
a826 1
             dtxz = (txz[j+1][i]-txz[j][i]);
a828 1
      	    u[j][i] = u[j][i] + ( dtx*dtxx + dtz*dtxz ) * rho[j][i];
d842 1
a842 5
      	  for (i=ifx; i<=ilx; ++i) {
      	    dwx = F1*(w[j][i+1]-w[j][i])
             +F2*(w[j][i+2]-w[j][i-1]);
      	    duz = F1*(u[j][i]-u[j-1][i])
      	     +F2*(u[j+1][i]-u[j-2][i]);
d851 6
d890 16
a905 1
      	}
d915 7
a921 1
void add_lp_source(float **txx, float **tzz, float amp, int i, int j, int jfz, int jlz)
d923 80
a1002 4
      for (j=jfz; j<=jlz; ++j) {
         txx[j][i] = txx[j][i] + amp;
         tzz[j][i] = tzz[j][i] + amp;
      }
d1005 1
a1005 1
void add_v_source(float **u, float **w, float amp, int i, int j)
d1007 93
a1099 1
      w[j][i] = w[j][i] + amp*0.000001;
d1589 2
a1590 2
	    u[j][i]*=fac; w[j][i]*=fac;
	    txx[j][i]*=fac; tzz[j][i]*=fac; txz[j][i]*=fac;}}
d1600 3
a1603 1
      		txz[1][i]=0.; txz[0][i]=0.; txz[2][i]=0.;
d1622 1
a1622 1
	for (i=2; i<nx-2; ++i){
d1631 1
a1631 1
	for (i=2; i<nx-2; ++i){
d1638 46
d1691 1
a1691 1
      		txx[j][1]=-txx[j][3]; txx[j][0]=-txx[j][4]; 
d1714 3
d1718 1
a1718 1
      		tzz[nz-2][i]=-tzz[nz-4][i]; tzz[nz-1][i]=-tzz[nz-5][i];
d1729 2
d1732 1
a1732 1
      		w[nz-2][i]=-w[nz-3][i];w[nz-1][i]=-w[nz-4][i];}
d1868 30
@


1.6
log
@24 October 2001 version
@
text
@d1 1
a1 1
/* SUEA2DF: $Revision: 1.6 $ ; $Date: 2001/08/12 09:50:40 $	    */
d640 1
a640 1
	return EXIT_SUCCESS;
@


1.5
log
@Chris Juhlin's new version
@
text
@d1 1
a1 1
/* SUEA2DF: $Revision: 1.5 $ ; $Date: 2001/05/17 09:50:40 $	    */
d13 1
a68 1
" Notes:								",
d73 1
a78 3
" The wave types are:   dg==derivative of Gaussian, ri==Ricker,		",
" ga=Gaussian  favg is 10% level for fmax, and sp=spike.		",
"									",
a96 3
" Alogrithm based on Juhlin (1995, Geophys. Prosp.)			",
"       and Levander (1988, Geophysics)			                ",
" Attenuation included as in Graves (1996, BSSA)       			",
d133 6
d1426 1
a1426 2
/*	if(NINT(x)%100==0)
	    fprintf(stdout,"msw %d %d %d %f \n",msw,nzl,nxl,x);*/
d1430 3
a1432 1
	  for (jl=0; jl<=nzl; ++jl){
d1452 4
a1455 2
    
	    j2=NINT((z-zmin)/dz); if(jl==nzl) j2=nz;
a1457 2
/*	if(NINT(x)%100==0)
	    fprintf(stdout,"%d %d %d %d %f %f\n",il,jl,j1,j2,z,p);*/
d1460 1
@


1.4
log
@Chris Juhlin's latest version
@
text
@d1 1
a1 1
/* SUEA2DF: $Revision: 1.4 $ ; $Date: 2001/01/18 16:16:40 $	    */
a12 5
" Alogrithm based on Juhlin (1995, Geophys. Prosp.)			",
"       and Levander (1988, Geophysics)			                ",
" Attenuation included as in Graves (1996, BSSA)       			",
"									",
"									",
d62 3
d68 1
a72 1
"									",
d78 3
d99 3
d118 1
a118 3
 * 3. 2001-01-18: Changed routine for updating velocities to only use 
 * shear stress if material is non-fluid, otherwise problems occur at 
 * near grazing angles for fluid-solid boundary (dispersion). 
d120 17
a136 1
 * 4. 2001-01-30: Added option to set absorbing bc constants bc_a and bc_r 
a137 2
 * 5. 2001-02-23: Corrected bug in outputting model boundaries to standard output in 
 * routine get_econst
d144 1
a144 1
segy tr;
d153 3
d173 1
a173 1
	segy tr, FILE *fp, int b1, int b2);
d178 1
a178 1
	float *vlim, int msw, FILE *fp, FILE *mfp);
d253 1
d327 1
d456 14
d486 1
a486 1
 	  for (i=0; i<ns; i++)fprintf(soeisfp,"%d %f\n",i,source[i]);
d542 2
a543 1
	update_vel(ifx,ilx,jfz,jlz,u,w,txx,tzz,txz,rho,e55,dtx,dtz);
a604 1
	fclose(sneisfp);
d621 2
a622 1
	make_seis(ut,wt,sx,sz,dx,dt,nx,nt,hsz,xmin,zmin,tr,hseisfp,wbc[1],wbc[3]);
d632 2
a633 1
	make_seis(ut,wt,sx,sz,dz,dt,nz,nt,vsx,xmin,zmin,tr,vseisfp,wbc[0],wbc[2]);
d636 3
d682 21
d704 1
a704 1
/*        	    if(e55[j][i]>0) {  */
d709 5
a713 5
/*              } */
/*  	    else{ */
/*               dtxz = (txz[j+1][i]-txz[j][i]); */
/*        	     dtzx = (txz[j][i]-txz[j][i-1]); */
/*  	    } */
a742 2
/*        	    txz[j][i] = txz[j][i] + */
/*         	     0.25*(e55[j-1][i]+e55[j][i]+e55[j][i+1]+e55[j-1][i+1])*(dtz*duz + dtx*dwx);  */
d753 2
a754 2
	float duxm,duzm,dwzp,dwxp;
      	for (j=jfz; j<=jlz; ++j) {
d756 1
a756 1
      	    dwxp = F1*(w[j][i+1]-w[j][i])
d758 1
a758 1
      	    duzm = F1*(u[j][i]-u[j-1][i])
d760 1
a760 1
      	    dwzp = F1*(w[j+1][i]-w[j][i])
d762 1
a762 1
      	    duxm = F1*(u[j][i]-u[j][i-1])
d765 2
a766 2
      	     e11[j][i]*dtx*duxm + e13[j][i]*dtz*dwzp +
      	     e15[j][i]*(dtz*duzm + dtx*dwxp);
d768 2
a769 2
      	     e33[j][i]*dtz*dwzp + e13[j][i]*dtx*duxm +
      	     e35[j][i]*(dtz*duzm + dtx*dwxp);
d771 2
a772 2
      	     e15[j][i]*dtx*duxm + e35[j][i]*dtz*dwzp +
      	     e55[j][i]*(dtz*duzm + dtx*dwxp);
d840 2
a841 1
void make_seis(float **ut, float **wt, float sx, float sz, 
d843 2
a844 2
	float xmin, float zmin,
	segy tr, FILE *fp, int b1, int b2){
d851 2
a852 2
	rewind(fp); 
	tracl = tracr = 0;
d854 1
a854 1
	tr.sdepth = 0;
a856 3
	tr.selev = -sz ;
	tr.gelev = -dd ;
	tr.f2 = xmin ;
d858 9
a867 1

d873 9
a881 3
		tr.gx = xmin+dn*k ;
		tr.offset = tr.gx-tr.sx ;
		for(j=0; j<nt; ++j){tr.data[j] = ut[j][i];}
d889 8
a896 2
		tr.gx = xmin+dn*k ;
		tr.offset = tr.gx-tr.sx ;
d906 1
a906 1
	float *vlim, int msw, FILE *fp, FILE *mfp){
d1074 2
a1075 2
			  if(vpl[i][j]*(1+2*epl[i][j])>vmax){
			  vmax=vpl[i][j]*(1+2*epl[i][j]);}}
d1104 1
a1104 1
	  for (j=0; j<nz; ++j) fwrite(&tmp[i][j], 4, 1, fp);
d1113 1
a1113 1
	  for (j=0; j<nz; ++j) fwrite(&tmp[i][j], 4, 1, fp);
d1122 1
a1122 1
	  for (j=0; j<nz; ++j) fwrite(&tmp[i][j], 4, 1, fp);
d1135 1
a1135 1
	    for (j=0; j<nz; ++j) fwrite(&tmp[i][j], 4, 1, fp);
d1143 1
a1143 1
	  vmin=10000000;vmax=0;
d1148 1
a1148 1
	    for (j=0; j<nz; ++j) fwrite(&tmp[i][j], 4, 1, fp);
d1154 1
a1154 1
	  vmin=10000000;vmax=0;
d1159 1
a1159 1
	    for (j=0; j<nz; ++j) fwrite(&tmp[i][j], 4, 1, fp);
d1169 1
a1169 1
	  vmin=10000000;vmax=0;
d1174 1
a1174 1
	    for (j=0; j<nz; ++j) fwrite(&tmp[i][j], 4, 1, fp);
a1185 7
/*  CJ 30-01-01: Shift e55 grid 1/2 the grid spacing by interpolation */
/*  This reduces dispersion at strong contrasts in elastic properties and  */
/*  positions the e55 grid correctly relative to the e11 and e33 grids */
	for (i=0;i<nx-1;i++) {for (j=1;j<nz;j++) {
       	  tmp[i][j]=0.25*(e55[j-1][i]+e55[j][i]+e55[j][i+1]+e55[j-1][i+1]);
	}}
	for (i=0;i<nx-1;i++) {for (j=1;j<nz;j++) {e55[j][i]=tmp[i][j];}}
d1309 2
a1310 1
		
d1313 3
a1315 1
	    2*( F1*(w[2][i+1]-w[2][i]) + F2*(w[2][i+2]-w[2][i-1]) );
d1317 1
a1317 2
/*	    2*((e11[2][i]-2*e55[2][i])/e11[2][i])*	*/
	    2*(1-2*(e55[2][i]/e11[2][i]))*	
d1319 2
d1322 3
a1324 1
	    2*( F1*(w[2][i+1]-w[2][i]) + F2*(w[2][i+2]-w[2][i-1]) );
d1326 1
a1326 2
/*	    2*((e11[2][i]-2*e55[2][i])/e11[2][i])*	*/
	    2*(1-2*(e55[2][i]/e11[2][i]))*	
d1328 1
a1328 1
	    }
d1350 1
a1350 1
      		u[j][1]=-u[j][2]; u[j][0]=-u[j][2]; 
d1433 1
a1433 1
	    if (x<=xl[0]) {z=zl[0][jl];
d1436 1
a1436 1
	    } else if (x>=xl[nxl-1]) {z=zl[nxl-1][jl];
a1444 2
	    }  

d1446 1
a1446 1
	    if(msw==1) p = pl[il][jl];
d1448 3
a1450 2
	    if(msw==2) p = x1*pl[il][jl]+x2*pl[il+1][jl];
	    
d1453 1
a1453 1
	    if(j1<0) j2=0;
@


1.3
log
@update from Chris Julin
@
text
@d1 1
a1 1
/* SUEA2DF: $Revision: 1.0 $ ; $Date: 1999/5/15 20:01:19 $	    */
d64 3
d114 8
a122 1
 
d136 1
a136 1
	float **rho, float dtx, float dtz);
d145 1
d263 2
d349 4
d354 8
a361 8
	bc0=alloc1float(bc[0]); bc0[0]=0.95;
	bc1=alloc1float(bc[1]); bc1[0]=0.95;
	bc2=alloc1float(bc[2]); bc2[0]=0.95;
	bc3=alloc1float(bc[3]); bc3[0]=0.95;
	for(j=1; j<bc[0]; j++) bc0[j]=0.95*bc0[j-1];
	for(j=1; j<bc[1]; j++) bc1[j]=0.95*bc1[j-1];
	for(j=1; j<bc[2]; j++) bc2[j]=0.95*bc2[j-1];
	for(j=1; j<bc[3]; j++) bc3[j]=0.95*bc3[j-1];
d363 1
d454 1
d499 1
d507 1
a507 1
	update_vel(ifx,ilx,jfz,jlz,u,w,txx,tzz,txz,rho,dtx,dtz);
d519 1
d632 1
a632 1
	float **rho, float dtx, float dtz)
d635 1
a635 1
	float dtxx,dtzz,dtxz,dtzx;
d642 3
a644 1
      	    dtxz = F1*(txz[j+1][i]-txz[j][i])
d646 1
a646 1
      	    dtzx = F1*(txz[j][i]-txz[j][i-1])
d648 5
d659 1
d682 2
d725 8
d1009 5
a1013 2
		   vsl[i][j],rhol[i][j]);}
	  if(asw==1) for (j=0; j<nzl; ++j){
d1015 2
a1016 1
	       ,vpl[i][j],vsl[i][j],rhol[i][j],epl[i][j],dsl[i][j],anl[i][j]);}
d1109 7
d1193 1
a1193 1
	void abs_bc_bot(float **u, float **w, float **txx, float **tzz, float **txz,
@


1.2
log
@*** empty log message ***
@
text
@d1 1
a1 1
/* SUEA2DF: $Revision: 1.1 $ ; $Date: 1999/09/07 21:57:26 $	    */
d13 4
a65 1
" Notes:								",
d71 1
d101 7
a107 2
 * All rights reserved.
 * Parts of program use Seismic Unix Package - CSM 
d109 1
a109 3
 * Alogrithm based on Juhlin (1995, Geophys. Prosp.)
 *      and Levander (1988, Geophysics)
 * Attenuation included as in Graves (1996, BSSA)   
d138 1
d195 1
a195 1
	float *snaptime;	/* snapshot times		*/
a199 1

d381 4
a384 4
 	if((sx<xmin) | (sx>xmax) )
			err("sx=%f source must lie within model \n",sx);
 	if((sz<zmin) | (sz>zmax))
			err("sz=%f source must lie within model \n",sz);
d540 1
a540 1
		make_snap(u,w,sx,sz,dx,dz,nx,nz,k,t,tr,sneisfp,wbc);
d542 3
a544 3
 	if((verbose==1) & (k%50==0))
		warn("%d %f %f %d %d %d %d",
 		k,t,energy*efac,ifx,ilx,jfz,jlz);
a577 1

d663 1
a663 1
	float dux,duz,dwz,dwx;
d666 1
a666 1
      	    dwx = F1*(w[j][i+1]-w[j][i])
d668 1
a668 1
      	    duz = F1*(u[j][i]-u[j-1][i])
d670 1
a670 1
      	    dwz = F1*(w[j+1][i]-w[j][i])
d672 1
a672 1
      	    dux = F1*(u[j][i]-u[j][i-1])
d675 2
a676 2
      	     e11[j][i]*dtx*dux + e13[j][i]*dtz*dwz +
      	     e15[j][i]*(dtz*duz + dtx*dwx);
d678 2
a679 2
      	     e33[j][i]*dtz*dwz + e13[j][i]*dtx*dux +
      	     e15[j][i]*(dtz*duz + dtx*dwx);
d681 2
a682 2
      	     e15[j][i]*dtx*dux + e35[j][i]*dtz*dwz +
      	     e55[j][i]*(dtz*duz + dtx*dwx);
d701 1
d705 2
a706 2
	long tracl=0;		/* trace number within a line */
	long tracr=0;		/* trace number within a reel */
d716 2
d720 3
a722 1
	tracl = tracr = 0;
d725 1
a725 1
		tr.offset = i * dx - sx;
d727 1
d731 1
d734 2
a735 1
		tr.offset = i * dx - sx;
d813 10
a822 10
	int nvpl=0;		/* number of vpl specified 	*/
	int nvsl=0;		/* number of vsl specified 	*/
	int nrhol=0;		/* number of rhol specified 	*/
	int nql=0;		/* number of ql specified 	*/
	int nepl=0;		/* number of epl specified 	*/
	int ndsl=0;		/* number of dsl specified 	*/
	int nanl=0;		/* number of anl specified 	*/
	float zint=0.;		/* interpolated depth 		*/
	float pint=0.;		/* interpolated constant 	*/
	float x=0.;		/* x surface location		*/
d964 12
d1297 1
a1297 1
	float z=0.,x1=0.,x2=0.,p=0.;
@


1.1
log
@Initial revision
@
text
@d1 1
a1 5
/* Copyright (c) Uppsala University, 1998.*/
/* All rights reserved.                       */
/* Parts of program use Seismic Unix Package - CSM                  */

/* SUEA2DF: $Revision: 1.0 $ ; $Date: 1999/5/15 20:01:19 $	    */
a12 4
" Alogrithm based on Juhlin (1995, Geophys. Prosp.)			",
"       and Levander (1988, Geophysics)			                ",
" Attenuation included as in Graves (1996, BSSA)       			",
"									",
d62 1
a67 1
"									",
d96 7
a185 1
	float **r,**s;		/* receiver and shot coordinates*/
d188 1
a188 1
	int *isnap;		/* snapshot samples		*/
d192 1
d202 4
a205 4
	float **e11;		/* elastic constant c11(x,z)	*/
	float **e55;		/* elastic constant c55(x,z)	*/
	float **rho;		/* density rho(x,z)		*/
	float **q;		/* Q-factor q(x,z)		*/
d207 4
a210 4
	float **e33;		/* elastic constant c33(x,z)	*/
	float **e13;		/* elastic constant c13(x,z)	*/
	float **e15;		/* elastic constant c13(x,z)	*/
	float **e35;		/* elastic constant c35(x,z)	*/
d252 1
a252 1
	FILE *efp;		/* constants file pointer 	*/
d374 4
a377 2
 	if(sx<xmin | sx>xmax) err("sx=%f source must lie within model \n",sx);
 	if(sz<zmin | sz>zmax) err("sz=%f source must lie within model \n",sz);
d535 2
a536 1
 	if(verbose==1 & k%50==0) fprintf(stderr,"%d %f %f %d %d %d %d \n",
d571 2
d778 31
a808 33
	int nxl;		/* number of locations to define model	*/
	int nzl;		/* number of zl specified 		*/
	float *xl;		/* model locations			*/
	float **zl;		/* model depths				*/
	float **rhol;		/* model rho at xl,zl			*/
	float **vpl;		/* model vp at xl,zl sloths		*/
	float **vsl;		/* model vs at xl,zl sloths		*/
	float **ql;		/* model Q at xl,zl sloths		*/
	float **epl;		/* model (c11-c33)/2c33 at xl,zl sloths	*/
	float **dsl;		/* model del* at xl,zl sloths		*/
	float **anl;		/* model anisotropy angle at xl,zl sloths*/
	float **rhoo;		/* model rho at xl,z sloths		*/
	float **vpo;		/* model vp at xl,z			*/
	float **vso;		/* model vs at xl,z			*/
	float **qo;		/* model Q at xl,z			*/
	float **epo;		/* model (c11-c33)/2c33 at xl,z		*/
	float **dso;		/* model del* at xl,z			*/
	float **ano;		/* model anisotropy angle at xl,z	*/
	float **tmp;		/* temporary work array			*/
	float *tmp1, *tmp2;	/* temporary work arrays		*/

	int ixl;		/* index into model array 	*/
	int jzl;		/* index into model array 	*/
	int nvpl;		/* number of vpl specified 	*/
	int nvsl;		/* number of vsl specified 	*/
	int nrhol;		/* number of rhol specified 	*/
	int nql;		/* number of ql specified 	*/
	int nepl;		/* number of epl specified 	*/
	int ndsl;		/* number of dsl specified 	*/
	int nanl;		/* number of anl specified 	*/
	float zint;		/* interpolated depth 		*/
	float pint;		/* interpolated constant 	*/
	float x;		/* x surface location		*/
d1270 2
a1271 2
	int j,i1,j1,i2,j2,jl;
	float z,x1,x2,p;
@
