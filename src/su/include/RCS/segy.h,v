head	1.33;
access;
symbols;
locks
	john:1.33; strict;
comment	@ * @;


1.33
date	2011.11.11.23.56.14;	author john;	state Exp;
branches;
next	1.32;

1.32
date	2011.09.09.22.27.46;	author john;	state Exp;
branches;
next	1.31;

1.31
date	2009.01.16.21.30.55;	author john;	state Exp;
branches;
next	1.30;

1.30
date	2007.04.09.23.01.53;	author john;	state Exp;
branches;
next	1.29;

1.29
date	2007.04.04.20.09.29;	author john;	state Exp;
branches;
next	1.28;

1.28
date	2006.08.14.20.44.48;	author john;	state Exp;
branches;
next	1.27;

1.27
date	2006.04.27.22.13.32;	author john;	state Exp;
branches;
next	1.26;

1.26
date	2005.01.21.20.18.45;	author john;	state Exp;
branches;
next	1.25;

1.25
date	2004.08.25.17.14.20;	author john;	state Exp;
branches;
next	1.24;

1.24
date	2004.02.17.18.32.15;	author john;	state Exp;
branches;
next	1.23;

1.23
date	98.03.26.23.48.18;	author john;	state Exp;
branches;
next	1.22;

1.22
date	97.10.15.15.18.28;	author john;	state Exp;
branches;
next	1.21;

1.21
date	97.07.15.19.28.37;	author john;	state Exp;
branches;
next	1.20;

1.20
date	96.02.20.16.41.29;	author jkc;	state Exp;
branches;
next	1.19;

1.19
date	95.11.13.19.51.04;	author jkc;	state Exp;
branches;
next	1.18;

1.18
date	95.11.13.19.31.23;	author john;	state Exp;
branches;
next	1.17;

1.17
date	94.11.28.15.46.37;	author john;	state Exp;
branches;
next	1.16;

1.16
date	94.11.18.13.36.36;	author john;	state Exp;
branches;
next	1.15;

1.15
date	94.10.06.14.22.48;	author jkc;	state Exp;
branches;
next	1.14;

1.14
date	94.09.06.09.24.39;	author jkc;	state Exp;
branches;
next	1.13;

1.13
date	94.08.04.09.57.50;	author jkc;	state Exp;
branches;
next	1.12;

1.12
date	94.07.08.13.47.25;	author jkc;	state Exp;
branches;
next	1.11;

1.11
date	94.06.24.14.25.49;	author john;	state Exp;
branches;
next	1.10;

1.10
date	94.03.29.14.04.37;	author john;	state Exp;
branches;
next	1.9;

1.9
date	94.03.29.11.57.39;	author john;	state Exp;
branches;
next	1.8;

1.8
date	94.03.28.14.17.06;	author jkc;	state Exp;
branches;
next	1.7;

1.7
date	93.11.02.13.18.55;	author jkc;	state Exp;
branches;
next	1.6;

1.6
date	92.06.18.14.14.20;	author jkc;	state Exp;
branches;
next	1.5;

1.5
date	91.06.23.11.33.22;	author jkcohen;	state Exp;
branches;
next	1.4;

1.4
date	91.02.14.10.24.21;	author jkcohen;	state Exp;
branches;
next	1.3;

1.3
date	90.11.04.09.19.43;	author jkc;	state Exp;
branches;
next	1.2;

1.2
date	90.09.01.13.00.30;	author jkc;	state Exp;
branches;
next	1.1;

1.1
date	90.09.01.12.57.54;	author jkc;	state Exp;
branches;
next	;


desc
@Include file for SEG-Y traces
@


1.33
log
@copyright statement
@
text
@/* Copyright (c) Colorado School of Mines, 2011.*/
/* All rights reserved.                       */

/* segy.h - include file for SEGY traces
 *
 * declarations for:
 *	typedef struct {} segy - the trace identification header
 *	typedef struct {} bhed - binary header
 *
 * Note:
 *	If header words are added, run the makefile in this directory
 *	to recreate hdr.h.
 *
 * Reference:
 *	K. M. Barry, D. A. Cavers and C. W. Kneale, "Special Report:
 *		Recommended Standards for Digital Tape Formats",
 *		Geophysics, vol. 40, no. 2 (April 1975), P. 344-352.
 *	
 * $Author: john $
 * $Source: /usr/local/cwp/src/su/include/RCS/segy.h,v $
 * $Revision: 1.32 $ ; $Date: 2011/09/09 22:27:46 $
 */ 

#include <limits.h>

#ifndef SEGY_H
#define SEGY_H

#define SU_NFLTS	32767	/* Arbitrary limit on data array size	*/


/* TYPEDEFS */
typedef struct {	/* segy - trace identification header */

	int tracl;	/* Trace sequence number within line
			   --numbers continue to increase if the
			   same line continues across multiple
			   SEG Y files.
			   byte# 1-4
			 */

	int tracr;	/* Trace sequence number within SEG Y file
			   ---each file starts with trace sequence
			   one
			   byte# 5-8
			 */

	int fldr;	/* Original field record number
			   byte# 9-12 
			*/

	int tracf;	/* Trace number within original field record 
			   byte# 13-16
			*/

	int ep;		/* energy source point number
			   ---Used when more than one record occurs
			   at the same effective surface location.
			   byte# 17-20
			 */

	int cdp;	/* Ensemble number (i.e. CDP, CMP, CRP,...) 
			   byte# 21-24
			*/

	int cdpt;	/* trace number within the ensemble
			   ---each ensemble starts with trace number one.
			   byte# 25-28
			 */

	short trid;	/* trace identification code:
			-1 = Other
		         0 = Unknown
			 1 = Seismic data
			 2 = Dead
			 3 = Dummy
			 4 = Time break
			 5 = Uphole
			 6 = Sweep
			 7 = Timing
			 8 = Water break
			 9 = Near-field gun signature
			10 = Far-field gun signature
			11 = Seismic pressure sensor
			12 = Multicomponent seismic sensor
				- Vertical component
			13 = Multicomponent seismic sensor
				- Cross-line component 
			14 = Multicomponent seismic sensor
				- in-line component 
			15 = Rotated multicomponent seismic sensor
				- Vertical component
			16 = Rotated multicomponent seismic sensor
				- Transverse component
			17 = Rotated multicomponent seismic sensor
				- Radial component
			18 = Vibrator reaction mass
			19 = Vibrator baseplate
			20 = Vibrator estimated ground force
			21 = Vibrator reference
			22 = Time-velocity pairs
			23 ... N = optional use 
				(maximum N = 32,767)

			Following are CWP id flags:

			109 = autocorrelation
			110 = Fourier transformed - no packing
			     xr[0],xi[0], ..., xr[N-1],xi[N-1]
			111 = Fourier transformed - unpacked Nyquist
			     xr[0],xi[0],...,xr[N/2],xi[N/2]
			112 = Fourier transformed - packed Nyquist
	 		     even N:
			     xr[0],xr[N/2],xr[1],xi[1], ...,
				xr[N/2 -1],xi[N/2 -1]
				(note the exceptional second entry)
			     odd N:
			     xr[0],xr[(N-1)/2],xr[1],xi[1], ...,
				xr[(N-1)/2 -1],xi[(N-1)/2 -1],xi[(N-1)/2]
				(note the exceptional second & last entries)
			113 = Complex signal in the time domain
			     xr[0],xi[0], ..., xr[N-1],xi[N-1]
			114 = Fourier transformed - amplitude/phase
			     a[0],p[0], ..., a[N-1],p[N-1]
			115 = Complex time signal - amplitude/phase
			     a[0],p[0], ..., a[N-1],p[N-1]
			116 = Real part of complex trace from 0 to Nyquist
			117 = Imag part of complex trace from 0 to Nyquist
			118 = Amplitude of complex trace from 0 to Nyquist
			119 = Phase of complex trace from 0 to Nyquist
			121 = Wavenumber time domain (k-t)
			122 = Wavenumber frequency (k-omega)
			123 = Envelope of the complex time trace
			124 = Phase of the complex time trace
			125 = Frequency of the complex time trace
			130 = Depth-Range (z-x) traces
			201 = Seismic data packed to bytes (by supack1)
			202 = Seismic data packed to 2 bytes (by supack2)
			   byte# 29-30
			*/

	short nvs;	/* Number of vertically summed traces yielding
			   this trace. (1 is one trace, 
			   2 is two summed traces, etc.)
			   byte# 31-32
			 */

	short nhs;	/* Number of horizontally summed traces yielding
			   this trace. (1 is one trace
			   2 is two summed traces, etc.)
			   byte# 33-34
			 */

	short duse;	/* Data use:
				1 = Production
				2 = Test
			   byte# 35-36
			 */

	int offset;	/* Distance from the center of the source point 
			   to the center of the receiver group 
			   (negative if opposite to direction in which 
			   the line was shot).
			   byte# 37-40
			 */

	int gelev;	/* Receiver group elevation from sea level
			   (all elevations above the Vertical datum are 
			   positive and below are negative).
			   byte# 41-44
			 */

	int selev;	/* Surface elevation at source.
			   byte# 45-48
			 */

	int sdepth;	/* Source depth below surface (a positive number).
			   byte# 49-52
			 */

	int gdel;	/* Datum elevation at receiver group.
			   byte# 53-56
			*/

	int sdel;	/* Datum elevation at source.
			   byte# 57-60
			*/

	int swdep;	/* Water depth at source.
			   byte# 61-64
			*/

	int gwdep;	/* Water depth at receiver group.
			   byte# 65-68
			*/

	short scalel;	/* Scalar to be applied to the previous 7 entries
			   to give the real value. 
			   Scalar = 1, +10, +100, +1000, +10000.
			   If positive, scalar is used as a multiplier,
			   if negative, scalar is used as a divisor.
			   byte# 69-70
			 */

	short scalco;	/* Scalar to be applied to the next 4 entries
			   to give the real value. 
			   Scalar = 1, +10, +100, +1000, +10000.
			   If positive, scalar is used as a multiplier,
			   if negative, scalar is used as a divisor.
			   byte# 71-72
			 */

	int  sx;	/* Source coordinate - X 
			   byte# 73-76
			*/

	int  sy;	/* Source coordinate - Y 
			   byte# 77-80
			*/

	int  gx;	/* Group coordinate - X 
			   byte# 81-84
			*/

	int  gy;	/* Group coordinate - Y 
			   byte# 85-88
			*/

	short counit;	/* Coordinate units: (for previous 4 entries and
				for the 7 entries before scalel)
			   1 = Length (meters or feet)
			   2 = Seconds of arc
			   3 = Decimal degrees
			   4 = Degrees, minutes, seconds (DMS)

			In case 2, the X values are longitude and 
			the Y values are latitude, a positive value designates
			the number of seconds east of Greenwich
				or north of the equator

			In case 4, to encode +-DDDMMSS
			counit = +-DDD*10^4 + MM*10^2 + SS,
			with scalco = 1. To encode +-DDDMMSS.ss
			counit = +-DDD*10^6 + MM*10^4 + SS*10^2 
			with scalco = -100.
			   byte# 89-90
			*/

	short wevel;	/* Weathering velocity. 
			   byte# 91-92
			*/

	short swevel;	/* Subweathering velocity. 
			   byte# 93-94
			*/

	short sut;	/* Uphole time at source in milliseconds. 
			   byte# 95-96
			*/

	short gut;	/* Uphole time at receiver group in milliseconds. 
			   byte# 97-98
			*/

	short sstat;	/* Source static correction in milliseconds. 
			   byte# 99-100
			*/

	short gstat;	/* Group static correction  in milliseconds.
			   byte# 101-102
			*/

	short tstat;	/* Total static applied  in milliseconds.
			   (Zero if no static has been applied.)
			   byte# 103-104
			*/

	short laga;	/* Lag time A, time in ms between end of 240-
			   byte trace identification header and time
			   break, positive if time break occurs after
			   end of header, time break is defined as
			   the initiation pulse which maybe recorded
			   on an auxiliary trace or as otherwise
			   specified by the recording system 
			   byte# 105-106
			*/

	short lagb;	/* lag time B, time in ms between the time break
			   and the initiation time of the energy source,
			   may be positive or negative 
			   byte# 107-108
			*/

	short delrt;	/* delay recording time, time in ms between
			   initiation time of energy source and time
			   when recording of data samples begins
			   (for deep water work if recording does not
			   start at zero time) 
			   byte# 109-110
			*/

	short muts;	/* mute time--start 
			   byte# 111-112
			*/

	short mute;	/* mute time--end 
			   byte# 113-114
			*/

	unsigned short ns;	/* number of samples in this trace 
			   byte# 115-116
			*/

	unsigned short dt;	/* sample interval; in micro-seconds
			   byte# 117-118
			*/

	short gain;	/* gain type of field instruments code:
				1 = fixed
				2 = binary
				3 = floating point
				4 ---- N = optional use 
			   byte# 119-120
			*/

	short igc;	/* instrument gain constant 
			   byte# 121-122
			*/

	short igi;	/* instrument early or initial gain 
			   byte# 123-124
			*/

	short corr;	/* correlated:
				1 = no
				2 = yes 
			   byte# 125-126
			*/

	short sfs;	/* sweep frequency at start 
			   byte# 127-128
			*/

	short sfe;	/* sweep frequency at end
			   byte# 129-130
			*/

	short slen;	/* sweep length in ms 
			   byte# 131-132
			*/

	short styp;	/* sweep type code:
				1 = linear
				2 = cos-squared
				3 = other
			   byte# 133-134
			*/

	short stas;	/* sweep trace length at start in ms
			   byte# 135-136
			*/

	short stae;	/* sweep trace length at end in ms 
			   byte# 137-138
			*/

	short tatyp;	/* taper type: 1=linear, 2=cos^2, 3=other 
			   byte# 139-140
			*/

	short afilf;	/* alias filter frequency if used 
			   byte# 141-142
			*/

	short afils;	/* alias filter slope
			   byte# 143-144
			*/

	short nofilf;	/* notch filter frequency if used
			   byte# 145-146
			*/

	short nofils;	/* notch filter slope
			   byte# 147-148
			*/

	short lcf;	/* low cut frequency if used
			   byte# 149-150
			*/

	short hcf;	/* high cut frequncy if used
			   byte# 151-152
			*/

	short lcs;	/* low cut slope
			   byte# 153-154
			*/

	short hcs;	/* high cut slope
			   byte# 155-156
			*/

	short year;	/* year data recorded
			   byte# 157-158
			*/

	short day;	/* day of year
			   byte# 159-160
			*/

	short hour;	/* hour of day (24 hour clock) 
			   byte# 161-162
			*/

	short minute;	/* minute of hour
			   byte# 163-164
			*/

	short sec;	/* second of minute
			   byte# 165-166
			*/

	short timbas;	/* time basis code:
				1 = local
				2 = GMT
				3 = other
			   byte# 167-168
			*/

	short trwf;	/* trace weighting factor, defined as 1/2^N
			   volts for the least sigificant bit
			   byte# 169-170
			*/

	short grnors;	/* geophone group number of roll switch
			   position one
			   byte# 171-172
			*/

	short grnofr;	/* geophone group number of trace one within
			   original field record
			   byte# 173-174
			*/

	short grnlof;	/* geophone group number of last trace within
			   original field record
			   byte# 175-176
			*/

	short gaps;	/* gap size (total number of groups dropped)
			   byte# 177-178
			*/

	short otrav;	/* overtravel taper code:
				1 = down (or behind)
				2 = up (or ahead)
			   byte# 179-180
			*/

#ifdef SLTSU_SEGY_H  /* begin Unocal SU segy.h differences */


	/* cwp local assignments */
	float d1;	/* sample spacing for non-seismic data
			   byte# 181-184
			*/

	float f1;	/* first sample location for non-seismic data
			   byte# 185-188
			*/

	float d2;	/* sample spacing between traces
			   byte# 189-192
			*/

	float f2;	/* first trace location
			   byte# 193-196
			*/

	float ungpow;	/* negative of power used for dynamic
			   range compression
			   byte# 197-200
			*/

	float unscale;	/* reciprocal of scaling factor to normalize
			   range
			   byte# 201-204
			*/

	short mark;	/* mark selected traces
			   byte# 205-206
			*/

	/* SLTSU local assignments */ 
	short mutb;	/* mute time at bottom (start time)
			   bottom mute ends at last sample
			   byte# 207-208
			*/
	float dz;	/* depth sampling interval in (m or ft)
			if =0.0, input are time samples
			   byte# 209-212
			*/

	float fz;	/* depth of first sample in (m or ft)
			   byte# 213-116
			*/

	short n2;	/* number of traces per cdp or per shot
			   byte# 217-218
			*/

        short shortpad; /* alignment padding
			   byte# 219-220
			*/

	int ntr; 	/* number of traces
			   byte# 221-224
			*/

	/* SLTSU local assignments end */ 

	short unass[8];	/* unassigned
			   byte# 225-240
			*/

#else

	/* cwp local assignments */
	float d1;	/* sample spacing for non-seismic data
			   byte# 181-184
			*/

	float f1;	/* first sample location for non-seismic data
			   byte# 185-188
			*/

	float d2;	/* sample spacing between traces
			   byte# 189-192
			*/

	float f2;	/* first trace location
			   byte# 193-196
			*/

	float ungpow;	/* negative of power used for dynamic
			   range compression
			   byte# 197-200
			*/

	float unscale;	/* reciprocal of scaling factor to normalize
			   range
			   byte# 201-204
			*/

	int ntr; 	/* number of traces
			   byte# 205-208
			*/

	short mark;	/* mark selected traces
			   byte# 209-210
			*/

        short shortpad; /* alignment padding
			   byte# 211-212
			*/


	short unass[14];	/* unassigned--NOTE: last entry causes 
			   a break in the word alignment, if we REALLY
			   want to maintain 240 bytes, the following
			   entry should be an odd number of short/UINT2
			   OR do the insertion above the "mark" keyword
			   entry
			   byte# 213-240
			*/
#endif

	float  data[SU_NFLTS];

} segy;


typedef struct {	/* bhed - binary header */

	int jobid;	/* job identification number */

	int lino;	/* line number (only one line per reel) */

	int reno;	/* reel number */

	short ntrpr;	/* number of data traces per record */

        short nart;	/* number of auxiliary traces per record */

	unsigned short hdt; /* sample interval in micro secs for this reel */

	unsigned short dto; /* same for original field recording */

	unsigned short hns; /* number of samples per trace for this reel */

	unsigned short nso; /* same for original field recording */

	short format;	/* data sample format code:
				1 = floating point, 4 byte (32 bits)
				2 = fixed point, 4 byte (32 bits)
				3 = fixed point, 2 byte (16 bits)
				4 = fixed point w/gain code, 4 byte (32 bits)
				5 = IEEE floating point, 4 byte (32 bits)
				8 = two's complement integer, 1 byte (8 bits)
			*/

	short fold;	/* CDP fold expected per CDP ensemble */

	short tsort;	/* trace sorting code: 
				1 = as recorded (no sorting)
				2 = CDP ensemble
				3 = single fold continuous profile
				4 = horizontally stacked */

	short vscode;	/* vertical sum code:
				1 = no sum
				2 = two sum ...
				N = N sum (N = 32,767) */

	short hsfs;	/* sweep frequency at start */

	short hsfe;	/* sweep frequency at end */

	short hslen;	/* sweep length (ms) */

	short hstyp;	/* sweep type code:
				1 = linear
				2 = parabolic
				3 = exponential
				4 = other */

	short schn;	/* trace number of sweep channel */

	short hstas;	/* sweep trace taper length at start if
			   tapered (the taper starts at zero time
			   and is effective for this length) */

	short hstae;	/* sweep trace taper length at end (the ending
			   taper starts at sweep length minus the taper
			   length at end) */

	short htatyp;	/* sweep trace taper type code:
				1 = linear
				2 = cos-squared
				3 = other */

	short hcorr;	/* correlated data traces code:
				1 = no
				2 = yes */

	short bgrcv;	/* binary gain recovered code:
				1 = yes
				2 = no */

	short rcvm;	/* amplitude recovery method code:
				1 = none
				2 = spherical divergence
				3 = AGC
				4 = other */

	short mfeet;	/* measurement system code:
				1 = meters
				2 = feet */

	short polyt;	/* impulse signal polarity code:
				1 = increase in pressure or upward
				    geophone case movement gives
				    negative number on tape
				2 = increase in pressure or upward
				    geophone case movement gives
				    positive number on tape */

	short vpol;	/* vibratory polarity code:
				code	seismic signal lags pilot by
				1	337.5 to  22.5 degrees
				2	 22.5 to  67.5 degrees
				3	 67.5 to 112.5 degrees
				4	112.5 to 157.5 degrees
				5	157.5 to 202.5 degrees
				6	202.5 to 247.5 degrees
				7	247.5 to 292.5 degrees
				8	293.5 to 337.5 degrees */

	short hunass[170];	/* unassigned */

} bhed;

/* DEFINES */
#define gettr(x)	fgettr(stdin, (x))
#define vgettr(x)	fvgettr(stdin, (x))
#define puttr(x)	fputtr(stdout, (x))
#define vputtr(x)	fvputtr(stdout, (x))
#define gettra(x, y)    fgettra(stdin, (x), (y))


/* TOTHER represents "other"					*/
#define		TOTHER		-1	
/* TUNK represents time traces of an unknown type		*/
#define		TUNK		0
/* TREAL represents real time traces 				*/
#define		TREAL		1
/* TDEAD represents dead time traces 				*/
#define		TDEAD		2
/* TDUMMY represents dummy time traces 				*/
#define		TDUMMY		3
/* TBREAK represents time break traces 				*/
#define		TBREAK		4
/* UPHOLE represents uphole traces 				*/
#define		UPHOLE		5
/* SWEEP represents sweep traces 				*/
#define		SWEEP		6
/* TIMING represents timing traces 				*/
#define		TIMING		7
/* WBREAK represents timing traces 				*/
#define		WBREAK		8
/* NFGUNSIG represents near field gun signature 		*/
#define		NFGUNSIG	9	
/* FFGUNSIG represents far field gun signature	 		*/
#define		FFGUNSIG	10
/* SPSENSOR represents seismic pressure sensor	 		*/
#define		SPSENSOR	11
/* TVERT represents multicomponent seismic sensor 
	- vertical component */
#define		TVERT		12
/* TXLIN represents multicomponent seismic sensor 
	- cross-line component */
#define		TXLIN		13
/* TINLIN represents multicomponent seismic sensor 
	- in-line component */
#define		TINLIN	14
/* ROTVERT represents rotated multicomponent seismic sensor 
	- vertical component */
#define		ROTVERT		15
/* TTRANS represents rotated multicomponent seismic sensor 
	- transverse component */
#define		TTRANS		16
/* TRADIAL represents rotated multicomponent seismic sensor 
	- radial component */
#define		TRADIAL		17
/* VRMASS represents vibrator reaction mass */
#define		VRMASS		18
/* VBASS represents vibrator baseplate */
#define		VBASS		19
/* VEGF represents vibrator estimated ground force */
#define		VEGF		20
/* VREF represents vibrator reference */
#define		VREF		21

/*** CWP trid assignments ***/
/* ACOR represents autocorrelation  */
#define		ACOR		109
/* FCMPLX represents fourier transformed - no packing 
   xr[0],xi[0], ..., xr[N-1],xi[N-1] */
#define		FCMPLX		110
/* FUNPACKNYQ represents fourier transformed - unpacked Nyquist
   xr[0],xi[0],...,xr[N/2],xi[N/2] */
#define		FUNPACKNYQ	111
/* FTPACK represents fourier transformed - packed Nyquist
   even N: xr[0],xr[N/2],xr[1],xi[1], ...,
	xr[N/2 -1],xi[N/2 -1]
   (note the exceptional second entry)
    odd N:
     xr[0],xr[(N-1)/2],xr[1],xi[1], ...,
     xr[(N-1)/2 -1],xi[(N-1)/2 -1],xi[(N-1)/2]
   (note the exceptional second & last entries)
*/
#define		FTPACK		112
/* TCMPLX represents complex time traces 			*/
#define		TCMPLX		113
/* FAMPH represents freq domain data in amplitude/phase form	*/
#define		FAMPH		114
/* TAMPH represents time domain data in amplitude/phase form	*/
#define		TAMPH		115
/* REALPART represents the real part of a trace to Nyquist	*/
#define		REALPART	116
/* IMAGPART represents the real part of a trace to Nyquist	*/
#define		IMAGPART	117
/* AMPLITUDE represents the amplitude of a trace to Nyquist	*/
#define		AMPLITUDE	118
/* PHASE represents the phase of a trace to Nyquist		*/
#define		PHASE		119
/* KT represents wavenumber-time domain data 			*/
#define		KT		121
/* KOMEGA represents wavenumber-frequency domain data		*/
#define		KOMEGA		122
/* ENVELOPE represents the envelope of the complex time trace	*/
#define		ENVELOPE	123
/* INSTPHASE represents the phase of the complex time trace	*/
#define		INSTPHASE	124
/* INSTFREQ represents the frequency of the complex time trace	*/
#define		INSTFREQ	125
/* DEPTH represents traces in depth-range (z-x)			*/
#define		TRID_DEPTH	130
/* 3C data...  v,h1,h2=(11,12,13)+32 so a bitmask will convert  */
/* between conventions */
/* CHARPACK represents byte packed seismic data from supack1	*/
#define		CHARPACK	201
/* SHORTPACK represents 2 byte packed seismic data from supack2	*/
#define		SHORTPACK	202


#define ISSEISMIC(id) (( (id)==TUNK || (id)==TREAL || (id)==TDEAD || (id)==TDUMMY || (id)==TBREAK || (id)==UPHOLE || (id)==SWEEP || (id)==TIMING || (id)==WBREAK || (id)==NFGUNSIG || (id)==FFGUNSIG || (id)==SPSENSOR || (id)==TVERT || (id)==TXLIN || (id)==TINLIN || (id)==ROTVERT || (id)==TTRANS || (id)==TRADIAL || (id)==ACOR ) ? cwp_true : cwp_false ) 

/* FUNCTION PROTOTYPES */
#ifdef __cplusplus /* if C++, specify external linkage to C functions */
extern "C" {
#endif

/* get trace and put trace */
int fgettr(FILE *fp, segy *tp);
int fvgettr(FILE *fp, segy *tp);
void fputtr(FILE *fp, segy *tp);
void fvputtr(FILE *fp, segy *tp);
int fgettra(FILE *fp, segy *tp, int itr);

/* get gather and put gather */
segy **fget_gather(FILE *fp, cwp_String *key,cwp_String *type,Value *n_val,
                        int *nt,int *ntr, float *dt,int *first);
segy **get_gather(cwp_String *key, cwp_String *type, Value *n_val,
			int *nt, int *ntr, float *dt, int *first);
segy **fput_gather(FILE *fp, segy **rec,int *nt, int *ntr);
segy **put_gather(segy **rec,int *nt, int *ntr);

/* hdrpkge */
void gethval(const segy *tp, int index, Value *valp);
void puthval(segy *tp, int index, Value *valp);
void getbhval(const bhed *bhp, int index, Value *valp);
void putbhval(bhed *bhp, int index, Value *valp);
void gethdval(const segy *tp, char *key, Value *valp);
void puthdval(segy *tp, char *key, Value *valp);
char *hdtype(const char *key);
char *getkey(const int index);
int getindex(const char *key);
void swaphval(segy *tp, int index);
void swapbhval(bhed *bhp, int index);
void printheader(const segy *tp);

void tabplot(segy *tp, int itmin, int itmax);

#ifdef __cplusplus /* if C++, end external linkage specification */
}
#endif

#endif
@


1.32
log
@*** empty log message ***
@
text
@d1 3
d21 1
a21 1
 * $Revision: 1.31 $ ; $Date: 2009/01/16 21:30:55 $
@


1.31
log
@added Balazs Nemeth's comments with the byte# entries.
@
text
@d18 1
a18 1
 * $Revision: 1.30 $ ; $Date: 2007/04/09 23:01:53 $
d26 1
a26 1
#define SU_NFLTS	USHRT_MAX	/* Arbitrary limit on data array size	*/
d811 1
d818 8
@


1.30
log
@changed UNOCAL to SLTSU
@
text
@a0 1

d18 1
a18 1
 * $Revision: 1.29 $ ; $Date: 2007/04/04 20:09:29 $
d36 1
d42 1
d45 3
a47 1
	int fldr;	/* Original field record number */
d49 3
a51 1
	int tracf;	/* Trace number within original field record */
d56 1
d59 3
a61 1
	int cdp;	/* Ensemble number (i.e. CDP, CMP, CRP,...) */
d65 1
d136 1
d142 1
d148 1
d154 1
d161 1
d167 1
d170 3
a172 1
	int selev;	/* Surface elevation at source. */
d174 3
a176 1
	int sdepth;	/* Source depth below surface (a positive number). */
d178 3
a180 1
	int gdel;	/* Datum elevation at receiver group. */
d182 3
a184 1
	int sdel;	/* Datum elevation at source. */
d186 3
a188 1
	int swdep;	/* Water depth at source. */
d190 3
a192 1
	int gwdep;	/* Water depth at receiver group. */
d199 1
d207 1
d210 3
a212 1
	int  sx;	/* Source coordinate - X */
d214 3
a216 1
	int  sy;	/* Source coordinate - Y */
d218 3
a220 1
	int  gx;	/* Group coordinate - X */
d222 3
a224 1
	int  gy;	/* Group coordinate - Y */
d243 1
d246 3
a248 1
	short wevel;	/* Weathering velocity. */
d250 3
a252 1
	short swevel;	/* Subweathering velocity. */
d254 3
a256 1
	short sut;	/* Uphole time at source in milliseconds. */
d258 3
a260 1
	short gut;	/* Uphole time at receiver group in milliseconds. */
d262 3
a264 1
	short sstat;	/* Source static correction in milliseconds. */
d266 3
a268 1
	short gstat;	/* Group static correction  in milliseconds.*/
d272 1
d281 3
a283 1
			   specified by the recording system */
d287 3
a289 1
			   may be positive or negative */
d295 3
a297 1
			   start at zero time) */
d299 3
a301 1
	short muts;	/* mute time--start */
d303 3
a305 1
	short mute;	/* mute time--end */
d307 3
a309 1
	unsigned short ns;	/* number of samples in this trace */
d311 3
a313 1
	unsigned short dt;	/* sample interval; in micro-seconds */
d319 3
a321 1
				4 ---- N = optional use */
d323 3
a325 1
	short igc;	/* instrument gain constant */
d327 3
a329 1
	short igi;	/* instrument early or initial gain */
d333 3
a335 1
				2 = yes */
d337 3
a339 1
	short sfs;	/* sweep frequency at start */
d341 3
a343 1
	short sfe;	/* sweep frequency at end */
d345 3
a347 1
	short slen;	/* sweep length in ms */
d352 3
a354 1
				3 = other */
d356 3
a358 1
	short stas;	/* sweep trace length at start in ms */
d360 3
a362 1
	short stae;	/* sweep trace length at end in ms */
d364 3
a366 1
	short tatyp;	/* taper type: 1=linear, 2=cos^2, 3=other */
d368 3
a370 1
	short afilf;	/* alias filter frequency if used */
d372 3
a374 1
	short afils;	/* alias filter slope */
d376 3
a378 1
	short nofilf;	/* notch filter frequency if used */
d380 3
a382 1
	short nofils;	/* notch filter slope */
d384 3
a386 1
	short lcf;	/* low cut frequency if used */
d388 3
a390 1
	short hcf;	/* high cut frequncy if used */
d392 3
a394 1
	short lcs;	/* low cut slope */
d396 3
a398 1
	short hcs;	/* high cut slope */
d400 3
a402 1
	short year;	/* year data recorded */
d404 3
a406 1
	short day;	/* day of year */
d408 3
a410 1
	short hour;	/* hour of day (24 hour clock) */
d412 3
a414 1
	short minute;	/* minute of hour */
d416 3
a418 1
	short sec;	/* second of minute */
d423 3
a425 1
				3 = other */
d428 3
a430 1
			   volts for the least sigificant bit */
d433 3
a435 1
			   position one */
d438 3
a440 1
			   original field record */
d443 3
a445 1
			   original field record */
d447 3
a449 1
	short gaps;	/* gap size (total number of groups dropped) */
d453 3
a455 1
				2 = up (or ahead) */
d461 3
a463 1
	float d1;	/* sample spacing for non-seismic data */
d465 3
a467 1
	float f1;	/* first sample location for non-seismic data */
d469 3
a471 1
	float d2;	/* sample spacing between traces */
d473 3
a475 1
	float f2;	/* first trace location */
d478 3
a480 1
			   range compression */
d483 3
a485 1
			   range */
d487 3
a489 1
	short mark;	/* mark selected traces */
d492 8
a499 4
	short mutb;	/* mute time at bottom (start time)  */
			/* bottom mute ends at last sample   */
	float dz;	/* depth sampling interval in (m or ft)  */
			/* if =0.0, input are time samples       */
d501 3
a503 1
	float fz;	/* depth of first sample in (m or ft)  */
d505 3
a507 1
	short n2;	/* number of traces per cdp or per shot */
d509 3
a511 1
        short shortpad; /* alignment padding */
d513 3
a515 1
	int ntr; 	/* number of traces */
d519 3
a521 1
	short unass[8];	/* unassigned */
d526 3
a528 1
	float d1;	/* sample spacing for non-seismic data */
d530 3
a532 1
	float f1;	/* first sample location for non-seismic data */
d534 3
a536 1
	float d2;	/* sample spacing between traces */
d538 3
a540 1
	float f2;	/* first trace location */
d543 3
a545 1
			   range compression */
d548 3
a550 1
			   range */
d552 3
a554 1
	int ntr; 	/* number of traces */
d556 3
a558 1
	short mark;	/* mark selected traces */
d560 3
a562 1
        short shortpad; /* alignment padding */
d570 3
a572 1
			   entry */
@


1.29
log
@updated format field
@
text
@d19 1
a19 1
 * $Revision: 1.28 $ ; $Date: 2006/08/14 20:44:48 $
d330 1
a330 1
#ifdef UNOCAL_SEGY_H  /* begin Unocal SU segy.h differences */
d350 1
a350 1
	/* UNOCAL local assignments */ 
d364 1
a364 1
	/* UNOCAL local assignments end */ 
@


1.28
log
@updated ISSEISMIC macro to include other "seismic" types.
@
text
@d19 1
a19 1
 * $Revision: 1.27 $ ; $Date: 2006/04/27 22:13:32 $
d426 7
a432 4
				1 = floating point (4 bytes)
				2 = fixed point (4 bytes)
				3 = fixed point (2 bytes)
				4 = fixed point w/gain code (4 bytes) */
@


1.27
log
@changed SU_NFLTS to USHRT_MAX and put in an include for limits.h
@
text
@d19 1
a19 1
 * $Revision: 1.26 $ ; $Date: 2005/01/21 20:18:45 $
a124 5
			143 = Seismic Data, Vertical Component 
			144 = Seismic Data, Horizontal Component 1 
			145 = Seismic Data, Horizontal Component 2 
			146 = Seismic Data, Radial Component
			147 = Seismic Data, Transverse Component  
d520 4
d625 2
a626 4
/* #define ISSEISMIC(id) (( (id)==0 || (id)==TREAL || (id)==TDEAD || (id)==TDUMMY ) ? cwp_true : cwp_false ) */
#define ISSEISMIC(id) (( (id)==0 || (id)==TREAL || (id)==TDEAD || (id)==TDUMMY || \
						 (id)==TVERT || (id)==TXLIN || (id)==TINLIN || \
						 (id)==TRADIAL || (id)==TTRANS  ) ? cwp_true : cwp_false ) 
@


1.26
log
@updated TRIDS and segy header field descriptions in accordance
with SEGY REV 1
@
text
@d1 1
d19 1
a19 1
 * $Revision: 1.25 $ ; $Date: 2004/08/25 17:14:20 $
d22 2
d27 1
a27 1
#define SU_NFLTS	32768	/* Arbitrary limit on data array size	*/
d335 4
a338 1
	/* local assignments */
d353 14
d369 8
a376 1
	short mark;	/* mark selected traces */
d378 1
a378 1
#ifdef UNOCAL_SEGY_H  /* begin Unocal SU segy.h differences */
d380 1
a380 4
        short mutb;     /* mute time at bottom (start time)  */
                        /* bottom mute ends at last sample   */
        float dz;       /* depth sampling interval in (m or ft)  */
                        /* if =0.0, input are time samples       */
d382 1
a382 1
        float fz;       /* depth of first sample in (m or ft)  */
d384 2
a385 1
        short n2;       /* number of traces per cdp or per shot */
d387 4
a390 1
        short shortpad; /* alignment padding */
d392 1
a392 2
        short unass[8];        /* end Unocal SU segy.h header differences */
#else
@


1.25
log
@*** empty log message ***
@
text
@a0 3
/* Copyright (c) Colorado School of Mines, 2002.*/
/* All rights reserved.                       */

d18 1
a18 1
 * $Revision: 1.24 $ ; $Date: 2004/02/17 18:32:15 $
d30 25
a54 13
	int tracl;	/* trace sequence number within line */

	int tracr;	/* trace sequence number within reel */

	int fldr;	/* field record number */

	int tracf;	/* trace number within field record */

	int ep;	/* energy source point number */

	int cdp;	/* CDP ensemble number */

	int cdpt;	/* trace number within CDP ensemble */
d57 32
a88 9
			1 = seismic data
			2 = dead
			3 = dummy
			4 = time break
			5 = uphole
			6 = sweep
			7 = timing
			8 = water break
			9---, N = optional use (N = 32,767)
d92 2
a93 3
			 9 = autocorrelation

			10 = Fourier transformed - no packing
d95 1
a95 2

			11 = Fourier transformed - unpacked Nyquist
d97 1
a97 2

			12 = Fourier transformed - packed Nyquist
d106 1
a106 2

			13 = Complex signal in the time domain
d108 1
a108 2

			14 = Fourier transformed - amplitude/phase
d110 1
a110 2

			15 = Complex time signal - amplitude/phase
d112 18
d131 78
a208 13
			16 = Real part of complex trace from 0 to Nyquist

			17 = Imag part of complex trace from 0 to Nyquist

			18 = Amplitude of complex trace from 0 to Nyquist

			19 = Phase of complex trace from 0 to Nyquist

			21 = Wavenumber time domain (k-t)

			22 = Wavenumber frequency (k-omega)

			23 = Envelope of the complex time trace
d210 1
a210 1
			24 = Phase of the complex time trace
d212 1
a212 1
			25 = Frequency of the complex time trace
d214 1
a214 1
			30 = Depth-Range (z-x) traces
d216 1
a216 1
			43 = Seismic Data, Vertical Component 
d218 1
a218 1
			44 = Seismic Data, Horizontal Component 1 
d220 1
a220 1
			45 = Seismic Data, Horizontal Component 2 
d222 2
a223 7
			46 = Seismic Data, Radial Component

			47 = Seismic Data, Transverse Component  

			101 = Seismic data packed to bytes (by supack1)
			
			102 = Seismic data packed to 2 bytes (by supack2)
d226 1
a226 72
	short nvs;	/* number of vertically summed traces (see vscode
			   in bhed structure) */

	short nhs;	/* number of horizontally summed traces (see vscode
			   in bhed structure) */

	short duse;	/* data use:
				1 = production
				2 = test */

	int offset;	/* distance from source point to receiver
			   group (negative if opposite to direction
			   in which the line was shot) */

	int gelev;	/* receiver group elevation from sea level
			   (above sea level is positive) */

	int selev;	/* source elevation from sea level
			   (above sea level is positive) */

	int sdepth;	/* source depth (positive) */

	int gdel;	/* datum elevation at receiver group */

	int sdel;	/* datum elevation at source */

	int swdep;	/* water depth at source */

	int gwdep;	/* water depth at receiver group */

	short scalel;	/* scale factor for previous 7 entries
			   with value plus or minus 10 to the
			   power 0, 1, 2, 3, or 4 (if positive,
			   multiply, if negative divide) */

	short scalco;	/* scale factor for next 4 entries
			   with value plus or minus 10 to the
			   power 0, 1, 2, 3, or 4 (if positive,
			   multiply, if negative divide) */

	int  sx;	/* X source coordinate */

	int  sy;	/* Y source coordinate */

	int  gx;	/* X group coordinate */

	int  gy;	/* Y group coordinate */

	short counit;	/* coordinate units code:
				for previous four entries
				1 = length (meters or feet)
				2 = seconds of arc (in this case, the
				X values are longitude and the Y values
				are latitude, a positive value designates
				the number of seconds east of Greenwich
				or north of the equator */

	short wevel;	/* weathering velocity */

	short swevel;	/* subweathering velocity */

	short sut;	/* uphole time at source */

	short gut;	/* uphole time at receiver group */

	short sstat;	/* source static correction */

	short gstat;	/* group static correction */

	short tstat;	/* total static applied */

	short laga;	/* lag time A, time in ms between end of 240-
a496 5
/* The following refer to the trid field in segy.h		*/
/* CHARPACK represents byte packed seismic data from supack1	*/
#define		CHARPACK	101
/* SHORTPACK represents 2 byte packed seismic data from supack2	*/
#define		SHORTPACK	102
d514 52
a565 1

d567 3
a569 1
#define		TCMPLX		13
d571 1
a571 9
#define		TAMPH		15
/* FPACK represents packed frequency domain data 		*/
#define		FPACK		12
/* FUNPACKNYQ represents complex frequency domain data 		*/
#define		FUNPACKNYQ	11
/* FCMPLX represents complex frequency domain data 		*/
#define		FCMPLX		10
/* FAMPH represents freq domain data in amplitude/phase form	*/
#define		FAMPH		14
d573 1
a573 1
#define		REALPART	16
d575 1
a575 1
#define		IMAGPART	17
d577 1
a577 1
#define		AMPLITUDE	18
d579 1
a579 1
#define		PHASE		19
d581 1
a581 1
#define		KT		21
d583 1
a583 1
#define		KOMEGA		22
d585 1
a585 1
#define		ENVELOPE	23
d587 1
a587 1
#define		INSTPHASE	24
d589 1
a589 1
#define		INSTFREQ	25
d591 1
a591 1
#define		TRID_DEPTH	30
d594 4
a597 10
/* TVERT represents the vertical component */
#define     TVERT          43
/* TVHOZ1 represents the horizontal-1 component */
#define     THORZ1         44
/* TVHOZ2 represents the horizontal-2 component */
#define     THORZ2         45
/* TRADIAL represents the radial component */
#define     TRADIAL        46
/* TTRANS represents the transverse component */
#define     TTRANS         47
d601 1
a601 1
						 (id)==TVERT || (id)==THORZ1 || (id)==THORZ2 || \
@


1.24
log
@all sorts of stuff
@
text
@d21 1
a21 1
 * $Revision: 1.23 $ ; $Date: 1998/03/26 23:48:18 $
d318 16
d343 1
@


1.23
log
@Stew Levin's segy.h
@
text
@d1 1
a1 4
/* Copyright (c) Colorado School of Mines, 1997.*/
/* All rights reserved.                       */

/* Copyright (c) Colorado School of Mines, 1994.*/
d19 1
a19 1
 * $Author: jkc $
d21 1
a21 1
 * $Revision: 1.20 $ ; $Date: 1996/02/20 16:41:29 $
d107 10
d444 1
d502 17
a518 2

#define ISSEISMIC(id) (( (id)==0 || (id)==TREAL || (id)==TDEAD || (id)==TDUMMY ) ? cwp_true : cwp_false )
d528 1
@


1.22
log
@updated ISSEISMIC to include cwp_true, cwp_false
@
text
@d1 3
d22 1
a22 1
 * $Author: john $
d24 1
a24 1
 * $Revision: 1.21 $ ; $Date: 1997/07/15 19:28:37 $
d30 1
a30 1
#define SU_NFLTS	32767	/* Arbitrary limit on data array size	*/
d311 2
d314 1
a314 1
	short unass[15];	/* unassigned--NOTE: last entry causes 
@


1.21
log
@changed SU_NFLTS to short min minus 1
@
text
@d19 1
a19 1
 * $Author: jkc $
d21 1
a21 1
 * $Revision: 1.20 $ ; $Date: 1996/02/20 16:41:29 $
d490 1
a490 1
#define ISSEISMIC(id) ( (id)==0 || (id)==TREAL || (id)==TDEAD || (id)==TDUMMY )
@


1.20
log
@Typed hns, hdt, dto, nso as unsigned short to be compatible
with ns and dt.  Since SU_NFLTS has now been bumped one
higher than the max signed positive short, this made a
bug with data that had the legal value ns=32768.
Thx to Toralf.
@
text
@d21 1
a21 1
 * $Revision: 1.19 $ ; $Date: 1995/11/13 19:51:04 $
d27 1
a27 1
#define SU_NFLTS	32768	/* Arbitrary limit on data array size	*/
@


1.19
log
@Added prototype for fvgettr.
Also updated hdr.h.save and header.h.save in this directory.
@
text
@d19 1
a19 1
 * $Author: john $
d21 1
a21 1
 * $Revision: 1.18 $ ; $Date: 1995/11/13 19:31:23 $
d333 1
a333 1
	short hdt;	/* sample interval in micro secs for this reel */
d335 1
a335 1
	short dto;	/* same for original field recording */
d337 1
a337 1
	short hns;	/* number of samples per trace for this reel */
d339 1
a339 1
	short nso;	/* same for original field recording */
@


1.18
log
@*** empty log message ***
@
text
@d21 1
a21 1
 * $Revision: 1.17 $ ; $Date: 1994/11/28 15:46:37 $
d498 1
@


1.17
log
@added vgettr macro and added new locally assigned header field
"ntr".
@
text
@d19 3
a21 3
 * $Author: jkc $
 * $Source: /NeXTMount_3.1b/usr/local/cwp/src/su/include/RCS/segy.h,v $
 * $Revision: 1.15 $ ; $Date: 94/10/06 14:22:48 $
d304 2
a307 1
	int ntr; 	/* number of traces */
@


1.16
log
@added macro vgettr
@
text
@d1 3
d20 1
a20 1
 * $Source: /usr/local/cwp/src/su/include/RCS/segy.h,v $
d306 3
a308 1
	short unass[17];	/* unassigned--NOTE: last entry causes 
d429 1
a429 1
#define vgettr(x)	fgettr(stdin, (x))
a496 1
int fvgettr(FILE *fp, segy *tp);
@


1.15
log
@Moved defines having to do with bytes and numbers of fields on a segy-y
tape from segy.h to tapesegy.h.
@
text
@d17 2
a18 2
 * $Source: /NeXTMount_3.1b/usr/local/cwp/src/su/include/RCS/segy.h,v $
 * $Revision: 1.14 $ ; $Date: 94/09/06 09:24:39 $
d424 1
d492 1
@


1.14
log
@Added BHED_NKEYS macro.
Moved #defines for gettr(x), puttr(x) and gettra(x, y) here from su.h
Moved #defines for trid options (like TREAL) here from su.h
Moved #define for ISSEISMIC(id) here from su.h
Moved prototypes that involve segys (like fgettr, gethval) here from su.h
Added const declaration to appropriate prototype arguments
@
text
@d18 1
a18 1
 * $Revision: 1.13 $ ; $Date: 94/08/04 09:57:50 $
a23 5
#define	EBCBYTES	3200	/* Bytes in the card image EBCDIC block */
#define	BNYBYTES	400	/* Bytes in the binary coded block	*/
#define	SEGY_HDRBYTES	240	/* Bytes in the tape trace header	*/
#define	SEGY_NKEYS	71	/* Number of mandated header fields	*/
#define BHED_NKEYS	27	/* Number of mandated binary fields	*/
@


1.13
log
@Added SEGY_HDRBYTES (240) and SEGY_NKEYS (71).
@
text
@d18 1
a18 1
 * $Revision: 1.12 $ ; $Date: 94/07/08 13:47:25 $
a25 1
#define SU_NFLTS	32768	/* Arbitrary limit on data array size	*/
d28 2
d31 2
d426 92
@


1.12
log
@Changed long to int for compatibility with new 64 bit standard of
long=8bytes, int=4bytes.  To hell with 16 bit micros that never could
run unix anyway.
@
text
@d16 1
a16 1
 * $Author: john $
d18 1
a18 1
 * $Revision: 1.11 $ ; $Date: 94/06/24 14:25:49 $
d27 2
@


1.11
log
@changed   Y source coordinate to Y group coordinate
@
text
@d17 2
a18 2
 * $Source: /usr/local/cwp/src/su/include/RCS/segy.h,v $
 * $Revision: 1.10 $ ; $Date: 94/03/29 14:04:37 $
d30 1
a30 1
	long tracl;	/* trace sequence number within line */
d32 1
a32 1
	long tracr;	/* trace sequence number within reel */
d34 1
a34 1
	long fldr;	/* field record number */
d36 1
a36 1
	long tracf;	/* trace number within field record */
d38 1
a38 1
	long ep;	/* energy source point number */
d40 1
a40 1
	long cdp;	/* CDP ensemble number */
d42 1
a42 1
	long cdpt;	/* trace number within CDP ensemble */
d119 1
a119 1
	long offset;	/* distance from source point to receiver
d123 1
a123 1
	long gelev;	/* receiver group elevation from sea level
d126 1
a126 1
	long selev;	/* source elevation from sea level
d129 1
a129 1
	long sdepth;	/* source depth (positive) */
d131 1
a131 1
	long gdel;	/* datum elevation at receiver group */
d133 1
a133 1
	long sdel;	/* datum elevation at source */
d135 1
a135 1
	long swdep;	/* water depth at source */
d137 1
a137 1
	long gwdep;	/* water depth at receiver group */
d149 1
a149 1
	long  sx;	/* X source coordinate */
d151 1
a151 1
	long  sy;	/* Y source coordinate */
d153 1
a153 1
	long  gx;	/* X group coordinate */
d155 1
a155 1
	long  gy;	/* Y group coordinate */
d317 1
a317 1
	long jobid;	/* job identification number */
d319 1
a319 1
	long lino;	/* line number (only one line per reel) */
d321 1
a321 1
	long reno;	/* reel number */
@


1.10
log
@added trid = 25 comment.
@
text
@d17 2
a18 2
 * $Source: /usr/local/src/su/include/RCS/segy.h,v $
 * $Revision: 1.9 $ ; $Date: 94/03/29 11:57:39 $
d155 1
a155 1
	long  gy;	/* Y source coordinate */
@


1.9
log
@upped SU_NFLTS to 32767
@
text
@d16 1
a16 1
 * $Author: jkc $
d18 1
a18 1
 * $Revision: 1.8 $ ; $Date: 94/03/28 14:17:06 $
d99 2
@


1.8
log
@Added trids for envelope and phase(!)
@
text
@d17 2
a18 2
 * $Source: /NeXTMount_3.1b/usr/local/src/su/include/RCS/segy.h,v $
 * $Revision: 1.7 $ ; $Date: 93/11/02 13:18:55 $
d26 1
a26 1
#define SU_NFLTS	16384	/* Arbitrary limit on data array size	*/
@


1.7
log
@Corrected typo in description of counit.
@
text
@d18 1
a18 1
 * $Revision: 1.6 $ ; $Date: 92/06/18 14:14:20 $
d95 4
@


1.6
log
@Corrected ancient typo sweves -> swevel
@
text
@d16 3
a18 3
 * $Author: jkcohen $
 * $Source: /NeXTMount/usr/local/src/su/include/RCS/segy.h,v $
 * $Revision: 1.5 $ ; $Date: 91/06/23 11:33:22 $
d152 1
a152 1
				for previoius four entries
@


1.5
log
@Added TRID_DEPTH (30)
@
text
@d17 2
a18 2
 * $Source: /usr/local/cwp/src/su/include/RCS/segy.h,v $
 * $Revision: 1.4 $ ; $Date: 91/02/14 10:24:21 $
d162 1
a162 1
	short sweves;	/* subweathering velocity */
@


1.4
log
@Added floats d1,d2,f1,f2 took out s_sta, etc. and srstat, etc.
This will enable programs that don't output time domain data
to pass along good values to the plotting programs.
@
text
@d16 3
a18 3
 * $Author: jkc $
 * $Source: /usr/local/src/su/include/RCS/segy.h,v $
 * $Revision: 1.3 $ ; $Date: 90/11/04 09:19:43 $
d95 2
@


1.3
log
@ANSI C doesn't trailing comments
@
text
@d18 1
a18 1
 * $Revision: 1.2 $ ; $Date: 90/09/01 13:00:30 $
d279 1
a279 1
	short s_sta;
d281 1
a281 1
	short g_sta;
d283 1
a283 1
	short h_sta;
d285 1
a285 1
	short y_sta;
a286 4
	long srstat;	/* residual shot statics */

	long grstat;	/* residual geophone statics */

a292 2
	long ntr;	/* number of traces in the data set */

d295 1
a295 1
	short unass[15];	/* unassigned--NOTE: last entry causes 
@


1.2
log
@Wrote description for trid 11
@
text
@d18 1
a18 1
 * $Revision: 1.1 $ ; $Date: 90/09/01 12:57:54 $
d419 2
a420 1
#endif INCLUDE_SEGY_H
@


1.1
log
@Initial revision
@
text
@d17 2
a18 2
 * $Source: /src/su/include/RCS/segy.h,v $
 * $Revision: 1.44 $ ; $Date: 88/11/26 22:53:08 $
d63 1
a63 1
			     ???
@
