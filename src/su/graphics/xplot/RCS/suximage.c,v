head	1.40;
access;
symbols;
locks; strict;
comment	@ * @;


1.40
date	2011.11.12.00.45.18;	author john;	state Exp;
branches;
next	1.39;

1.39
date	2011.09.09.22.35.53;	author john;	state Exp;
branches;
next	1.38;

1.38
date	2005.02.16.23.07.41;	author john;	state Exp;
branches;
next	1.37;

1.37
date	2005.02.02.00.14.53;	author john;	state Exp;
branches;
next	1.36;

1.36
date	2004.08.18.18.41.30;	author john;	state Exp;
branches;
next	1.35;

1.35
date	2003.08.20.18.26.36;	author john;	state Exp;
branches;
next	1.34;

1.34
date	97.10.23.21.42.28;	author john;	state Exp;
branches;
next	1.33;

1.33
date	96.09.16.18.59.38;	author jkc;	state Exp;
branches;
next	1.32;

1.32
date	96.08.11.21.03.49;	author jkc;	state Exp;
branches;
next	1.31;

1.31
date	96.08.11.20.06.23;	author jkc;	state Exp;
branches;
next	1.30;

1.30
date	96.08.02.22.50.20;	author jkc;	state Exp;
branches;
next	1.29;

1.29
date	95.10.03.19.07.29;	author jkc;	state Exp;
branches;
next	1.28;

1.28
date	95.10.03.18.50.57;	author jkc;	state Exp;
branches;
next	1.27;

1.27
date	95.02.28.13.10.50;	author jkc;	state Exp;
branches;
next	1.26;

1.26
date	95.02.21.14.56.14;	author jkc;	state Exp;
branches;
next	1.25;

1.25
date	95.01.19.12.14.29;	author john;	state Exp;
branches;
next	1.24;

1.24
date	95.01.19.11.37.39;	author john;	state Exp;
branches;
next	1.23;

1.23
date	94.12.05.09.54.53;	author john;	state Exp;
branches;
next	1.22;

1.22
date	94.11.28.15.46.13;	author john;	state Exp;
branches;
next	1.21;

1.21
date	94.03.30.14.01.34;	author john;	state Exp;
branches;
next	1.20;

1.20
date	93.09.14.13.23.51;	author jkc;	state Exp;
branches;
next	1.19;

1.19
date	93.09.11.08.06.07;	author john;	state Exp;
branches;
next	1.18;

1.18
date	92.10.26.15.17.33;	author john;	state Exp;
branches;
next	1.17;

1.17
date	91.09.06.08.30.35;	author jkcohen;	state Exp;
branches;
next	1.16;

1.16
date	91.03.05.15.18.29;	author jkcohen;	state Exp;
branches;
next	1.15;

1.15
date	91.03.03.13.49.18;	author jkc;	state Exp;
branches;
next	1.14;

1.14
date	91.02.22.15.12.53;	author jkcohen;	state Exp;
branches;
next	1.13;

1.13
date	91.02.14.10.27.24;	author jkcohen;	state Exp;
branches;
next	1.12;

1.12
date	90.11.03.14.40.22;	author jkc;	state Exp;
branches;
next	1.11;

1.11
date	90.11.02.09.27.23;	author jkc;	state Exp;
branches;
next	1.10;

1.10
date	90.11.01.22.41.16;	author jkc;	state Exp;
branches;
next	1.9;

1.9
date	90.11.01.20.46.10;	author jkc;	state Exp;
branches;
next	1.8;

1.8
date	90.11.01.16.38.02;	author jkc;	state Exp;
branches;
next	1.7;

1.7
date	90.10.29.10.42.11;	author jkc;	state Exp;
branches;
next	1.6;

1.6
date	90.09.13.10.23.55;	author jkc;	state Exp;
branches;
next	1.5;

1.5
date	90.06.12.22.59.05;	author jkc;	state Exp;
branches;
next	1.4;

1.4
date	90.06.04.11.40.38;	author jkc;	state Exp;
branches;
next	1.3;

1.3
date	90.06.02.07.33.04;	author jkc;	state Exp;
branches;
next	1.2;

1.2
date	90.06.01.20.31.02;	author jkc;	state Exp;
branches;
next	1.1;

1.1
date	90.06.01.15.53.09;	author jkc;	state Exp;
branches;
next	;


desc
@Put an image into an X window by calling Hale's ximage
@


1.40
log
@copyright
@
text
@/* Copyright (c) Colorado School of Mines, 2011.*/
/* All rights reserved.                       */

/* SUXIMAGE: $Revision: 1.39 $ ; $Date: 2011/09/09 22:35:53 $		*/

#include "su.h"
#include "segy.h"
#include <signal.h>

/*********************** self documentation *****************************/
char *sdoc[] = {
"									",
" SUXIMAGE - X-windows IMAGE plot of a segy data set	                ",
"									",
" suximage infile= [optional parameters] | ...  (direct I/O)            ",
"  or					                		",
" suximage <stdin [optional parameters] | ...	(sequential I/O)        ",
"									",
" Optional parameters:						 	",
"									",
" infile=NULL SU data to be ploted, default stdin with sequential access",
"             if 'infile' provided, su data read by (fast) direct access",
"									",
"	      with ftr,dtr and n2 suximage will pass a subset of data   ",
"	      to the plotting program-ximage:                           ",
" ftr=1       First trace to be plotted                                 ",
" dtr=1       Trace increment to be plotted                             ",
" n2=tr.ntr   (Max) number of traces to be plotted (ntr is an alias for n2)",
"	      Priority: first try to read from parameter line;		",
"		        if not provided, check trace header tr.ntr;     ",
"		        if still not provided, figure it out using ftello",
"									",
" d1=tr.d1 or tr.dt/10^6	sampling interval in the fast dimension	",
"   =.004 for seismic 		(if not set)				",
"   =1.0 for nonseismic		(if not set)				",
" 							        	",
" d2=tr.d2		sampling interval in the slow dimension	        ",
"   =1.0 		(if not set or was set to 0)		        ",
"									",
" key=			key for annotating d2 (slow dimension)		",
" 			If annotation is not at proper increment, try	",
" 			setting d2; only first trace's key value is read",
" 							        	",
" f1=tr.f1 or tr.delrt/10^3 or 0.0  first sample in the fast dimension	",
" 							        	",
" f2=tr.f2 or tr.tracr or tr.tracl  first sample in the slow dimension	",
"   =1.0 for seismic		    (if not set)			",
"   =d2 for nonseismic		    (if not set)			",
" 							        	",
" verbose=0             =1 to print some useful information		",
"									",
" tmpdir=	 	if non-empty, use the value as a directory path	",
"		 	prefix for storing temporary files; else if the	",
"	         	the CWP_TMPDIR environment variable is set use	",
"	         	its value for the path; else use tmpfile()	",
" 									",
" Note that for seismic time domain data, the \"fast dimension\" is	",
" time and the \"slow dimension\" is usually trace number or range.	",
" Also note that \"foreign\" data tapes may have something unexpected	",
" in the d2,f2 fields, use segyclean to clear these if you can afford	",
" the processing time or use d2= f2= to override the header values if	",
" not.									",
"									",
" See the ximage selfdoc for the remaining parameters.		        ",
"									",
NULL};

/* Credits:
 *
 *	CWP: Dave Hale and Zhiming Li (ximage, etc.)
 *	   Jack Cohen and John Stockwell (suximage, etc.)
 *	MTU: David Forel, June 2004, added key for annotating d2
 *      ConocoPhillips: Zhaobo Meng, Dec 2004, added direct I/O
 *
 * Notes:
 *
 *      When provide ftr and dtr and infile, suximage can be used to plot 
 *      multi-dimensional volumes efficiently.  For example, for a Offset-CDP
 *      dataset with 32 offsets, the command line
 *      suximage infile=volume3d.su ftr=1 dtr=32 ... &
 *      will display the zero-offset common offset data with ranrom access.  
 *      It is highly recommend to use infile= to view large datasets, since
 *      using stdin only allows sequential access, which is very slow for 
 *      large datasets.
 *
 *	When the number of traces isn't known, we need to count
 *	the traces for ximage.  You can make this value "known"
 *	either by getparring n2 or by having the ntr field set
 *	in the trace header.  A getparred value takes precedence
 *	over the value in the trace header.
 *
 *	When we must compute ntr, we don't allocate a 2-d array,
 *	but just content ourselves with copying trace by trace from
 *	the data "file" to the pipe into the plotting program.
 *	Although we could use tr.data, we allocate a trace buffer
 *	for code clarity.
 */
/**************** end self doc *******************************************/

static void closefiles(void);

/* Globals (so can trap signal) defining temporary disk files	*/
char tracefile[BUFSIZ];	/* filename for trace storage file	*/
FILE *tracefp;		/* fp for trace storage file		*/

segy tr;

int
main(int argc, char **argv)
{
	char plotcmd[BUFSIZ];   /* build ximage command for popen	*/
	float *trbuf;		/* trace buffer				*/
	FILE *plotfp;		/* fp for plot data			*/
	int nt;			/* number of samples on trace	  	*/
	int ntr;      	        /* number of traces			*/
	int verbose;		/* verbose flag				*/
	float d1;		/* time/depth sample rate		*/
	float d2;		/* trace/dx sample rate			*/
	float f1;		/* tmin/zmin			   	*/
	float f2;		/* tracemin/xmin			*/
	cwp_Bool seismic;	/* is this seismic data?		*/
	cwp_Bool have_ntr=cwp_false;/* is ntr known from header or user?*/
	char *tmpdir;		/* directory path for tmp files		*/
	cwp_Bool istmpdir=cwp_false;/* true for user given path		*/
	char *infile=NULL;      /* dataset file name */
        FILE *infp=stdin;       /* input SU dataset to be viewed */
        int dtr,ftr,ntraces,nseek,jtr;	/* work variables */

	char *cwproot=NULL;	/* value of CWPROOT environment variable*/
	char *bindir;		/* directory path for tmp files		*/

  	cwp_String skey=NULL, stype=NULL ; /* trace annotation		*/
	Value val1 ;		/* trace annotation			*/
	cwp_Bool akey = 0 ;	/* trace annotation			*/
      
	/* Initialize */
	initargs(argc, argv);
	requestdoc(1);

        /* ZM: begin: get the line number, trace number type of control parameters for plotting */

        if (!getparint("ftr", &ftr)) ftr=1; /* using fortran convention */
        if (!getparint("dtr", &dtr)) dtr=1;
            
        if (ftr==0) ftr=1; /* for C-people like me */
        ftr--;             /* convert to C convention */
        if (ftr<0) err("First trace to be plotted ftr=%d must be positive",ftr);
        if (dtr<=0) err("Trace increment dtr=%d must be positive",dtr);
        if (ftr<0) err("ftr=%d must not be negative",ftr); 

	if (!getparstring("infile",&infile)) { /* default is stdin */
          infile=NULL;
          infp=stdin;
        } else               /* must provide a valid dataset name */
          if ((infp=fopen(infile, "r"))==NULL) 
            err("Can not open %s to plot",infile);
        /* ZM: end: get the line number, trace number type of control parameters for plotting */
	
	/* Get info from first trace */
	if (!fgettr(infp,&tr)) err("can't get first trace");
	seismic = ISSEISMIC(tr.trid); 
	nt = tr.ns;
	ntr = tr.ntr;
	if (ntr) have_ntr = cwp_true; 

	if (!getparint("verbose", &verbose))  verbose=0;
	if (!getparfloat("d1", &d1)) {
		if      (tr.d1)  d1 = tr.d1;
		else if (tr.dt)  d1 = ((double) tr.dt)/1000000.0;
		else {
			if (seismic) {
				d1 = 0.004;
				warn("tr.dt not set, assuming dt=0.004");
			} else { /* non-seismic data */
				d1 = 1.0;
				warn("tr.d1 not set, assuming d1=1.0");
			}
		}
	}
        if (fabs(d1)<=0.1E-20) d1=1.0;

      	if (!getparstring("key", &skey)) {
		akey = 0 ;
		skey = "" ;
	} else {
		akey  = 1 ;
		gethdval(&tr, skey, &val1) ;
		stype = hdtype(skey) ;
	}

	if (!getparfloat("d2", &d2)) d2 = (tr.d2) ? tr.d2 : 1.0;
        if (fabs(d2)<=0.1E-20) d2=1.0;

	if (!getparfloat("f1", &f1)) {
		if      (tr.f1)     f1 = tr.f1;
		else if (tr.delrt)  f1 = (float) tr.delrt/1000.0;
		else                f1 = 0.0;
	}

	if (!getparfloat("f2", &f2)) {
		if	(tr.f2)	f2 = tr.f2;
                else if (akey)      f2 = vtof(stype,val1) ;
		else if (tr.tracr)  f2 = (float) tr.tracr;
		else if (tr.tracl)  f2 = (float) tr.tracl;
		else if (seismic)   f2 = 1.0;
		else	            f2 = 0.0;
	}

	/* Look for user-supplied tmpdir */
	if (!getparstring("tmpdir",&tmpdir) &&
	    !(tmpdir = getenv("CWP_TMPDIR"))) tmpdir="";
	if (!STREQ(tmpdir, "") && access(tmpdir, WRITE_OK))
		err("you can't write in %s (or it doesn't exist)", tmpdir);

	/* See if CWPBIN environment variable is not set */
	if (!(bindir = getenv("CWPBIN"))) { /* construct bindir from CWPROOT */

		bindir = (char *) emalloc(BUFSIZ);

		/* Get value of CWPROOT environment variable */
		if (!(cwproot = getenv("CWPROOT"))) cwproot ="" ;
		if (STREQ(cwproot, "")) {
			warn("CWPROOT environment variable is not set! ");
			err("Set CWPROOT in shell environment as per instructions in CWP/SU Installation README files");
		}
		/* then bindir = $CWPROOT/bin */
	/*	sprintf(bindir, "%s/bin", cwproot); */
	}
	/* strcat(bindir,"/"); */   /* put / at the end of bindir */

	/* Allocate trace buffer */
	trbuf = ealloc1float(nt);


        /* ZM: begin: get n2 by random access */
	/* Get or set ntr */
	if (getparint("n2", &ntr) || getparint("ntr", &ntr)) have_ntr = cwp_true;
        else if (infp!=stdin) {  /* ZM */

	    if (efseeko(infp,(off_t) 0,SEEK_END)==-1)
		err("input file size unknown; specify n2\n");

            if (verbose)
              warn("eftello(infp)=%ld",eftello(infp));

	    ntraces = (int) (eftello(infp)/((nt+60)*FSIZE));

            if (verbose)
              warn("There are ntraces=%d in the dataset",ntraces);

            if (ftr>=ntraces) err("First trace pass End of File: ftr=%d ntraces=%d",ftr,ntraces);
            ntr = (int) ((ntraces-1-ftr)/dtr);

            if (verbose)
              warn("Number of traces to be plotted",ntr);

            /* efseeko(infp,(off_t)0,SEEK_SET); */
            have_ntr = cwp_true;
        }
        /* ZM: end: get n2 by random access */


	if (!have_ntr) { /* count traces */
		if (verbose) {
			warn("n2 not getparred and ntr header field not set");
			warn("....  counting traces");
		}

		/* Create temporary "file" to hold data */
		if (STREQ(tmpdir,"")) {
			tracefp = etmpfile();
			if (verbose) warn("using tmpfile() call");
		} else { /* user-supplied tmpdir */
			char directory[BUFSIZ];
			strcpy(directory, tmpdir);
			strcpy(tracefile, temporary_filename(directory));
			/* Handle user interrupts */
			signal(SIGINT, (void (*) (int)) closefiles);
			signal(SIGQUIT, (void (*) (int)) closefiles);
			signal(SIGHUP,  (void (*) (int)) closefiles);
			signal(SIGTERM, (void (*) (int)) closefiles);
			tracefp = efopen(tracefile, "w+");
			istmpdir=cwp_true;		
			if (verbose)
			      warn("putting temporary files in %s", directory);
		}

		/* Loop over input data and read to temporary file */
		ntr = 0;
		do {
			++ntr;
			efwrite(tr.data, FSIZE, nt, tracefp);
		} while (fgettr(infp,&tr));


	} 

	/* Set up ximage command line */
        if (verbose) {
    	    fprintf(stderr,
	        "%s/bin/ximage n1=%d n2=%d d1=%f d2=%f f1=%f f2=%f", cwproot,
		   nt, ntr, d1, d2, f1, f2);
        }

	sprintf(plotcmd,
	    "%s/bin/ximage n1=%d n2=%d d1=%f d2=%f f1=%f f2=%f verbose=%d ", cwproot,
		   nt, ntr, d1, d2, f1, f2, verbose);

	for (--argc, ++argv; argc; --argc, ++argv) {
		if (strncmp(*argv, "d1=", 3) && /* skip those already set */
		    strncmp(*argv, "d2=", 3) &&
		    strncmp(*argv, "f1=", 3) &&
		    strncmp(*argv, "verbose=", 8) &&
		    strncmp(*argv, "n1=", 3) &&
		    strncmp(*argv, "n2=", 3) &&
		    strncmp(*argv, "f2=", 3)) {
		    
			strcat(plotcmd, " ");   /* put a space between args */
			strcat(plotcmd, "\"");  /* user quotes are stripped */
			strcat(plotcmd, *argv); /* add the arg */
			strcat(plotcmd, "\"");  /* user quotes are stripped */
		}
	}


	/* Open pipe to ximage and send the traces */
	plotfp = epopen(plotcmd, "w");
	
	if (!have_ntr) { /* send out stored traces one by one  by sequential access*/
		rewind(tracefp);
		{ register int itr;
			for (itr = 0; itr < ntr; ++itr) {
				efread (trbuf, FSIZE, nt, tracefp);
                                if (itr>=ftr && (itr-ftr)/dtr*dtr==(itr-ftr)) efwrite(trbuf, FSIZE, nt, plotfp);
			}
		}
	} else {  /* ZM: just pump out traces and let ximage do the work by random access */
                for (jtr=0;jtr<ntr;jtr++) {
                    nseek = (off_t)(60+nt)*(ftr+jtr*dtr);
                    efseeko(infp,nseek*((off_t) FSIZE),SEEK_SET);

    	            if (!fgettr(infp,&tr)) break;
	    	        efwrite(tr.data, FSIZE, nt, plotfp);
                } /* ZM: end: reading by random access */
	}


	/* Clean up */
	epclose(plotfp);
	if (!have_ntr) {
		efclose(tracefp);
		if (istmpdir) eremove(tracefile);
	} else
		efclose(infp);

	return EXIT_SUCCESS;
}

/* for graceful interrupt termination */
static void closefiles(void)
{
	efclose(tracefp);
	eremove(tracefile);
	exit(EXIT_FAILURE);
}
@


1.39
log
@*** empty log message ***
@
text
@d1 4
a4 1
/* SUXIMAGE: $Revision: 1.38 $ ; $Date: 2005/02/16 23:07:41 $		*/
@


1.38
log
@ZaHhHH[3~[3~aobo's fix
@
text
@d1 1
a1 1
/* SUXIMAGE: $Revision: 1.37 $ ; $Date: 2005/02/02 00:14:53 $		*/
d126 1
a126 1
	char *cwproot;		/* value of CWPROOT environment variable*/
d224 1
a224 1
		sprintf(bindir, "%s/bin", cwproot);
d226 1
a226 1
	strcat(bindir,"/");   /* put / at the end of bindir */
d298 1
a298 1
	        "%sximage n1=%d n2=%d d1=%f d2=%f f1=%f f2=%f", bindir,
d303 1
a303 1
	    "%sximage n1=%d n2=%d d1=%f d2=%f f1=%f f2=%f verbose=%d ", bindir,
@


1.37
log
@Zhaobo Meng's updates
@
text
@d1 1
a1 1
/* SUXIMAGE: $Revision: 1.36 $ ; $Date: 2004/08/18 18:26:36 $		*/
d35 1
a35 1
"   =1.0 		(if not set)				        ",
d177 1
d189 1
@


1.36
log
@David Forel's key= option added
@
text
@d1 1
a1 1
/* SUXWIGB: $Revision: 36.2 $ ; $Date: 2003/08/05 22:24:47 $            */
d10 1
a10 1
" SUXIMAGE - X-windows IMAGE plot of a segy data set			",
d12 3
a14 1
" suximage <stdin [optional parameters] | ...				",
d18 11
a28 1
" n2=tr.ntr or number of traces in the data set (ntr is an alias for n2)",
d34 3
a36 3
" d2=tr.d2		sampling interval in the slow dimension		",
"   =1.0 		(if not set)					",
" 							        	",
d47 1
a47 1
" verbose=0              =1 to print some useful information		",
d61 1
a61 1
" See the ximage selfdoc for the remaining parameters.			",
d70 1
d73 10
d112 1
a112 1
	int ntr;		/* number of traces			*/
d122 3
d129 1
a129 1
	cwp_String skey=NULL, stype=NULL ; /* trace annotation		*/
d132 1
a132 1

d136 19
d157 1
a157 1
	if (!gettr(&tr)) err("can't get first trace");
d163 1
a163 1
	if (!getparint("verbose", &verbose))    verbose=0;
d178 1
a178 1
	if (!getparstring("key", &skey)) {
d197 1
a197 1
		else if (akey)      f2 = vtof(stype,val1) ;
d229 2
d233 24
d288 1
a288 1
		} while (gettr(&tr));
d294 6
d301 2
a302 2
		"%sximage n1=%d n2=%d d1=%f d2=%f f1=%f f2=%f", bindir,
			   nt, ntr, d1, d2, f1, f2);
d308 3
d324 1
a324 1
	if (!have_ntr) { /* send out stored traces one by one */
d329 1
a329 1
				efwrite(trbuf, FSIZE, nt, plotfp);
d332 8
a339 4
	} else { /* just pump out traces and let ximage do the work */
		do {
			efwrite(tr.data, FSIZE, nt, plotfp);
		} while (gettr(&tr));
d348 2
a349 1
	}
@


1.35
log
@20 August 2003
@
text
@d1 1
a1 1
/* SUXIMAGE: $Revision: 1.34 $ ; $Date: 1997/10/23 21:42:28 $		*/
d22 6
a27 2
" d2=tr.d2			sampling interval in the slow dimension	",
"   =1.0 			(if not set)				",
a50 1
" On NeXT:	suximage < infile [optional parameters]  | open		",
d57 1
d96 1
a96 1
	cwp_Bool have_ntr=cwp_false;/* is ntr known from header or user?	*/
d103 4
d133 9
d152 1
@


1.34
log
@cwp_true and other Stew Levin fixes
@
text
@d1 1
a1 1
/* SUXIMAGE: $Revision: 1.33 $ ; $Date: 1996/09/16 18:59:38 $		*/
d96 2
d147 16
d206 1
a206 1
		"ximage n1=%d n2=%d d1=%f d2=%f f1=%f f2=%f",
@


1.33
log
@Updated tmpfile handling.
@
text
@d1 1
a1 1
/* SUXIMAGE: $Revision: 1.32 $ ; $Date: 1996/08/11 21:03:49 $		*/
d92 1
a92 1
	cwp_Bool have_ntr=false;/* is ntr known from header or user?	*/
d94 1
a94 1
	cwp_Bool istmpdir=false;/* true for user given path		*/
d106 1
a106 1
	if (ntr) have_ntr = true; 
d149 1
a149 1
	if (getparint("n2", &ntr) || getparint("ntr", &ntr)) have_ntr = true;
d171 1
a171 1
			istmpdir=true;		
@


1.32
log
@Document verbose option.
@
text
@d1 1
a1 1
/* SUXIMAGE: $Revision: 1.31 $ ; $Date: 1996/08/11 20:06:23 $		*/
d73 2
a74 2
char datafile[BUFSIZ];	/* filename for trace storage file	*/
FILE *datafp;		/* fp for trace storage file		*/
d159 1
a159 1
			datafp = etmpfile();
d164 1
a164 1
			strcpy(datafile, temporary_filename(directory));
d167 2
d170 1
a170 1
			datafp = efopen(datafile, "w+");
d180 1
a180 1
			efwrite(tr.data, FSIZE, nt, datafp);
d209 1
a209 1
		rewind(datafp);
d212 1
a212 1
				efread (trbuf, FSIZE, nt, datafp);
d226 2
a227 2
		efclose(datafp);
		if (istmpdir) eremove(datafile);
d233 1
d236 3
a238 3
	efclose(datafp);
	eremove(datafile);

@


1.31
log
@Removed unistd.h to par.h.
@
text
@d1 1
a1 1
/* SUXIMAGE: $Revision: 1.30 $ ; $Date: 1996/08/02 22:50:20 $		*/
d31 2
@


1.30
log
@Inserted user-supplied tmpdir stuff.
@
text
@d1 1
a1 1
/* SUXIMAGE: $Revision: 1.29 $ ; $Date: 1995/10/03 19:07:29 $		*/
a5 1
#include <unistd.h>
@


1.29
log
@Cosmetic.
@
text
@d1 1
a1 1
/* SUXIMAGE: $Revision: 1.28 $ ; $Date: 1995/10/03 18:50:57 $		*/
d5 2
d32 5
a60 10
 *	When we do have to count the traces, we use the "tmpfile"
 *	routine because on many machines it is implemented
 *	as a memory area instead of a disk file.
 *
 *	If your system does make a disk file, consider altering
 *	the code to remove the file on interrupt.  This could be
 *	done either by trapping the interrupt with "signal"
 *	or by using the "tmpnam" routine followed by an immediate
 *	"remove" (aka "unlink" in old unix).
 *
d69 5
d77 1
a81 1
	FILE *datafp;		/* fp for trace data file 		*/
d92 2
d138 6
d157 15
a171 1
		datafp = etmpfile();
d222 4
a225 1
	if (!have_ntr) efclose(datafp);
d228 7
@


1.28
log
@Honor f1 and d1.  Converted to standard style self-doc.
@
text
@d1 1
a1 1
/* SUXIMAGE: $Revision: 1.27 $ ; $Date: 1995/02/28 13:10:50 $		*/
d131 1
a131 1
		else		f2 = 0.0;
@


1.27
log
@Modified boolean variables.
@
text
@d1 1
a1 1
/* SUXIMAGE: $Revision: 1.26 $ ; $Date: 95/02/21 14:56:14 $		*/
d15 1
a15 16
" n2 is the number of traces (ntr is an acceptable alias for n2)	",
"									",
" d1 is the sampling interval in the fast dimension.  If not getparred  ",
" then for seismic time domain data d1=tr.dt/10^6 if set, else 0.004.	",
" For other types of data d1=tr.d1 if set, else 1.0			",
"									",
" d2 is the sampling interval in the slow dimension.  If not getparred  ",
" d2=tr.d2 if set, else 1.0						",
"									",
" f1 is the first sample in the fast dimension.  If not getparred	",
" then for seismic time domain data f1=tr.delrt/10^3 if set, else 0.0.  ",
" For other types of data f1=tr.d1 if set else 0.0			",
"									",
" f2 is the first sample in the slow dimension.  If not getparred	",
" f2=tr.f2 if set, else tr.tracr if set, else tr.tracl if set,		",
" else 1.0 for seismic time domain data, else 0.0			",
d17 13
d105 4
a108 4
		if (seismic) {
			if (tr.dt) {
				d1 = (float) tr.dt / 1000000.0;
			} else {
d111 1
a111 5
			}
		} else { /* non-seismic data */
			if (tr.d1) {
				d1 = tr.d1;
			} else {
d121 3
a123 5
		if (seismic) {
			f1 = (tr.delrt) ? (float) tr.delrt/1000.0 : 0.0;
		} else {
			f1 = (tr.f1) ? tr.f1 : 0.0;
		}
@


1.26
log
@Modified boolean test variables.
@
text
@d1 1
a1 1
/* SUXIMAGE: $Revision: 1.18 $ ; $Date: 95/01/19 12:09:21 $		*/
d91 1
a91 1
	cwp_Bool know_ntr=false;/* is ntr known from header or user?	*/
d103 1
a103 1
	if (ntr) know_ntr = true; 
d146 1
a146 1
	if (getparint("n2", &ntr) || getparint("ntr", &ntr)) know_ntr = true;
d148 1
a148 1
	if (!know_ntr) { /* count traces */
d189 1
a189 1
	if (!know_ntr) { /* send out stored traces one by one */
d206 1
a206 1
	if (!know_ntr) efclose(datafp);
@


1.25
log
@added verbose
@
text
@d1 1
a1 1
/* SUXIMAGE: $Revision: 1.24 $ ; $Date: 95/01/19 11:37:39 $		*/
d8 1
a8 1
" 									",
d10 1
a10 1
" 									",
d12 7
a18 8
" 							        	",
" Optional parameters: 							",
" 							        	",
" n2 is the number of traces.  If not getparred then it			",
" is the total number of traces in the data set.  			",
" 							        	",
" d1 is the sampling interval in the fast dimension.  If not getparred	",
" then for seismic time domain data d1=tr.dt/10^6 if set, else 0.004. 	",
d20 2
a21 2
" 							        	",
" d2 is the sampling interval in the slow dimension.  If not getparred	",
d23 1
a23 1
" 							        	",
d25 3
a27 3
" then for seismic time domain data f1=tr.delrt/10^3 if set, else 0.0.	",
" For other types of data f1=tr.d1 if set else 0.0	 		",
" 							        	",
d30 2
a31 2
" else 1.0 for seismic time domain data, else 0.0 			",
" 							        	",
d36 1
a36 1
" the processing time or use d2= f2= to over-ride the header values if	",
d38 4
a41 4
" 							        	",
" See the ximage selfdoc for the remaining parameters.		",
" 							        	",
" On NeXT:     suximage < infile [optional parameters]  | open      	",
d46 2
a47 3
 *	CWP: Dave Hale and Zhiming Li (ximage)
 *	     Jack K. Cohen  (suxmovie)
 *	     John Stockwell (suximage)
d50 18
a67 11
 *	When n2 isn't getparred, we need to count the traces
 *	for ximage.  In this case:
 *	we are using tmpfile because on many machines it is
 *	implemented as a memory area instead of a disk file.
 *	However, if your system really makes a disk file you
 *	should consider altering the code to remove the file
 *	on interrupt.  Two possibilities are trapping the
 *	interrupt with "signal" or using "tmpnam" followed
 *	by an immediate "remove" (aka unlink in old unix).
 *	Although we compute ntr, we don't allocate a 2-d array
 *	and content ourselves with copying trace by trace from
d79 3
a81 3
	char plotcmd[BUFSIZ];	/* build ximage command for popen 	*/
	float *trbuf;		/* trace buffer			 	*/
	FILE *datafp;		/* fp for trace data file (if n2 < ntr)	*/
d83 1
a83 2
	int nt;			/* number of samples on trace		*/
	int n2;			/* number of traces			*/
d86 4
a89 4
	float d1;		/* time/depth sample rate 		*/
	float d2;		/* trace/dx sample rate 		*/
	float f1;		/* tmin/zmin				*/
	float f2;		/* tracemin/xmin	 		*/
d91 1
a91 2
	cwp_Bool got_n2 = true;	/* was n2 getparred?			*/
	cwp_Bool got_ntr = true;	/* was ntr set in header?	*/
a100 1
		 
d103 1
a103 1
	if (ntr==0) got_ntr = false; 
d105 1
a105 1
	if (!getparint("verbose", &verbose))	verbose=0;
d135 1
a135 1
		if      (tr.f2)     f2 = tr.f2;
d139 1
a139 1
		else 		    f2 = 0.0;
d145 2
a146 2
	/* Get or set n2 and n3 */
	if (!getparint("n2", &n2)) got_n2 = false;
d148 1
a148 1
	if (!got_n2 && !got_ntr) { /* count traces */
d150 2
a151 2
 			warn("n2 not getparred and ntr header field not set");
 			warn("....  counting traces");
a166 2
	if (!got_n2) n2 = ntr;

d170 1
a170 1
			   nt, n2, d1, d2, f1, f2);
d189 1
a189 1
	if (!got_n2 && !got_ntr) { /* send out stored traces one by one */
d206 1
a206 1
	if (!got_n2 && !got_ntr) efclose(datafp);
@


1.24
log
@removed extraneous getpar of f2 parameter
@
text
@d1 1
a1 1
/* SUXIMAGE: $Revision: 1.23 $ ; $Date: 94/12/05 09:54:53 $		*/
d81 1
d103 1
d147 4
a150 2
 		warn("n2 not getparred and ntr header field not set");
 		warn("....  counting traces");
@


1.23
log
@updated to permit getparring of n2 or reading of ntr parameter from header
@
text
@d1 1
a1 1
/* SUXIMAGE: $Revision: 1.22 $ ; $Date: 94/11/28 15:46:13 $		*/
a136 2

	if (!getparfloat("f2", &f2)) f2 = 1.0;
@


1.22
log
@changed to permit slow dimension to be input via getpar of n2 or via
new locally assigned header field "ntr".
@
text
@d1 1
a1 4
/* Copyright (c) Colorado School of Mines, 1994.*/
/* All rights reserved.                       */

/* SUXIMAGE: $Revision: 1.2 $ ; $Date: 94/09/16 12:56:19 $		*/
@


1.21
log
@added ISSEISMIC macro
@
text
@d1 2
a2 1
/* SUXIMAGE: $Revision: 1.20 $ ; $Date: 93/09/14 13:23:51 $		*/
d4 1
a4 12
/*----------------------------------------------------------------------
 * Copyright (c) Colorado School of Mines, 1990.
 * All rights reserved.
 *
 * This code is part of SU.  SU stands for Seismic Unix, a processing line
 * developed at the Colorado School of Mines, partially based on Stanford
 * Exploration Project (SEP) software.  Inquiries should be addressed to:
 *
 *  Jack K. Cohen, Center for Wave Phenomena, Colorado School of Mines,
 *  Golden, CO 80401  (jkc@@dix.mines.colorado)
 *----------------------------------------------------------------------
 */
d12 1
a12 1
" SUXIMAGE - X IMAGE plot of a segy data set 				",
d14 1
a14 1
" suximage <stdin [optional parameters]					",
d18 3
d43 1
a43 1
" See the ximage selfdoc for the remaining parameters and X functions.	",
d45 1
a46 1
/**************** end self doc *******************************************/
d50 3
a52 1
 *	CWP: Dave (ximage), Jack & John (su tee shirt)
d55 3
a57 1
 *	We are using tmpfile because on many machines it is
a63 1
 *	
a66 1
 *
d70 1
d79 1
a79 1
	FILE *datafp;		/* fp for trace data file		*/
d82 1
d88 3
a90 1
	cwp_Bool seismic;		/* is this seismic data?		*/
a96 1

d102 2
d141 1
d146 2
d149 3
a151 2
	/* Create temporary "file" to hold data */
	datafp = etmpfile();
d153 2
d156 6
a161 6
	/* Loop over input traces & put them into the data file */
	ntr = 0;
	do {
		++ntr;
		efwrite(tr.data, FSIZE, nt, datafp);
	} while (gettr(&tr));
d164 4
d169 3
a171 2
	sprintf(plotcmd, "ximage n1=%d n2=%d d1=%f d2=%f f1=%f f2=%f",
			   nt, ntr, d1, d2, f1, f2);
d187 1
a187 1
	/* Open pipe; read data to buf; write buf to plot program */
d189 8
a196 5
	rewind(datafp);
	{ register int itr;
		for (itr = 0; itr < ntr; ++itr) {
			efread (trbuf, FSIZE, nt, datafp);
			efwrite(trbuf, FSIZE, nt, plotfp);
d198 4
d207 1
a207 2
	efclose(datafp);

@


1.20
log
@Allow TDEAD etc. as seismic time traces.
@
text
@d1 1
a1 1
/* SUXIMAGE: $Revision: 1.19 $ ; $Date: 93/09/11 08:06:07 $		*/
d101 2
a102 2
	seismic = (tr.trid == 0 || tr.trid == TREAL ||
		   tr.trid == TDEAD || tr.trid == TDUMMY);
@


1.19
log
@Bool -> cwp_Bool, String -> cwp_String
@
text
@d1 1
a1 1
/* SUXIMAGE: $Revision: 1.18 $ ; $Date: 92/10/26 15:17:33 $		*/
d101 2
a102 1
	seismic =  (tr.trid == 0 || tr.trid == TREAL);
@


1.18
log
@new selfdoc installed
@
text
@d1 1
a1 1
/* SUXIMAGE: $Revision: 1.17 $ ; $Date: 91/09/06 08:30:35 $		*/
d91 1
a91 1
	Bool seismic;		/* is this seismic data?		*/
@


1.17
log
@string -> String, etc.
@
text
@d1 1
a1 1
/* SUXIMAGE: $Revision: 1.16 $ ; $Date: 91/03/05 15:18:29 $		*/
d20 33
a52 33
String sdoc =
" 									\n"
" SUXIMAGE - X IMAGE plot of a segy data set 				\n"
" 									\n"
" suximage <stdin [optional parameters]					\n"
" 							        	\n"
" Optional parameters: 							\n"
" 							        	\n"
" d1 is the sampling interval in the fast dimension.  If not getparred	\n"
" then for seismic time domain data d1=tr.dt/10^6 if set, else 0.004. 	\n"
" For other types of data d1=tr.d1 if set, else 1.0			\n"
" 							        	\n"
" d2 is the sampling interval in the slow dimension.  If not getparred	\n"
" d2=tr.d2 if set, else 1.0						\n"
" 							        	\n"
" f1 is the first sample in the fast dimension.  If not getparred	\n"
" then for seismic time domain data f1=tr.delrt/10^3 if set, else 0.0.	\n"
" For other types of data f1=tr.d1 if set else 0.0	 		\n"
" 							        	\n"
" f2 is the first sample in the slow dimension.  If not getparred	\n"
" f2=tr.f2 if set, else tr.tracr if set, else tr.tracl if set,		\n"
" else 1.0 for seismic time domain data, else 0.0 			\n"
" 							        	\n"
" Note that for seismic time domain data, the \"fast dimension\" is	\n"
" time and the \"slow dimension\" is usually trace number or range.	\n"
" Also note that \"foreign\" data tapes may have something unexpected	\n"
" in the d2,f2 fields, use segyclean to clear these if you can afford	\n"
" the processing time or use d2= f2= to over-ride the header values if	\n"
" not.									\n"
" 							        	\n"
" See the ximage selfdoc for the remaining parameters and X functions.	\n"
" 							        	\n"
;
d96 1
a96 1
	askdoc(1);
@


1.16
log
@Another change to d1 etc. defaults to partially guard against
just from a foreign tape
@
text
@d1 1
a1 1
/* SUXIMAGE: $Revision: 1.15 $ ; $Date: 91/03/03 13:49:18 $		*/
d20 1
a20 1
string sdoc =
d91 1
a91 1
	bool seismic;		/* is this seismic data?		*/
@


1.15
log
@Tweaked f2 default to look at tr.tracr before tr.tracl
@
text
@d1 1
a1 1
/* SUXIMAGE: $Revision: 1.14 $ ; $Date: 91/02/22 15:12:53 $		*/
d29 2
a30 2
" d1=tr.d1 if set, else d1=tr.dt/10^6 if set, else 0.004 for seismic	\n"
" time domain data, else 1.0						\n"
d36 2
a37 1
" f1=tr.d1 if set, else f1=tr.delrt/10^3 if set, else 0.0 		\n"
d45 4
d105 14
a118 8
		if      (tr.d1)  d1 = tr.d1;
		else if (tr.dt)  d1 = (float) tr.dt / 1000000.0;
		else if (seismic) {
			d1 = 0.004;
			warn("tr.dt not set, assuming dt=0.004");
		} else { /* not time domain data */
			d1 = 1.0;
			warn("tr.d1 not set, assuming d1=1.0");
d122 1
a122 4
	if (!getparfloat("d2", &d2)) {
		if (tr.d2)  d2 = tr.d2;
		else d2 = 1.0;
	}
d125 5
a129 3
		if      (tr.f1)     f1 = tr.f1;
		else if (tr.delrt)  f1 = (float) tr.delrt/1000.0;
		else                f1 = 0.0;
@


1.14
log
@Make d2, etc. the default if set.
@
text
@d1 1
a1 1
/* SUXIMAGE: $Revision: 1.13 $ ; $Date: 91/02/14 10:27:24 $		*/
d39 2
a40 2
" f2=tr.f2 if set, else f2=tr.tracl if set, else 1.0 for seismic time	\n"
" domain data, else 0.0 						\n"
d124 1
@


1.13
log
@Look at d1,d2,f1,f2 header fields.
@
text
@d1 1
a1 1
/* SUXIMAGE: $Revision: 1.12 $ ; $Date: 90/11/03 14:40:22 $		*/
d29 2
a30 2
" d1=tr.dt/10^6 if set, else 0.004 for seismic time domain data, it is	\n"
"   =tr.d1 if set, else 1.0 for all other types of data			\n"
d33 1
a33 1
" d1=tr.d2 if set, else 1.0						\n"
d36 1
a36 2
" f1=tr.delrt/10^3 if set, else 0.0 for seismic time data, it is	\n"
" f1=tr.d1 if set, else 0.0  for all other types of data.		\n"
d39 2
a40 2
" f2=tr.tracl if set, else 1.0 for seismic time data, it is		\n"
" f2=tr.d2 if set, else 0.0  for all other types of data.		\n"
d98 1
d100 5
a104 7
		if (seismic) { /* seismic time data */
			if (tr.dt) { /* is dt field set? */
				d1 = (float) tr.dt / 1000000.0;
			} else { /* dt not set, assume 4 ms */
				d1 = 0.004;
				warn("tr.dt not set, assuming dt=0.004");
			}
d106 2
a107 6
			if (tr.d1) { /* is d1 field set? */
				d1 = tr.d1;
			} else { /* d1 not set, assume 1.0 */
				d1 = 1.0;
				warn("tr.d1 not set, assuming d1=1.0");
			}
d111 4
a114 2
	if (!getparfloat("f1", &f1))
		f1 = (seismic) ? (float) tr.delrt/1000.0 : tr.f1;
d116 5
a120 2
	if (!getparfloat("d2", &d2))	d2 = tr.d2;
	if (!d2) d2 = 1.0;
d122 6
a127 2
	if (!getparfloat("f2", &f2))
		f2 = (seismic) ? ((tr.tracl) ? (float) tr.tracl : 1.0) : 0.0;
@


1.12
log
@Use etmpfile
@
text
@d1 1
a1 1
/* SUXIMAGE: $Revision: 1.11 $ ; $Date: 90/11/02 09:27:23 $		*/
d28 3
a30 4
" d1=tr.dt or 0.004      sampling interval in fast dim, often dt or dz	\n"
" d2=1.0                 ... in slow dim, often unit step in trace or dx\n"
" f1=0.0                 first sample in fast dim, often tmin or zmin	\n"
" f2=1.0                 ... in slow dim, often first tracl or xmin	\n"
d32 2
a33 1
" See the ximage selfdoc for the remaining parameters.			\n"
d35 13
d87 1
d97 1
d100 14
a113 5
		if (tr.dt) {  /* is dt field set? */
			d1 = tr.dt / 1000000.0;
		} else {		/* dt not set, assume 4 ms */
			d1 = 0.004;
			warn("tr.dt not set, assuming dt=%g", d1);
a115 3
	if (!getparfloat("d2", &d2)) d2 = 1.0; /* default count by traces */
	if (!getparfloat("f1", &f1)) f1 = 0.0; /* default tmin */
	if (!getparfloat("f2", &f2)) f2 = tr.tracl ? tr.tracl : 1.0;
d117 2
d120 7
a140 1
	erewind(datafp);
d163 1
@


1.11
log
@Better variable names; explicit close of file pointers.
Specific trace buffer for code clarity.
@
text
@d1 1
a1 1
/* SUXIMAGE: $Revision: 1.10 $ ; $Date: 90/11/01 22:41:16 $		*/
d43 7
a49 3
 *	We are using tmpfile because it apparently cleans up
 *	up after itself (probably just a memory area, rather than
 *	a disk area).
d51 1
a51 1
 *	Although we know ntr, we don't allocate a 2-d array
d102 1
a102 1
	datafp = tmpfile();
d124 2
a125 2
			strcat(plotcmd, " ");   /* get a space in between args */
			strcat(plotcmd, "\"");  /* user quotes will be stripped */
d127 1
a127 1
			strcat(plotcmd, "\"");  /* user quotes will be stripped */
@


1.10
log
@Tweak
@
text
@d1 1
a1 1
/* SUXIMAGE: $Revision: 1.9 $ ; $Date: 90/11/01 20:46:10 $		*/
d50 3
d60 2
a61 1
	char cmd[BUFSIZ];	/* build ximage command for popen 	*/
d93 4
d111 1
a111 1
	sprintf(cmd, "ximage n1=%d n2=%d d1=%f d2=%f f1=%f f2=%f",
d120 4
a123 4
			strcat(cmd, " ");   /* get a space in between args */
			strcat(cmd, "\"");  /* user quotes will be stripped */
			strcat(cmd, *argv); /* add the arg */
			strcat(cmd, "\"");  /* user quotes will be stripped */
d129 1
a129 1
	plotfp = epopen(cmd, "w");
d132 2
a133 2
			efread (tr.data, FSIZE, nt, datafp);
			efwrite(tr.data, FSIZE, nt, plotfp);
d136 3
d140 1
@


1.9
log
@Tweaks
@
text
@d1 1
a1 1
/* SUXIMAGE: $Revision: 1.8 $ ; $Date: 90/11/01 16:38:02 $		*/
d60 1
a60 1
	int ns;			/* number of samples on trace		*/
d75 1
a75 1
	ns = tr.ns;
d97 1
a97 1
		efwrite(tr.data, FSIZE, ns, datafp);
d104 1
a104 1
			   ns, ntr, d1, d2, f1, f2);
d124 2
a125 2
			efread (tr.data, FSIZE, ns, datafp);
			efwrite(tr.data, FSIZE, ns, plotfp);
@


1.8
log
@Changed to avoid making an actual file in /tmp.
That is, use tmpfile/popen instead of tmpnam/system.
@
text
@d1 1
a1 1
/* SUXIMAGE: $Revision: 1.7 $ ; $Date: 90/10/29 10:42:11 $		*/
d57 1
a57 1
	char cmd[BUFSIZ];	/* build ximage command for popen call	*/
d59 1
a59 1
	FILE *plotfp;		/* fp for popen call			*/
d102 1
a102 1
	/* Set popen call to ximage */
d120 1
a120 1
	/* Read trace by trace from data file and write (pipe) to ximage */
d124 1
a124 1
			efread(tr.data, FSIZE, ns, datafp);
d128 1
@


1.7
log
@Added cmap param description to self-doc
@
text
@d1 1
a1 1
/* SUXIMAGE: $Revision: 1.6 $ ; $Date: 90/09/13 10:23:55 $		*/
d20 16
a35 49
string sdoc = "\
									\n\
SUXIMAGE - X IMAGE plot of a segy data set 				\n\
									\n\
suximage <stdin [optional parameters]					\n\
							        	\n\
Optional parameters: 							\n\
							        	\n\
d1=tr.dt or 0.004      sampling interval in fast dim, often dt or dz	\n\
d2=1.0                 ... in slow dim, often unit step in trace or dx	\n\
f1=0.0                 first sample in fast dim, often tmin or zmin	\n\
f2=1.0                 ... in slow dim, often first tracl or xmin	\n\
							        	\n\
perc=100.0             percentile used to determine clip		\n\
clip=(perc percentile) clip used to determine bclip and wclip		\n\
bperc=perc             percentile for determining black clip value	\n\
wperc=100.0-perc       percentile for determining white clip value	\n\
bclip=clip             data values outside of [bclip,wclip] are clipped	\n\
wclip=-clip            data values outside of [bclip,wclip] are clipped	\n\
cmap=gray              gray, hue, or default colormaps may be specified \n\
verbose=1              =1 for info printed on stderr (0 for no info)	\n\
xbox=50                x in pixels of upper left corner of window	\n\
ybox=50                y in pixels of upper left corner of window	\n\
wbox=400               width in pixels of window			\n\
hbox=400               height in pixels of window			\n\
x1beg=x1min            value at which axis 1 begins			\n\
x1end=x1max            value at which axis 1 ends			\n\
d1num=0.0              numbered tic interval on axis 1 (0.0 for automatic)\n\
f1num=x1min            first numbered tic on axis 1 (used if d1num not 0.0)\n\
n1tic=1                number of tics per numbered tic on axis 1	\n\
grid1=none             grid lines on axis 1 - none, dot, dash, or solid	\n\
label1=                label on axis 1					\n\
x2beg=x2min            value at which axis 2 begins			\n\
x2end=x2max            value at which axis 2 ends			\n\
d2num=0.0              numbered tic interval on axis 2 (0.0 for automatic)\n\
f2num=x2min            first numbered tic on axis 2 (used if d2num not 0.0)\n\
n2tic=1                number of tics per numbered tic on axis 2	\n\
grid2=none             grid lines on axis 2 - none, dot, dash, or solid	\n\
label2=                label on axis 2					\n\
labelfont=Erg14        font name for axes labels			\n\
title=                 title of plot					\n\
titlefont=Rom22        font name for title				\n\
labelcolor=blue        color for axes labels				\n\
titlecolor=red         color for title					\n\
gridcolor=yellow       color for grid lines				\n\
style=seismic          normal (axis 1 horizontal, axis 2 vertical) or	\n\
                       seismic (axis 1 vertical, axis 2 horizontal)	\n\
							        	\n\
";
d42 8
d57 3
a59 3
	char xdata[L_tmpnam];	/* tmp file for ximage data		*/
	char cmd[BUFSIZ];	/* build ximage command for system call	*/
	FILE *xdatafp;		/* fp for ximage input file		*/
d76 1
a76 1
	if (!fgetpar("d1", &d1)) {
d84 3
a86 3
	if (!fgetpar("d2", &d2)) d2 = 1.0; /* default count by traces */
	if (!fgetpar("f1", &f1)) f1 = 0.0; /* default tmin */
	if (!fgetpar("f2", &f2)) f2 = tr.tracl ? tr.tracl : 1.0;
a87 3
	/* Prepare temporary file to hold xdata */
	tmpnam(xdata);
	xdatafp = efopen(xdata, "w+");
d89 2
d92 2
a93 1
	/* Loop over input traces & put them into the xdata file */
d97 1
a97 1
		efwrite(tr.data, FSIZE, ns, xdatafp);
d99 1
a99 1
	erewind(xdatafp);
d102 3
a104 3
	/* System call to ximage */
	sprintf(cmd, "ximage <%s n1=%d n2=%d d1=%f d2=%f f1=%f f2=%f",
			   xdata, ns, ntr, d1, d2, f1, f2);
a118 1
	system(cmd);
d120 8
a127 4

	/* Clean up */
	efclose(xdatafp);
	eremove(xdata);
@


1.6
log
@Fix quote stripping bug reported by Craig.
@
text
@d1 1
a1 1
/* SUXIMAGE: $Revision: 1.5 $ ; $Date: 90/06/12 22:59:05 $		*/
d39 1
@


1.5
log
@Eliminated unused itr and tweaks.
@
text
@d1 1
a1 1
/* SUXIMAGE: $Revision: 1.4 $ ; $Date: 90/06/04 11:40:38 $		*/
d131 1
a131 1
		if (strncmp(*argv, "d1=", 3) && /* these already set */
d136 4
a139 2
			/* get a space in between args */
			strcat(cmd, " "); strcat(cmd, *argv);
@


1.4
log
@Using d1,f1, etc.
@
text
@d1 1
a1 1
/* SUXIMAGE: $Revision: 1.3 $ ; $Date: 90/06/02 07:33:04 $		*/
a78 2


d84 2
a89 3
	int ns;			/* number of samples on trace		*/
	int ntr;		/* number of traces			*/
	int itr;		/* counter over traces			*/
d110 1
a110 7
	if (!fgetpar("f2", &f2)) {
		if (tr.tracl) {
			f2 = tr.tracl;
		} else {
			f2 = 1.0;
		}
	}
@


1.3
log
@Tweaks
@
text
@d1 1
a1 1
/* SUXIMAGE: $Revision: 1.2 $ ; $Date: 90/06/01 20:31:02 $		*/
d28 4
a31 2
dt=tr.dt or 0.004      time sampling interval 				\n\
dx=1.0                 sampling interval in range 			\n\
a32 3
							        	\n\
The following are passed along to ximage:				\n\
							        	\n\
d86 5
a90 3
	float dt;		/* time sample rate in secs		*/
	float dx;		/* trace spacing			*/
	int nt;			/* number of samples on trace		*/
d102 2
a103 2
	nt = tr.ns;
	if (!fgetpar("dt", &dt)) {
d105 1
a105 1
			dt = tr.dt / 1000000.0;
d107 2
a108 2
			dt = 0.004;
			warn("tr.dt not set, assuming dt=%g", dt);
d111 9
a119 1
	
a120 4
	/* Set dx */
	if (!fgetpar("dx" , &dx))	dx = 1.0;


d130 1
a130 1
		efwrite(tr.data, FSIZE, nt, xdatafp);
d136 2
a137 2
	sprintf(cmd, "ximage <%s n1=%d n2=%d d1=%f d2=%f f1=0.0 f2=0.0",
			   xdata, nt, ntr, dt, dx);
d140 7
a146 3
		if (strncmp(*argv, "dx=", 3)) { /* skip dx= arg */
			strcat(cmd, " ");   /* get a space in between args */
			strcat(cmd, *argv);
@


1.2
log
@Tweaks
q
@
text
@d1 1
a1 1
/* SUXIMAGE: $Revision: 1.1 $ ; $Date: 90/06/01 15:53:09 $		*/
d86 1
a86 1
	FILE *datafp;		/* fp for ximage input file		*/
d107 1
a107 1
			warn("tr.dt not set, for labeling assume dt=%g", dt);
d116 1
a116 1
	/* Prepare temporary file to hold data */
d118 1
a118 1
	datafp = efopen(xdata, "w+");
d125 1
a125 1
		efwrite(tr.data, nt, FSIZE, datafp);
d127 1
a127 1
	erewind(datafp);
d135 1
a135 1
		if (strncmp(*argv, "dx", 2)) { /* skip dx= arg */
d145 1
a145 1
	efclose(datafp);
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/* SUXIMAGE: $Revision: 1.2 $ ; $Date: 90/05/25 19:25:47 $		*/
d73 1
a73 1
 *	CWP: Dave (ximage), Jack (su tee shirt)
d127 1
a127 1
	rewind(datafp);
d134 3
a136 3
	for(--argc, ++argv; argc; --argc, ++argv) {
		if (strncmp(*argv, "dx", 2)) {
			strcat(cmd, " "); /* get a space inbetween args */
@
