head	1.45;
access;
symbols;
locks; strict;
comment	@ * @;


1.45
date	2011.11.11.23.57.38;	author john;	state Exp;
branches;
next	1.44;

1.44
date	2011.09.09.22.28.18;	author john;	state Exp;
branches;
next	1.43;

1.43
date	2006.03.29.22.44.17;	author john;	state Exp;
branches;
next	1.42;

1.42
date	2004.12.23.22.37.43;	author john;	state Exp;
branches;
next	1.41;

1.41
date	2003.08.19.16.50.36;	author john;	state Exp;
branches;
next	1.40;

1.40
date	2002.03.15.18.16.01;	author john;	state Exp;
branches;
next	1.39;

1.39
date	98.03.31.20.34.37;	author john;	state Exp;
branches;
next	1.38;

1.38
date	98.03.26.23.55.04;	author john;	state Exp;
branches;
next	1.37;

1.37
date	96.09.16.17.11.52;	author john;	state Exp;
branches;
next	1.36;

1.36
date	96.09.06.19.56.31;	author john;	state Exp;
branches;
next	1.35;

1.35
date	96.05.01.16.17.04;	author jkc;	state Exp;
branches;
next	1.34;

1.34
date	96.02.22.16.12.46;	author jkc;	state Exp;
branches;
next	1.33;

1.33
date	96.02.12.16.51.33;	author jkc;	state Exp;
branches;
next	1.32;

1.32
date	96.01.23.20.27.29;	author jkc;	state Exp;
branches;
next	1.31;

1.31
date	96.01.20.05.25.26;	author jkc;	state Exp;
branches;
next	1.30;

1.30
date	96.01.19.22.57.35;	author jkc;	state Exp;
branches;
next	1.28;

1.28
date	96.01.15.21.11.32;	author jkc;	state Exp;
branches;
next	1.27;

1.27
date	96.01.12.20.39.29;	author jkc;	state Exp;
branches;
next	1.26;

1.26
date	95.05.22.13.06.20;	author jkc;	state Exp;
branches;
next	1.25;

1.25
date	95.05.22.12.23.09;	author jkc;	state Exp;
branches;
next	1.24;

1.24
date	94.11.18.13.36.22;	author john;	state Exp;
branches;
next	1.23;

1.23
date	94.03.14.14.19.29;	author john;	state Exp;
branches;
next	1.22;

1.22
date	93.08.13.10.26.19;	author john;	state Exp;
branches;
next	1.21;

1.21
date	92.12.14.11.46.59;	author john;	state Exp;
branches;
next	1.20;

1.20
date	92.12.14.11.44.37;	author john;	state Exp;
branches
	1.20.1.1;
next	1.19;

1.19
date	92.12.11.09.46.08;	author john;	state Exp;
branches;
next	1.18;

1.18
date	92.12.11.09.35.05;	author john;	state Exp;
branches;
next	1.17;

1.17
date	92.10.30.08.56.06;	author john;	state Exp;
branches;
next	1.16;

1.16
date	92.10.30.08.43.27;	author john;	state Exp;
branches;
next	1.15;

1.15
date	91.09.05.08.47.27;	author jkcohen;	state Exp;
branches;
next	1.14;

1.14
date	91.06.28.09.40.39;	author jkcohen;	state Exp;
branches;
next	1.13;

1.13
date	91.06.27.19.07.15;	author jkcohen;	state Exp;
branches;
next	1.12;

1.12
date	91.06.27.18.10.52;	author jkcohen;	state Exp;
branches;
next	1.11;

1.11
date	91.06.27.14.55.22;	author jkcohen;	state Exp;
branches;
next	1.10;

1.10
date	91.01.10.09.35.06;	author jkc;	state Exp;
branches;
next	1.9;

1.9
date	90.12.23.20.01.55;	author jkc;	state Exp;
branches;
next	1.8;

1.8
date	90.12.22.18.37.43;	author jkc;	state Exp;
branches;
next	1.7;

1.7
date	90.12.21.14.14.07;	author jkc;	state Exp;
branches;
next	1.6;

1.6
date	90.12.19.08.43.05;	author jkc;	state Exp;
branches;
next	1.5;

1.5
date	90.10.27.22.32.38;	author jkc;	state Exp;
branches;
next	1.4;

1.4
date	90.10.26.19.27.49;	author jkc;	state Exp;
branches;
next	1.3;

1.3
date	90.10.25.09.34.46;	author jkc;	state Exp;
branches;
next	1.2;

1.2
date	90.09.03.09.59.00;	author jkc;	state Exp;
branches;
next	1.1;

1.1
date	90.04.15.15.55.44;	author jkc;	state Exp;
branches;
next	;

1.20.1.1
date	93.01.12.14.47.57;	author john;	state Exp;
branches;
next	;


desc
@Get a segy trace
@


1.45
log
@copyright
@
text
@/* Copyright (c) Colorado School of Mines, 2011.*/
/* All rights reserved.                       */

/* FGETTR: $Revision: 1.44 $; $Date: 2011/09/09 22:28:18 $	*/

/*********************** self documentation **********************/
/****************************************************************************
FGETTR - Routines to get an SU trace from a file 

fgettr		get a fixed-length segy trace from a file by file pointer
fvgettr		get a variable-length segy trace from a file by file pointer
fgettra		get a fixed-length trace from disk file by trace number
gettr		macro using fgettr to get a trace from stdin
vgettr		macro using vfgettr to get a trace from stdin
gettra		macro using fgettra to get a trace from stdin by trace number
 
*****************************************************************************
Function Prototype:
int fgettr(FILE *fp, segy *tp);
int fvgettr(FILE *fp, segy *tp);
int fgettra(FILE *fp, segy *tp, int itr);

*****************************************************************************
Returns:
fgettr, fvgettr:
int: number of bytes read on current trace (0 after last trace)

fgettra:
int: number of traces in disk file
 
Macros defined in segy.h
#define gettr(x)	fgettr(stdin, (x))
#define vgettr(x)	fgettr(stdin, (x))

Usage example:
 	segy tr;
 	...
 	while (gettr(&tr)) {
 		tr.offset = abs(tr.offset);
 		puttr(&tr);
 	}
 	...

*****************************************************************************
Authors: SEP: Einar Kjartansson, Stew Levin CWP: Shuki Ronen, Jack Cohen
****************************************************************************/
/*
 * Revised: 7/2/95 Stewart A. Levin   Mobil
 *     Major rewrite:  Use xdr library for portable su output file
 *     format.   Merge fgettr and fgettra into same source file.
 *     Make input from multiple streams work (at long last!).
 * Revised: 11/22/95 Stewart A. Levin  Mobil
 *     Always set ntr for DISK input.  This fixes susort failure.
 * Revised: 1/9/96  jkc CWP
 *     Set lastfp on nread <=0 return, too.
 * Revised: 28 Mar, 2006 Stewart A. Levin   Landmark Graphics
 *     Reworked XDR to support random seeks on > 2GB files
 *     and to read big endian SHORTPACK data on little endian machines.
 */
/**************** end self doc ********************************/

#ifndef TEST

#ifdef SU_LINE_HEADER

int out_line_hdr=1;

#else

int out_line_hdr=0;

#endif

#include "su.h"
#include "segy.h"

int isebcdic_txt( unsigned char* ,int len);
int isascii_txt( unsigned char* ,int len);

int in_line_hdr=0;

unsigned char su_text_hdr[3200];
bhed su_binary_hdr;

#ifdef SUXDR
/********************************************
code using XDR
*********************************************/

#include "su_xdr.h"
#include "header.h"

static struct insegyinfo {
	FILE *infp;		     /* FILE * ptr for search	 */
	struct insegyinfo *nextinfo; /* linked list pointer	 */
	off_t itr;		     /* number of traces read	 */
	int nsfirst;		     /* samples from 1st header	 */
	unsigned short bytesper;     /* bytes per datum		 */
	size_t nsegy; 		     /* segy bytes from nsfirst	 */
	off_t ntr;		     /* traces in input,if known */
	FileType ftype;		     /* file type of input *fp	 */
	XDR *segy_xdr;		     /* allocated XDR structure  */
	char *buf;		     /* buffer for trace I/O     */
	size_t bufstart;	     /* "offset" of start of buf */
} *insegylist = (struct insegyinfo *) NULL;

static FILE *lastfp = (FILE *) NULL;
static struct insegyinfo *infoptr, **oldinfoptr;



static
void searchlist(FILE *fp)
{
	oldinfoptr = &insegylist;
	for(infoptr = insegylist; infoptr != ((struct insegyinfo *) NULL);
	    infoptr = infoptr->nextinfo) {
		if(fp == infoptr->infp) break;
		oldinfoptr = &infoptr->nextinfo;
	}
}

static
int dataread(struct insegyinfo *iptr, segy *tp, cwp_Bool fixed_length)
{
	unsigned int nsread = fixed_length?iptr->nsfirst:tp->ns;
	unsigned int databytes = infoptr->bytesper*nsread;
	int nread;
	int itest = 1;
	char *ctest = (char *) (&itest);


	/* read trace data */
	switch(tp->trid) {
	case CHARPACK:
		nread = efread((char *) (&((tp->data)[0])),1,databytes,
				iptr->infp);
	case SHORTPACK:
		nread = efread((char *) (&((tp->data)[0])),1,databytes,
				iptr->infp);
		if(ctest[0]) swab((char *) (&((tp->data)[0])),
				  (char *) (&((tp->data)[0])),
				  databytes);
	break;
	default:
		nread = efread(((char *) (iptr->buf))+HDRBYTES,1,databytes,
				iptr->infp);
		if(nread != databytes || FALSE == xdr_vector(iptr->segy_xdr,
					(char *) (&((tp->data)[0])),
					nsread,sizeof(float),(xdrproc_t) xdr_float))
			nread = 0;
		else
			nread = databytes;

	break;
	}
	
	if(nread > 0 && nread != databytes) 
		err("%s: on trace #%ld, tried to read %d bytes, "
		    "read %d bytes",
		    __FILE__, (infoptr->itr)+1, databytes, nread);
	
	return(nread);
}


static
int fgettr_internal(FILE *fp, segy *tp, cwp_Bool fixed_length)
{
	int nread;		/* bytes seen by fread calls	*/
	off_t curoff;

	if(fp != lastfp)  /* search linked list for possible alternative */
			    searchlist(fp);

	if (infoptr == ((struct insegyinfo *) NULL)) {
	/* initialize new segy input stream */
		unsigned int databytes;	/* bytes from nsfirst		*/

		/* allocate new segy input information table */
		*oldinfoptr = (struct insegyinfo *)
			malloc(sizeof(struct insegyinfo));
		infoptr = *oldinfoptr;
		infoptr->nextinfo = (struct insegyinfo *) NULL;
		/* save FILE * ptr */
		infoptr->infp = fp;
		infoptr->itr = 0;
		infoptr->ntr = -1;
		/* allocate XDR struct and associate FILE * ptr */
		infoptr->segy_xdr = (XDR *) malloc(sizeof(XDR));

		switch (infoptr->ftype = filestat(fileno(fp))) {
		case DIRECTORY:
			err("%s: segy input can't be a directory", __FILE__);
		case TTY:
			err("%s: segy input can't be tty", __FILE__);
		break;
		default: /* the rest are ok */
		break;
		}
		/* xdrstdio_create(infoptr->segy_xdr,fp,XDR_DECODE); */
		infoptr->buf = ealloc1(sizeof(segy),sizeof(char));
		xdrmem_create(infoptr->segy_xdr, infoptr->buf, sizeof(segy), XDR_DECODE);
		infoptr->bufstart = xdr_getpos(infoptr->segy_xdr);

		/* retrieve segy trace header */
		nread = efread(infoptr->buf ,1 ,HDRBYTES ,infoptr->infp);

		if(nread != HDRBYTES || FALSE == xdrhdrsub(infoptr->segy_xdr,tp))
			err("%s: bad first header", __FILE__);
		
		/* Have the header, now for the data */
		infoptr->nsfirst = tp->ns;
		if (infoptr->nsfirst > SU_NFLTS)
			err("%s: unable to handle %d > %d samples per trace",
				    __FILE__, infoptr->nsfirst, SU_NFLTS);

		switch(tp->trid) {
		case CHARPACK:
		   infoptr->bytesper = sizeof(char); break;
		case SHORTPACK:
		   infoptr->bytesper = 2*sizeof(char); break;
		default:
		   infoptr->bytesper = BYTES_PER_XDR_UNIT; break;
		}

		databytes = infoptr->bytesper * tp->ns;

		infoptr->nsegy = databytes + HDRBYTES;

		nread = dataread(infoptr, tp, fixed_length);


		switch (nread) {
		case 0:   err("%s: no data on first trace", __FILE__);
		default:  if (nread != databytes)
				 err("%s: first trace: tried to read %d bytes "
				     "read %d bytes",
					__FILE__, databytes, nread);
			else nread += HDRBYTES;
		}

		if(infoptr->ftype == DISK) { /* compute ntr */
		    curoff = eftello(fp); 
		    efseeko(fp,(off_t) 0,SEEK_END);
		    infoptr->ntr = eftello(fp)/infoptr->nsegy;
		    efseeko(fp, curoff, SEEK_SET); /* restore location */
		    }


	} else { /* Not first entry */

		  xdr_setpos(infoptr->segy_xdr, infoptr->bufstart);
		  nread = efread(infoptr->buf ,1 ,HDRBYTES ,infoptr->infp);
		  if ( nread != HDRBYTES || FALSE == xdrhdrsub(infoptr->segy_xdr,tp)) nread=0;
		  if(nread == HDRBYTES)
			nread += dataread(infoptr, tp, fixed_length);
		  if (nread <= 0) {
			   lastfp = infoptr->infp;
			   return 0;
		  }



		if (fixed_length && (tp->ns != infoptr->nsfirst))
			err("%s: on trace #%ld, "
			    "number of samples in header (%d) "
			    "differs from number for first trace (%d)", 
			     __FILE__, infoptr->itr, tp->ns, infoptr->nsfirst);
	}

	++(infoptr->itr);
	lastfp = infoptr->infp;
	return (nread);
}

int fgettr(FILE *fp, segy *tp)
{
 return(fgettr_internal(fp,tp,cwp_true));
}

int fvgettr(FILE *fp, segy *tp)
{
 return(fgettr_internal(fp,tp,cwp_false));
}
int fgettra(FILE *fp, segy *tp, int itr)
{
 int nread;
 if(lastfp != fp) /* search for match */
		     searchlist(fp);

 if(infoptr == (struct insegyinfo *) NULL) {
	/* get first trace */
	if(0 >= fgettr(fp, tp)) return(0); /* error return */

	switch(infoptr->ftype) {
	  case TTY:
	    warn("stdin not redirected");
	    break;
	  case DISK: /* correct */
	    break;
	  default:
	    err("%s: input must be disk file",__FILE__);
	    break;
	  }

	efseeko(fp,(off_t) 0,SEEK_END);
	infoptr->ntr = eftello(fp)/infoptr->nsegy;
	} /* end first entry initialization */

 /* Check on requested trace number */
  if(itr >= infoptr->ntr) err("%s: trying to read off end of file",__FILE__);

 /* Position file pointer at start of requested trace */
  if(0 > efseeko(fp, ((off_t) itr) * ((off_t) infoptr->nsegy), SEEK_SET)) {
	err("%s: unable to seek xdr disk file to trace %d",__FILE__,itr);
  }

 nread=fgettr(fp, tp);
 if(nread != infoptr->nsegy)
	err("%s: read %d bytes with %d bytes in trace",
		__FILE__,nread,infoptr->nsegy);

 if(tp->ns != infoptr->nsfirst)
	warn("%s: header ns field = %d differs from first trace = %d",
		__FILE__,tp->ns,infoptr->nsfirst);

 return(infoptr->ntr);
}


#else 
/**********************************************************
code without  XDR 
***********************************************************/

#include "header.h"

static struct insegyinfo {
	FILE *infp;		  /* FILE * ptr for search	 */
	struct insegyinfo *nextinfo; /* linked list pointer	*/
	off_t itr;	     /* number of traces read	 */
	int nsfirst;		     /* samples from 1st header	 */
	unsigned short bytesper;     /* bytes per datum		 */
	size_t  nsegy; 		     /* segy bytes from nsfirst	 */
	off_t ntr;		     /* traces in input,if known */
	FileType ftype;		     /* file type of input *fp	 */
} *insegylist = (struct insegyinfo *) NULL;

static FILE *lastfp = (FILE *) NULL;
static struct insegyinfo *infoptr, **oldinfoptr;

static
void searchlist(FILE *fp)
{
	oldinfoptr = &insegylist;
	for(infoptr = insegylist; infoptr != ((struct insegyinfo *) NULL);
	    infoptr = infoptr->nextinfo) {
		if(fp == infoptr->infp) break;
		oldinfoptr = &infoptr->nextinfo;
	}
}

static
int dataread(segy *tp, struct insegyinfo *iptr, cwp_Bool fixed_length)
{
	unsigned int nsread = fixed_length?iptr->nsfirst:tp->ns;
	unsigned int databytes = infoptr->bytesper*nsread;
	int nread = (int) efread((char *) (&((tp->data)[0])),1, databytes,
			   iptr->infp);

	if(nread > 0 && nread != databytes) 
		err("%s: on trace #%ld, tried to read %d bytes, "
		    "read %d bytes ",
		    __FILE__, (infoptr->itr)+1, databytes, nread);

	return(nread);
}


static
int fgettr_internal(FILE *fp, segy *tp, cwp_Bool fixed_length) {
   int nread;  /* bytes seen by fread calls  */
   unsigned char buf[240];  /* buffer for test for line header */

   /* search linked list for possible alternative */
   if(fp != lastfp)  searchlist(fp);

   if (infoptr == ((struct insegyinfo *) NULL)) {
	/* initialize new segy input stream */
	unsigned int databytes; /* bytes from nsfirst   */

	/* allocate new segy input information table */
	*oldinfoptr = (struct insegyinfo *)
	 malloc(sizeof(struct insegyinfo));
	infoptr = *oldinfoptr;
	infoptr->nextinfo = (struct insegyinfo *) NULL;
	infoptr->infp = fp;  /* save FILE * ptr */
	infoptr->itr = 0;
	infoptr->ntr = -1;
	
	switch (infoptr->ftype = filestat(fileno(fp))) {
	 case DIRECTORY:
	    err("%s: segy input can't be a directory", __FILE__);

	 case TTY:
	    err("%s: segy input can't be tty", __FILE__);

	 default:
	    /* all others are ok */
	    break;
	}

/*--------------------------------------------------------------------*\
   Check for the presence of a line header and set a flag if one is
   found. The decision of what to do will be delayed until the call
   to fputtr(). This allows us to accept data w/ or w/o a line
   header.

   Reginald H. Beardsley rhb@@acm.org
\*--------------------------------------------------------------------*/

	/* Attempt to get a text header */

	nread=efread(buf ,1 ,HDRBYTES ,infoptr->infp);

	switch( nread ){

	 case 0:   
	    return 0; /* no traces; trap in mains */

	 default:  

	    if (nread < HDRBYTES ){
		return 0; 

	    }else if( isascii_txt( buf ,HDRBYTES  )
		  || isebcdic_txt( buf ,HDRBYTES  ) ){
		in_line_hdr = 1;
		memcpy( su_text_hdr ,buf ,HDRBYTES );
		nread += efread(&(su_text_hdr[HDRBYTES]) ,1 
			,3200-HDRBYTES ,infoptr->infp);

	    }else{
		in_line_hdr=0;
		memcpy( tp ,buf ,HDRBYTES );

	    }
	}		

	
	if( in_line_hdr ){

	 /* Get the binary header */
	 nread = efread(&su_binary_hdr, 1, sizeof(bhed), infoptr->infp);
	 switch( nread ){
	    case 0:   
		return 0; /* no traces; trap in mains */

		default:  
		 if (nread != sizeof(su_binary_hdr)){
		    err("%s:%d bad binary header" , __FILE__ ,__LINE__ );
		 }
	 }	 

	 /* Get the first trace header */
	 nread = efread(tp, 1, HDRBYTES, infoptr->infp);
	 switch( nread ){
	    case 0:   
		return 0; /* no traces; trap in mains */

	    default:  
		if (nread != HDRBYTES){ 
		  err("%s: bad first header", __FILE__);
		}
	 }	 


	}

	/* Have the header, now for the data */
	infoptr->nsfirst = tp->ns;
	if (infoptr->nsfirst > SU_NFLTS){
	 err("%s: unable to handle %d > %d samples per trace",
		__FILE__, infoptr->nsfirst, SU_NFLTS);
	}

	switch (tp->trid) {
	 case CHARPACK:
	    infoptr->bytesper = sizeof(char); break;
	 case SHORTPACK:
	    infoptr->bytesper = 2*sizeof(char); break;
	 default:
	    infoptr->bytesper = sizeof(float); break;
	}

	databytes = infoptr->bytesper * tp->ns;

	infoptr->nsegy = HDRBYTES + databytes;


	/* Inconvenient to bump nread here; do it in the switch */
	nread = dataread(tp, infoptr, fixed_length);
	
	switch (nread) {
	 case 0:   
	    err("%s: no data on first trace", __FILE__);

	 default:  
	    if (nread != databytes){
		err("%s: first trace: " "read only %d bytes of %u",
		  __FILE__, nread, databytes);

	    }else{
		nread += HDRBYTES;
	    }
	}
	
	
	if (infoptr->ftype == DISK) { /* compute ntr */
	 efseeko(fp, (off_t) 0LL,SEEK_END);

	 if( in_line_hdr ){
	    infoptr->ntr = (eftello(fp)-3600)/infoptr->nsegy;
	    efseeko(fp, (off_t) 3600+infoptr->nsegy,SEEK_SET);

	 }else{
	    infoptr->ntr = eftello(fp)/infoptr->nsegy;
	    efseeko(fp, (off_t) infoptr->nsegy ,SEEK_SET);

	 }
	 
	}

   }else{

	/* not first trace */

/*--------------------------------------------------------------------*\
   A number of programs seek on the input file using either fseek(3c)
   or rewind(3c) and then expect to read trace data.  As a consequence
   we need to check and offset the filepointer if needed.
\*--------------------------------------------------------------------*/

	if( in_line_hdr && ftello( infoptr->infp ) == 0 ){

	 fseeko( infoptr->infp ,(off_t)3600L ,SEEK_SET );

	}

	nread = (int) efread(tp, 1, HDRBYTES, infoptr->infp);

	switch( nread ){

	 case 0: 
	    lastfp = infoptr->infp;
	    return 0; /* finished */

	 default:  
	    if (nread != HDRBYTES){
		err("%s: on trace #%ld read %d bytes expected %d bytes",
		  __FILE__,(infoptr->itr)+1,nread,HDRBYTES);
	    }
	}

	nread += dataread(tp, infoptr, fixed_length);

	if (fixed_length && (tp->ns != infoptr->nsfirst)){
	 err("%s: on trace #%ld number of samples in header (%d) differs from number for first trace (%d)"
		,__FILE__, (infoptr->itr)+1, tp->ns,

		infoptr->nsfirst);
	}
   }

   ++(infoptr->itr);
   lastfp = infoptr->infp;
   return (nread);
}


int fgettr(FILE *fp, segy *tp)
{
	return(fgettr_internal(fp,tp,cwp_true));
}

int fvgettr(FILE *fp, segy *tp)
{
	return(fgettr_internal(fp,tp,cwp_false));
}

int fgettra(FILE *fp, segy *tp, int itr)
{
	int nread;
	if(lastfp != fp)  searchlist(fp);  /* search for match */
		
	
	if(infoptr == (struct insegyinfo *) NULL) {
		/* get first trace */
		if(0 >= fgettr(fp, tp)) return(0); /* error return */

		switch(infoptr->ftype) {
		case TTY:
			warn("stdin not redirected");
		break;
		case DISK:	/* correct */
		break;
		default:
			err("%s: input must be disk file",__FILE__);
		}
	


		efseeko(fp,(off_t) 0LL,SEEK_END);
		if( in_line_hdr ){
			infoptr->ntr = (off_t)((eftello(fp)-3600)/infoptr->nsegy);
			efseeko(fp, (off_t) 3600+infoptr->nsegy,SEEK_SET);
		}else{
			infoptr->ntr = (off_t)(eftello(fp)/infoptr->nsegy);
			efseeko(fp, (off_t) infoptr->nsegy,SEEK_SET);
		}
	} /* end first entry initialization */
	
	/* Check on requested trace number */
	if(itr >= infoptr->ntr)
		err("%s: trying to read off end of file",__FILE__);
	
	/* Position file pointer at start of requested trace */
	if( in_line_hdr ){
		efseeko(fp, (off_t) 3600+itr*infoptr->nsegy,SEEK_SET);
	}else{
		efseeko(fp, (off_t) itr*infoptr->nsegy,SEEK_SET);
	}
	
	nread=fgettr(fp, tp); /* let fgettr do the work */
	if(nread != infoptr->nsegy)
		err("%s: read %d bytes in trace of %d bytes",
		    __FILE__,nread,infoptr->nsegy);
	
	if(tp->ns != infoptr->nsfirst)
		warn("%s: header ns field = %d differs from first trace = %d",
		     __FILE__,tp->ns,infoptr->nsfirst);
	
	return(infoptr->ntr);
}

#endif /* end of XDR choice */
 
/*====================================================================*\
   These functions determine the presence of a SEGY text header based
   on the character set statistics of the first 3200 bytes in the
   file.

   Reginald H. Beardsley			    rhb@@acm.org

\*====================================================================*/

static  unsigned char asciitext[256] = {
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
    1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
    1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
    1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
    1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
    1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 
};

  
static  unsigned char ebcdictext[256] = {
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    1,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,
    1,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,
    1,1,0,0,0,0,0,0,0,0,0,1,1,1,1,1,
    0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,
    0,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,
    0,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,
    0,0,1,1,1,1,1,1,1,1,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,
    0,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,
    0,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,
    0,0,1,1,1,1,1,1,1,1,0,0,0,0,0,0,
    1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0 
};

  
int isascii_txt( unsigned char* a ,int n){

  int ascii  = 0;
  int ebcdic = 0;
  int i;

  for (i=0; i<n; i++){

     ascii += asciitext[a[i]];
     ebcdic += ebcdictext[a[i]];
  }

  if( ascii > ebcdic && ascii > (int)(n*0.9) ){
    return(1);
  }else{
    return(0);
  }
}

  
int isebcdic_txt( unsigned char* a ,int n ){

  int ascii  = 0;
  int ebcdic = 0;
  int i;

  for (i=0; i<n; i++){

     ascii += asciitext[a[i]];
     ebcdic += ebcdictext[a[i]];
  }

  if( ascii < ebcdic && ebcdic > (int)(n*0.9) ){
    return(1);
  }else{
    return(0);
  }
}

#else

#include <stdio.h>

#include "su.h"
#include "segy.h"

char *sdoc[] = {
"								",
" tgettr <stdin >stdout						",
"								",
" 	Test harness for gettr.c				",
"	Changes cdp to abs(cdp)					",
"	Contrast the following results:	 			",
"	suplane offset=-100 | sugethw offset 			",
"	suplane offset=-100 | tgettr | sugethw offset		",
"								",
NULL};

segy tr;

main(int argc, char **argv)
{
	initargs(argc, argv);
	requestdoc(1);

 	while (gettr(&tr)) {
 		tr.offset = abs(tr.offset);
 		puttr(&tr);
 	}

	return EXIT_SUCCESS;
}
#endif

@


1.44
log
@*** empty log message ***
@
text
@d1 4
a4 1
/* FGETTR: $Revision: 1.43 $; $Date: 2006/03/29 22:44:17 $	*/
@


1.43
log
@Stew Levins   fixes of xdr and of reading packed formats
@
text
@d1 1
a1 1
/* FGETTR: $Revision: 1.42 $; $Date: 2004/12/23 22:37:43 $	*/
d92 2
a93 2
	struct insegyinfo *nextinfo; /* linked list pointer      */
	unsigned off_t itr;	     /* number of traces read	 */
d96 2
a97 2
	int nsegy; 		     /* segy bytes from nsfirst	 */
	unsigned off_t ntr;      /* traces in input,if known */
d100 2
a101 2
	char *buf;		 /* buffer for trace I/O     */
	 unsigned int bufstart;	/* "offset" of start of buf */
a166 1
	unsigned int startpos;	/* xdr stream offset */
d236 1
a236 1
				      __FILE__, databytes, nread);
d254 1
a254 1
		      nread += dataread(infoptr, tp, fixed_length);
d290 2
a291 2
      /* get first trace */
      if(0 >= fgettr(fp, tp)) return(0); /* error return */
d293 1
a293 1
      switch(infoptr->ftype) {
d304 3
a306 3
      efseeko(fp,(off_t) 0,SEEK_END);
      infoptr->ntr = eftello(fp)/infoptr->nsegy;
      } /* end first entry initialization */
d313 1
a313 1
        err("%s: unable to seek xdr disk file to trace %d",__FILE__,itr);
d338 2
a339 2
	struct insegyinfo *nextinfo; /* linked list pointer      */
	unsigned off_t itr;	     /* number of traces read	 */
d342 2
a343 2
	unsigned off_t  nsegy; 		     /* segy bytes from nsfirst	 */
	unsigned off_t ntr;		     /* traces in input,if known */
d387 2
a388 2
      /* initialize new segy input stream */
      unsigned int databytes; /* bytes from nsfirst   */
d390 2
a391 2
      /* allocate new segy input information table */
      *oldinfoptr = (struct insegyinfo *)
d393 7
a399 7
      infoptr = *oldinfoptr;
      infoptr->nextinfo = (struct insegyinfo *) NULL;
      infoptr->infp = fp;  /* save FILE * ptr */
      infoptr->itr = 0;
      infoptr->ntr = -1;
      
      switch (infoptr->ftype = filestat(fileno(fp))) {
d409 1
a409 1
      }
d420 1
a420 1
      /* Attempt to get a text header */
d422 1
a422 1
      nread=efread(buf ,1 ,HDRBYTES ,infoptr->infp);
d424 1
a424 1
      switch( nread ){
d446 1
a446 1
      }		
d448 2
a449 2
      
      if( in_line_hdr ){
d476 1
a476 1
      }
d478 3
a480 3
      /* Have the header, now for the data */
      infoptr->nsfirst = tp->ns;
      if (infoptr->nsfirst > SU_NFLTS){
d483 1
a483 1
      }
d485 1
a485 1
      switch (tp->trid) {
d492 1
a492 1
      }
d494 1
a494 1
      databytes = infoptr->bytesper * tp->ns;
d496 1
a496 1
      infoptr->nsegy = HDRBYTES + databytes;
d499 4
a502 4
      /* Inconvenient to bump nread here; do it in the switch */
      nread = dataread(tp, infoptr, fixed_length);
      
      switch (nread) {
d514 4
a517 4
      }
      
      
      if (infoptr->ftype == DISK) { /* compute ntr */
d530 1
a530 1
      }
d534 1
a534 1
      /* not first trace */
d542 1
a542 1
      if( in_line_hdr && ftello( infoptr->infp ) == 0 ){
d546 1
a546 1
      }
d548 1
a548 1
      nread = (int) efread(tp, 1, HDRBYTES, infoptr->infp);
d550 1
a550 1
      switch( nread ){
d561 1
a561 1
      }
d563 1
a563 1
      nread += dataread(tp, infoptr, fixed_length);
d565 1
a565 1
      if (fixed_length && (tp->ns != infoptr->nsfirst)){
d567 1
a567 1
	      ,__FILE__, (infoptr->itr)+1, tp->ns,
d569 2
a570 2
	      infoptr->nsfirst);
      }
d608 1
a608 1
      
@


1.42
log
@off_t put in for large file support
@
text
@d1 1
a1 1
/* FGETTR: $Revision: 36.9 $; $Date: 2003/08/05 22:22:36 $	*/
d53 3
d100 2
d107 2
d126 3
d133 2
d137 4
a140 1
			       iptr->infp);
d143 5
a147 3
		if(FALSE == xdr_vector(iptr->segy_xdr,
				       (char *) (&((tp->data)[0])),
				       nsread,sizeof(float),(xdrproc_t) xdr_float))
d151 1
a166 1
	unsigned short bytesper;
d169 1
d199 4
a202 2
		xdrstdio_create(infoptr->segy_xdr,fp,XDR_DECODE);
		startpos = xdr_getpos(infoptr->segy_xdr);
d205 3
a207 1
		if(FALSE == xdrhdrsub(infoptr->segy_xdr,tp))
d227 1
a227 2
		infoptr->nsegy = xdr_getpos(infoptr->segy_xdr) +
						databytes - startpos;
d231 1
d242 1
a242 1
		    startpos = xdr_getpos(infoptr->segy_xdr);
d245 1
a245 2
		    if(FALSE == xdr_setpos(infoptr->segy_xdr,startpos))
			err("%s: DISK reposition failure",__FILE__);
d248 1
d251 11
a261 8
                startpos = xdr_getpos(infoptr->segy_xdr);
                if (FALSE == xdrhdrsub(infoptr->segy_xdr,tp)) nread=0;
		else nread = xdr_getpos(infoptr->segy_xdr)-startpos;
		nread += dataread(infoptr, tp, fixed_length);
		if (nread <= 0) {
			lastfp = infoptr->infp;
			return 0;
		}
d313 3
a315 2
  if(FALSE == xdr_setpos(infoptr->segy_xdr, itr*infoptr->nsegy))
	err("%s: unable to seek xdr disk file to trace %d",__FILE__,itr);
d323 1
a323 1
       warn("%s: header ns field = %d differs from first trace = %d",
d338 1
a338 1
	FILE *infp;                  /* FILE * ptr for search	 */
d344 1
a344 1
	unsigned off_t ntr;                     /* traces in input,if known */
d393 1
a393 1
         malloc(sizeof(struct insegyinfo));
d401 2
a402 2
         case DIRECTORY:
            err("%s: segy input can't be a directory", __FILE__);
d404 2
a405 2
         case TTY:
            err("%s: segy input can't be tty", __FILE__);
d407 3
a409 3
         default:
            /* all others are ok */
            break;
d427 2
a428 2
         case 0:   
            return 0; /* no traces; trap in mains */
d430 1
a430 1
         default:  
d432 2
a433 2
            if (nread < HDRBYTES ){
               return 0; 
d435 10
a444 10
            }else if( isascii_txt( buf ,HDRBYTES  )
                  || isebcdic_txt( buf ,HDRBYTES  ) ){
               in_line_hdr = 1;
               memcpy( su_text_hdr ,buf ,HDRBYTES );
               nread += efread(&(su_text_hdr[HDRBYTES]) ,1 
                        ,3200-HDRBYTES ,infoptr->infp);

            }else{
               in_line_hdr=0;
               memcpy( tp ,buf ,HDRBYTES );
d446 2
a447 2
            }
      }               
d452 23
a474 23
         /* Get the binary header */
         nread = efread(&su_binary_hdr, 1, sizeof(bhed), infoptr->infp);
         switch( nread ){
            case 0:   
               return 0; /* no traces; trap in mains */

               default:  
                 if (nread != sizeof(su_binary_hdr)){
                    err("%s:%d bad binary header" , __FILE__ ,__LINE__ );
                 }
         }         

         /* Get the first trace header */
         nread = efread(tp, 1, HDRBYTES, infoptr->infp);
         switch( nread ){
            case 0:   
               return 0; /* no traces; trap in mains */

            default:  
               if (nread != HDRBYTES){ 
                  err("%s: bad first header", __FILE__);
               }
         }         
d482 2
a483 2
         err("%s: unable to handle %d > %d samples per trace",
               __FILE__, infoptr->nsfirst, SU_NFLTS);
d487 6
a492 6
         case CHARPACK:
            infoptr->bytesper = sizeof(char); break;
         case SHORTPACK:
            infoptr->bytesper = 2*sizeof(char); break;
         default:
            infoptr->bytesper = sizeof(float); break;
d504 2
a505 2
         case 0:   
            err("%s: no data on first trace", __FILE__);
d507 8
a514 8
         default:  
            if (nread != databytes){
               err("%s: first trace: " "read only %d bytes of %u",
                  __FILE__, nread, databytes);

            }else{
                nread += HDRBYTES;
            }
d519 1
a519 1
         efseeko(fp, (off_t) 0LL,SEEK_END);
d521 7
a527 7
         if( in_line_hdr ){
            infoptr->ntr = (eftello(fp)-3600)/infoptr->nsegy;
            efseeko(fp, (off_t) 3600+infoptr->nsegy,SEEK_SET);

         }else{
            infoptr->ntr = eftello(fp)/infoptr->nsegy;
            efseeko(fp, (off_t) infoptr->nsegy ,SEEK_SET);
d529 2
a530 2
         }
         
d545 1
a545 1
         fseeko( infoptr->infp ,(off_t)3600L ,SEEK_SET );
d553 9
a561 9
         case 0: 
            lastfp = infoptr->infp;
            return 0; /* finished */

         default:  
            if (nread != HDRBYTES){
               err("%s: on trace #%ld read %d bytes expected %d bytes",
                  __FILE__,(infoptr->itr)+1,nread,HDRBYTES);
            }
d567 2
a568 2
         err("%s: on trace #%ld number of samples in header (%d) differs from number for first trace (%d)"
              ,__FILE__, (infoptr->itr)+1, tp->ns,
d570 1
a570 1
              infoptr->nsfirst);
d613 7
a619 7
                if( in_line_hdr ){
                       infoptr->ntr = (off_t)((eftello(fp)-3600)/infoptr->nsegy);
                       efseeko(fp, (off_t) 3600+infoptr->nsegy,SEEK_SET);
                }else{
                       infoptr->ntr = (off_t)(eftello(fp)/infoptr->nsegy);
                       efseeko(fp, (off_t) infoptr->nsegy,SEEK_SET);
                }
d627 5
a631 5
        if( in_line_hdr ){
               efseeko(fp, (off_t) 3600+itr*infoptr->nsegy,SEEK_SET);
        }else{
               efseeko(fp, (off_t) itr*infoptr->nsegy,SEEK_SET);
        }
d652 1
a652 1
   Reginald H. Beardsley                            rhb@@acm.org
@


1.41
log
@updated for new support for Unocal SU
@
text
@d1 1
a1 1
/* FGETTR: $Revision: 36.7 $; $Date: 2003/04/07 22:52:55 $	*/
d90 1
a90 1
	unsigned long itr;	     /* number of traces read	 */
d92 1
a92 1
	unsigned short bytesper;  /* bytes per datum		 */
d94 1
a94 1
	int ntr;                     /* traces in input,if known */
d314 1
a314 1
	unsigned long itr;	     /* number of traces read	 */
d317 2
a318 2
	int nsegy; 		     /* segy bytes from nsfirst	 */
	int ntr;                     /* traces in input,if known */
d493 1
a493 1
         efseeko(fp, (off_t) 0,SEEK_END);
d496 1
a496 1
            infoptr->ntr = (int)((eftello(fp)-3600)/infoptr->nsegy);
d500 1
a500 1
            infoptr->ntr = (int)(eftello(fp)/infoptr->nsegy);
d517 1
a517 1
      if( in_line_hdr && ftell( infoptr->infp ) == 0 ){
d519 1
a519 1
         fseeko( infoptr->infp ,3600L ,SEEK_SET );
d586 1
a586 1
		efseeko(fp,(off_t) 0,SEEK_END);
d588 1
a588 1
                       infoptr->ntr = (int)((eftello(fp)-3600)/infoptr->nsegy);
d591 1
a591 1
                       infoptr->ntr = (int)(eftello(fp)/infoptr->nsegy);
d743 1
@


1.40
log
@changed eftell to eftello changed fseek efseeko
@
text
@d1 1
a1 1
/* FGETTR: $Revision: 1.39 $; $Date: 1998/03/31 20:34:37 $	*/
d56 22
a308 2
#include "su.h"
#include "segy.h"
d354 152
a505 3
int fgettr_internal(FILE *fp, segy *tp, cwp_Bool fixed_length)
{
	int nread;	/* bytes seen by fread calls	*/
d507 1
a507 2
	/* search linked list for possible alternative */
	if(fp != lastfp)  searchlist(fp);
d509 1
a509 3
	if (infoptr == ((struct insegyinfo *) NULL)) {
		/* initialize new segy input stream */
		unsigned int databytes;	/* bytes from nsfirst	*/
d511 5
a515 18
		/* allocate new segy input information table */
		*oldinfoptr = (struct insegyinfo *)
			malloc(sizeof(struct insegyinfo));
		infoptr = *oldinfoptr;
		infoptr->nextinfo = (struct insegyinfo *) NULL;
		infoptr->infp = fp;  /* save FILE * ptr */
		infoptr->itr = 0;
		infoptr->ntr = -1;
		
		switch (infoptr->ftype = filestat(fileno(fp))) {
		case DIRECTORY:
			err("%s: segy input can't be a directory", __FILE__);
		case TTY:
			err("%s: segy input can't be tty", __FILE__);
		default:
			/* all others are ok */
		break;
		}
d517 1
a517 6
		/* Get the header */
		switch (nread = (int) efread(tp, 1, HDRBYTES, infoptr->infp)) {
		case 0:   return 0; /* no traces; trap in mains */
		default:  if (nread != HDRBYTES)
				err("%s: bad first header", __FILE__);
		}		
d519 1
a519 5
		/* Have the header, now for the data */
		infoptr->nsfirst = tp->ns;
		if (infoptr->nsfirst > SU_NFLTS)
			err("%s: unable to handle %d > %d samples per trace",
			    __FILE__, infoptr->nsfirst, SU_NFLTS);
d521 1
a521 8
		switch (tp->trid) {
		case CHARPACK:
			infoptr->bytesper = sizeof(char); break;
		case SHORTPACK:
			infoptr->bytesper = 2*sizeof(char); break;
		default:
			infoptr->bytesper = sizeof(float); break;
		}
d523 1
a523 1
		databytes = infoptr->bytesper * tp->ns;
d525 1
a525 1
		infoptr->nsegy = HDRBYTES + databytes;
d527 3
a529 2
		/* Inconvenient to bump nread here; do it in the switch */
		nread = dataread(tp, infoptr, fixed_length);
d531 6
a536 8
		switch (nread) {
		case 0:   err("%s: no data on first trace", __FILE__);
		default:  if (nread != databytes)
				err("%s: first trace: "
				    "read only %d bytes of %u",
				    __FILE__, nread, databytes);
			  else nread += HDRBYTES;
		}
d538 1
a538 17
		if (infoptr->ftype == DISK) { /* compute ntr */
			efseeko(fp, (off_t) 0,SEEK_END);
			infoptr->ntr = (int)(eftello(fp)/infoptr->nsegy);
			efseeko(fp, (off_t) infoptr->nsegy,SEEK_SET);
							/* reset fp */
	        }


	} else {		/* Not first entry */
		switch (nread = (int) efread(tp, 1, HDRBYTES, infoptr->infp)) {
		case 0: lastfp = infoptr->infp;
			return 0; /* finished */
		default:  if (nread != HDRBYTES)
				err("%s: on trace #%ld read %d bytes ",
				    "expected %d bytes",
				    __FILE__,(infoptr->itr)+1,nread,HDRBYTES);
		}
d540 3
a542 1
                nread += dataread(tp, infoptr, fixed_length);
d544 3
a546 7
		if (fixed_length && (tp->ns != infoptr->nsfirst))
			err("%s: on trace #%ld, "
			    "number of samples in header (%d) "
			    "differs from number for first trace (%d)", 
			    __FILE__, (infoptr->itr)+1, tp->ns,
			    infoptr->nsfirst);
	}
d548 3
a550 3
	++(infoptr->itr);
	lastfp = infoptr->infp;
	return (nread);
d553 1
d584 2
d587 7
a593 1
		infoptr->ntr = (int) (eftello(fp)/infoptr->nsegy);
d601 5
a605 1
	efseeko(fp, (off_t) itr*infoptr->nsegy, SEEK_SET);
d621 94
a714 1
#ifdef TEST
a742 1

@


1.39
log
@Stew Levin's changes
@
text
@d1 1
a1 2
/* FGETTR: $Revision: 1.31 $; $Date: 1996/02/05 21:04:19 $	*/

d155 4
a158 1
			}
d194 1
d199 2
a200 2
		    efseek(fp,0L,SEEK_END);
		    infoptr->ntr = eftell(fp)/infoptr->nsegy;
d258 2
a259 2
      efseek(fp,0L,SEEK_END);
      infoptr->ntr = eftell(fp)/infoptr->nsegy;
d403 4
a406 3
			efseek(fp,0L,SEEK_END);
			infoptr->ntr = (int)(eftell(fp)/infoptr->nsegy);
			efseek(fp,infoptr->nsegy,SEEK_SET); /* reset fp */
d465 2
a466 2
		efseek(fp,0L,SEEK_END);
		infoptr->ntr = (int) (eftell(fp)/infoptr->nsegy);
d474 1
a474 1
	efseek(fp, itr*infoptr->nsegy, SEEK_SET);
@


1.38
log
@version 38
@
text
@d1 1
a1 1
/* FGETTR: $Revision: 1.37 $; $Date: 1996/09/16 17:11:52 $	*/
d12 1
a12 1
vgettr		macro using fvgettr to get a trace from stdin
d29 1
a29 1
The function gettr(x) is a macro defined in su.h
d31 1
d43 1
a43 3
Authors: SEP & MOBIL: Stewart A. Levin
	 SEP: Einar Kjartansson
         CWP: Shuki Ronen, Jack Cohen
d45 10
d57 227
d484 2
d515 1
@


1.37
log
@added a break; after default:
@
text
@d1 1
a1 1
/* FGETTR: $Revision: 1.36 $; $Date: 1996/09/06 19:56:31 $	*/
d82 1
a82 1
	int nread = efread((char *) (&((tp->data)[0])),1, databytes,
d126 1
a126 1
		switch (nread = efread(tp, 1, HDRBYTES, infoptr->infp)) {
d165 1
a165 1
			infoptr->ntr = eftell(fp)/infoptr->nsegy;
d171 1
a171 1
		switch (nread = efread(tp, 1, HDRBYTES, infoptr->infp)) {
d197 1
a197 1
	return(fgettr_internal(fp,tp,true));
d202 1
a202 1
	return(fgettr_internal(fp,tp,false));
d226 1
a226 1
		infoptr->ntr = eftell(fp)/infoptr->nsegy;
@


1.36
log
@added default: line to make -Wall happy (hope this is right).
@
text
@d1 1
a1 1
/* FGETTR: $Revision: 1.35 $; $Date: 1996/05/01 16:17:04 $	*/
d122 1
@


1.35
log
@Did not augment nread from databytes by HDRBYTES on first entry,
so fgettr returned wrong number. Thx to Alexander Koek, Delft.
@
text
@d1 1
a1 1
/* FGETTR: $Revision: 1.34 $; $Date: 1996/02/22 16:12:46 $	*/
d120 2
@


1.34
log
@Switched args of dataread to agree with order in fread.
@
text
@d1 1
a1 1
/* FGETTR: $Revision: 1.33 $; $Date: 1996/02/12 16:51:33 $	*/
d148 1
d157 1
@


1.33
log
@Cosmetic.
@
text
@d1 1
a1 1
/* FGETTR: $Revision: 1.32 $; $Date: 1996/01/23 20:27:29 $	*/
d78 1
a78 1
int dataread(struct insegyinfo *iptr, segy *tp, cwp_Bool fixed_length)
d148 1
a148 1
		nread = dataread(infoptr, tp, fixed_length);
d175 1
a175 1
                nread += dataread(infoptr, tp, fixed_length);
@


1.32
log
@short -> 2*char for compatibility with supack2
@
text
@d1 1
a1 4
/* Copyright (c) Colorado School of Mines, 1994.*/
/* All rights reserved.                       */

/* FGETTR: $Revision: 1.31 $; $Date: 1996/01/20 05:25:26 $	*/
@


1.31
log
@better error messages, removed superfluous check of bytes returned
from dataread in fgettr_internal.
@
text
@d4 1
a4 1
/* FGETTR: $Revision: 1.30 $; $Date: 1996/01/19 22:57:35 $	*/
d142 1
a142 1
			infoptr->bytesper = sizeof(short); break;
@


1.30
log
@Moved some assignments in dataread to initializations.
@
text
@d4 1
a4 1
/* FGETTR: $Revision: 1.29 $; $Date: 1996/01/17 04:46:49 $	*/
a82 1
	int nread;
d85 2
a87 2
	/* read trace data */
	nread = efread((char *) (&((tp->data)[0])),1, databytes, iptr->infp);
d89 3
a91 2
		err("%s: read only %d bytes of %d bytes on trace #%ld",
		    __FILE__, nread, databytes, (infoptr->itr)+1);
d173 3
a175 2
				err("%s: bad header on trace #%ld",
				    __FILE__, (infoptr->itr)+1);
a178 5
		if (nread <= HDRBYTES) {
			lastfp = infoptr->infp;
			err("%s: bad data section on trace #%ld",
			    __FILE__, (infoptr->itr)+1);
		}
d236 1
a236 1
		err("%s: read only %d bytes of %d bytes in trace",
@


1.28
log
@Changed "not first entry" error handling in fgettr_internal.
@
text
@d4 1
a4 1
/* FGETTR: $Revision: 1.27 $; $Date: 1996/01/12 20:39:29 $	*/
d56 1
a56 1
	FILE *infp;		/* FILE * ptr for search	 */
d58 7
a64 6
	unsigned long itr;	/* number of traces read	 */
	int nsfirst;		/* samples from 1st header	 */
	int nsegy; 		/* segy bytes from nsfirst	 */
	int ntr;                /* no. traces in input, if known */
	FileType ftype;		/* file type of input *fp	 */
	} *insegylist = (struct insegyinfo *) NULL;
d72 2
a73 2
    oldinfoptr = &insegylist;
    for(infoptr = insegylist; infoptr != ((struct insegyinfo *) NULL);
d77 1
a77 1
	    }
d83 9
a91 20
 unsigned short bytesper;
 unsigned int databytes, nsread;
 int nread;

 /* read trace data */
 nsread = fixed_length?iptr->nsfirst:tp->ns;
 switch(tp->trid) {
 case CHARPACK:
    bytesper = sizeof(char);
    break;
 case SHORTPACK:
    bytesper = sizeof(short);
    break;
 default:
    bytesper = sizeof(float);
    break;
 }
 nread = efread((char *) (&((tp->data)[0])),1,bytesper*nsread, iptr->infp);
 if(nread > 0 && nread != (bytesper*nsread)) 
	 err("%s: read trace #%ld", __FILE__, infoptr->itr);
d93 1
a93 1
 return(nread);
d100 1
a100 1
	int nread;			/* bytes seen by fread calls	*/
d102 2
a103 2
	if(fp != lastfp)  /* search linked list for possible alternative */
			    searchlist(fp);
d106 2
a107 3
	/* initialize new segy input stream */
		unsigned short bytesper; /* bytes per datum (packed?)	*/
		unsigned int databytes;	/* bytes from nsfirst		*/
d114 1
a114 2
		/* save FILE * ptr */
		infoptr->infp = fp;
d129 1
a129 2
			err("%s: bad first header", __FILE__);
		break;
d136 1
a136 1
				    __FILE__, infoptr->nsfirst, SU_NFLTS);
d140 1
a140 1
		   bytesper = sizeof(char); break;
d142 1
a142 1
		   bytesper = sizeof(short); break;
d144 1
a144 1
		   bytesper = sizeof(float); break;
d147 1
a147 1
		databytes = bytesper * tp->ns;
d156 3
a158 4
				 err("%s: first trace: "
				     "read only %d bytes of %u",
				      __FILE__, nread, databytes);
		break;
d162 3
a164 3
		    efseek(fp,0L,SEEK_END);
		    infoptr->ntr = eftell(fp)/infoptr->nsegy;
		    efseek(fp,infoptr->nsegy,SEEK_SET); /* reset fp */
d168 1
a168 1
} else { /* Not first entry */
a174 1
		break;
d199 1
a199 1
 return(fgettr_internal(fp,tp,true));
d204 1
a204 1
 return(fgettr_internal(fp,tp,false));
d209 7
a215 22
 int nread;
 if(lastfp != fp) /* search for match */
		     searchlist(fp);

 if(infoptr == (struct insegyinfo *) NULL) {
      /* get first trace */
      if(0 >= fgettr(fp, tp)) return(0); /* error return */

      switch(infoptr->ftype) {
	  case TTY:
	    warn("stdin not redirected");
	    break;
	  case DISK: /* correct */
	    break;
	  default:
	    err("%s: input must be disk file",__FILE__);
	    break;
	  }

      efseek(fp,0L,SEEK_END);
      infoptr->ntr = eftell(fp)/infoptr->nsegy;
      } /* end first entry initialization */
d217 31
a247 16
 /* Check on requested trace number */
  if(itr >= infoptr->ntr) err("%s: trying to read off end of file",__FILE__);

 /* Position file pointer at start of requested trace */
 efseek(fp, itr*infoptr->nsegy, SEEK_SET);
 
 nread=fgettr(fp, tp);
 if(nread != infoptr->nsegy)
	err("%s: read only %d bytes of %d bytes in trace",
		__FILE__,nread,infoptr->nsegy);

 if(tp->ns != infoptr->nsfirst)
       warn("%s: header ns field = %d differs from first trace = %d",
		__FILE__,tp->ns,infoptr->nsfirst);

 return(infoptr->ntr);
@


1.27
log
@/*
 * Revised: 7/2/95 Stewart A. Levin   Mobil
 *     Merge fgettr and fgettra into same source file.
 *     Make input from multiple streams work (at long last!).
 * Revised: 11/22/95 Stewart A. Levin  Mobil
 *     Always set ntr for DISK input.  This fixes susort failure.
 * Revised: 1/9/96  jkc CWP
 *     Set lastfp on nread <=0 return, too.
 *
 *     Remark: Stew also had xdr support which I've removed
 *     for version 28--Jack.
 */
@
text
@d4 1
a4 1
/* FGETTR: $Revision: 1.27 $; $Date: 95/07/02 00:00:00 $	*/
d172 1
d183 9
a191 1
		nread = efread(tp, 1, HDRBYTES, infoptr->infp);
d193 1
a193 1
		if (nread <= 0) {
d195 2
a196 1
			return 0;
d203 2
a204 1
			     __FILE__, infoptr->itr, tp->ns, infoptr->nsfirst);
@


1.26
log
@Fixed bug pointed out by Jim Childress of Cray: the "first' branch
of fvgettr was accessing an ungotten trace to ascertain bytesper.
At cost of some efficiency, moved the bytesper down into the main
branch.
@
text
@d1 4
a4 1
/* FGETTR: $Revision: 1.25 $; $Date: 95/05/22 12:23:09 $	*/
d9 1
a9 1
FGETTR - Routines to sequentially get SU traces from a file 
d11 6
a16 4
fgettr		get a segy trace from a file by file pointer (nt constant)
gettr		macro using fgettr to get a trace from stdin (nt constant)
fvgettr		get a segy trace from a file by file pointer (nt may vary)
vgettr		macro using fgettr to get a trace from stdin (nt may vary)
d22 1
d26 1
d28 3
d32 1
a32 1
Macros defined in segy.h
a33 3
#define vgettr(x)	fgettr(stdin, (x))

See Also: su/lib/fgettra.c for random access of SU traces
d45 3
a47 1
Authors: SEP: Einar Kjartansson, Stew Levin CWP: Shuki Ronen, Jack Cohen
d55 51
d107 2
a108 1
int fgettr(FILE *fp, segy *tp)
a109 5
	static unsigned long itr = 0;	/* number of traces read	*/
	static cwp_Bool first = true;	/* to check if first entry	*/
	static int nsfirst;		/* samples from 1st header	*/
	static int nsegy; 		/* segy bytes from nsfirst	*/
	static FileType ftype;		/* file type of input *fp	*/
d112 2
d115 2
a116 1
	if (first) {
d120 11
a130 3
		first = false;

		switch (ftype = filestat(fileno(fp))) {
d132 1
a132 1
			err("%s: stdin can't be a directory", __FILE__);
d134 22
a155 1
			err("%s: stdin can't be tty", __FILE__);
d157 15
a171 31
			/* Get the header */
			switch (nread = efread(tp, 1, HDRBYTES, fp)) {
			case 0:   return 0; /* no traces; trap in mains */
			default:  if (nread != HDRBYTES)
					err("%s: bad first header", __FILE__);
			break;
			}

			/* Have the header, now for the data */
			nsfirst = tp->ns;
			if (nsfirst > SU_NFLTS)
				err("%s: unable to handle %d > %d "
				    "samples per trace",
				    __FILE__, nsfirst, SU_NFLTS);

			if      (tp->trid==CHARPACK)   bytesper=sizeof(char);
			else if (tp->trid==SHORTPACK)  bytesper=sizeof(short);
			else			       bytesper=sizeof(float);

			databytes = bytesper * nsfirst;
			nsegy = HDRBYTES + databytes;

			switch (nread = efread(tp->data, 1, databytes, fp)) {
			case 0:   err("%s: no data on first trace", __FILE__);
			default:  if (nread != databytes)
					 err("%s: first trace: "
					     "read only %d bytes of %u",
					      __FILE__, nread, databytes);
			break;
			}
		break;
d174 6
a179 1
	} else { /* Not first entry */
d181 6
a186 5
		switch (nread = efread(tp, 1, nsegy, fp)) {
		case 0:   return 0; /* finished */
		default:  if (nread != nsegy)
			      err("%s: read trace #%ld", __FILE__, itr);
		break;
d189 1
a189 1
		if (tp->ns != nsfirst)
d193 1
a193 1
			     __FILE__, itr, tp->ns, nsfirst);
d196 3
a198 2
	++itr;
	return nsegy;
d201 4
d207 3
a209 5
/************************************************************************* 
  fvgettr - GET a segy TRace from a file by File pointer (nt can Vary)
************************************************************************** 
Input:
fp	input file pointer
d211 24
a234 2
Output:
tp	pointer to a type segy
d236 2
a237 2
Returns:
	int: number of bytes read on current trace (0 after last trace)
d239 11
a249 60
************************************************************************** 
Notes: The bytesper variable is computed over and over again as an
       alternate to having duplicate for the first and later reads.
       If this loss of efficiency matters, the reverse decision could
       be made.

Macro defined in segy.h :	#define vgettr(x)	fgettr(stdin, (x))
************************************************************************** 
Credits: CWP: Jack K. Cohen, Michel Dietrich 
**************************************************************************/
{
	static unsigned long itr = 0;	/* number of traces read	*/
	static cwp_Bool first = true;	/* to check if first entry	*/
	static FileType ftype;		/* file type of input *fp	*/
	static unsigned short bytesper;	/* bytes per datum (packed?)	*/
	int databytes;			/* data bytes on current segy	*/
	int nt;				/* samples on trace (can vary)	*/
	int nsegy; 			/* total bytes on current segy	*/
	int nread;			/* bytes seen by fread calls	*/


	if (first) {
		first = false;

		switch (ftype = filestat(fileno(fp))) {
		case DIRECTORY:
			err("%s: stdin can't be a directory", __FILE__);
		case TTY:
			err("%s: stdin can't be tty", __FILE__);
		}
	}

	/* Get the header */
	switch (nread = efread(tp, 1, HDRBYTES, fp)) {
	case 0:   return 0; /* no more traces */
	default:  if (nread != HDRBYTES)
			err("%s: bad header, trace #%ld", __FILE__, itr);
	break;
	}

	/* Have the header, now for the data */
	nt = tp->ns;
	if (nt > SU_NFLTS)
		err("%s: unable to handle %d > %d "
			"samples per trace", __FILE__, nt, SU_NFLTS);

        if      (tp->trid==CHARPACK)   bytesper=sizeof(char);
        else if (tp->trid==SHORTPACK)  bytesper=sizeof(short);
        else			       bytesper=sizeof(float);
        
        databytes = bytesper * nt;
	nsegy = HDRBYTES + databytes;

	switch (nread = efread(tp->data, 1, databytes, fp)) {
	case 0:   err("%s: no data on trace #%ld, itr", __FILE__);
	default:  if (nread != databytes)
			 err("%s: trace #%ld, read only %d bytes of %u",
				__FILE__, itr, nread, databytes);
	break;
	}
d251 1
a251 2
	++itr;
	return nsegy;
@


1.25
log
@Addition to self-doc material.
@
text
@d1 1
a1 1
/* FGETTR: $Revision: 1.24 $; $Date: 94/11/18 13:36:22 $	*/
a122 2
#include "header.h"

d137 5
a141 1
Notes: Cloned from .../su/lib/fgettr.c   
a164 4
		default:
			if      (tp->trid==CHARPACK)   bytesper=sizeof(char);
			else if (tp->trid==SHORTPACK)  bytesper=sizeof(short);
			else			       bytesper=sizeof(float);
d182 5
a186 1
	databytes = bytesper * nt;
@


1.24
log
@added fvgettr
@
text
@d1 1
a1 1
/* FGETTR: $Revision: 1.23 $; $Date: 94/03/14 14:19:29 $	*/
d6 1
a6 1
FGETTR - Routines to get an SU trace from a file 
d11 1
a11 1
vgettr		macro using fgettr to get a trace from stdin (nt may vary_
d25 2
@


1.23
log
@added dummy selfdocs
@
text
@d1 1
a1 1
/* FGETTR: $Revision: 1.22 $; $Date: 93/08/13 10:26:19 $	*/
d8 4
a11 2
fgettr		get a segy trace from a file by file pointer
gettr		macro using fgettr to get a trace from stdin
d16 1
d22 1
a22 1
The function gettr(x) is a macro defined in su.h
d24 1
d121 75
@


1.22
log
@changed String to cwp_String, Bool to cwp_Bool
@
text
@d1 1
a1 1
/* FGETTR: $Revision: 1.20.1.1 $; $Date: 93/01/12 14:47:57 $	*/
a2 12
/*----------------------------------------------------------------------
 * Copyright (c) Colorado School of Mines, 1989.
 * All rights reserved.
 *
 * This code is part of SU.  SU stands for Seismic Unix, a processing line
 * developed at the Colorado School of Mines, partially based on Stanford
 * Exploration Project (SEP) software.  Inquiries should be addressed to:
 *
 *  Jack K. Cohen, Center for Wave Phenomena, Colorado School of Mines,
 *  Golden, CO 80401  (jkc@@dix.mines.colorado.edu)
 *----------------------------------------------------------------------
 */
d4 32
a39 25
/* fgettr - get a segy trace from a file by file pointer
 * gettr  - get a segy trace from stdin
 *
 * Returns:
 *	int: number of bytes read on current trace (0 after last trace)
 *
 * Synopsis:
 *	int fgettr(FILE *fp, segy *tp)
 *
 *	gettr(tp) is a macro for fgettr(stdin, tp)
 *
 * Example:
 *	segy tr;
 *	...
 *	while (gettr(&tr)) {
 *		tr.offset = abs(tr.offset);
 *		puttr(&tr);
 *	}
 *	...
 *
 * Credits:
 *	SEP: Einar, Stew
 *	CWP: Shuki, Jack
 *
 */
a40 1

a119 1
/*********************** self documentation **********************/
a130 1
/**************** end self doc ********************************/
@


1.21
log
@retreated to version 1.18 of fgettr.c
@
text
@d1 1
a1 1
/* FGETTR: $Revision: 1.18 $; $Date: 92/12/11 09:35:05 $	*/
d50 1
a50 1
	static Bool first = true;	/* to check if first entry	*/
d80 2
a81 1
			err("%s: unable to handle %d > %d samples per trace",
d112 3
a114 2
		warn("%s: on trace #%ld, number of samples in header (%d) );
		err("differs from number for first trace (%d)",
d131 1
a131 1
"	Test harness for gettr.c				",
@


1.20
log
@*** empty log message ***
@
text
@d1 1
a1 1
/* FGETTR: $Revision: 1.19 $; $Date: 92/12/11 09:46:08 $	*/
d80 1
a80 1
			  err("%s: unable to handle %d > %d samples per trace",
d93 3
a95 3
				  warn("%s: first trace: ",__FILE__);
				  err("read only %d bytes of %u", 
						nread, databytes);
d111 3
a113 3
		warn("%s: on trace #%ld, number of samples in header (%d)", 
			__FILE__,itr,tp->ns);
		err("differs from number for first trace (%d)", nsfirst);
@


1.20.1.1
log
@*** empty log message ***
@
text
@d1 1
a1 1
/* FGETTR: $Revision: 1.16 $; $Date: 92/10/30 08:43:27 $	*/
d80 1
a80 2
				err("%s: unable to handle %d > %d "
				    "samples per trace",
d93 3
a95 3
					 err("%s: first trace: "
					     "read only %d bytes of %u",
					      __FILE__, nread, databytes);
d111 3
a113 4
			err("%s: on trace #%ld, "
			    "number of samples in header (%d) "
			    "differs from number for first trace (%d)", 
			     __FILE__, itr, tp->ns, nsfirst);
d129 1
a129 1
" 	Test harness for gettr.c				",
@


1.19
log
@changed more concatenated strings in err
@
text
@d1 1
a1 1
/* FGETTR: $Revision: 1.18 $; $Date: 92/12/11 09:35:05 $	*/
@


1.18
log
@removed broken "  " "  " in err calls
@
text
@d1 1
a1 1
/* FGETTR: $Revision: 1.17 $; $Date: 92/10/30 08:56:06 $	*/
d80 1
a80 1
			err("%s: unable to handle %d > %d samples per trace",
d93 3
a95 3
					 err("%s: first trace: "
					     "read only %d bytes of %u",
					      __FILE__, nread, databytes);
d111 3
a113 3
		warn("%s: on trace #%ld, number of samples in header (%d) );
		err("differs from number for first trace (%d)",
			     __FILE__, itr, tp->ns, nsfirst);
@


1.17
log
@cosmetic fix
@
text
@d1 1
a1 1
/* FGETTR: $Revision: 1.16 $; $Date: 92/10/30 08:43:27 $	*/
d80 1
a80 2
				err("%s: unable to handle %d > %d "
				    "samples per trace",
d111 2
a112 3
			err("%s: on trace #%ld, "
			    "number of samples in header (%d) "
			    "differs from number for first trace (%d)", 
@


1.16
log
@new selfdoc installed in test program
@
text
@d1 1
a1 1
/* FGETTR: $Revision: 1.15 $; $Date: 91/09/05 08:47:27 $	*/
d128 9
a136 9
								",
tgettr <stdin >stdout						",
								",
	Test harness for gettr.c				",
	Changes cdp to abs(cdp)					",
	Contrast the following results:	 			",
	suplane offset=-100 | sugethw offset 			",
	suplane offset=-100 | tgettr | sugethw offset		",
								",
@


1.15
log
@string -> String and so forth.
@
text
@d1 1
a1 1
/* FGETTR: $Revision: 1.14 $; $Date: 91/06/28 09:40:39 $	*/
d127 12
a138 12
string sdoc = "\
								\n\
tgettr <stdin >stdout						\n\
								\n\
	Test harness for gettr.c				\n\
	Changes cdp to abs(cdp)					\n\
	Contrast the following results:	 			\n\
	suplane offset=-100 | sugethw offset 			\n\
	suplane offset=-100 | tgettr | sugethw offset		\n\
								\n\
";
/*****************************************************************/
d145 1
a145 1
	askdoc(1);
@


1.14
log
@Using __FILE__ macro
@
text
@d1 1
a1 1
/* FGETTR: $Revision: 1.13 $; $Date: 91/06/27 19:07:15 $	*/
d50 1
a50 1
	static bool first = true;	/* to check if first entry	*/
d53 1
a53 1
	static filetype ftype;		/* file type of input *fp	*/
@


1.13
log
@Eliminated 2 anarchronistic references to DISK traces
@
text
@d1 1
a1 1
/* FGETTR: $Revision: 1.12 $; $Date: 91/06/27 18:10:52 $	*/
d53 2
a54 2
	static filetype ftype;		/* file type			*/
	int nread;			/* bytes read			*/
d65 1
a65 1
			err("fgettr: stdin can't be a directory");
d67 1
a67 1
			err("fgettr: stdin can't be tty");
d73 1
a73 1
					err("fgettr: bad first header");
d80 3
a82 2
				err("fgettr: unable to handle %d > %d "
				    "samples per trace", nsfirst, SU_NFLTS);
d92 1
a92 1
			case 0:   err("fgettr: no data on first trace");
d94 1
a94 1
					 err("fgettr: first trace: "
d96 1
a96 1
					      nread, databytes);
d107 1
a107 1
			      err("fgettr: read trace #%ld", itr);
d112 1
a112 1
			err("fgettr: on trace #%ld, "
d115 1
a115 1
			     itr, tp->ns, nsfirst);
@


1.12
log
@Dangling %s in line 114 error message left when converting to
ansi-c string format.
@
text
@d1 1
a1 1
/* FGETTR: $Revision: 1.11 $; $Date: 91/06/27 14:55:22 $	*/
d93 1
a93 1
					 err("fgettr: first disktrace: "
d106 1
a106 1
			      err("fgettr: disk read trace #%ld", itr);
@


1.11
log
@Return 0 if no traces instead of calling it an error (maybe
fgettra got the first--and only--trace!).
@
text
@d1 1
a1 1
/* FGETTR: $Revision: 1.10 $; $Date: 91/01/10 09:35:06 $	*/
d112 1
a112 1
			    "number of samples in header (%d) %s "
@


1.10
log
@make default to behave like DISK instead of BADFILETYPE.
This should insulate against vendors who make pipe into FIFO.
@
text
@d1 1
a1 1
/* FGETTR: $Revision: 1.9 $; $Date: 90/12/23 20:01:55 $	*/
d71 1
a71 1
			case 0:   err("fgettr: no traces");
@


1.9
log
@Made some variables local to "first" block
@
text
@d1 1
a1 1
/* FGETTR: $Revision: 1.8 $; $Date: 90/12/22 18:37:43 $	*/
d64 5
a68 3
		case TAPE:
		case PIPE:
		case DISK:
a98 7
		case DIRECTORY:
			err("fgettr: stdin can't be a directory");
		case TTY:
			err("fgettr: stdin can't be tty");
		default:
			err("fgettr: stdin is undefined filetype: %s",
						printstat(ftype));
d103 4
a106 10
		switch (ftype) {
		case TAPE:
		case PIPE:
		case DISK:
			switch (nread = efread(tp, 1, nsegy, fp)) {
			case 0:   return 0; /* finished */
			default:  if (nread != nsegy)
				      err("fgettr: disk read trace #%ld", itr);
			break;
			}
a107 3
		default:
		     err("fgettr: %s: mysterious filetype trace #%ld",
							__LINE__, itr);
@


1.8
log
@fp version
@
text
@d1 1
a1 1
/* FGETTR: $Revision: 1.6 $; $Date: 90/12/19 08:43:05 $	*/
a50 1
	static filetype ftype;		/* filetype of fd		*/
a51 1
	static unsigned int databytes;	/* bytes from nsfirst		*/
d53 1
a53 1
	static unsigned short bytesper; /* bytes per datum (eg. packed)	*/
d57 3
a60 1
	if (first) {
@


1.7
log
@Tweaks
@
text
@d20 1
a20 1
/* fgettr - get a segy trace from a file by descriptor
d27 1
a27 2
 *	int fgettr(fd, tp)
 *	segy *tp;
d47 1
a47 1
int fgettr(int fd, segy *tp)
d63 1
a63 1
		switch (ftype = filestat(fd)) {
d68 3
a70 5
			switch (nread = eread(fd, (char *) tp, HDRBYTES)) {
			case 0:	/* no traces */
				err("fgettr: no traces");
			default:
				if (nread != HDRBYTES)
d88 6
a93 7
			switch (nread=eread(fd, (char*)tp->data, databytes)) {
			case 0:	/* no data on trace */
				err("fgettr: no data on first trace");
			default:
				if (nread != databytes)
				    err("fgettr: first disktrace: read only "
					"%d bytes of %u", nread, databytes);
d97 2
d112 4
a115 6
			switch (nread = eread(fd, (char *) tp, nsegy)) {
			case 0:	/* finished */
				return 0;
			default:
				if (nread != nsegy)
				    err("fgettr: disk read trace #%ld", itr);
@


1.6
log
@Removed all the special logic for TAPE, PIPE and seems to
work fine from tape & pipe anyway.
@
text
@d1 1
a1 1
/* FGETTR: $Revision: 1.5 $; $Date: 90/10/27 22:32:38 $	*/
d12 1
a12 1
 *  Golden, CO 80401  (isis!csm9a!jkcohen)
a40 3
 * The original SEP version contained code for asynchronous use of
 * TAPE on the Convex.  The tape handling in this code is untested.
 *
d43 1
a43 1
 *	CWP: Jack, Shuki
d50 1
a50 1
	static ulong itr = 0;		/* number of traces read	*/
d53 5
a57 5
	static int nsfirst;	/* number of samples from 1st header	*/
	static uint ndata;	/* number of data bytes from nsfirst	*/
	static int nsegy; 	/* number of segy bytes from nsfirst	*/
	static ushort bytesper; /* bytes per datum (might be packed)	*/
	int nread;		/* number of bytes read			*/
d73 2
a74 4
				if (nread != HDRBYTES) {
					err("fgettr: %s",
					    "bad first header on disk");
				}
d80 3
a82 5
			if (nsfirst > SU_NFLTS) {
				err("fgettr: %s %d > %d %s",
				    "unable to handle", nsfirst, SU_NFLTS,
				    "samples per trace");
			}
d84 3
a86 6
			if (tp->trid == CHARPACK)
				bytesper = sizeof(char);
			else if (tp->trid == SHORTPACK)
				bytesper = sizeof(short);
			else
				bytesper = sizeof(float);
d88 2
a89 2
			ndata = bytesper * nsfirst;
			nsegy = HDRBYTES + ndata;
d91 1
a91 1
			switch (nread = eread(fd, (char *) tp->data, ndata)) {
d95 3
a97 5
				if (nread != ndata) {
				    err("fgettr: %s %d bytes of %u", 
				        "first disktrace: read only",
					nread, ndata);
				}
d118 2
a119 4
				if (nread != nsegy) {
					err("fgettr: %s #%ld",
					    "disk read trace", itr);
				}
d128 5
a132 6
		if (tp->ns != nsfirst) {
			err("fgettr: on trace #%ld, %s (%d) %s (%d)", 
			     itr, "number of samples in header",
			     tp->ns, "differs from number for first trace",
			     nsfirst);
		}
d135 1
a135 1
	itr++;
@


1.5
log
@Some minor cleaning up.
@
text
@d1 1
a1 1
/* FGETTR: $Revision: 1.4 $; $Date: 90/10/26 19:27:49 $	*/
d59 1
a59 1
	static ushort bytesper;	/* bytes per datum (might be packed)	*/
a68 26
			switch (nsegy = eread(fd, (char *) tp, MAXSEGY)) {
			case 0:
				err("fgettr: no traces");
			default:
				nsfirst = tp->ns;
				if (nsfirst > SU_NFLTS) {
					err("fgettr: %s %d > %d %s",
					    "unable to handle", nsfirst,
					    SU_NFLTS, "samples per trace");
				}

				if (tp->trid == CHARPACK)
					bytesper = sizeof(char);
				else if (tp->trid == SHORTPACK)
					bytesper = sizeof(short);
				else
					bytesper = sizeof(float);

				if (nsegy !=
					HDRBYTES + nsfirst * bytesper) {
					err("%s: %s", fgettr,
					    "bad first trace on tape");
				}
			break;
			}
		break;
a69 40
			/* Get the header */
			switch (nread = pread(fd, tp, HDRBYTES)) {
			case 0:
				err("fgettr: no traces");
			default:
				if (nread != HDRBYTES) {
					err("fgettr: %s",
					    "bad first header on pipe");
				}
			}

			/* Have the header, now for the data */
			nsfirst = tp->ns;
			if (nsfirst > SU_NFLTS) {
			    err("%s: %s %d>%d %s", fgettr, "unable to handle",
			        nsfirst, SU_NFLTS, "samples per trace");
			}

			if (tp->trid == CHARPACK)
				bytesper = sizeof(char);
			else if (tp->trid == SHORTPACK)
				bytesper = sizeof(short);
			else
				bytesper = sizeof(float);

			nsegy = HDRBYTES + bytesper * nsfirst;
			ndata = bytesper * nsfirst;

			switch (nread = pread(fd, tp->data, ndata)) {
			case 0:	/* no data on trace */
				return(HDRBYTES);
			default:
				if (nread != ndata) {
				    err("%s: %s %d bytes of %u", 
				        fgettr, "first pipetrace: read only",
					nread, ndata);
				}
			break;
			}
		break;
a123 10
			switch (nread = eread(fd, (char *) tp, nsegy)) {
			case 0:	/* finished */
				return 0;
			default:
				if (nread != nsegy) {
					err("fgettr: %s #%ld",
					    "tape read trace", itr);
				}
			}
		break;
a124 11
			switch (nread = pread(fd, tp, nsegy)) {
			case 0:	/* finished */
				return 0;
			default:
				if (nread != nsegy) {
					err("fgettr: %s #%ld",
					    "pipe read trace", itr);
				}
			break;
			}
		break;
@


1.4
log
@Changed to look at tr.trid to check for packing
instead of having cloned fgettr, fputtr
@
text
@d1 1
a1 1
/* FGETTR: $Revision: 1.3 $; $Date: 90/10/25 09:34:46 $	*/
d53 1
a53 1
	static ulong itr = 0;	/* number of traces read		*/
d55 1
a55 1
	static filetype ftype;	/* filetype of fd			*/
d59 1
a59 1
	static ushort bytesper;	/* bytes per float (might be packed)	*/
d69 1
a69 1
			switch (nsegy = eread(fd, tp, MAXSEGY)) {
d71 1
a71 1
				err("%s: no traces", fgettr);
d75 1
a75 1
					err("%s: %s %d > %d %s", fgettr,
d80 6
a85 3
				if (tp->trid == CHARPACK)  bytesper = sizeof(char);
				else if (tp->trid == SHORTPACK) bytesper = sizeof(short);
				else bytesper = sizeof(float);
d90 1
a90 1
					    "bad first header on tape");
d99 1
a99 1
				err("%s: no traces", fgettr);
d102 1
a102 1
					err("%s: %s", fgettr,
d114 6
a119 3
			if (tp->trid == CHARPACK)  bytesper = sizeof(char);
			else if (tp->trid == SHORTPACK) bytesper = sizeof(short);
			else bytesper = sizeof(float);
d138 1
a138 1
			switch (nread = eread(fd, tp, HDRBYTES)) {
d140 1
a140 1
				err("%s: no traces", fgettr);
d143 1
a143 1
					err("%s: %s", fgettr,
d152 1
a152 1
				err("%s: %s %d > %d %s", fgettr,
d157 6
a162 3
			if (tp->trid == CHARPACK)  bytesper = sizeof(char);
			else if (tp->trid == SHORTPACK) bytesper = sizeof(short);
			else bytesper = sizeof(float);
d167 1
a167 2
			switch (nread =
			        eread(fd, tp->data, ndata)) {
d169 1
a169 1
				err("%s: no data on first trace", fgettr);
d172 2
a173 2
				    err("%s: %s %d bytes of %u", 
				        fgettr, "first disktrace: read only",
d180 1
a180 1
			err("%s: stdin can't be tty", fgettr);
d182 2
a183 2
			err("%s: stdin is undefined filetype: %s",
						fgettr, printstat(ftype));
d190 1
a190 1
			switch (nread = eread(fd, tp, nsegy)) {
d195 1
a195 1
					err("%s: %s #%ld", fgettr,
d206 1
a206 1
					err("%s: %s #%ld", fgettr,
d213 1
a213 1
			switch (nread = eread(fd, tp, nsegy)) {
d218 1
a218 1
					err("%s: %s #%ld", fgettr,
d225 2
a226 2
		     err("%s: %s: mysterious filetype trace #%ld",
							fgettr, __LINE__, itr);
d230 3
a232 5
			err("%s: on trace #%ld, %s (%d) %s (%d)", 
			     fgettr, itr,
			     "number of samples in header",
			     tp->ns,
			     "differs from number for first trace",
d238 1
a238 1
	return (int) nsegy;
@


1.3
log
@Changed a declaration to make ANSI C police happy.
@
text
@d1 1
a1 1
/* FGETTR: $Revision: 1.2 $; $Date: 90/09/03 09:59:00 $	*/
d20 2
a21 2
/* fgettr, fgettr1, fgettr2 - get a segy trace from a file by descriptor
 * gettr, gettr1, gettr2 - get a segy trace from stdin
d27 1
a27 1
 *	int fgettr(fd, tp)	for standard float traces
d30 1
a30 2
 *	int fgettr1(fd, tp)	for 1 byte traces as in suunpack1
 *	segy *tp;
a31 9
 *	int fgettr2(fd, tp)	for 2 byte traces as in suunpack2
 *	segy *tp;
 *
 *	gettr, gettr1 and gettr2 are implemented as macros in su.h:
 *
 *	gettr(tp)  is equivalent to fgettr(stdin, tp)
 *	gettr1(tp) is equivalent to fgettr1(stdin, tp)
 *	gettr2(tp) is equivalent to fgettr2(stdin, tp)
 *
a40 7
 * Notes:
 *	To avoid having to maintain nearly identical codes, we make
 *	three versions from this source code.  The "1" variant is for
 *      segy traces with char data, the "2" variant is for short data.
 *	Use the compile options -DGETTR, -DGETTR1, and -DGETTR2
 *	respectively, for the three versions.
 *
a47 1
 *
a50 15
#ifdef GETTR1
#define NAME		"fgettr1"
#define BYTESPER	sizeof(char)	/* bytes per input datum */
int fgettr1(int fd, segy *tp)
#endif

#ifdef GETTR2
#define NAME		"fgettr2"
#define BYTESPER	sizeof(short)	/* bytes per input datum */
int fgettr2(int fd, segy *tp)
#endif

#ifdef GETTR
#define NAME		"fgettr"
#define BYTESPER	sizeof(float)	/* bytes per input datum */
a51 3
#endif


d59 1
d71 1
a71 1
				err("%s: no traces", NAME);
d75 1
a75 1
					err("%s: %s %d > %d %s", NAME,
d79 5
d85 2
a86 2
					HDRBYTES + nsfirst * BYTESPER) {
					err("%s: %s", NAME,
d96 1
a96 1
				err("%s: no traces", NAME);
d99 1
a99 1
					err("%s: %s", NAME,
d107 1
a107 1
			    err("%s: %s %d>%d %s", NAME, "unable to handle",
a109 2
			nsegy = HDRBYTES + BYTESPER * nsfirst;
			ndata = BYTESPER * nsfirst;
d111 8
a118 2
			switch (nread =
				 pread(fd, tp->data, ndata)) {
d124 1
a124 1
				        NAME, "first pipetrace: read only",
d134 1
a134 1
				err("%s: no traces", NAME);
d137 1
a137 1
					err("%s: %s", NAME,
d146 1
a146 1
				err("%s: %s %d > %d %s", NAME,
d150 6
a155 1
			ndata = BYTESPER * nsfirst;
d161 1
a161 1
				err("%s: no data on first trace", NAME);
d165 1
a165 1
				        NAME, "first disktrace: read only",
d172 1
a172 1
			err("%s: stdin can't be tty", NAME);
d175 1
a175 1
						NAME, printstat(ftype));
d187 1
a187 1
					err("%s: %s #%ld", NAME,
d198 1
a198 1
					err("%s: %s #%ld", NAME,
d210 1
a210 1
					err("%s: %s #%ld", NAME,
d218 1
a218 1
							NAME, __LINE__, itr);
d223 1
a223 1
			     NAME, itr,
@


1.2
log
@Drop unnecessary casts in ANSI C system calls.
@
text
@d1 1
a1 1
/* FGETTR: $Revision: 1.1 $; $Date: 90/04/15 15:55:44 $	*/
d94 1
a94 1
	static uint nsegy; 	/* number of segy bytes from nsfirst	*/
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/* FGETTR: $Revision: 1.55 $; $Date: 89/05/25 16:10:09 $	*/
d104 1
a104 1
			switch (nsegy = eread(fd, (char *) tp, MAXSEGY)) {
d124 1
a124 1
			switch (nread = pread(fd,(char *) tp,(uint) HDRBYTES)) {
d144 1
a144 1
				 pread(fd, (char *) tp->data, ndata)) {
d158 1
a158 1
			switch (nread = eread(fd,(char*)tp,HDRBYTES)) {
d180 1
a180 1
			        eread(fd, (char *) tp->data, ndata)) {
d203 1
a203 1
			switch (nread = eread(fd, (char *)tp, nsegy)) {
d214 1
a214 1
			switch (nread = pread(fd, (char *) tp, nsegy)) {
d226 1
a226 1
			switch (nread = eread(fd, (char *)tp, nsegy)) {
@
