head	1.86;
access
	jkc
	cartley
	john;
symbols;
locks
	john:1.86; strict;
comment	@ * @;


1.86
date	2014.05.22.21.19.50;	author john;	state Exp;
branches;
next	1.85;

1.85
date	2011.12.21.23.15.01;	author john;	state Exp;
branches;
next	1.84;

1.84
date	2011.11.23.22.20.19;	author john;	state Exp;
branches;
next	1.83;

1.83
date	2011.10.20.21.04.48;	author john;	state Exp;
branches;
next	1.82;

1.82
date	2011.08.08.18.24.43;	author john;	state Exp;
branches;
next	1.81;

1.81
date	2011.02.22.16.58.38;	author john;	state Exp;
branches;
next	1.80;

1.80
date	2010.07.20.21.03.48;	author john;	state Exp;
branches;
next	1.79;

1.79
date	2010.03.22.18.29.59;	author john;	state Exp;
branches;
next	1.78;

1.78
date	2010.01.28.18.04.34;	author john;	state Exp;
branches;
next	1.77;

1.77
date	2010.01.25.17.38.34;	author john;	state Exp;
branches;
next	1.76;

1.76
date	2009.03.17.00.03.14;	author john;	state Exp;
branches;
next	1.75;

1.75
date	2008.11.06.23.35.32;	author john;	state Exp;
branches;
next	1.74;

1.74
date	2007.09.20.21.04.51;	author john;	state Exp;
branches;
next	1.73;

1.73
date	2007.05.17.17.52.05;	author john;	state Exp;
branches;
next	1.72;

1.72
date	2007.05.17.16.24.46;	author john;	state Exp;
branches;
next	1.71;

1.71
date	2007.02.20.17.58.50;	author john;	state Exp;
branches;
next	1.70;

1.70
date	2006.10.25.22.13.12;	author john;	state Exp;
branches;
next	1.69;

1.69
date	2006.10.25.22.09.26;	author john;	state Exp;
branches;
next	1.68;

1.68
date	2006.04.11.17.03.12;	author john;	state Exp;
branches;
next	1.67;

1.67
date	2005.12.20.23.07.08;	author john;	state Exp;
branches;
next	1.66;

1.66
date	2005.11.15.20.55.08;	author john;	state Exp;
branches;
next	1.65;

1.65
date	2005.02.03.21.39.28;	author john;	state Exp;
branches;
next	1.64;

1.64
date	2004.12.23.22.20.28;	author john;	state Exp;
branches;
next	1.63;

1.63
date	2003.11.18.20.46.03;	author john;	state Exp;
branches;
next	1.62;

1.62
date	2003.08.11.17.20.20;	author john;	state Exp;
branches;
next	1.61;

1.61
date	2003.08.11.17.19.40;	author john;	state Exp;
branches;
next	1.60;

1.60
date	2002.10.10.19.49.59;	author john;	state Exp;
branches;
next	1.59;

1.59
date	2001.05.16.15.50.45;	author john;	state Exp;
branches;
next	1.58;

1.58
date	2000.10.05.19.44.15;	author john;	state Exp;
branches;
next	1.57;

1.57
date	2000.03.01.21.04.24;	author john;	state Exp;
branches;
next	1.56;

1.56
date	98.12.15.16.22.54;	author john;	state Exp;
branches;
next	1.55;

1.55
date	98.08.31.21.12.09;	author john;	state Exp;
branches;
next	1.54;

1.54
date	98.08.27.20.11.36;	author john;	state Exp;
branches;
next	1.53;

1.53
date	98.08.21.18.44.13;	author john;	state Exp;
branches;
next	1.52;

1.52
date	98.04.06.15.47.12;	author john;	state Exp;
branches;
next	1.51;

1.51
date	98.03.31.17.11.12;	author john;	state Exp;
branches;
next	1.50;

1.50
date	97.07.16.14.59.50;	author john;	state Exp;
branches;
next	1.49;

1.49
date	97.05.16.20.14.00;	author john;	state Exp;
branches;
next	1.48;

1.48
date	97.05.16.20.06.45;	author jkc;	state Exp;
branches;
next	1.47;

1.47
date	96.04.17.17.25.55;	author john;	state Exp;
branches;
next	1.46;

1.46
date	95.10.27.16.03.04;	author john;	state Exp;
branches;
next	1.45;

1.45
date	95.08.06.17.35.09;	author jkc;	state Exp;
branches;
next	1.44;

1.44
date	95.06.05.10.06.47;	author john;	state Exp;
branches;
next	1.43;

1.43
date	95.04.03.10.48.05;	author john;	state Exp;
branches;
next	1.42;

1.42
date	94.09.14.12.55.08;	author john;	state Exp;
branches;
next	1.41;

1.41
date	94.09.14.12.37.31;	author john;	state Exp;
branches;
next	1.40;

1.40
date	94.09.14.11.22.38;	author john;	state Exp;
branches;
next	1.39;

1.39
date	94.09.06.14.55.00;	author john;	state Exp;
branches;
next	1.38;

1.38
date	94.06.23.14.57.21;	author jkc;	state Exp;
branches;
next	1.37;

1.37
date	94.06.17.15.11.26;	author john;	state Exp;
branches;
next	1.36;

1.36
date	94.04.12.09.45.42;	author jkc;	state Exp;
branches;
next	1.35;

1.35
date	94.04.12.09.39.39;	author john;	state Exp;
branches;
next	1.34;

1.34
date	94.03.03.15.01.30;	author john;	state Exp;
branches;
next	1.33;

1.33
date	94.03.03.14.07.58;	author john;	state Exp;
branches;
next	1.32;

1.32
date	94.03.02.10.08.51;	author john;	state Exp;
branches;
next	1.31;

1.31
date	94.02.03.10.47.56;	author john;	state Exp;
branches;
next	1.30;

1.30
date	94.01.31.10.57.16;	author john;	state Exp;
branches;
next	1.29;

1.29
date	94.01.28.15.10.09;	author jkc;	state Exp;
branches;
next	1.28;

1.28
date	93.12.15.10.53.07;	author john;	state Exp;
branches;
next	1.27;

1.27
date	93.12.14.15.41.39;	author john;	state Exp;
branches;
next	1.26;

1.26
date	93.05.10.10.16.03;	author john;	state Exp;
branches;
next	1.25;

1.25
date	92.12.08.09.46.16;	author john;	state Exp;
branches;
next	1.24;

1.24
date	92.12.01.15.27.02;	author john;	state Exp;
branches;
next	1.23;

1.23
date	92.06.10.13.43.19;	author john;	state Exp;
branches;
next	1.22;

1.22
date	91.10.24.16.34.14;	author dhale;	state Exp;
branches;
next	1.21;

1.21
date	91.10.22.08.26.54;	author jkc;	state Exp;
branches;
next	1.20;

1.20
date	91.09.06.14.01.53;	author dhale;	state Exp;
branches;
next	1.19;

1.19
date	91.09.04.13.22.34;	author jkcohen;	state Exp;
branches;
next	1.18;

1.18
date	91.06.07.11.41.33;	author dhale;	state Exp;
branches;
next	1.17;

1.17
date	91.02.02.14.48.21;	author jkc;	state Exp;
branches;
next	1.16;

1.16
date	91.01.10.08.38.55;	author jkc;	state Exp;
branches;
next	1.15;

1.15
date	91.01.10.08.21.40;	author jkc;	state Exp;
branches;
next	1.14;

1.14
date	90.08.11.11.25.35;	author dhale;	state Exp;
branches;
next	1.13;

1.13
date	90.08.11.11.07.14;	author dhale;	state Exp;
branches;
next	1.12;

1.12
date	90.08.06.04.19.50;	author dhale;	state Exp;
branches;
next	1.11;

1.11
date	90.07.27.14.01.57;	author jkc;	state Exp;
branches;
next	1.10;

1.10
date	90.07.05.10.49.10;	author dhale;	state Exp;
branches;
next	1.9;

1.9
date	90.06.06.16.48.29;	author dhale;	state Exp;
branches;
next	1.8;

1.8
date	90.05.30.13.18.44;	author dhale;	state Exp;
branches;
next	1.7;

1.7
date	90.05.09.21.43.23;	author jkc;	state Exp;
branches;
next	1.6;

1.6
date	90.04.26.07.28.18;	author dhale;	state Exp;
branches;
next	1.5;

1.5
date	90.04.24.14.51.58;	author jkc;	state Exp;
branches;
next	1.4;

1.4
date	90.04.21.12.35.24;	author jkc;	state Exp;
branches;
next	1.3;

1.3
date	90.04.19.21.35.09;	author jkc;	state Exp;
branches;
next	1.2;

1.2
date	90.04.19.21.31.53;	author jkc;	state Exp;
branches;
next	1.1;

1.1
date	90.04.01.09.24.29;	author jkc;	state Exp;
branches;
next	;


desc
@Include file for cwp top level.
@


1.86
log
@*** empty log message ***
@
text
@/* Copyright (c) Colorado School of Mines, 2011.*/
/* All rights reserved.                       */

/* cwp.h - include file for general purpose CWP stuff */

#ifndef CWP_H
#define CWP_H


/* INCLUDES */

#include <stdio.h>
#include <stddef.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>
#include <ctype.h>
#include <limits.h>
#include <float.h>

#include <fcntl.h>      /* non-ANSI */
#include <unistd.h>     /* non-ANSI */
#include <sys/types.h>  /* non-ANSI */

#ifdef CADDR_T_NOT_DEFINED
typedef char *          caddr_t;
#endif

/* TYPEDEFS */
typedef enum {cwp_false, cwp_true} cwp_Bool;
typedef char *cwp_String;

typedef enum {BADFILETYPE = -1,
        TTY, DISK, DIRECTORY, TAPE, PIPE, FIFO, SOCKET, SYMLINK} FileType;

#if defined(CRAY) || defined(OVERRIDE_CWP_COMPLEX)
typedef struct _complexStruct { /* complex number */
	float r,i;
}  cwp_complex;
typedef struct _dcomplexStruct { /* double-precision complex number */
	double r,i;
}  cwp_dcomplex;
#define complex cwp_complex
#define dcomplex cwp_dcomplex
#define cadd cwp_cadd
#define csub cwp_csub
#define cmul cwp_cmul
#define cdiv cwp_cdiv
#define rcabs cwp_rcabs
#define cmplx cwp_cmplx
#define conjg cwp_conjg
#define cneg cwp_cneg
#define cinv cwp_cinv
#define cwp_csqrt cwp_csqrt
#define cwp_cexp cwp_cexp
#define crmul cwp_crmul
#define cipow cwp_cipow
#define crpow cwp_crpow
#define rcpow cwp_rcpow
#define ccpow cwp_ccpow
#define cwp_ccos cwp_ccos
#define cwp_csin cwp_csin
#define cwp_ccosh cwp_ccosh
#define cwp_csinh cwp_csinh
#define cwp_cexp1 cwp_cexp1
#define cwp_clog cwp_clog

#else
 
#ifndef __cplusplus /* if not C++, define the C struct complex */
#ifndef complex
typedef struct _complexStruct { /* complex number */
	float r,i;
} complex;
#endif/* complex */

#ifndef dcomplex
typedef struct _dcomplexStruct { /* double-precision complex number */
	double r,i;
} dcomplex;
#endif/* dcomplex */

#else /* if C++, define the C++ class complex */
#include "Complex.h"

/**********Lines added  *******Daniel Tradd *******/ 
#ifndef dcomplex
typedef struct _dcomplexStruct { /* double-precision complex number */
        double r,i;
}  dcomplex;
#endif
/*******************************/
#endif /* C++ */

#endif

/* DEFINES */
/* uncomment the next block if you are installing */
/* under ultrix, but not using the GCC compiler */

/*
#ifdef ultrix
#define const
#endef
*/

/* CWP ENDIAN */
#ifdef CWP_BIG_ENDIAN
#define CWPENDIAN 1
#endif
#ifdef CWP_LITTLE_ENDIAN
#define CWPENDIAN 0
#endif


#ifndef NULL
#define NULL	((void *)0)
#endif
#ifndef EXIT_FAILURE
#define EXIT_FAILURE (1)
#endif
#ifndef EXIT_SUCCESS
#define EXIT_SUCCESS (0)
#endif
#ifndef SEEK_SET
#define SEEK_SET (0)
#endif
#ifndef SEEK_CUR
#define SEEK_CUR (1)
#endif
#ifndef SEEK_END
#define SEEK_END (2)
#endif
#ifndef PI
#define PI (3.141592653589793)
#endif
#ifndef D_PI 
#define D_PI (double) (3.1415926535897932385)
#endif
#ifndef GOLDEN_RATIO 
#define GOLDEN_RATIO (1.618034)   /* the golden ratio */
#endif
#ifndef TRUE
#define TRUE (1)
#endif
#ifndef FALSE
#define FALSE (0)
#endif
#ifndef YES
#define YES (1)
#endif
#ifndef NO
#define NO (0)
#endif
#ifndef SGN
#define SGN(x) ((x) < 0 ? -1.0 : 1.0)
#endif
#ifndef ABS
#define ABS(x) ((x) < 0 ? -(x) : (x))
#endif
#ifndef MAX
#define	MAX(x,y) ((x) > (y) ? (x) : (y))
#endif
#ifndef MIN
#define	MIN(x,y) ((x) < (y) ? (x) : (y))
#endif
#define NINT(x) ((int)((x)>0.0?(x)+0.5:(x)-0.5))
#define CLOSETO(x, y) ((ABS((x) - (y)) <= FLT_EPSILON*ABS(y))?cwp_true:cwp_false)
#define ISODD(n) ((n) & 01)
#define ISIZE sizeof(int)
#define FSIZE sizeof(float)
#define CSIZE sizeof(complex)
#define DSIZE sizeof(double)
#define	STREQ(s,t) (strcmp(s,t) == 0)
#define	STRLT(s,t) (strcmp(s,t) < 0)
#define	STRGT(s,t) (strcmp(s,t) > 0)
#define	DIM(a) (sizeof(a)/sizeof(a[0]))

#define SQR(x) ((x))*((x))

/* FUNCTION PROTOTYPES */

#ifdef __cplusplus /* if C++, specify external linkage to C functions */
extern "C" {
#endif

/* allocate and free multi-dimensional arrays */
void *alloc1 (size_t n1, size_t size);
void *realloc1 (void *v, size_t n1, size_t size);
void **alloc2 (size_t n1, size_t n2, size_t size);
void ***alloc3 (size_t n1, size_t n2, size_t n3, size_t size);
void ****alloc4 (size_t n1, size_t n2, size_t n3, size_t n4, size_t size);
void *****alloc5 (size_t n1, size_t n2, size_t n3, size_t n4, size_t n5, size_t size);
void ******alloc6 (size_t n1, size_t n2, size_t n3, size_t n4, size_t n5, size_t n6, 
                   size_t size);

void free1 (void *p);
void free2 (void **p);
void free3 (void ***p);
void free4 (void ****p);
void free5 (void *****p);
void free6 (void ******p);
int *alloc1int (size_t n1);
int *realloc1int (int *v, size_t n1);
int **alloc2int (size_t n1, size_t n2);
int ***alloc3int (size_t n1, size_t n2, size_t n3);
float *alloc1float (size_t n1);
float *realloc1float (float *v, size_t n1);
float **alloc2float (size_t n1, size_t n2);
float ***alloc3float (size_t n1, size_t n2, size_t n3);

float ****alloc4float (size_t n1, size_t n2, size_t n3, size_t n4);
void free4float (float ****p);
float *****alloc5float (size_t n1, size_t n2, size_t n3, size_t n4, size_t n5);
void free5float (float *****p);
float ******alloc6float (size_t n1, size_t n2, size_t n3, size_t n4, size_t n5, size_t n6);
void free6float (float ******p);
int ****alloc4int (size_t n1, size_t n2, size_t n3, size_t n4);
void free4int (int ****p);
int *****alloc5int (size_t n1, size_t n2, size_t n3, size_t n4, size_t n5);
void free5int (int *****p);
unsigned short ******alloc6ushort(size_t n1,size_t n2,size_t n3,size_t n4,
        size_t n5, size_t n6);
unsigned char *****alloc5uchar(size_t n1,size_t n2,size_t n3,size_t n4,
        size_t n5);
void free5uchar(unsigned char *****p);
unsigned short *****alloc5ushort(size_t n1,size_t n2,size_t n3,size_t n4,
        size_t n5);
void free5ushort(unsigned short *****p);
unsigned char ******alloc6uchar(size_t n1,size_t n2,size_t n3,size_t n4,
        size_t n5, size_t n6);
void free6uchar(unsigned char ******p);
unsigned short ******alloc6ushort(size_t n1,size_t n2,size_t n3,size_t n4,
        size_t n5, size_t n6);
void free6ushort(unsigned short ******p);

double *alloc1double (size_t n1);
double *realloc1double (double *v, size_t n1);
double **alloc2double (size_t n1, size_t n2);
double ***alloc3double (size_t n1, size_t n2, size_t n3);
complex *alloc1complex (size_t n1);
complex *realloc1complex (complex *v, size_t n1);
complex **alloc2complex (size_t n1, size_t n2);
complex ***alloc3complex (size_t n1, size_t n2, size_t n3);

dcomplex *alloc1dcomplex (size_t n1);
dcomplex *realloc1dcomplex (dcomplex *v, size_t n1);
dcomplex **alloc2dcomplex (size_t n1, size_t n2);
dcomplex ***alloc3dcomplex (size_t n1, size_t n2, size_t n3);

void free1int (int *p);
void free2int (int **p);
void free3int (int ***p);
void free1float (float *p);
void free2float (float **p);
void free3float (float ***p);

void free1double (double *p);
void free2double (double **p);
void free3double (double ***p);
void free1complex (complex *p);
void free2complex (complex **p);
void free3complex (complex ***p);

void free1dcomplex (dcomplex *p);
void free2dcomplex (dcomplex **p);
void free3dcomplex (dcomplex ***p);

#ifndef __cplusplus /* if not C++, declare C complex functions */
/* complex number manipulation */
complex cadd (complex a, complex b);
complex csub (complex a, complex b);
complex cmul (complex a, complex b);
complex cdiv (complex a, complex b);
float rcabs (complex z);
complex cmplx (float re, float im);
complex conjg (complex z);
complex cneg (complex z);
complex cinv (complex z);
complex cwp_csqrt (complex z);
complex cwp_cexp (complex z);
complex crmul (complex a, float x);

/* complex functions */
complex cipow(complex a, int p);
complex crpow(complex a, float p);
complex rcpow(float a, complex p);
complex ccpow (complex a, complex p);
complex cwp_ccos(complex a);
complex cwp_csin(complex a);
complex cwp_ccosh(complex a);
complex cwp_csinh(complex a);
complex cwp_cexp1(complex a);
complex cwp_clog(complex a);

/* double complex */
dcomplex dcadd (dcomplex a, dcomplex b);
dcomplex dcsub (dcomplex a, dcomplex b);
dcomplex dcmul (dcomplex a, dcomplex b);
dcomplex dcdiv (dcomplex a, dcomplex b);
double drcabs (dcomplex z);
dcomplex dcmplx (double re, double im);
dcomplex dconjg (dcomplex z);
dcomplex dcneg (dcomplex z);
dcomplex dcinv (dcomplex z);
dcomplex dcsqrt (dcomplex z);
dcomplex dcexp (dcomplex z);
dcomplex dcrmul (dcomplex a, double x);

/* double complex functions */
dcomplex dcipow(dcomplex a, int p);
dcomplex dcrpow(dcomplex a, float p);
dcomplex rdcpow(float a, dcomplex p);
dcomplex dcdcpow(dcomplex a, dcomplex p);
dcomplex dccos(dcomplex a);
dcomplex dcsin(dcomplex a);
dcomplex dccosh(dcomplex a);
dcomplex dcsinh(dcomplex a);
dcomplex dcexp1(dcomplex a);
dcomplex dclog(dcomplex a);

void chermite (int n, float x[], float y[], float yd[][4]);

#endif /* endif C++ */

/* big matrix handler */
void *bmalloc (int nbpe, int n1, int n2);
void bmfree (void *bm);
void bmread (void *bm, int dir, int k1, int k2, int n, void *v);
void bmwrite (void *bm, int dir, int k1, int k2, int n, void *v);

/* interpolation */
float fsinc (float x);
double dsinc (double x);
void mksinc (float d, int lsinc, float sinc[]);
void ints8r (int nxin, float dxin, float fxin, float yin[], 
	float yinl, float yinr, int nxout, float xout[], float yout[]);
void ints8c (int nxin, float dxin, float fxin, complex yin[], 
	complex yinl, complex yinr, int nxout, float xout[], complex yout[]);
void intt8r (int ntable, float table[][8],
	int nxin, float dxin, float fxin, float yin[], 
	float yinl, float yinr, int nxout, float xout[], float yout[]);
void intt8c (int ntable, float table[][8],
	int nxin, float dxin, float fxin, complex yin[], 
	complex yinl, complex yinr, int nxout, float xout[], complex yout[]);
void ress8r (int nxin, float dxin, float fxin, float yin[], 
	float yinl, float yinr, 
	int nxout, float dxout, float fxout, float yout[]);
void ress8c (int nxin, float dxin, float fxin, complex yin[], 
	complex yinl, complex yinr, 
	int nxout, float dxout, float fxout, complex yout[]);
void shfs8r (float dx, int nxin, float fxin, float yin[], 
	float yinl, float yinr, int nxout, float fxout, float yout[]);
void xindex (int nx, float ax[], float x, int *index);
void intl2b (int nxin, float dxin, float fxin,
	int nyin, float dyin, float fyin, unsigned char *zin,
	int nxout, float dxout, float fxout,
	int nyout, float dyout, float fyout, unsigned char *zout);
void intlin (int nin, float xin[], float yin[], float yinl, float yinr,
	int nout, float xout[], float yout[]);
void intcub (int ideriv, int nin, float xin[], float ydin[][4],
	int nout, float xout[], float yout[]);
void cakima (int n, float x[], float y[], float yd[][4]);
void cmonot (int n, float x[], float y[], float yd[][4]);
void csplin (int n, float x[], float y[], float yd[][4]);
void yxtoxy (int nx, float dx, float fx, float y[], 
	int ny, float dy, float fy, float xylo, float xyhi, float x[]);
void intlinc (int nin, float xin[], complex yin[], complex yinl, complex yinr,
        int nout, float xout[], complex yout[]);
void intlirr2b (int nxin, float *xin,
        int nyin, float dyin, float fyin, unsigned char *zin,
        int nxout, float dxout, float fxout,
        int nyout, float dyout, float fyout, unsigned char *zout);

void linear_regression(float *y, float *x, int n, float coeff[4]);

void linfit( float *x, float *y, int ndata, float *sig, int mwt,
          float *a, float *b, float *siga, float *sigb,
          float *chi2, float *q);

/* Butterworth filters */
void bfhighpass (int npoles, float f3db, int n, float p[], float q[]);
void bflowpass (int npoles, float f3db, int n, float p[], float q[]);
void bfdesign (float fpass, float apass, float fstop, float astop,
	int *npoles, float *f3db);

/* differentiator approximations */
void mkdiff (int n, float a, float h, int l, int m, float d[]);
void mkhdiff (float h, int l, float d[]);
void holbergd1 (float e, int n, float d[]);
void differentiate(int n, float h, float *f, float *fprime);
void ddifferentiate(int n, double h, double *f, double *fprime);


/* general signal processing */
void convolve_cwp (int lx, int ifx, float *x, int ly, int ify, float *y,
	int lz, int ifz, float *z);
void xcor (int lx, int ifx, float *x, int ly, int ify, float *y ,
	int lz, int ifz, float *z);
void hilbert (int n, float x[], float y[]);
void antialias (float frac, int phase, int n, float p[], float q[]);

/* max and min */
int max_index(int n, float *a,int inc);
int min_index(int n, float *a,int inc);


/* Abel transformer */
void *abelalloc (int n);
void abelfree (void *at);
void abel (void *at, float f[], float g[]);

/* Hankel transformer */
void *hankelalloc (int nfft);
void hankelfree (void *ht);
void hankel0 (void *ht, float f[], float h[]);
void hankel1 (void *ht, float f[], float h[]);

/* Hartley transforms */
void srfht(int *n, int *m, float *f);
void r4fht(int n, int m, float *f);
int nextpow2(int n);
int nextpow4(int n);

/* Hartley transforms (double precision) */
void dsrfht(int *n, int *m, double *f);


/* sorting and searching */
void hpsort (int n, float a[]);
void qksort (int n, float a[]);
void qkfind (int m, int n, float a[]);
void qkisort (int n, float a[], int i[]);
void qkifind (int m, int n, float a[], int i[]);

/* statistics */
float quest (float p, int n, float x[]);
void *questalloc (float p, int n, float x[]);
float questupdate (void *q, int n, float x[]);
void questfree (void *q);

/* PC byte swapping */
void swap_short_2(short *tni2);
void swap_u_short_2(unsigned short *tni2);
void swap_int_4(int *tni4);
void swap_u_int_4(unsigned int *tni4);
void swap_long_4(long *tni4);
void swap_u_long_4(unsigned long *tni4);
void swap_float_4(float *tnf4);
void swap_double_8(double *tndd8);

/* Phase unwrapping */
void oppenheim_unwrap_phase(int n, int trend, int zeromean,
                float df, float *xr, float *xi, float *phase);
void simple_unwrap_phase(int n, int trend, int zeromean, float w,
		float *phase);

/* Prime Factor FFTs */
int npfa (int nmin);
int npfao (int nmin, int nmax);
int npfar (int nmin);
int npfaro (int nmin, int nmax);
void pfacc (int isign, int n, complex z[]);
void pfarc (int isign, int n, float rz[], complex cz[]);
void pfacr (int isign, int n, complex cz[], float rz[]);
void pfa2cc (int isign, int idim, int n1, int n2, complex z[]);
void pfa2rc (int isign, int idim, int n1, int n2, float rz[], complex cz[]);
void pfa2cr (int isign, int idim, int n1, int n2, complex cz[], float rz[]);
void pfamcc (int isign, int n, int nt, int k, int kt, complex z[]);

/* Prime Factor FFTs (double version)*/
int npfa_d (int nmin);
int npfao_d (int nmin, int nmax);
int npfar_d (int nmin);
int npfaro_d (int nmin, int nmax);
void pfacc_d (int isign, int n, dcomplex z[]);
void pfacr_d (int isign, int n, dcomplex cz[], double rz[]);
void pfarc_d (int isign, int n, double rz[], dcomplex cz[]);
void pfamcc_d (int isign, int n, int nt, int k, int kt, dcomplex z[]);
void pfa2cc_d (int isign, int idim, int n1, int n2, dcomplex z[]);
void pfa2cr_d (int isign, int idim, int n1, int n2, dcomplex cz[],
double rz[]);
void pfa2rc_d (int isign, int idim, int n1, int n2, double rz[],
dcomplex cz[]);

/* BLAS (Basic Linear Algebra Subroutines adapted from LINPACK FORTRAN) */
int isamax (int n, float *sx, int incx);
float sasum (int n, float *sx, int incx);
void saxpy (int n, float sa, float *sx, int incx, float *sy, int incy);
void scopy (int n, float *sx, int incx, float *sy, int incy);
float sdot (int n, float *sx, int incx, float *sy, int incy);
float snrm2 (int n, float *sx, int incx);
void sscal (int n, float sa, float *sx, int incx);
void sswap (int n, float *sx, int incx, float *sy, int incy);
int idamax (int n, double *sx, int incx);
double dasum (int n, double *sx, int incx);
void daxpy (int n, double sa, double *sx, int incx, double *sy, int incy);
void dcopy (int n, double *sx, int incx, double *sy, int incy);
double ddot (int n, double *sx, int incx, double *sy, int incy);
double dnrm2 (int n, double *sx, int incx);
void dscal (int n, double sa, double *sx, int incx);
void dswap (int n, double *sx, int incx, double *sy, int incy);

/* LINPACK functions (adapted from LINPACK FORTRAN) */
void sgeco (float **a, int n, int *ipvt, float *rcond, float *z);
void sgefa (float **a, int n, int *ipvt, int *info);
void sgesl (float **a, int n, int *ipvt, float *b, int job);
void sqrdc (float **x, int n, int p, float *qraux, int *jpvt,
	float *work, int job);
void sqrsl (float **x, int n, int k, float *qraux,
	float *y, float *qy, float *qty,
	float *b, float *rsd, float *xb, int job, int *info);
void sqrst (float **x, int n, int p, float *y, float tol,
	float *b, float *rsd, int *k,
	int *jpvt, float *qraux, float *work);
void dgeco (double **a, int n, int *ipvt, double *rcond, double *z);
void dgefa (double **a, int n, int *ipvt, int *info);
void dgesl (double **a, int n, int *ipvt, double *b, int job);

/* other linear system solvers */
void stoepd (int n, double r[], double g[], double f[], double a[]);
void stoepf (int n, float r[], float g[], float f[], float a[]);
void vanded (int n, double v[], double b[], double x[]);
void vandef (int n, float v[], float b[], float x[]);
void tridif (int n, float a[], float b[], float c[], float r[], float u[]);
void tridid (int n, double a[], double b[], double c[], double r[], double u[]);
void tripd (float *d, float *e, float *b, int n);
void tripp (int n, float *d, float *e, float *c, float *b);

/* root finding */
int mnewt (int maxiter, float ftol, float dxtol, int n, float *x, void *aux,
            void (*fdfdx)(int n, float *x, float *f, float **dfdx, void *aux));

/* transform rectangular => polar and polar => to rectangular coordinates */
void recttopolar ( int nx, float dx, float fx, int ny, float dy,
	float fy, float **p, int na, float da, float fa, int nr, float dr,
	float fr, float **q);
void polartorect ( int na, float da, float fa, int nr, float dr,
	float fr, float **q, int nx, float dx, float fx, int ny, float dy,
	float fy, float **p);

/* graphics utilities */
void rfwtva (int n, float z[], float zmin, float zmax, float zbase,
	int yzmin, int yzmax, int xfirst, int xlast,
	int wiggle, int nbpr, unsigned char *bits, int endian);
void rfwtvaint (int n, float z[], float zmin, float zmax, float zbase,
	int yzmin, int yzmax, int xfirst, int xlast,
	int wiggle, int nbpr, unsigned char *bits, int endian);
void scaxis (float x1, float x2, int *nxnum, float *dxnum, float *fxnum);
int yclip (int nx, float dx, float fx, float y[], float ymin, float ymax,
	float xc[], float yc[]);

/* special functions */
float airya (float x);
float airyb (float x);
float airyap (float x);
float airybp (float x);

/* timers */
float cpusec (void);
float cputime (void);
float wallsec (void);
float walltime (void);

/* pseudo-random numbers */
float franuni (void);
void sranuni (int seed);
float frannor (void);
void srannor (int seed);


/* Ax=b routines */
void LU_decomposition (int nrows, float **matrix, int *index, float *d);
void backward_substitution (int nrows, float **matrix, int *index, float *b);
void inverse_matrix (int nrows, float **matrix);
void inverse_matrix_multiply (int nrows1, float **matrix1, int ncols2,
        int nrows2, float **matrix2, float **out_matrix);

/* singular value decomposition routines */
int compute_svd(float **a, int m, int n, float w[], float **v);
void svd_backsubstitute(float **u, float w[], float **v,
		int m, int n, float b[], float x[]);
void svd_sort(float **u, float *w, float **v, int n, int m);

/* symmetric matrix eigenvalue routines */
void eig_jacobi(float **a, float d[], float **v, int n);
void sort_eigenvalues(float d[], float **v, int n);


/* waveforms */
void ricker1_wavelet (int nt, float dt, float fpeak, float *wavelet);
void ricker2_wavelet (int hlw, float dt, float period, float ampl, 
	float distort, float *wavelet);
void akb_wavelet (int nt, float dt, float fpeak, float *wavelet);
void spike_wavelet (int nt, int tindex, float *wavelet);
void unit_wavelet (int nt, float *wavelet);
void zero_wavelet (int nt, float *wavelet);
void berlage_wavelet (int nt, float dt, float fpeak, float ampl, float tn, 
                       float decay, float ipa, float *wavelet);
void gaussian_wavelet (int nt, float dt, float fpeak, float *wavelet);
void gaussderiv_wavelet (int nt, float dt, float fpeak, float *wavelet);
void deriv_n_gauss(double dt, int nt, double t0, float fpeak, int n, double *w,
            int sign, int verbose);

/* orthogonal polynomials */
void
hermite_n_polynomial(double *h, double *h0, double *h1,
                                double *t, int nt, int n, double sigma);



/* windowing functions */
void hanningnWindow(int n, float *w);

/* wrap */
void wrapArray(void *base, size_t nmemb, size_t size, int f);


/* miscellaneous */
void pp1d (FILE *fp, char *title, int lx, int ifx, float x[]);
void pplot1 (FILE *fp, char *title, int nx, float ax[]);
FILE *temporary_stream (char const * prefix);
char *temporary_filename(char *prefix);
void zasc (char *ainput, char *aoutput, int nchar);
void zebc (char *ainput, char *aoutput, int nchar);
void IBMFLT(float *in, float *out, int *nwds, int *idirec);

dcomplex *alloc1dcomplex (size_t n1);
dcomplex *realloc1dcomplex (dcomplex *v, size_t n1);
dcomplex **alloc2dcomplex (size_t n1, size_t n2);
dcomplex ***alloc3dcomplex (size_t n1, size_t n2, size_t n3);

void free1dcomplex (dcomplex *p);
void free2dcomplex (dcomplex **p);
void free3dcomplex (dcomplex ***p);


/* Prime Factor FFTs (double version)*/
int npfa_d (int nmin);
int npfao_d (int nmin, int nmax);
int npfar_d (int nmin);
int npfaro_d (int nmin, int nmax);
void pfacc_d (int isign, int n, dcomplex z[]);
void pfacr_d (int isign, int n, dcomplex cz[], double rz[]);
void pfarc_d (int isign, int n, double rz[], dcomplex cz[]);
void pfamcc_d (int isign, int n, int nt, int k, int kt, dcomplex z[]);
void pfa2cc_d (int isign, int idim, int n1, int n2, dcomplex z[]);
void pfa2cr_d (int isign, int idim, int n1, int n2, dcomplex cz[],
double rz[]);
void pfa2rc_d (int isign, int idim, int n1, int n2, double rz[],
dcomplex cz[]);

dcomplex *alloc1dcomplex (size_t n1);
dcomplex *realloc1dcomplex (dcomplex *v, size_t n1);
dcomplex **alloc2dcomplex (size_t n1, size_t n2);
dcomplex ***alloc3dcomplex (size_t n1, size_t n2, size_t n3);

void free1dcomplex (dcomplex *p);
void free2dcomplex (dcomplex **p);
void free3dcomplex (dcomplex ***p);

/* Prime Factor FFTs (double version)*/
int npfa_d (int nmin);
int npfao_d (int nmin, int nmax);
int npfar_d (int nmin);
int npfaro_d (int nmin, int nmax);
void pfacc_d (int isign, int n, dcomplex z[]);
void pfacr_d (int isign, int n, dcomplex cz[], double rz[]);
void pfarc_d (int isign, int n, double rz[], dcomplex cz[]);
void pfamcc_d (int isign, int n, int nt, int k, int kt, dcomplex z[]);
void pfa2cc_d (int isign, int idim, int n1, int n2, dcomplex z[]);
void pfa2cr_d (int isign, int idim, int n1, int n2, dcomplex cz[],
double rz[]);
void pfa2rc_d (int isign, int idim, int n1, int n2, double rz[],
dcomplex cz[]);


/* string manipulation */
char *cwp_strdup(char *str);
void strchop(char *s, char *t);

/* if off_t, fseeko, and ftello not defined */
/* redefine these items back to the int, fseek, ftell */
#ifndef _LARGEFILE_SOURCE
#ifndef off_t
#define off_t long
#endif

#ifndef ftello
#define ftello ftell
#endif

#ifndef fseeko
#define fseeko fseek
#endif

#endif

/*--------------------------------------------------------------------*\
  Redefine things to get largefile support for Solaris 5.6 to work
  properly.  Sun didn't get this *quite* correct.

  Reginald H. Beardsley                            rhb@@acm.org
\*--------------------------------------------------------------------*/

#ifdef _LARGEFILE64_SOURCE	/* if the largefile source flag is set */


#define open  open64
#define creat creat64
#define lseek lseek64

#undef off_t
#define off_t long long

#define fstat fstat64
#define stat  stat64

#undef fseeko
#define fseeko fseeko64

#undef ftello
#define ftello ftello64

#ifndef fopen			/* trap for Sfio def */
#define fopen  fopen64
#endif
#ifndef freopen			/* trap for Sfio def */
#define freopen freopen64
#endif


#endif				/* end of largefile flag block */

/* exit function */
int CWP_Exit();

#ifdef __cplusplus /* if C++, end external linkage specification */

}
#endif


#endif /* CWP_H */
@


1.85
log
@Reg Beardsley's C99 upgrade of complex functions
@
text
@d30 7
a36 1
#ifdef CRAY
d172 1
d392 1
d396 1
a396 1
void conv (int lx, int ifx, float *x, int ly, int ify, float *y,
@


1.84
log
@removed m_unwrap phase, because it doesn't work
@
text
@d48 2
a49 2
#define csqrt cwp_csqrt
#define cexp cwp_cexp
d55 6
a60 6
#define ccos cwp_ccos
#define csin cwp_csin
#define ccosh cwp_ccosh
#define csinh cwp_csinh
#define cexp1 cwp_cexp1
#define clog cwp_clog
d273 2
a274 2
complex csqrt (complex z);
complex cexp (complex z);
d282 6
a287 6
complex ccos(complex a);
complex csin(complex a);
complex ccosh(complex a);
complex csinh(complex a);
complex cexp1(complex a);
complex clog(complex a);
@


1.83
log
@added copyright statement
@
text
@a448 2
void m_unwrap_phase(int n, float w, int trend, int zeromean,
                float df,  float *phase);
@


1.82
log
@8 august
@
text
@d1 3
@


1.81
log
@added unwrapping functions
\.
@
text
@d446 2
a447 1

@


1.80
log
@added temporary_stream
@
text
@d312 1
d381 2
d441 7
a475 1

@


1.79
log
@SQR macro defined
@
text
@d603 1
@


1.78
log
@added deriv_n_gauss and hermite_n_polynomial function prototypes.
@
text
@d169 1
@


1.77
log
@several Balazs Nemeth code prototypes
@
text
@d570 1
a570 1
/* wavelets */
d582 9
@


1.76
log
@added a function prototype for intlirr2b
added ifndef.... _LARGEFILE_SOURCE endif  Marc Langlois
@
text
@d365 4
d388 5
d583 5
d647 1
@


1.75
log
@*** empty log message ***
@
text
@d358 5
d639 1
d652 2
@


1.74
log
@John Gravley's changes
@
text
@d546 1
a546 1
void compute_svd(float **a, int m, int n, float w[], float **v);
@


1.73
log
@function prototype for cwp_strrev added
@
text
@d10 1
a11 1
#include <stddef.h>
a17 1

a574 1
char *cwp_tmpnam(char *s);
a629 1
char *cwp_strrev(char *str);
a631 1

d672 1
d674 2
d677 1
@


1.72
log
@function prototype for cwp_tmpnam
@
text
@d632 1
@


1.71
log
@added gaussian_wavelet and gaussian_derivative wavelets
@
text
@d10 1
a11 1
#include <stdlib.h>
d18 1
d576 1
d634 1
@


1.70
log
@waveform -> wavelet
@
text
@d566 3
@


1.69
log
@wavelet -> waveform
@
text
@d556 10
a565 10
/* waveforms */
void ricker1_waveform (int nt, float dt, float fpeak, float *waveform);
void ricker2_waveform (int hlw, float dt, float period, float ampl, 
	float distort, float *waveform);
void akb_waveform (int nt, float dt, float fpeak, float *waveform);
void spike_waveform (int nt, int tindex, float *waveform);
void unit_waveform (int nt, float *waveform);
void zero_waveform (int nt, float *waveform);
void berlage_waveform (int nt, float dt, float fpeak, float ampl, float tn, 
                       float decay, float ipa, float *waveform);
@


1.68
log
@werner heigl's hartley transform stuff
@
text
@d557 10
a566 7
void ricker1_wavelet (int nt, float dt, float fpeak, float *wavelet);
void ricker2_wavelet (int hlw, float dt, float period, float ampl, 
	float distort, float *wavelet);
void akb_wavelet (int nt, float dt, float fpeak, float *wavelet);
void spike_wavelet (int nt, int tindex, float *wavelet);
void unit_wavelet (int nt, float *wavelet);
void zero_wavelet (int nt, float *wavelet);
@


1.67
log
@changed svd definition
@
text
@d390 10
@


1.66
log
@added a couple of offt items
@
text
@d539 1
@


1.65
log
@retreated to   long long as the 64 bit definition of off_t
for large files
@
text
@a643 1
#ifndef _GNU_SOURCE
a644 16
#else
#define off_t long long
/* 
JWS - 3 Feb. I tried  putting in 

#define off_t off64_t

here as a substitute for 'long long' to squash C89 compiler warnings
about 'long long' not being defined. 
However, there is no    unsigned off64_t   so I am back to using
long long.  The C9X committee has ruled that types
'long long' and 'unsigned long long' will be types in C9X so
I figure that the warnings will eventually go away on their own.
*/

#endif
@


1.64
log
@added entries for linear_regression, eig_jacobi and sort_eigenvalues
@
text
@d638 1
d644 3
d648 15
d675 1
@


1.63
log
@*** empty log message ***
@
text
@d358 1
d539 5
@


1.62
log
@added Reg Beardsley's fixes.
@
text
@d624 1
a624 1
  Redefine things to get largfile support for Solaris 5.6 to work
d630 1
a630 1
#ifdef _LARGEFILE64_SOURCE
d650 2
a651 1
#endif
@


1.61
log
@*** empty log message ***
@
text
@d623 28
@


1.60
log
@*** empty log message ***
@
text
@d76 8
d128 3
d356 2
d535 2
a536 2
void svdcmp(float **a, int m, int n, float w[], float **v);
void svbksb(float **u, float w[], float **v,
@


1.59
log
@new strings subroutines
@
text
@d288 13
d595 17
@


1.58
log
@added prototypes for cwp_strdup
@
text
@d580 2
a581 1
char * cwp_strdup(char *str);
@


1.57
log
@caddr_t svd stuff
@
text
@d120 3
d578 3
@


1.56
log
@added Han's updates for double complex
@
text
@d18 6
a23 2
#ifdef HAVE_UNISTD_H
#include <unistd.h>
a79 6
/* in case caddr_t is not defined */
#ifndef _CADDR_T
#define _CADDR_T
typedef char * 		caddr_t;
#endif

d505 5
d535 1
@


1.55
log
@added prototype for tripp
@
text
@a173 1

d222 6
d242 4
d273 14
d398 16
d524 48
d573 1
d576 1
@


1.54
log
@removed REDHAT fix
@
text
@d416 2
a417 1
void tripd(float *d, float *e, float *b, int n);
d421 1
a421 1
	void (*fdfdx)(int n, float *x, float *f, float **dfdx, void *aux));
@


1.53
log
@added patch for RED_HAT systems
@
text
@a22 4
#ifdef REDHAT
typedef char * caddr_t;
#endif

@


1.52
log
@added John Anderson'
s changes
@
text
@d23 3
d78 6
@


1.51
log
@added John Anderson's fixes
@
text
@d166 3
d175 1
d189 2
d195 2
d203 6
@


1.50
log
@added Stew Levin's items
@
text
@d18 3
d23 34
d75 1
d192 3
d463 1
a463 3
#ifdef _CRAYMPP
void IBMFLT (float *in, float *out, short *nwds, short *idirec);
#endif
@


1.49
log
@added Zhaobo Meng's alloc4 and alloc5 additions
@
text
@d104 1
a104 1
#define CLOSETO(x, y) (ABS((x) - (y)) <= FLT_EPSILON*ABS(y))
d420 5
@


1.48
log
@temoary_filename prototype.
@
text
@d127 2
d133 1
d142 13
d169 1
@


1.47
log
@added axb, complex function, and waveform prototypes
@
text
@d402 1
@


1.46
log
@added function prototype for rfwtvaint
@
text
@d174 14
a187 1
#endif /* C++ */
d381 17
@


1.45
log
@Protect complex and dcomplex with ifndefs.  Thx Stew Levin.
@
text
@d344 3
@


1.44
log
@updated endian handling
@
text
@d22 1
d26 1
d28 1
d32 1
@


1.43
log
@added dcomplex type
@
text
@d45 9
d339 1
a339 1
	int wiggle, int nbpr, unsigned char *bits);
@


1.42
log
@added function prototype for swap_u_int_4
@
text
@d25 5
@


1.41
log
@added swap_int prototype.
@
text
@d247 2
a249 1
void swap_int_4(int *tni4);
@


1.40
log
@fixed ifdef thing.
@
text
@d248 1
@


1.39
log
@slight change on the ultrix ifdef
@
text
@d31 4
a34 2
/* for DEC STATIONS, const qualifier not implemented */
/* however, with GNU C compiler it is */
a35 2
#ifndef __GNUC__   /* added by swatson@@ultrix5.cs.csubak.edu to make gcc work
*/
d37 1
a37 1
#endef __GNUC__    /* added by swatson@@ultrix5.cs.csubak.edu to make gcc work
a38 1
#endif ultrix
@


1.38
log
@fccabs -> rcabs
@
text
@a30 1

d32 1
d34 2
d37 3
a39 1
#endif
@


1.37
log
@changed fcabs fccabs
@
text
@d145 1
a145 1
float fccabs (complex z);
@


1.36
log
@Added fseek macros with the ifndef bit for Sun 2's and maybe others.
@
text
@d145 1
a145 1
float fcabs (complex z);
@


1.35
log
@added prototypes for new tridiagonal solvers
.,
@
text
@d46 9
@


1.34
log
@removed static
@
text
@d293 2
@


1.33
log
@added recttopolar polartorect
@
text
@d299 1
a299 1
static void recttopolar ( int nx, float dx, float fx, int ny, float dy,
d302 1
a302 1
static void polartorect ( int na, float da, float fa, int nr, float dr,
@


1.32
log
@put a  void on swap_double_8
@
text
@d298 8
@


1.31
log
@added swaps for unsigned short and unsigned long
@
text
@d238 1
a238 1
void swap_double_8(double *tnd8);
@


1.30
log
@added byte swapping prototypes
@
text
@d234 1
d236 1
@


1.29
log
@Added conditional defines for NULL, EXIT_SUCCESS and EXIT_FAILURE for
portability.
@
text
@d232 6
@


1.28
log
@retreat to 1.26
@
text
@a5 4
/* for DEC STATIONS, const qualifier not implemented */
#ifdef ultrix
#define const
#endif
d32 14
@


1.27
log
@added CWP_ENDIAN define
@
text
@a10 4
/*#define CWP_ENDIAN 0 for DEC and PC's */
/* big endian machines, IBM RS6000, SUN, HP, etc. use default */
#define CWP_ENDIAN 1

@


1.26
log
@kludge for DEC STATION added
@
text
@d11 4
@


1.25
log
@made protypes for conv and xcor consistent with conv.c and xcor.c
@
text
@d6 4
@


1.24
log
@removed CWPBIN definition
@
text
@d187 4
a190 4
void conv (int lx, int ifx, float x[], int ly, int ify, float y[],
	int lz, int ifz, float z[]);
void xcor (int lx, int ifx, float x[], int ly, int ify, float y[],
	int lz, int ifz, float z[]);
@


1.23
log
@changed CWPBIN to /usr/local/cwp/bin
@
text
@a6 4
/* The bin directory--$B in the Makefiles--check when porting */
#define	CWPBIN	"/usr/local/cwp/bin"


@


1.22
log
@added missing prototype for conjg function
@
text
@d8 1
a8 1
#define	CWPBIN	"/usr/local/bin"
@


1.21
log
@Revised CLOSETO macro to do RELATIVE instead of abolute comparison.
@
text
@d128 1
@


1.20
log
@Numerous changes, primarily eliminated typedefs that users of libcwp
should not see or depend on - bmstate, QuestState are now gone.
@
text
@d64 1
a64 1
#define CLOSETO(x, y) (ABS((x) - (y)) <= FLT_EPSILON)
@


1.19
log
@Take out a bucnh of typedefs, defines that belong at a lower
level or in the garbage can.  Remove non-ansi includes.
@
text
@a32 8
typedef struct _bmstateStruct { /* big matrix state */
	int l1,l2,m1,m2,nbpe;
	char *p;
} bmstate;
typedef struct _QuestStateStruct { /* quantile estimator state */
	int m0,m1,m2,m3,m4;
	float q0,q1,q2,q3,q4,f0,f1,f2,f3,f4,d0,d1,d2,d3,d4;
} QuestState;
a33 1

d136 4
a139 4
bmstate *bmalloc (int nbpe, int n1, int n2);
void bmfree (bmstate *state);
void bmread (bmstate *state, int dir, int k1, int k2, int n, void *v);
void bmwrite (bmstate *state, int dir, int k1, int k2, int n, void *v);
d217 3
a219 2
QuestState *questinit (float p, int n, float x[]);
float questupdate (QuestState *state, int n, float x[]);
@


1.18
log
@added prototypes for airyap, airybp, holbergd1, and mnewt
@
text
@d8 1
a8 1
#define	CWPBIN	"/usr/local/cwp/bin"
a18 1
#include <fcntl.h>
a20 1
#include <sys/types.h>
a24 5
typedef char *string;
typedef enum {false, true} bool;
typedef enum {BADFILETYPE = -1,
	TTY, DISK, DIRECTORY, TAPE, PIPE, FIFO, SOCKET, SYMLINK} filetype;

a40 22
typedef union { /* pointer to arbitrary type */
	char *s;
	short *h;
	unsigned short *u;
	long *l;
	unsigned long *v;
	int *i;
	unsigned int *p;
	float *f;
	double *d;
} mixed;
typedef union { /* storage for arbitrary type */
	char s[8];
	short h;
	unsigned short u;
	long l;
	unsigned long v;
	int i;
	unsigned int p;
	float f;
	double d;
} value;
d54 1
d56 2
d59 2
a60 16
#define STDIN (0)
#define STDOUT (1)
#define STDERR (2)
#define	EOL ('\n')
#define	EOS ('\0')
#define	EOP ('\014')
#define ISIZE sizeof(int)
#define FSIZE sizeof(float)
#define DSIZE sizeof(double)
#define PISIZE sizeof(int *)
#define PFSIZE sizeof(float *)
#define PDSIZE sizeof(double *)
#define NALLOC	(524288)
#define NFALLOC	(NALLOC/FSIZE)
#define NIALLOC	(NALLOC/ISIZE)
#define NDALLOC	(NALLOC/DSIZE)
d62 2
d65 7
a73 2
#define	MAX(x,y) ((x) > (y) ? (x) : (y))
#define	MIN(x,y) ((x) < (y) ? (x) : (y))
d75 3
a77 1
#define IN_RANGE(n,lo,hi) ((lo) <= (n) && (n) <= (hi))
a81 8
#define	LOOPDN(r,n) for ((r) = (n)+1; --(r)) > 0; )
#define	LOOPDN2(r,n,j) for ((r) = (n) + (j); ((r) -= (j)) > 0; )
#define LOWBYTE(w) ((w) & 0xFF)
#define HIGHBYTE(w) LOWBYTE((w) >>8)
#define LOWWORD(w) ((w) & 0xFFFF)
#define HIGHWORD(w) LOWWORD((w) >>16)
#define ISNEGCHAR(c) ((c) & 0x80)
#define SIGNEXTEND(c) (~0xFF | (int) (c))
a315 11
filetype filestat(int fd);
string printstat(int fd);


/* EXTERNS - for compatibility with some older programs till updated */
/* Zero-based vector and matrix allocation */
extern float *vec(), *re_vec(), **mat();
extern int *ivec(), *re_ivec(), **imat();
extern double *dvec(), *re_dvec(), **dmat();
extern void free_vec(), free_ivec(), free_dvec();
extern void free_mat(), free_imat(), free_dmat();
@


1.17
log
@Updated CWPBIN (sigh).
@
text
@d235 1
d322 4
d337 2
@


1.16
log
@Typo
@
text
@d8 1
a8 1
#define	CWPBIN	"/usr/local/bin"
@


1.15
log
@Added new filetypes
@
text
@d30 1
a30 1
	TTY, DISK, DIRECTORY, TAPE, PIPE, FIFO, SOCKET, SYMLINK}, filetype;
@


1.14
log
@modified to #include "Complex.h", if C++, so that declarations
of complex* alloc1complex(), and other such functions will work.
@
text
@d29 2
a30 1
typedef enum {BADFILETYPE = -1, TTY, DISK, DIRECTORY, TAPE, PIPE} filetype;
@


1.13
log
@modified to not include Complex.h; users must now include Complex.h
explicitly, if C++ class complex is desired.  Also, declared
cadd(), cmul(), etc. only if not C++, since these C functions
don't work with C++ class complex.
@
text
@d35 2
@


1.12
log
@Modified for C++, including use of class complex.
@
text
@d31 1
a31 3
#ifdef __cplusplus /* if C++, define the C++ class complex */
#include "Complex.h"
#else /* else, if not C++, define the C struct complex */
d165 1
d178 1
@


1.11
log
@Added cputime, walltime
@
text
@d30 4
d37 2
d72 2
a73 1
 
d75 1
d124 4
d332 1
a333 1
float cputime (void);
d356 4
@


1.10
log
@no change
@
text
@d321 2
@


1.9
log
@added function prototypes for ress8r.c ress8c.c antialias.c abel.c hankel.c.
@
text
@@


1.8
log
@changed arguments to intl2b from signed char to unsigned char
@
text
@d188 6
d227 12
@


1.7
log
@Add CLOSETO macro
@
text
@d192 1
a192 1
	int nyin, float dyin, float fyin, signed char *zin,
d194 1
a194 1
	int nyout, float dyout, float fyout, signed char *zout);
@


1.6
log
@Added function cinv().
@
text
@d95 1
@


1.5
log
@z -> d for doubles
@
text
@d162 1
a162 1
complex conjg (complex z);
@


1.4
log
@added realloc1 routines
@
text
@d50 1
a50 1
	double *z;
d61 1
a61 1
	double z;
@


1.3
log
@Added CWPBIN, NALLOC
@
text
@a104 2
/* Do NOT use next two to extract major & minor numbers if sys/types.h has
   major(x), minor(x) might also in places like <sys/param.h>, <sysmacros.h> */
d107 2
d117 1
d126 1
d130 1
d134 1
d138 1
@


1.2
log
@Dropped some detritus.c
@
text
@d7 4
d88 4
@


1.1
log
@Initial revision
@
text
@a69 2
#define SUCCEED (0)
#define FAIL (1)
a96 8
/* st is the structure tag or typedef, m is the field
 * To use, define the variable _aligned (cf. portdefs.h) as:
 * static STRICT_ALIGN _aligned = 0; */
#define	OFFSET(st,m) ((char*) &((st*)&_aligned)->m - (char*)(st*)&_aligned)
/* Your stddef.h may define an offsetof macro for the same purpose. */
/* an alternative, used by the X Windows Intrinsics macro XtOffset */
#define OFFFLD(type,field) \
    ((unsigned int) (((char*) (& (((type) NULL)->field))) - ((char *) NULL)))
a102 1
#define GMALLOC(n,type) (type*)malloc(n*sizeof(type))
d287 2
a288 2
float cpusec ();
float wallsec ();
d299 2
@
