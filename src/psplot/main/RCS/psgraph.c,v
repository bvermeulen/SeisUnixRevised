head	1.40;
access;
symbols;
locks; strict;
comment	@ * @;


1.40
date	2011.11.17.00.10.53;	author john;	state Exp;
branches;
next	1.39;

1.39
date	2007.11.16.19.23.28;	author john;	state Exp;
branches;
next	1.38;

1.38
date	2003.04.30.21.14.45;	author john;	state Exp;
branches;
next	1.37;

1.37
date	2003.02.26.16.57.15;	author john;	state Exp;
branches;
next	1.36;

1.36
date	98.08.04.16.43.35;	author john;	state Exp;
branches;
next	1.35;

1.35
date	97.03.28.18.34.46;	author john;	state Exp;
branches;
next	1.34;

1.34
date	96.09.16.16.17.16;	author john;	state Exp;
branches;
next	1.33;

1.33
date	96.03.18.21.21.00;	author jkc;	state Exp;
branches;
next	1.32;

1.32
date	95.06.28.21.01.14;	author jkc;	state Exp;
branches;
next	1.31;

1.31
date	95.06.28.15.50.00;	author jkc;	state Exp;
branches;
next	1.30;

1.30
date	94.11.16.14.10.40;	author john;	state Exp;
branches;
next	1.29;

1.29
date	93.12.17.15.48.02;	author cartley;	state Exp;
branches;
next	1.28;

1.28
date	93.04.06.15.45.02;	author cartley;	state Exp;
branches;
next	1.27;

1.27
date	93.03.15.13.34.57;	author cartley;	state Exp;
branches;
next	1.26;

1.26
date	93.02.16.14.41.06;	author john;	state Exp;
branches;
next	1.25;

1.25
date	93.01.05.09.06.11;	author john;	state Exp;
branches;
next	1.24;

1.24
date	92.10.28.15.39.57;	author john;	state Exp;
branches;
next	1.23;

1.23
date	92.10.28.15.08.03;	author john;	state Exp;
branches;
next	1.22;

1.22
date	92.10.28.08.46.18;	author john;	state Exp;
branches;
next	1.21;

1.21
date	92.08.21.08.49.41;	author john;	state Exp;
branches;
next	1.20;

1.20
date	91.11.05.07.33.35;	author dhale;	state Exp;
branches;
next	1.19;

1.19
date	91.10.22.14.50.50;	author jkc;	state Exp;
branches;
next	1.18;

1.18
date	91.09.12.15.11.30;	author cartley;	state Exp;
branches;
next	1.17;

1.17
date	91.09.09.14.29.43;	author cartley;	state Exp;
branches;
next	1.16;

1.16
date	91.09.04.10.34.50;	author cartley;	state Exp;
branches;
next	1.15;

1.15
date	91.09.02.16.42.54;	author jkcohen;	state Exp;
branches;
next	1.14;

1.14
date	91.06.25.15.25.07;	author jkcohen;	state Exp;
branches;
next	1.13;

1.13
date	91.06.14.20.03.12;	author jkc;	state Exp;
branches;
next	1.12;

1.12
date	91.06.07.11.58.27;	author dhale;	state Exp;
branches;
next	1.11;

1.11
date	91.02.21.14.51.35;	author cartley;	state Exp;
branches;
next	1.10;

1.10
date	91.02.18.16.59.28;	author cartley;	state Exp;
branches;
next	1.9;

1.9
date	91.01.23.16.28.33;	author jkc;	state Exp;
branches;
next	1.8;

1.8
date	91.01.23.13.20.32;	author jkc;	state Exp;
branches;
next	1.7;

1.7
date	91.01.23.13.10.31;	author jkc;	state Exp;
branches;
next	1.6;

1.6
date	91.01.22.16.50.13;	author jkc;	state Exp;
branches;
next	1.5;

1.5
date	90.12.08.10.20.50;	author cartley;	state Exp;
branches;
next	1.4;

1.4
date	90.12.08.09.49.55;	author cartley;	state Exp;
branches;
next	1.3;

1.3
date	90.11.20.12.30.18;	author jkc;	state Exp;
branches;
next	1.2;

1.2
date	90.11.07.14.09.46;	author dhale;	state Exp;
branches;
next	1.1;

1.1
date	90.11.07.14.08.28;	author dhale;	state Exp;
branches;
next	;


desc
@PostScript graphs of functions y(x)
@


1.40
log
@added Reg Beardsley's checkpar() and copyright statements
@
text
@/* Copyright (c) Colorado School of Mines, 2011.*/
/* All rights reserved.                       */

/* PSGRAPH: $Revision: 1.39 $ ; $Date: 2007/11/16 19:23:28 $	*/

#include "par.h"
#include "psplot.h"

/*********************** self documentation **********************/
char *sdoc[] = {
"									",
" PSGRAPH - PostScript GRAPHer						",
" Graphs n[i] pairs of (x,y) coordinates, for i = 1 to nplot.		",
"									",
" psgraph n= [optional parameters] <binaryfile >postscriptfile		",
"									",
" Required Parameters:							",
" n                      array containing number of points per plot	",
"									",
" Data formats supported:						",
"	1.a. x1,y1,x2,y2,...,xn,yn					",
"	  b. x1,x2,...,xn,y1,y2,...,yn (must set pairs=0)		",
"	2.   y1,y2,...,yn (must give non-zero d1[]=)			",
"	3.   x1,x2,...,xn (must give non-zero d2[]=)			",
"	4.   nil (must give non-zero d1[]= and non-zero d2[]=)		",
"  The formats may be repeated and mixed in any order, but if		",
"  formats 2-4 are used, the d1 and d2 arrays must be specified including",
"  d1[]=0.0 d2[]=0.0 entries for any internal occurences of format 1.	",
"  Similarly, the pairs array must contain place-keeping entries for	",
"  plots of formats 2-4 if they are mixed with both formats 1.a and 1.b.",
"  Also, if formats 2-4 are used with non-zero f1[] or f2[] entries, then",
"  the corresponding array(s) must be fully specified including f1[]=0.0",
"  and/or f2[]=0.0 entries for any internal occurences of format 1 or	",
"  formats 2-4 where the zero entries are desired.			",
"									",
"  Available colors are all the common ones and many more. The complete	",
"  list of 68 colors is in the file $CWPROOT/src/psplot/basic.c.	",
"									",
" Optional Parameters:							",
" nplot=number of n's    number of plots				",
" d1=0.0,...             x sampling intervals (0.0 if x coordinates input)",
" f1=0.0,...             first x values (not used if x coordinates input)",
" d2=0.0,...             y sampling intervals (0.0 if y coordinates input)",
" f2=0.0,...             first y values (not used if y coordinates input)",
" pairs=1,...            =1 for data pairs in format 1.a, =0 for format 1.b",
" linewidth=1.0,...      line widths (in points) (0.0 for no lines)	",
" linegray=0.0,...       line gray levels (black=0.0 to white=1.0)	",
" linecolor=none,...     line colors; none means use linegray		",
"                        Typical use: linecolor=red,yellow,blue,...	",
" lineon=1.0,...         length of line segments for dashed lines (in points)",
" lineoff=0.0,...        spacing between dashes (0.0 for solid line)	",
" mark=0,1,2,3,...       indices of marks used to represent plotted points",
" marksize=0.0,0.0,...   size of marks (0.0 for no marks)		",
" xbox=1.5               offset in inches of left side of axes box	",
" ybox=1.5               offset in inches of bottom side of axes box	",
" wbox=6.0               width in inches of axes box			",
" hbox=8.0               height in inches of axes box			",
" x1beg=x1min            value at which axis 1 begins			",
" x1end=x1max            value at which axis 1 ends			",
" d1num=0.0              numbered tic interval on axis 1 (0.0 for automatic)",
" f1num=x1min            first numbered tic on axis 1 (used if d1num not 0.0)",
" n1tic=1                number of tics per numbered tic on axis 1	",
" grid1=none             grid lines on axis 1 - none, dot, dash, or solid",
" label1=                label on axis 1				",
" x2beg=x2min            value at which axis 2 begins			",
" x2end=x2max            value at which axis 2 ends			",
" d2num=0.0              numbered tic interval on axis 2 (0.0 for automatic)",
" f2num=x2min            first numbered tic on axis 2 (used if d2num not 0.0)",
" n2tic=1                number of tics per numbered tic on axis 2	",
" grid2=none             grid lines on axis 2 - none, dot, dash, or solid",
" label2=                label on axis 2				",
" labelfont=Helvetica    font name for axes labels			",
" labelsize=18           font size for axes labels			",
" title=                 title of plot					",
" titlefont=Helvetica-Bold font name for title				",
" titlesize=24           font size for title				",
" titlecolor=black       color of title					",
" axescolor=black        color of axes					",
" gridcolor=black        color of grid					",
" axeswidth=1            width (in points) of axes			",
" ticwidth=axeswidth     width (in points) of tic marks		",
" gridwidth=axeswidth    width (in points) of grid lines		",
" style=normal           normal (axis 1 horizontal, axis 2 vertical) or	",
"                        seismic (axis 1 vertical, axis 2 horizontal)	",
" reverse=0              =1 to reverse sequence of plotting curves      ",             /* JGHACK */
" Note:	n1 and n2 are acceptable aliases for n and nplot, respectively.	",
"									",
" mark index:                                                           ",
" 1. asterisk                                                           ",
" 2. x-cross                                                            ",
" 3. open triangle                                                      ",
" 4. open square                                                        ",
" 5. open circle                                                        ",
" 6. solid triangle                                                     ",
" 7. solid square                                                       ",
" 8. solid circle                                                       ",
"									",
" All color specifications may also be made in X Window style Hex format",
" example:   axescolor=#255						",
"									",
" Example:								",
" psgraph n=50,100,20 d1=2.5,1,0.33 <datafile >psfile			",
"  plots three curves with equally spaced x values in one plot frame	",
"  x1-coordinates are x1(i) = f1+i*d1 for i = 1 to n (f1=0 by default)	",
"  number of x2's and then x2-coordinates for each curve are read	",
"  sequentially from datafile.						",
"									",
" Legal font names are:							",
" AvantGarde-Book AvantGarde-BookOblique AvantGarde-Demi AvantGarde-DemiOblique"
" Bookman-Demi Bookman-DemiItalic Bookman-Light Bookman-LightItalic ",
" Courier Courier-Bold Courier-BoldOblique Courier-Oblique ",
" Helvetica Helvetica-Bold Helvetica-BoldOblique Helvetica-Oblique ",
" Helvetica-Narrow Helvetica-Narrow-Bold Helvetica-Narrow-BoldOblique ",
" Helvetica-Narrow-Oblique NewCentrySchlbk-Bold"
" NewCenturySchlbk-BoldItalic NewCenturySchlbk-Roman Palatino-Bold  ",
" Palatino-BoldItalic Palatino-Italics Palatino-Roman ",
" SanSerif-Bold SanSerif-BoldItalic SanSerif-Roman ",
" Symbol Times-Bold Times-BoldItalic ",
" Times-Roman Times-Italic ZapfChancery-MediumItalic ",
NULL};
/**************** end self doc ********************************/

/*
AUTHOR:  Dave Hale, Colorado School of Mines, 05/29/90
MODIFIED:  Jack K. Cohen 11/23/90 for different input data format
MODIFIED:  Lydia Deng 06/07/91 for dashed lines
MODIFIED:  Craig Artley, Colorado School of Mines, 08/30/91
           BoundingBox moved to top of PostScript output
           Added optional paired data sub-format
MODIFIED:  Dave Hale, Colorado School of Mines, 11/05/91
           Set PostScript line join to always use beveled joins.
MODIFIED:  John Stockwell, CSM, 21 August 1992, removed the info
	   in this comment block from the selfdoc to prevent sdoc
	   overflow error.
MODIFIED:   John Stockwell, CSM, 28 OCT 1992, new selfdoc strategy implemented.
MODIFIED:  Craig Artley, Colorado School of Mines, 12/16/93
           Added color options (Courtesy of Dave Hale, Advance Geophysical).
Modified: Morten Wendell Pedersen, Aarhus University, 23/3-97
          Added ticwidth,axeswidth, gridwidth parameters 
MODIFIED: James Gunning CSIRO, added reversing option
*/

#define NPMAX 5000	/* Arbitrary maximum number of plots allowed	*/

int main (int argc, char **argv)
{
	int nplot,n[NPMAX],nn,iplot,n1tic,n2tic,nd1,nf1,nd2,nf2,npairs,
		mark[NPMAX],pairs[NPMAX],grid1,grid2,style,npar,bbox[4];
	register int i;
	float labelsize,titlesize,
		linewidth[NPMAX],linegray[NPMAX],lineon[NPMAX],lineoff[NPMAX],
		marksize[NPMAX],d1[NPMAX],f1[NPMAX],d2[NPMAX],f2[NPMAX],
		x1beg,x2beg,x1end,x2end,xbox,ybox,wbox,hbox,dash[2],
		x1min,x1max,x2min,x2max, d1num,f1num,d2num,f2num,
		xsize,ysize,xscale,yscale;
	float axeswidth, ticwidth, gridwidth;
	char *label1="",*label2="",*title="",
		*labelfont="Helvetica",*titlefont="Helvetica-Bold",
		*styles="normal",*grid1s="none",*grid2s="none",
		*titlecolor="black",*axescolor="black",*gridcolor="black",
		*scolor="none",*linecolor[NPMAX];
	float **x1data, **x2data;
	
	int reverse=0,plot_direction=1;         /* JGHACK */
	int nplot_start, nplot_end;             /* JGHACK */

	/* initialize getpar */
	initargs(argc,argv);
	requestdoc(1);

	/* get parameters needed to interpret datafile */
	for (i=0; i<NPMAX; i++) {
		pairs[i] = 1;
		d1[i] = 0.0;
		f1[i] = 0.0;
		d2[i] = 0.0;
		f2[i] = 0.0;
	}
	npairs = getparint("pairs",pairs);
	nd1 = getparfloat("d1",d1);
 	nf1 = getparfloat("f1",f1);
	nd2 = getparfloat("d2",d2);
 	nf2 = getparfloat("f2",f2);

	/* get plotting order JGHACK */
	if (getparint("reverse", &reverse) && (reverse==1)) plot_direction=-1; /* JGHACK */


	if (!(nn = getparint("n",n)))  nn = getparint("n1",n);
	if (nn==0)  err("Must specify n, the number of points per plot!");
	nplot = nn; getparint("n2",&nplot); getparint("nplot",&nplot);
	if (nplot > NPMAX)  err("too many plots");
	for (i=nn; i<nplot; ++i)
		n[i] = n[nn-1];
	if (npairs>0)
		for (i=npairs; i<nplot; ++i)
			pairs[i] = pairs[npairs-1];
	if (nd1>0)
		for (i=nd1; i<nplot; ++i)
			d1[i] = d1[nd1-1];
	if (nf1>0)
		for (i=nf1; i<nplot; ++i)
			f1[i] = f1[nf1-1];
	if (nd2>0)
		for (i=nd2; i<nplot; ++i)
			d2[i] = d2[nd2-1];
	if (nf2>0)
		for (i=nf2; i<nplot; ++i)
			f2[i] = f2[nf2-1];

	/* read, regularize and compute extreme values of data */
	x1data = (float **)ealloc1(nplot, sizeof(float*));
	x2data = (float **)ealloc1(nplot, sizeof(float*));
	x2max = x1max = -FLT_MAX;
	x2min = x1min =  FLT_MAX;
	for (iplot=0; iplot<nplot; ++iplot) {
		register int npoint = n[iplot];

		x1data[iplot] = ealloc1float(npoint);
		x2data[iplot] = ealloc1float(npoint);

		/* read data for this plot */
		if (d1[iplot] && d2[iplot]) { /* straight line */
			register int i;
			register float *px1data=x1data[iplot];
			register float *px2data=x2data[iplot];
			float x1,x2;

			for (i=0; i<npoint; ++i) {
				x1 = f1[iplot] + i*d1[iplot];
				x2 = f2[iplot] + i*d2[iplot];
				x1max = MAX(x1, x1max);
				x1min = MIN(x1, x1min);
				x2max = MAX(x2, x2max);
				x2min = MIN(x2, x2min);
				*px1data++ = x1;
				*px2data++ = x2;
			}
		} else if (d1[iplot]) { /* equally spaced x1's */
			register int i;
			register float *px1data=x1data[iplot];
			register float *px2data=x2data[iplot];
			float x1,x2;

			for (i=0; i<npoint; ++i) {
				if (efread(&x2, FSIZE, 1, stdin)!=1)
					err("Error reading input!\n");
				x1 = f1[iplot] + i*d1[iplot];
				x1max = MAX(x1, x1max);
				x1min = MIN(x1, x1min);
				x2max = MAX(x2, x2max);
				x2min = MIN(x2, x2min);
				*px1data++ = x1;
				*px2data++ = x2;
			}
		} else if (d2[iplot]) { /* equally spaced x2's */
			register int i;
			register float *px1data=x1data[iplot];
			register float *px2data=x2data[iplot];
			float x1,x2;

			for (i=0; i<npoint; ++i) {
				if (efread(&x1, FSIZE, 1, stdin)!=1)
					err("Error reading input!\n");
				x2 = f2[iplot] + i*d2[iplot];
				x1max = MAX(x1, x1max);
				x1min = MIN(x1, x1min);
				x2max = MAX(x2, x2max);
				x2min = MIN(x2, x2min);
				*px1data++ = x1;
				*px2data++ = x2;
			}
		} else { /* pairs */
			register int i;
			register float *px1data=x1data[iplot];
			register float *px2data=x2data[iplot];
			float x1,x2;

			if (pairs[iplot]) { /* x1,y1,x2,y2,...,xn,yn */
				for (i=0; i<npoint; ++i) {
					if (efread(&x1, FSIZE, 1, stdin)!=1)
						err("Error reading input!\n");
					if (efread(&x2, FSIZE, 1, stdin)!=1)
						err("Error reading input!\n");
					x1max = MAX(x1, x1max);
					x1min = MIN(x1, x1min);
					x2max = MAX(x2, x2max);
					x2min = MIN(x2, x2min);
					*px1data++ = x1;
					*px2data++ = x2;
				}

			} else { /* x1,x2,...,xn,y1,y2,...,yn */
				for (i=0; i<npoint; ++i) {
					if (efread(&x1, FSIZE, 1, stdin)!=1)
						err("Error reading input!\n");
					x1max = MAX(x1, x1max);
					x1min = MIN(x1, x1min);
					*px1data++ = x1;
				}
				for (i=0; i<npoint; ++i) {
					if (efread(&x2, FSIZE, 1, stdin)!=1)
						err("Error reading input!\n");
					x2max = MAX(x2, x2max);
					x2min = MIN(x2, x2min);
					*px2data++ = x2;
				}
			}
		}
	}

	/* cope with special cases */
	if (x1min==FLT_MAX) x1min = x1max = 0.0;
	if (x2min==FLT_MAX) x2min = x2max = 0.0;
	if (x1min == x1max) {
		x1min -= 1.0;
		x1max += 1.0;
	}
	if (x2min == x2max) {
		x2min -= 1.0;
		x2max += 1.0;
	}

	/* get plotting parameters */
	getparstring("label1",&label1);
	getparstring("label2",&label2);
	getparstring("title",&title);
	getparstring("style",&styles);
	if (STREQ("normal",styles))
		style = NORMAL;
	else
		style = SEISMIC;
	getparstring("labelfont",&labelfont);
	getparstring("titlefont",&titlefont);
	labelsize = 18.0; getparfloat("labelsize",&labelsize);
	titlesize = 24.0; getparfloat("titlesize",&titlesize);
	getparstring("titlecolor",&titlecolor);
	getparstring("axescolor",&axescolor);
	getparstring("gridcolor",&gridcolor);
	xbox = 1.5; getparfloat("xbox",&xbox);
	ybox = 1.5; getparfloat("ybox",&ybox);
	wbox = 6.0; getparfloat("wbox",&wbox);
	hbox = 8.0; getparfloat("hbox",&hbox);

	x1beg = x1min; getparfloat("x1beg",&x1beg);
	x1end = x1max; getparfloat("x1end",&x1end);
	x2beg = x2min; getparfloat("x2beg",&x2beg);
	x2end = x2max; getparfloat("x2end",&x2end);
	d1num = 0.0; getparfloat("d1num",&d1num);
	f1num = x1min; getparfloat("f1num",&f1num);
	n1tic = 1; getparint("n1tic",&n1tic);
	getparstring("grid1",&grid1s);
	if (STREQ("dot",grid1s))
		grid1 = DOT;
	else if (STREQ("dash",grid1s))
		grid1 = DASH;
	else if (STREQ("solid",grid1s))
		grid1 = SOLID;
	else
		grid1 = NONE;
	d2num = 0.0; getparfloat("d2num",&d2num);
	f2num = 0.0; getparfloat("f2num",&f2num);
	n2tic = 1; getparint("n2tic",&n2tic);
	getparstring("grid2",&grid2s);
	if (STREQ("dot",grid2s))
		grid2 = DOT;
	else if (STREQ("dash",grid2s))
		grid2 = DASH;
	else if (STREQ("solid",grid2s))
		grid2 = SOLID;
	else
		grid2 = NONE;
	for (i=0; i<nplot; i++) {
		mark[i] = i%9;
		marksize[i] = 0.0;
		linewidth[i] = 1.0;
		lineon[i] = 1.0;
		lineoff[i] = 0.0;
		linegray[i] = 0.0;
		linecolor[i] = scolor;
	}
	if ((npar=getparint("mark",mark)))
		for (i=npar; i<nplot; ++i)  mark[i] = mark[npar-1];
	if ((npar=getparfloat("marksize",marksize)))
		for (i=npar; i<nplot; ++i)  marksize[i] = marksize[npar-1];
	if ((npar=getparfloat("linewidth",linewidth)))
		for (i=npar; i<nplot; ++i)  linewidth[i] = linewidth[npar-1];
	if ((npar=getparfloat("lineon",lineon)))
		for (i=npar; i<nplot; ++i)  lineon[i] = lineon[npar-1];
	if ((npar=getparfloat("lineoff",lineoff)))
		for (i=npar; i<nplot; ++i)  lineoff[i] = lineoff[npar-1];
	if ((npar=getparfloat("linegray",linegray)))
		for (i=npar; i<nplot; ++i)  linegray[i] = linegray[npar-1];
	if (getparstring("linecolor",&scolor)) {
		int i,j;  char *s;
		for (i=0,s=strtok(scolor,","); s!=NULL; ++i,s=strtok(NULL,","))
			linecolor[i] = s;
		for (j=i-1; i<nplot; ++i)
			linecolor[i] = linecolor[j];
	}
	if(!getparfloat("axeswidth",&axeswidth)) axeswidth=1;
	if (!getparfloat("ticwidth",&ticwidth)) ticwidth=axeswidth;
	if(!getparfloat("gridwidth",&gridwidth)) gridwidth =axeswidth;;

        checkpars();

	/* convert box parameters from inches to points */
	xbox *= 72.0;
	ybox *= 72.0;
	wbox *= 72.0;
	hbox *= 72.0;

	/* set bounding box */
	psAxesBBox(
		xbox,ybox,wbox,hbox,
		labelfont,labelsize,
		titlefont,titlesize,
		style,bbox);
	boundingbox(bbox[0],bbox[1],bbox[2],bbox[3]);

	/* begin PostScript */
	begineps();

	/* save graphics state */
	gsave();

	/* set clip */
	rectclip(xbox,ybox,wbox,hbox);

	/* determine axes sizes */
	xsize = (style==NORMAL)?wbox:hbox;
	ysize = (style==NORMAL)?hbox:wbox;

	/* translate coordinate system by box offset */
	translate(xbox,ybox);

	/* if style is not normal, rotate coordinate system */
	if (style!=NORMAL) {
		rotate(-90.0);
		translate(-hbox,0.0);
	}
	
	/* always use beveled joins of line segments */
	setlinejoin(2);

	/* determine x and y scale factors */
	xscale = xsize/(x1end-x1beg);
	yscale = ysize/(x2end-x2beg);

	/* draw the plots */
	/* Plot in fwd or reverse order. JGHACK ......here...........*/
	if (plot_direction==1) {
	  nplot_start=0;
	  nplot_end=nplot-1;
	} else {
	  nplot_start=nplot-1;
	  nplot_end=0;
	}
	for (iplot=nplot_start; (plot_direction==1) ? (iplot<=nplot_end) : (iplot>=nplot_end); 
			   iplot+=plot_direction) {
	        /* ......to here */
	        register int j;
		register int ni = n[iplot];
		register float *px1data = x1data[iplot];
		register float *px2data = x2data[iplot];
		float *x1 = ealloc1float(ni);
		float *x2 = ealloc1float(ni);

		/* translate and scale */
		for (j=0; j<ni; ++j) {
			x1[j] = (*px1data++ - x1beg)*xscale;
			x2[j] = (*px2data++ - x2beg)*yscale;
		}

		/* plot */
		gsave();
		if (linewidth[iplot]!=0.0) {
			setlinewidth(linewidth[iplot]);
			if (lineoff[iplot]!=0.0){
				dash[0] = lineon[iplot];
				dash[1] = lineoff[iplot];
				setdash(dash,2,0.0);
			} else {
				setdash(dash,0,0.0);
			}
			if (strcmp(linecolor[iplot],"none"))
				setcolor(linecolor[iplot]);
			else
				setgray(linegray[iplot]);
			polyline(x1,x2,ni);
		}
		if (marksize[iplot]!=0.0) {
			if (strcmp(linecolor[iplot],"none"))
				setcolor(linecolor[iplot]);
			else
				setgray(linegray[iplot]);
			for (j=0; j<ni; ++j)
			    markto(x1[j],x2[j],mark[iplot],marksize[iplot]);
		}
		grestore();

		free1float(x1);
		free1float(x2);
	}

	/* restore graphics state */
	grestore();

	/* draw axes and title */
	psAxesBox(
		xbox,ybox,wbox,hbox,
		x1beg,x1end,0.0,0.0,
		d1num,f1num,n1tic,grid1,label1,
		x2beg,x2end,0.0,0.0,
		d2num,f2num,n2tic,grid2,label2,
		labelfont,labelsize,
		title,titlefont,titlesize,
		titlecolor,axescolor,gridcolor,
		ticwidth,axeswidth,gridwidth,
		style);

	/* end PostScript */
	showpage();
	endeps();

	return 0;
}
@


1.39
log
@added legal font names
@
text
@d1 4
a4 1
/* PSGRAPH: $Revision: 1.38 $ ; $Date: 2003/04/30 21:14:45 $	*/
d405 2
@


1.38
log
@added mark index for Chris Liner
@
text
@d1 1
a1 1
/* PSGRAPH: $Revision: 1.37 $ ; $Date: 2003/02/26 16:57:15 $	*/
d104 13
@


1.37
log
@eftell -> eftello
@
text
@d1 1
a1 1
/* PSGRAPH: $Revision: 1.36 $ ; $Date: 1998/08/04 16:43:35 $	*/
d84 10
@


1.36
log
@updated selfdoc to include hex color specification
@
text
@d1 1
a1 1
/* PSGRAPH: $Revision: 1.35 $ ; $Date: 1997/03/28 18:34:46 $	*/
d81 2
a82 2
"                       seismic (axis 1 vertical, axis 2 horizontal)	",
"									",
d114 1
d137 3
d159 4
d423 12
a434 2
	for (iplot=0; iplot<nplot; ++iplot) {
		register int j;
@


1.35
log
@added Morten Pedersen's tick, axis, and grid width items.
@
text
@d1 1
a1 1
/* PSGRAPH: $Revision: 1.34 $ ; $Date: 1996/09/16 16:17:16 $	*/
d84 3
@


1.34
log
@silenced -Wall messages
@
text
@d1 1
a1 1
/* PSGRAPH: $Revision: 1.33 $ ; $Date: 1996/03/18 21:21:00 $	*/
d77 3
d109 2
d126 1
d364 3
d470 1
@


1.33
log
@Better documented use of linecolor and available colors.
@
text
@d1 1
a1 1
/* PSGRAPH: $Revision: 1.32 $ ; $Date: 1995/06/28 21:01:14 $	*/
d339 1
a339 1
	if (npar=getparint("mark",mark))
d341 1
a341 1
	if (npar=getparfloat("marksize",marksize))
d343 1
a343 1
	if (npar=getparfloat("linewidth",linewidth))
d345 1
a345 1
	if (npar=getparfloat("lineon",lineon))
d347 1
a347 1
	if (npar=getparfloat("lineoff",lineoff))
d349 1
a349 1
	if (npar=getparfloat("linegray",linegray))
@


1.32
log
@tweak self-doc
@
text
@d1 1
a1 1
/* PSGRAPH: $Revision: 1.31 $ ; $Date: 95/06/28 15:50:00 $	*/
d33 3
d46 1
@


1.31
log
@Elucidated self-doc re using pairs parameter in 1.b. option
@
text
@d1 1
a1 1
/* PSGRAPH: $Revision: 1.30 $ ; $Date: 1994/11/16 14:10:40 $	*/
d19 1
a19 1
"	  b. x1,x2,...,xn,y1,y2,...,yn (must set pairs=0		",
@


1.30
log
@added appropriate RCS header on file
@
text
@d1 1
a1 1
/* PSGRAPH: $Revision: 1.8 $ ; $Date: 94/08/25 15:00:32 $	*/
d19 1
a19 1
"	  b. x1,x2,...,xn,y1,y2,...,yn					",
@


1.29
log
@Added color support.
@
text
@d1 1
a1 1
/* psgraph - PostScript grapher */
@


1.28
log
@Removed Page comments from PostScript output.
@
text
@d42 1
d70 3
d95 1
d99 3
a101 1
MDIFIED:   John Stockwell, CSM, 28 OCT 1992, new selfdoc strategy implemented.
a103 1

d106 1
a106 1
main (int argc, char **argv)
d119 3
a121 1
		*styles="normal",*grid1s="none",*grid2s="none";
d290 3
a329 1
		linegray[i] = 0.0;
d332 2
a340 2
	if (npar=getparfloat("linegray",linegray))
		for (i=npar; i<nplot; ++i)  linegray[i] = linegray[npar-1];
d345 9
d372 2
a373 10
	/* draw axes and title */
	psAxesBox(
		xbox,ybox,wbox,hbox,
		x1beg,x1end,0.0,0.0,
		d1num,f1num,n1tic,grid1,label1,
		x2beg,x2end,0.0,0.0,
		d2num,f2num,n2tic,grid2,label2,
		labelfont,labelsize,
		title,titlefont,titlesize,
		style);
a416 1
			setgray(linegray[iplot]);
d424 4
a427 1

d431 4
a434 1
			setgray(linegray[iplot]);
d444 15
d462 2
@


1.27
log
@Fix bug in self-doc.
@
text
@d351 1
a351 2
	beginps();
	newpage("1",1);
d430 1
a430 1
	endps();
@


1.26
log
@experimented with NPMAX val
@
text
@d65 1
a65 1
" labelsize=12           font size for axes labels			",
@


1.25
log
@changed NPMAX from 500 to 5000
@
text
@@


1.24
log
@added begin selfdoc end selfdoc lines
@
text
@d98 1
a98 1
#define NPMAX 500	/* Arbitrary maximum number of plots allowed	*/
@


1.23
log
@added comment at top of file
@
text
@d6 1
d81 2
@


1.22
log
@new selfdoc installed
@
text
@d1 2
@


1.21
log
@reduced the size of the selfdoc to prevent
sdoc over flow error.
@
text
@d1 77
a77 74
char *sdoc =
"PSGRAPH - PostScript GRAPHer\n"
"Graphs n[i] pairs of (x,y) coordinates, for i = 1 to nplot.\n"
"\n"
"psgraph n= [optional parameters] <binaryfile >postscriptfile\n"
"\n"
"Required Parameters:\n"
"n                      array containing number of points per plot\n"
"\n"
"Data formats supported:\n"
"	1.a. x1,y1,x2,y2,...,xn,yn\n"
"	  b. x1,x2,...,xn,y1,y2,...,yn\n"
"	2.   y1,y2,...,yn (must give non-zero d1[]=)\n"
"	3.   x1,x2,...,xn (must give non-zero d2[]=)\n"
"	4.   nil (must give non-zero d1[]= and non-zero d2[]=)\n"
"  The formats may be repeated and mixed in any order, but if\n"
"  formats 2-4 are used, the d1 and d2 arrays must be specified including\n"
"  d1[]=0.0 d2[]=0.0 entries for any internal occurences of format 1.\n"
"  Similarly, the pairs array must contain place-keeping entries for\n"
"  plots of formats 2-4 if they are mixed with both formats 1.a and 1.b.\n"
"  Also, if formats 2-4 are used with non-zero f1[] or f2[] entries, then\n"
"  the corresponding array(s) must be fully specified including f1[]=0.0\n"
"  and/or f2[]=0.0 entries for any internal occurences of format 1 or\n"
"  formats 2-4 where the zero entries are desired.\n"
"\n"
"Optional Parameters:\n"
"nplot=number of n's    number of plots\n"
"d1=0.0,...             x sampling intervals (0.0 if x coordinates input)\n"
"f1=0.0,...             first x values (not used if x coordinates input)\n"
"d2=0.0,...             y sampling intervals (0.0 if y coordinates input)\n"
"f2=0.0,...             first y values (not used if y coordinates input)\n"
"pairs=1,...            =1 for data pairs in format 1.a, =0 for format 1.b\n"
"linewidth=1.0,...      line widths (in points) (0.0 for no lines)\n"
"linegray=0.0,...       line gray levels (black=0.0 to white=1.0)\n"
"lineon=1.0,...         length of line segments for dashed lines (in points)\n"
"lineoff=0.0,...        spacing between dashes (0.0 for solid line)\n"
"mark=0,1,2,3,...       indices of marks used to represent plotted points\n"
"marksize=0.0,0.0,...   size of marks (0.0 for no marks)\n"
"xbox=1.5               offset in inches of left side of axes box\n"
"ybox=1.5               offset in inches of bottom side of axes box\n"
"wbox=6.0               width in inches of axes box\n"
"hbox=8.0               height in inches of axes box\n"
"x1beg=x1min            value at which axis 1 begins\n"
"x1end=x1max            value at which axis 1 ends\n"
"d1num=0.0              numbered tic interval on axis 1 (0.0 for automatic)\n"
"f1num=x1min            first numbered tic on axis 1 (used if d1num not 0.0)\n"
"n1tic=1                number of tics per numbered tic on axis 1\n"
"grid1=none             grid lines on axis 1 - none, dot, dash, or solid\n"
"label1=                label on axis 1\n"
"x2beg=x2min            value at which axis 2 begins\n"
"x2end=x2max            value at which axis 2 ends\n"
"d2num=0.0              numbered tic interval on axis 2 (0.0 for automatic)\n"
"f2num=x2min            first numbered tic on axis 2 (used if d2num not 0.0)\n"
"n2tic=1                number of tics per numbered tic on axis 2\n"
"grid2=none             grid lines on axis 2 - none, dot, dash, or solid\n"
"label2=                label on axis 2\n"
"labelfont=Helvetica    font name for axes labels\n"
"labelsize=12           font size for axes labels\n"
"title=                 title of plot\n"
"titlefont=Helvetica-Bold font name for title\n"
"titlesize=24           font size for title\n"
"style=normal           normal (axis 1 horizontal, axis 2 vertical) or\n"
"                       seismic (axis 1 vertical, axis 2 horizontal)\n"
"\n"
"Note:	n1 and n2 are acceptable aliases for n and nplot, respectively.\n"
"\n"
"Example:\n"
"psgraph n=50,100,20 d1=2.5,1,0.33 <datafile >psfile\n"
"  plots three curves with equally spaced x values in one plot frame\n"
"  x1-coordinates are x1(i) = f1+i*d1 for i = 1 to n (f1=0 by default)\n"
"  number of x2's and then x2-coordinates for each curve are read\n"
"  sequentially from datafile.\n"
"  Dave Hale, with modifications by Jack K. Cohen, Lydia Deng, Craig Artley\n"
"\n";
d89 1
a91 2
#include "par.h"
#include "psplot.h"
d113 1
a113 1
	askdoc(1);
@


1.20
log
@Set line join to use beveled joins.
@
text
@d73 1
a73 9
"\n"
"AUTHOR:  Dave Hale, Colorado School of Mines, 05/29/90\n"
"MODIFIED:  Jack K. Cohen 11/23/90 for different input data format\n"
"MODIFIED:  Lydia Deng 06/07/91 for dashed lines\n"
"MODIFIED:  Craig Artley, Colorado School of Mines, 08/30/91\n"
"           BoundingBox moved to top of PostScript output\n"
"           Added optional paired data sub-format\n"
"MODIFIED:  Dave Hale, Colorado School of Mines, 11/05/91\n"
"           Set PostScript line join to always use beveled joins.\n"
d75 12
@


1.19
log
@changed NPMAX from 4096 to 500
@
text
@d80 2
d369 3
@


1.18
log
@Added error checking to warn user if requested number of points can not
be read from the input file.
@
text
@d85 1
a85 1
#define NPMAX 4096	/* Arbitrary maximum number of plots allowed	*/
@


1.17
log
@Fixed bug so that marks are drawn with the specified linegray,
rather than the default gray.
@
text
@d178 2
a179 1
				efread(&x2, FSIZE, 1, stdin);
d195 2
a196 1
				efread(&x1, FSIZE, 1, stdin);
d213 4
a216 2
					efread(&x1, FSIZE, 1, stdin);
					efread(&x2, FSIZE, 1, stdin);
d227 2
a228 1
					efread(&x1, FSIZE, 1, stdin);
d234 2
a235 1
					efread(&x2, FSIZE, 1, stdin);
@


1.16
log
@Added optional sub-format for data pairs.  (The default paired data
format remains the same.)  Also corrected sneaky bugs introduced by
me versions 1.10 & 1.11.
@
text
@d397 1
@


1.15
log
@BoundingBox comment moved to top of PostScript output.  (Craig Artley)
@
text
@d11 5
a15 4
"	1. x1,y1,x2,y2,...,xn,yn\n"
"	2. y1,y2,...,yn (must give non-zero d1[]=)\n"
"	3. x1,x2,...,xn (must give non-zero d2[]=)\n"
"	4. nil (must give non-zero d1[]= and non-zero d2[]=)\n"
d19 2
d32 1
d79 1
d89 2
a90 2
	int nplot,n[NPMAX],nn,iplot,n1tic,n2tic,nd1,nf1,nd2,nf2,
		mark[NPMAX],grid1,grid2,style,npar,bbox[4];
d109 1
d115 1
d127 15
a141 8
	for (i=nd1; i<nplot; ++i)
		d1[i] = d1[nd1-1];
	for (i=nf1; i<nplot; ++i)
		f1[i] = f1[nf1-1];
	for (i=nd2; i<nplot; ++i)
		d2[i] = d2[nd2-1];
	for (i=nf2; i<nplot; ++i)
		f2[i] = f2[nf2-1];
d209 25
a233 9
			for (i=0; i<npoint; ++i) {
				efread(&x1, FSIZE, 1, stdin);
				efread(&x2, FSIZE, 1, stdin);
				x1max = MAX(x1, x1max);
				x1min = MIN(x1, x1min);
				x2max = MAX(x2, x2max);
				x2min = MIN(x2, x2min);
				*px1data++ = x1;
				*px2data++ = x2;
@


1.14
log
@Upped NPMAX again (to 4096).
@
text
@d73 2
d82 1
a82 3

main (argc,argv)
int argc; char **argv;
a128 1

d136 1
a136 1
		
d139 1
a139 1
		
d146 1
a146 1
			
d225 4
a228 2
	if (STREQ("normal",styles)) style = NORMAL;
	else style = SEISMIC;
d246 8
a253 4
	if (STREQ("dot",grid1s)) grid1 = DOT;
	else if (STREQ("dash",grid1s)) grid1 = DASH;
	else if (STREQ("solid",grid1s)) grid1 = SOLID;
	else grid1 = NONE;
d258 8
a265 4
	if (STREQ("dot",grid2s)) grid2 = DOT;
	else if (STREQ("dash",grid2s)) grid2 = DASH;
	else if (STREQ("solid",grid2s)) grid2 = SOLID;
	else grid2 = NONE;
a286 4
	/* begin PostScript */
	beginps();
	newpage("1",1);

d301 4
d344 1
a344 2
		
				
@


1.13
log
@Upped NPMAX to 1024.
@
text
@d78 1
a78 1
#define NPMAX 1024	/* Arbitrary maximum number of plots allowed	*/
@


1.12
log
@added lineon, lineoff parameters for dashed lines
@
text
@d78 1
a78 1
#define NPMAX 500	/* Arbitrary maximum number of plots allowed	*/
@


1.11
log
@Fix moronic bug created during my last bug fix.
@
text
@d31 2
d72 1
d87 2
a88 1
	float labelsize,titlesize,linewidth[NPMAX],linegray[NPMAX],
d90 1
a90 1
		x1beg,x2beg,x1end,x2end,xbox,ybox,wbox,hbox,
d262 2
d273 4
d348 8
@


1.10
log
@Fixed bug that disregarded entries of d1[]=, f1[]=, d2[]=, and f2[]=
when the user specified fewer entries in the n[]= array.
Now all entries are used properly.
@
text
@d117 1
a117 1
		d1[i] = d1[nn-1];
d119 1
a119 1
		f1[i] = f1[nn-1];
d121 1
a121 1
		d2[i] = d2[nn-1];
d123 1
a123 1
		f2[i] = f2[nn-1];
@


1.9
log
@Tweaks
@
text
@d28 1
a28 1
"f1=0.0,...             first y values (not used if y coordinates input)\n"
d81 1
a81 1
	int nplot,n[NPMAX],nn,iplot,n1tic,n2tic,
d105 4
a108 4
	getparfloat("d1",d1);
 	getparfloat("f1",f1);
	getparfloat("d2",d2);
 	getparfloat("f2",f2);
d114 1
a114 1
	for (i=nn; i<nplot; ++i) {
d116 1
d118 1
d120 1
d122 1
d124 1
a124 1
	}
@


1.8
log
@ealloc1 -> ealloc1float and register declaration tweaks.
@
text
@d138 1
a138 1
			register float x1,x2;
a185 1
			
@


1.7
log
@Replaced malloc by ealloc1 and split data structure into
two for x1 and x2 components.  Also replaced some old x,y
notation by x1,x2 notation.
@
text
@d82 2
a83 1
		mark[NPMAX],i,grid1,grid2,style,npar,bbox[4];
d128 1
a128 1
		int npoint = n[iplot];
d130 2
a131 2
		x1data[iplot] = (float*)ealloc1(npoint, FSIZE);
		x2data[iplot] = (float*)ealloc1(npoint, FSIZE);
@


1.6
log
@Eliminated tmpfile for simple alloc as in xgraph.
@
text
@d82 1
a82 1
		mark[NPMAX],i,j,grid1,grid2,style,npar,bbox[4];
d91 1
a91 1
	float **data;
d122 2
a123 1
	data = (float **)malloc(nplot*sizeof(float*));
d129 3
a131 2
		data[iplot] = (float*)malloc(npoint*2*sizeof(float));

a133 2
			float x,y;
			float *pdata=data[iplot];
d135 4
a138 1

d140 8
a147 8
				x = f1[iplot] + i*d1[iplot];
				y = f2[iplot] + i*d2[iplot];
				x1max = MAX(x, x1max);
				x1min = MIN(x, x1min);
				x2max = MAX(y, x2max);
				x2min = MIN(y, x2min);
				*pdata++ = x;
				*pdata++ = y;
d149 1
a149 2
		} else if (d1[iplot]) { /* equally spaced x's */
			float x,y;
d151 3
a153 1
			float *pdata=data[iplot];
a154 1

d156 8
a163 8
				efread(&y, FSIZE, 1, stdin);
				x = f1[iplot] + i*d1[iplot];
				x1max = MAX(x, x1max);
				x1min = MIN(x, x1min);
				x2max = MAX(y, x2max);
				x2min = MIN(y, x2min);
				*pdata++ = x;
				*pdata++ = y;
d165 1
a165 2
		} else if (d2[iplot]) { /* equally spaced y's */
			float x,y;
d167 3
a169 1
			float *pdata=data[iplot];
d172 8
a179 8
				efread(&x, FSIZE, 1, stdin);
				y = f2[iplot] + i*d2[iplot];
				x1max = MAX(x, x1max);
				x1min = MIN(x, x1min);
				x2max = MAX(y, x2max);
				x2min = MIN(y, x2min);
				*pdata++ = x;
				*pdata++ = y;
a181 1
			float x,y;
d183 4
a186 1
			float *pdata=data[iplot];
d189 8
a196 8
				efread(&x, FSIZE, 1, stdin);
				efread(&y, FSIZE, 1, stdin);
				x1max = MAX(x, x1max);
				x1min = MIN(x, x1min);
				x2max = MAX(y, x2max);
				x2min = MIN(y, x2min);
				*pdata++ = x;
				*pdata++ = y;
d256 1
a256 2
		for (j=npar; j<nplot; j++)
			mark[j] = mark[npar-1];
d258 1
a258 2
		for (j=npar; j<nplot; j++)
			marksize[j] = marksize[npar-1];
d260 1
a260 2
		for (j=npar; j<nplot; j++)
			linewidth[j] = linewidth[npar-1];
d262 1
a262 2
		for (j=npar; j<nplot; j++)
			linegray[j] = linegray[npar-1];
a314 4
		int ni = n[iplot];
		float *pdata = data[iplot];
		float *x = ealloc1float(ni);
		float *y = ealloc1float(ni);
d316 6
a321 1

d325 2
a326 2
			x[j] = (*pdata++ - x1beg)*xscale;
			y[j] = (*pdata++ - x2beg)*yscale;
d334 1
a334 1
			polyline(x,y,ni);
d338 1
a338 1
				markto(x[j],y[j],mark[iplot],marksize[iplot]);
d342 2
a343 2
		free1float(x);
		free1float(y);
@


1.5
log
@made n1 and n2 aliases for n and nplot, respectively.
This is more consistent with the 1-2 axes notation anow used.
@
text
@d81 2
a82 2
	int nplot,n[NPMAX],nn,iplot,points,n1tic,n2tic,
		mark[NPMAX],i,j,grid1,grid2,style,npar,ni,bbox[4];
d91 1
a91 1
	FILE *plotfp;
d109 1
a109 2
	if (!(nn = getparint("n",n)))
		nn = getparint("n1",n);
d122 1
a122 1
	plotfp = etmpfile();
d126 3
a129 2
		points = n[iplot];

d133 1
d136 1
a136 1
			for (i=0; i<points; ++i) {
d143 2
a144 2
				efwrite(&x, FSIZE, 1, plotfp);
				efwrite(&y, FSIZE, 1, plotfp);
d149 1
d151 2
a152 1
			for (i=0; i<points; ++i) {
d159 2
a160 2
				efwrite(&x, FSIZE, 1, plotfp);
				efwrite(&y, FSIZE, 1, plotfp);
d165 1
d167 1
a167 1
			for (i=0; i<points; ++i) {
d174 2
a175 2
				efwrite(&x, FSIZE, 1, plotfp);
				efwrite(&y, FSIZE, 1, plotfp);
d180 1
d182 1
a182 1
			for (i=0; i<points; ++i) {
d189 2
a190 2
				efwrite(&x, FSIZE, 1, plotfp);
				efwrite(&y, FSIZE, 1, plotfp);
d312 5
a316 3
	rewind(plotfp);
	for (i=0; i<nplot; ++i) {
		float *x, *y;
d319 2
a320 5
		ni = n[i];
		x = ealloc1float(ni);
		y = ealloc1float(ni);

		/* read next set of pairs from tmpfile */
d322 2
a323 2
			efread(x+j, FSIZE, 1, plotfp);
			efread(y+j, FSIZE, 1, plotfp);
a324 6
		
		/* translate and scale */
		for (j=0; j<ni; j++) {
			x[j] = (x[j]-x1beg)*xscale;
			y[j] = (y[j]-x2beg)*yscale;
		}
d328 3
a330 3
		if (linewidth[i]!=0.0) {
			setlinewidth(linewidth[i]);
			setgray(linegray[i]);
d333 3
a335 3
		if (marksize[i]!=0.0) {
			for (j=0; j<ni; j++)
				markto(x[j],y[j],mark[i],marksize[i]);
@


1.4
log
@tweaked self-doc for style option to agree with 1-2 axes notation
@
text
@d59 2
d109 2
a110 1
	nn = getparint("n",n);
d112 1
a112 1
	nplot = nn; getparint("nplot",&nplot);
@


1.3
log
@ALtered data formats and other extensive changes--see
news item and self-doc.
@
text
@d56 2
a57 2
"style=normal           normal (x axis horizontal, y axis vertical) or\n"
"                       seismic (x axis vertical, y axis horizontal)\n"
a69 2
#include <stdio.h>
#include <math.h>
@


1.2
log
@replaced PostScript translation of coordinates with inline
coordinate translation to avoid roundoff error due to only 4(?)
digit precision in PostScript coordinates output by libpsplot.
@
text
@d10 13
d25 4
a28 4
"dx=1.0,...             x sampling intervals (0.0 if x coordinates input)\n"
"fx=0.0,...             first x values (not used if x coordinates input)\n"
"dy=0.0,...             y sampling intervals (0.0 if y coordinates input)\n"
"fy=0.0,...             first y values (not used if y coordinates input)\n"
d37 14
a50 14
"xbeg=xmin              value at which x axis begins\n"
"xend=xmax              value at which x axis ends\n"
"dxnum=0.0              numbered tic interval on x axis (0.0 for automatic)\n"
"fxnum=xmin             first numbered tic on x axis (used if dxnum not 0.0)\n"
"nxtic=1                number of tics per numbered tic on x axis\n"
"gridx=none             grid lines on x axis - none, dot, dash, or solid\n"
"labelx=                label on x axis\n"
"ybeg=ymin              value at which y axis begins\n"
"yend=ymax              value at which y axis ends\n"
"dynum=0.0              numbered tic interval on y axis (0.0 for automatic)\n"
"fynum=ymin             first numbered tic on y axis (used if dynum not 0.0)\n"
"nytic=1                number of tics per numbered tic on y axis\n"
"gridy=none             grid lines on y axis - none, dot, dash, or solid\n"
"labely=                label on y axis\n"
d60 5
a64 5
"psgraph n=50,100,20 dx=2.5,1,0.33 <datafile >psfile\n"
"  plots three curves in one plot frame\n"
"  x-coordinates are x(i) = fx+i*dx for i = 1 to n (fx=0 by default)\n"
"  y-coordinates are read sequentially from datafile -- 50 y-coordinates\n"
"  for the 1st plot, 100 for the 2nd, 20 for the 3rd.\n"
d67 1
d75 1
a75 2
#define NPMAX 500
#define NXMAX 10000
a76 1
static float x[NXMAX],y[NXMAX];
d81 2
a82 2
	int n[NPMAX],nn,nplot,nxtic,nytic,nxnum,nynum,
		mark[NPMAX],i,j,gridx,gridy,style,npar,ni,bbox[4];
d84 3
a86 3
		marksize[NPMAX],dx[NPMAX],fx[NPMAX],dy[NPMAX],fy[NPMAX],
		xbeg,ybeg,xend,yend,xbox,ybox,wbox,hbox,xmin,xmax,ymin,ymax,
		dxnum,fxnum,dynum,fynum,
d88 1
a88 1
	char *labelx="",*labely="",*title="",
d90 2
a91 2
		*styles="normal",*gridxs="none",*gridys="none";
	FILE *infp=stdin;
d97 1
a97 1
	/* get parameters */
d99 4
a102 5
		n[i] = 0;
		dx[i] = 1.0;
		fx[i] = 0.0;
		dy[i] = 0.0;
		fy[i] = 0.0;
d104 5
d110 1
a110 5
	if (nn==0) err("Must specify n, the number of points per plot!\n");
	getparfloat("dx",dx);
 	getparfloat("fx",fx);
	getparfloat("dy",dy);
 	getparfloat("fy",fy);
d112 2
a113 1
	for (i=nn; i<nplot; i++) {
d115 4
a118 4
		dx[i] = dx[nn-1];
		fx[i] = fx[nn-1];
		dy[i] = dy[nn-1];
		fy[i] = fy[nn-1];
d120 84
a203 2
	getparstring("labelx",&labelx);
	getparstring("labely",&labely);
d216 21
a236 21
	minmax(infp,nplot,n,dx,fx,dy,fy,&xmin,&xmax,&ymin,&ymax);
	xbeg = xmin; getparfloat("xbeg",&xbeg);
	xend = xmax; getparfloat("xend",&xend);
	ybeg = ymin; getparfloat("ybeg",&ybeg);
	yend = ymax; getparfloat("yend",&yend);
	dxnum = 0.0; getparfloat("dxnum",&dxnum);
	fxnum = xmin; getparfloat("fxnum",&fxnum);
	nxtic = 1; getparint("nxtic",&nxtic);
	getparstring("gridx",&gridxs);
	if (STREQ("dot",gridxs)) gridx = DOT;
	else if (STREQ("dash",gridxs)) gridx = DASH;
	else if (STREQ("solid",gridxs)) gridx = SOLID;
	else gridx = NONE;
	dynum = 0.0; getparfloat("dynum",&dynum);
	fynum = 0.0; getparfloat("fynum",&fynum);
	nytic = 1; getparint("nytic",&nytic);
	getparstring("gridy",&gridys);
	if (STREQ("dot",gridys)) gridy = DOT;
	else if (STREQ("dash",gridys)) gridy = DASH;
	else if (STREQ("solid",gridys)) gridy = SOLID;
	else gridy = NONE;
d277 4
a280 4
		xbeg,xend,0.0,0.0,
		dxnum,fxnum,nxtic,gridx,labelx,
		ybeg,yend,0.0,0.0,
		dynum,fynum,nytic,gridy,labely,
d302 2
a303 2
	xscale = xsize/(xend-xbeg);
	yscale = ysize/(yend-ybeg);
d305 6
a310 2
	/* draw nplot plots */
	for (i=0; i<nplot; i++) {
d312 2
d315 5
a319 11
		/* read or compute x and y coordinates */
		if (dx[i]==0)
			efread(x,sizeof(*x),ni,infp);
		else
			for (j=0; j<ni; j++)
				x[j] = fx[i]+j*dx[i];
		if (dy[i]==0)
			efread(y,sizeof(*y),ni,infp);
		else
			for (j=0; j<ni; j++)
				y[j] = fy[i]+j*dy[i];
d323 2
a324 2
			x[j] = (x[j]-xbeg)*xscale;
			y[j] = (y[j]-ybeg)*yscale;
d339 3
a346 74
}

/* subroutine finds minimum and maximum for x and y axes */
minmax (fp,nplot,n,dx,fx,dy,fy,xmin,xmax,ymin,ymax)
int nplot,*n;
float *dx,*fx,*dy,*fy,*xmin,*xmax,*ymin,*ymax;
FILE *fp;
{
	int i,j;
	float ex,xmint,xmaxt,ey,ymint,ymaxt,huge=1.0e20;
	
	*xmin = huge;  *xmax = -huge;
	*ymin = huge;  *ymax = -huge;
	for (i=0; i<nplot; i++)
	{
		if (dx[i]==0.0)
		{
			if (fread(x,sizeof(*x),n[i],fp)!=n[i])
				err("x coordinate read err: n=%d plot %d\n",
					n[i],i);
			for (j=0; j<n[i]; j++)
			{
				*xmin = (x[j]<*xmin)?x[j]:*xmin;
				*xmax = (x[j]>*xmax)?x[j]:*xmax;
			}
	 	}
		else 
		{
			if (n[i]>0)
			{
				ex = fx[i]+(n[i]-1)*dx[i];
				xmint = (fx[i]<ex)?fx[i]:ex;
				*xmin = (xmint<*xmin)?xmint:*xmin;
				xmaxt = (fx[i]>ex)?fx[i]:ex;
				*xmax = (xmaxt>*xmax)?xmaxt:*xmax;
			}
		}
		if (dy[i]==0.0)
		{
			if (fread(y,sizeof(*y),n[i],fp)!=n[i])
				err("y coordinate read err: n=%d plot %d\n",
					n[i],i);
			for (j=0; j<n[i]; j++)
			{
				*ymin = (y[j]<*ymin)?y[j]:*ymin;
				*ymax = (y[j]>*ymax)?y[j]:*ymax;
			}
	 	}
		else 
		{
			if (n[i]>0)
			{
				ey = fy[i]+(n[i]-1)*dy[i];
				ymint = (fy[i]<ey)?fy[i]:ey;
				*ymin = (ymint<*ymin)?ymint:*ymin;
				ymaxt = (fy[i]>ey)?fy[i]:ey;
				*ymax = (ymaxt>*ymax)?ymaxt:*ymax;
			}
		}
	}
	if (*xmin==huge) *xmin = *xmax = 0.0;
	if (*ymin==huge) *ymin = *ymax = 0.0;
	if (*xmin == *xmax)
	{
		*xmin -= 1.0;
		*xmax += 1.0;
	}
	if (*ymin == *ymax)
	{
		*ymin -= 1.0;
		*ymax += 1.0;
	}
	if (fseek(fp,0L,0)!=0)
		err("cannot read input data from a pipe!\n");
@


1.1
log
@Initial revision
@
text
@a209 3
	/* translate coordinate system by beginning axes values */
	translate(-xbeg*xscale,-ybeg*yscale);

d226 1
a226 1
		/* scale and translate */
d228 2
a229 2
			x[j] *= xscale;
			y[j] *= yscale;
@
