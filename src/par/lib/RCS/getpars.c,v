head	1.32;
access;
symbols;
locks
	john:1.32; strict;
comment	@ * @;


1.32
date	2011.11.22.20.21.05;	author john;	state Exp;
branches;
next	1.31;

1.31
date	2011.11.22.17.51.50;	author john;	state Exp;
branches;
next	1.30;

1.30
date	2011.11.16.16.41.18;	author john;	state Exp;
branches;
next	1.29;

1.29
date	2011.10.20.21.08.05;	author john;	state Exp;
branches;
next	1.28;

1.28
date	2011.09.09.22.26.43;	author john;	state Exp;
branches;
next	1.27;

1.27
date	2007.09.20.20.58.23;	author john;	state Exp;
branches;
next	1.26;

1.26
date	2006.05.09.17.12.32;	author john;	state Exp;
branches;
next	1.25;

1.25
date	2004.12.23.22.27.14;	author john;	state Exp;
branches;
next	1.24;

1.24
date	2003.08.19.21.15.57;	author john;	state Exp;
branches;
next	1.23;

1.23
date	2003.02.18.17.07.14;	author john;	state Exp;
branches;
next	1.22;

1.22
date	2001.01.26.17.19.10;	author john;	state Exp;
branches;
next	1.21;

1.21
date	2000.08.24.21.19.25;	author john;	state Exp;
branches;
next	1.20;

1.20
date	97.03.17.16.19.24;	author john;	state Exp;
branches;
next	1.19;

1.19
date	96.09.06.18.06.51;	author john;	state Exp;
branches;
next	1.18;

1.18
date	96.01.31.16.11.05;	author jkc;	state Exp;
branches;
next	1.17;

1.17
date	95.08.17.10.36.46;	author john;	state Exp;
branches;
next	1.16;

1.16
date	94.03.14.12.39.13;	author john;	state Exp;
branches;
next	1.15;

1.15
date	94.03.03.21.27.54;	author jkc;	state Exp;
branches;
next	1.14;

1.14
date	94.03.03.15.30.05;	author jkc;	state Exp;
branches;
next	1.13;

1.13
date	94.03.03.14.52.00;	author jkc;	state Exp;
branches;
next	1.12;

1.12
date	94.01.28.14.42.32;	author jkc;	state Exp;
branches;
next	1.11;

1.11
date	92.09.03.11.35.45;	author cartley;	state Exp;
branches;
next	1.10;

1.10
date	92.03.20.12.23.51;	author jkc;	state Exp;
branches;
next	1.9;

1.9
date	91.09.04.16.42.30;	author jkcohen;	state Exp;
branches;
next	1.8;

1.8
date	90.05.29.17.42.01;	author dhale;	state Exp;
branches;
next	1.7;

1.7
date	90.05.29.16.47.41;	author dhale;	state Exp;
branches;
next	1.6;

1.6
date	90.05.29.12.42.35;	author dhale;	state Exp;
branches;
next	1.5;

1.5
date	90.04.24.15.15.04;	author jkc;	state Exp;
branches;
next	1.4;

1.4
date	90.04.13.13.06.55;	author jkc;	state Exp;
branches;
next	1.3;

1.3
date	90.04.13.13.02.08;	author jkc;	state Exp;
branches;
next	1.2;

1.2
date	90.04.13.12.30.04;	author jkc;	state Exp;
branches;
next	1.1;

1.1
date	90.04.10.19.19.02;	author jkc;	state Exp;
branches;
next	;


desc
@namelist parameter parsing
@


1.32
log
@removed extraneous stdio
@
text
@/* Copyright (c) Colorado School of Mines, 2011.*/
/* All rights reserved.			*/


/*********************** self documentation **********************/
/*****************************************************************************
GETPARS - Functions to GET PARameterS from the command line. Numeric
	parameters may be single values or arrays of int, uint,
	short, ushort, long, ulong, float, or double.  Single character
	strings (type string or char *) may also be gotten.
	Arrays of strings, delimited by, but not containing
	commas are permitted.

The functions are:

initargs 	Makes command line args available to subroutines (re-entrant).
		Every par program starts with this call!
getparint		get integers
getparuint		get unsigned integers
getparshort		get short integers
getparushort		get unsigned short integers
getparlong		get long integers
getparulong		get unsigned long integers
getparfloat		get float
getpardouble		get double
getparstring		get a single string
getparstringarray	get string array (fields delimited by commas)
getpar			get parameter by type
getnparint		get n'th occurrence of integer
getnparuint		get n'th occurrence of unsigned int
getnparshort		get n'th occurrence of short integer
getnparushort		get n'th occurrence of unsigned short int
getnparlong		get n'th occurrence of long integer
getnparulong		get n'th occurrence of unsigned long int
getnparfloat		get n'th occurrence of float
getnpardouble		get n'th occurrence of double
getnparstring		get n'th occurrence of string
getnparstringarray	get n'th occurrence of string array
getnpar			get n'th occurrence by type
countparname		return the number of times a parameter names is used
countparval		return the number of values in the last occurrence
				of a parameter
countnparval		return the number of values in the n'th occurrence
				of a parameter
getPar			Promax compatible version of getpar
checkpars()		check the argument list for typos
******************************************************************************
Function Prototypes:
void initargs (int argc, char **argv);
int getparint (char *name, int *p);
int getparuint (char *name, unsigned int *p);
int getparshort (char *name, short *p);
int getparushort (char *name, unsigned short *p);
int getparlong (char *name, long *p);
int getparulong (char *name, unsigned long *p);
int getparfloat (char *name, float *p);
int getpardouble (char *name, double *p);
int getparstring (char *name, char **p);
int getparstringarray (char *name, char **p);
int getnparint (int n, char *name, int *p);
int getnparuint (int n, char *name, unsigned int *p);
int getnparshort (int n, char *name, short *p);
int getnparushort (int n, char *name, unsigned short *p);
int getnparlong (int n, char *name, long *p);
int getnparulong (int n, char *name, unsigned long *p);
int getnparfloat (int n, char *name, float *p);
int getnpardouble (int n, char *name, double *p);
int getnparstring (int n, char *name, char **p);
int getnparstringarray (int n, char *name, char **p);
int getnpar (int n, char *name, char *type, void *ptr);
int countparname (char *name);
int countparval (char *name);
int countnparval (int n, char *name);
void getPar(char *name, char *type, void *ptr);
void checkpars( void );

******************************************************************************
Notes:
Here are some usage examples:

	... if integer n not specified, then default to zero.
	if (!getparint("n", &n)) n = 0;

	... if array of floats vx is specified, then
	if (nx=countparval("vx")) {
		... allocate space for array
		vx = ealloc1float(nx);
		... and get the floats
		getparfloat("vx",vx);
	}

The command line for the above examples might look like:
	progname n=35 vx=3.21,4,9.5
	Every par program starts with this call!

More examples are provided in the DTEST code at the end of this file.

The functions: eatoh, eatou, eatol, eatov, eatoi, eatop used
below are versions of atoi that check for overflow.  The source
file for these functions is atopkge.c.

******************************************************************************
Authors:
Rob Clayton & Jon Claerbout, Stanford University, 1979-1985
Shuki Ronen & Jack Cohen, Colorado School of Mines, 1985-1990
Dave Hale, Colorado School of Mines, 05/29/90
Credit to John E. Anderson for re-entrant initargs 03/03/94
*****************************************************************************/
/**************** end self doc ********************************/

#include <ctype.h>
#include <stdlib.h>
#include <string.h>

#include "par.h"

/* parameter table */
typedef struct {
	char *name;		/* external name of parameter	*/
	char *asciival;		/* ascii value of parameter	*/
} pointer_table;

/* global variables declared and used internally */
static pointer_table *argtbl;	/* parameter table		*/
static int nargs;		/* number of args that parse	*/
static int tabled = FALSE;	/* true when parameters tabled 	*/
static size_t targc;		/* total number of args		*/
static char **targv;		/* pointer to arg strings	*/
static char *argstr;		/* storage for command line	*/

/* functions declared and used internally */
static int getparindex (int n, char *name);
static void getparinit(void);
static void tabulate (size_t argc, char **argv);
static char *getpfname (void);
#if 0
/* getpars.c:571: warning: `white2null' defined but not used */
/* not used */
static size_t white2null (char *str, size_t len);
#endif
static int ccount (char c, char *s);

/*--------------------------------------------------------------------*\
  These variables are used by checkpars() to warn of parameter typos.
  par= does not use getpar() so we need to store that as the first
  parameter name.  lheaders= is buried in fgettr() so we intialize
  that also
\*--------------------------------------------------------------------*/

#define PAR_NAMES_MAX 512

static char* par_names[PAR_NAMES_MAX];
static int   par_count=0;
static int parcheck = 0;


/* make command line args available to subroutines -- re-entrant version */
void initargs(int argc, char **argv)
{
	memset( par_names ,0 ,sizeof(par_names) );
	par_names[0] = "par";
	par_names[1] = "lheader";
	par_count=2;

	xargc = argc; xargv = argv;
	if(tabled==TRUE){
		free(argstr);
		free(targv);
		free(argtbl);
	}
	tabled =  FALSE;
	return;
}

/* functions to get values for the last occurrence of a parameter name */
int getparint (char *name, int *ptr)
{
	return getnpar(0,name,"i",ptr);
}
int getparuint (char *name, unsigned int *ptr)
{
	return getnpar(0,name,"p",ptr);
}
int getparshort (char *name, short *ptr)
{
	return getnpar(0,name,"h",ptr);
}
int getparushort (char *name, unsigned short *ptr)
{
	return getnpar(0,name,"u",ptr);
}
int getparlong (char *name, long *ptr)
{
	return getnpar(0,name,"l",ptr);
}
int getparulong (char *name, unsigned long *ptr)
{
	return getnpar(0,name,"v",ptr);
}
int getparfloat (char *name, float *ptr)
{
	return getnpar(0,name,"f",ptr);
}
int getpardouble (char *name, double *ptr)
{
	return getnpar(0,name,"d",ptr);
}
int getparstring (char *name, char **ptr)
{
	return getnpar(0,name,"s",ptr);
}
int getparstringarray (char *name, char **ptr)
{
	return getnpar(0,name,"a",ptr);
}
int getpar (char *name, char *type, void *ptr)
{
	return getnpar(0,name,type,ptr);
}

/* functions to get values for the n'th occurrence of a parameter name */
int getnparint (int n, char *name, int *ptr)
{
	return getnpar(n,name,"i",ptr);
}
int getnparuint (int n, char *name, unsigned int *ptr)
{
	return getnpar(n,name,"p",ptr);
}
int getnparshort (int n, char *name, short *ptr)
{
	return getnpar(n,name,"h",ptr);
}
int getnparushort (int n, char *name, unsigned short *ptr)
{
	return getnpar(n,name,"u",ptr);
}
int getnparlong (int n, char *name, long *ptr)
{
	return getnpar(n,name,"l",ptr);
}
int getnparulong (int n, char *name, unsigned long *ptr)
{
	return getnpar(n,name,"v",ptr);
}
int getnparfloat (int n, char *name, float *ptr)
{
	return getnpar(n,name,"f",ptr);
}
int getnpardouble (int n, char *name, double *ptr)
{
	return getnpar(n,name,"d",ptr);
}
int getnparstring (int n, char *name, char **ptr)
{
	return getnpar(n,name,"s",ptr);
}
int getnparstringarray (int n, char *name, char **ptr)
{
	return getnpar(n,name,"a",ptr);
}
int getnpar (int n, char *name, char *type, void *ptr)
{
	int i;			/* index of name in symbol table	*/
	int j;		  /* index for par_names[]		*/
	int nval;		/* number of parameter values found	*/
	char *aval;		/* ascii field of symbol		*/

/*--------------------------------------------------------------------*\
   getpar gets called in loops reading traces in some programs.  So
   check for having seen this name before. Also make sure we don't
   walk off the end of the table.
\*--------------------------------------------------------------------*/

	if( parcheck && strcmp( "lheader" ,name ) ){
	   fprintf( stderr ,"getpar() call after checkpars(): %s\n" ,name );
	}

	for( j=0; j<par_count; j++ ){
	   if( !strcmp( par_names[j] ,name ) ){
		break;
	   }
	}

	if( j >= par_count && par_count < PAR_NAMES_MAX ){
	   par_names[par_count++] = name;
	}

	if(  par_count == PAR_NAMES_MAX ){
	   fprintf( stderr, " %s exceeded PAR_NAMES_MAX %d \n" ,xargv[0] ,PAR_NAMES_MAX );
	}

	if (xargc == 1) return 0;
	if (!tabled) getparinit();/* Tabulate command line and parfile */
	i = getparindex(n,name);/* Get parameter index */
	if (i < 0) return 0;	/* Not there */

	if (0 == ptr) {
	   err("%s: getnpar called with 0 pointer, type = %s", __FILE__,type);
	}
	  

	/*
	 * handle string type as a special case, since a string
	 * may contain commas.
	 */
	if (type[0]=='s') {
		*((char**)ptr) = argtbl[i].asciival;
		return 1;
	}

	/* convert vector of ascii values to numeric values */
	for (nval=0,aval=argtbl[i].asciival; *aval; nval++) {
		switch (type[0]) {
			case 'i':
				*(int*)ptr = eatoi(aval);
				ptr = (int*)ptr+1;
				break;
			case 'p':
				*(unsigned int*)ptr = eatop(aval);
				ptr = (unsigned int*)ptr+1;
				break;
			case 'h':
				*(short*)ptr = eatoh(aval);
				ptr = (short*)ptr+1;
				break;
			case 'u':
				*(unsigned short*)ptr = eatou(aval);
				ptr = (unsigned short*)ptr+1;
				break;
			case 'l':
				*(long*)ptr = eatol(aval);
				ptr = (long*)ptr+1;
				break;
			case 'v':
				*(unsigned long*)ptr = eatov(aval);
				ptr = (unsigned long*)ptr+1;
				break;
			case 'f':
				*(float*)ptr = eatof(aval);
				ptr = (float*)ptr+1;
				break;
			case 'd':
				*(double*)ptr = eatod(aval);
				ptr = (double*)ptr+1;
				break;
			case 'a':
				{ char *tmpstr="";
				   tmpstr = ealloc1(strlen(aval)+1,1);

				   strchop(aval,tmpstr);
				   *(char**)ptr = tmpstr;
				   ptr=(char **)ptr + 1;
				}
				   break;
			default:
				err("%s: invalid parameter type = %s",
					__FILE__,type);
		}
		while (*aval++ != ',') {
			if (!*aval) break;
		}
	}
	return nval;
}

void checkpars( void ){

   int i;
   int j;
   char buf[256];

   for( j=1; j<xargc; j++){

	for( i=0; i<par_count; i++ ){
	 sprintf( buf ,"%s=" ,par_names[i] );

	 if( !strncmp( buf ,xargv[j] ,strlen(buf) ) ){
	    break;
	 }
	}
	if( i == par_count && strchr( xargv[j] ,'=' ) ){
	 fprintf( stderr ,"Unknown %s argument %s\n" ,xargv[0] ,xargv[j] );
	}

   }

   parcheck = 1;
}

/* Promax compatible version of getnpar */
void getPar(char *name, char *type, void *ptr)
{
	(void) getnpar(0,name,type,ptr);
	return;
}

/* return number of occurrences of parameter name */
int countparname (char *name)
{
	int i,nname;

	if (xargc == 1) return 0;
	if (!tabled) getparinit();
	for (i=0,nname=0; i<nargs; ++i)
		if (!strcmp(name,argtbl[i].name)) ++nname;
	return nname;
}

/* return number of values in n'th occurrence of parameter name */
int countnparval (int n, char *name)
{
	int i;

	if (xargc == 1) return 0;
	if (!tabled) getparinit();
	i = getparindex(n,name);
	if (i>=0)
		return ccount(',',argtbl[i].asciival) + 1;
	else
		return 0;
}

/* return number of values in last occurrence of parameter name */
int countparval (char *name)
{
	return countnparval(0,name);
}



/*
 * Return the index of the n'th occurrence of a parameter name,
 * except if n==0, return the index of the last occurrence.
 * Return -1 if the specified occurrence does not exist.
 */
static int getparindex (int n, char *name)
{
	int i;
	if (n==0) {
		for (i=nargs-1; i>=0; --i)
			if (!strcmp(name,argtbl[i].name)) break;
		return i;
	} else {
		for (i=0; i<nargs; ++i)
			if (!strcmp(name,argtbl[i].name))
				if (--n==0) break;
		if (i<nargs)
			return i;
		else
			return -1;
	}
}

/* Initialize getpar */

static void getparinit (void)
{
	static char *pfname;	/* name of parameter file		*/
	FILE *pffd=NULL;	/* file id of parameter file		*/
	size_t pflen;		/* length of parameter file in bytes	*/
	static size_t pfargc;	/* arg count from parameter file	*/
	int parfile;		/* parfile existence flag		*/
	int argstrlen=0;
	char *pargstr;		/* storage for parameter file args	*/
	size_t nread=0;		/* bytes fread				*/
	int i, j;		/* counters				*/
	int start = TRUE;
	int debug = FALSE;
	int quote = FALSE;


	tabled = TRUE;		/* remember table is built		*/


	/* Check if xargc was initiated */

	if(!xargc)
		err("%s: xargc=%d -- not initiated in main", __FILE__, xargc);

	/* Space needed for command lines */

	for (i = 1, argstrlen = 0; i < xargc; i++) {
		argstrlen += strlen(xargv[i]) + 1;
	}

	/* Get parfile name if there is one */

	if ((pfname = getpfname())) {
		parfile = TRUE;
	} else {
		parfile = FALSE;
	}

	if (parfile) {
	 	pffd = efopen(pfname, "r");

		/* Get the length */
		efseek(pffd, 0, SEEK_END);

		pflen = (off_t) eftello(pffd);

		rewind(pffd);
		argstrlen += pflen;
	} else {
		pflen = 0;
	}

/*--------------------------------------------------------------------*\
   Allocate space for command line and parameter file. The pointer
   table could be as large as the string buffer, but no larger.

   The parser logic has been completely rewritten to prevent bad
   input from crashing the program.

   Reginald H. Beardsley			    rhb@@acm.org
\*--------------------------------------------------------------------*/

	argstr = (char *) ealloc1(argstrlen+1, 1);
	targv = (char **) ealloc1((argstrlen+1)/4,sizeof(char*));

	if (parfile) {
		/* Read the parfile */

		nread = efread(argstr, 1, pflen, pffd);
  		if (nread != pflen) {
  	 	    err("%s: fread only %d bytes out of %d from %s",
  					__FILE__,  nread, pflen, pfname);
		}
		efclose(pffd);


	} else {
		pfargc = 0;
	}


	/* force input to valid 7 bit ASCII */

	for( i=0; i<nread; i++ ){
	    argstr[i] &= 0x7F;
	}

	/* tokenize the input */

	j = 0;

	for( i=0; i<nread; i++ ){

	    /* look for start of token */

	    if( start ){

 /* getpars.c:475: warning: subscript has type `char' */
		if( isgraph( (int)argstr[i] ) ){
		    targv[j] = &(argstr[i]);
		    start = !start;
		    j++;

		}else{
		    argstr[i] = 0;

		}

	    /* terminate token */

/* getpars.c:487: warning: subscript has type `char' */
	    }else if( !quote && isspace( (int)argstr[i] ) ){
		argstr[i] = 0;
		start = !start;

	    }

	    /* toggle quote semaphore */

	    if( argstr[i] == '\'' || argstr[i] == '\"' ){
		quote = !quote;

	    }

	}

	/* display all tokens */

	if( debug ){

	    i=0;
	    while( i < j && targv[i] != 0 ){
		if( strlen( targv[i] ) ){
		    fprintf( stderr ,"%d -> %s\n" ,i ,targv[i] );
		}
		i++;

	    }
	}

	/* discard non-parameter tokens */

	i=0;
	targc=0;
	while( i < j && targv[i] != 0 ){
	    if( strchr( targv[i] ,'=' ) ){
		targv[targc] = targv[i];
		targc++;
	    }
	    i++;
	}

	/* Copy command line arguments */

	for (j = 1, pargstr = argstr + pflen + 1; j < xargc; j++) {
		strcpy(pargstr,xargv[j]);
		targv[targc++] = pargstr;
		pargstr += strlen(xargv[j]) + 1;
	}

	/* Allocate space for the pointer table */

	argtbl = (pointer_table*) ealloc1(targc, sizeof(pointer_table));

	/* Tabulate targv */

	tabulate(targc, targv);

	return;
}
#define PFNAME "par="
/* Get name of parameter file */
static char *getpfname (void)
{
	int i;
	size_t pfnamelen;

	pfnamelen = strlen(PFNAME);
	for (i = xargc-1 ; i > 0 ; i--) {
		if(!strncmp(PFNAME, xargv[i], pfnamelen)
		    && strlen(xargv[i]) != pfnamelen) {
			return xargv[i] + pfnamelen;
		}
	}
	return NULL;
}

#define iswhite(c)	((c) == ' ' || (c) == '\t' || (c) == '\n')

#if 0
/* getpars.c:571: warning: `white2null' defined but not used */
/* not used */
/*
 * Replace the whites by (possibly multiple) nulls.  If we see a non-white
 * and the previous char is a null, this signals the start of a string
 * and we bump the count.  This routine returns a count of the strings.
 */
static size_t white2null (char *str, size_t len)
{
	int i;
	size_t count = 0;
	int inquote = FALSE;

	str[0] = '\0'; /* This line added by Dave Hale, 1/30/96. */
	for (i = 1; i < len; i++) {
		if (str[i]=='"') inquote=(inquote==TRUE)?FALSE:TRUE;
		if (!inquote) {
			if (iswhite(str[i])) { /* Is this a new word ? */
				str[i] = '\0';
			} else if (!str[i-1]) { /* multiple whites */
				count++;
			}
		}
	}
	for (i = 1, inquote=FALSE; i < len; i++) {
		if (str[i]=='"') inquote=(inquote==TRUE)?FALSE:TRUE;
		if (inquote) {
			if (str[i+1]!='"') {
				str[i] = str[i+1];
			} else {
				str[i] = '\0';
				str[i+1] = '\0';
				inquote = FALSE;
			}
		}
	}
	str[len] = '\0';
	return count;
}
#endif

/* Install symbol table */
static void tabulate (size_t argc, char **argv)
{
	int i;
	char *eqptr;
	int debug=FALSE;

	for (i = 0, nargs = 0 ; i < argc; i++) {
		eqptr = strchr(argv[i], '=');
		if (eqptr) {
			argtbl[nargs].name = argv[i];
			argtbl[nargs].asciival = eqptr + 1;
			*eqptr = (char)0;

			/* Debugging dump */
			if( debug ){
				fprintf(stderr,
				"argtbl[%d]: name=%s asciival=%s\n",
				nargs,argtbl[nargs].name,argtbl[nargs].asciival);

			}
			nargs++;
		}
	}
	return;
}

/* Count characters in a string */
static int ccount (char c, char *s)
{
	int i, count;
	for (i = 0, count = 0; s[i] != 0; i++)
		if(s[i] == c) count++;
	return count;
}


#ifdef TEST
#define N 100
main(int argc, char **argv)
{
	char *s;
	short h, vh[N];
	unsigned short u, vu[N];
	long l, vl[N];
	unsigned long v, vv[N];
	int i, vi[N], ipar, npar, nval;
	unsigned int p, vp[N];
	float f, vf[N];
	double d, vd[N];

	initargs(argc, argv);

	/* int parameters */
	npar = countparname("i");
	printf("\nnumber of i pars = %d\n",npar);
	for (ipar=1; ipar<=npar; ++ipar) {
		getnparint(ipar,"i",&i);
		printf("occurrence %d of i=%d\n",ipar,i);
	}
	if (getparint("i", &i))
		printf("last occurrence of i=%d\n",i);
	npar = countparname("vi");
	printf("number of vi pars = %d\n",npar);
	for (ipar=1; ipar<=npar; ++ipar) {
		nval = countnparval(ipar,"vi");
		printf("occurrence %d has %d values\n",ipar,nval);
		nval = getnparint(ipar,"vi",vi);
		printf("vi=");
		for (i=0; i<nval; i++)
			printf("%d%c",vi[i],i==nval-1?'\n':',');
	}
	if (npar>0) {
		nval = countparval("vi");
		printf("last occurrence has %d values\n",nval);
		getparint("vi",vi);
		printf("vi=");
		for (i=0; i<nval; i++)
			printf("%d%c",vi[i],i==nval-1?'\n':',');
	}

	/* float parameters */
	npar = countparname("f");
	printf("\nnumber of f pars = %d\n",npar);
	for (ipar=1; ipar<=npar; ++ipar) {
		getnparfloat(ipar,"f",&f);
		printf("occurrence %d of f=%g\n",ipar,f);
	}
	if (getparfloat("f", &f))
		printf("last occurrence of f=%g\n",f);
	npar = countparname("vf");
	printf("number of vf pars = %d\n",npar);
	for (ipar=1; ipar<=npar; ++ipar) {
		nval = countnparval(ipar,"vf");
		printf("occurrence %d has %d values\n",ipar,nval);
		nval = getnparfloat(ipar,"vf",vf);
		printf("vf=");
		for (i=0; i<nval; i++)
			printf("%g%c",vf[i],i==nval-1?'\n':',');
	}
	if (npar>0) {
		nval = countparval("vf");
		printf("last occurrence has %d values\n",nval);
		getparfloat("vf",vf);
		printf("vf=");
		for (i=0; i<nval; i++)
			printf("%g%c",vf[i],i==nval-1?'\n':',');
	}

	/* string parameters */
	npar = countparname("s");
	printf("\nnumber of s pars = %d\n",npar);
	for (ipar=1; ipar<=npar; ++ipar) {
		getnparstring(ipar,"s",&s);
		printf("occurrence %d of s=%s\n",ipar,s);
	}
	if (getparstring("s", &s))
		printf("last occurrence of s=%s\n",s);

	return EXIT_SUCCESS;
}
#endif
@


1.31
log
@additional checkpar changes
by Reg Beardsley
@
text
@a112 1
#include <stdio.h>
@


1.30
log
@checkpar() added
parameter checking subroutine
@
text
@d2 1
a2 1
/* All rights reserved.                       */
d12 1
a12 1
        commas are permitted.
d46 1
a46 1
checkpars()              check the argument list for typos
d144 7
d155 2
d161 4
a164 1
        memset( par_names ,0 ,sizeof(par_names) );
d266 1
a266 1
        int j;                  /* index for par_names[]                */
d276 17
a292 13
        for( j=0; j<par_count; j++ ){
           if( !strcmp( par_names[j] ,name ) ){
              break;
           }
        }

        if( j >= par_count && par_count < PAR_NAMES_MAX ){
           par_names[par_count++] = name;
        }

        if(  par_count == PAR_NAMES_MAX ){
           fprintf( stderr, " %s exceeded PAR_NAMES_MAX %d \n" ,xargv[0] ,PAR_NAMES_MAX );
        }
d376 2
a377 2
      for( i=0; i<par_count; i++ ){
         sprintf( buf ,"%s=" ,par_names[i] );
d379 7
a385 7
         if( !strncmp( buf ,xargv[j] ,strlen(buf) ) ){
            break;
         }
      }
      if( i == par_count && strchr( xargv[j] ,'=' ) ){
         fprintf( stderr ,"Unknown %s argument %s\n" ,xargv[0] ,xargv[j] );
      }
d388 2
d469 3
a471 3
        int start = TRUE;
        int debug = FALSE;
        int quote = FALSE;
d517 1
a517 1
   Reginald H. Beardsley                            rhb@@acm.org
d539 1
a539 1
        /* force input to valid 7 bit ASCII */
d541 3
a543 3
        for( i=0; i<nread; i++ ){
            argstr[i] &= 0x7F;
        }
d545 1
a545 1
        /* tokenize the input */
d547 1
a547 1
        j = 0;
d549 1
a549 1
        for( i=0; i<nread; i++ ){
d551 1
a551 1
            /* look for start of token */
d553 1
a553 1
            if( start ){
d556 4
a559 4
               if( isgraph( (int)argstr[i] ) ){
                    targv[j] = &(argstr[i]);
                    start = !start;
                    j++;
d561 2
a562 2
                }else{
                    argstr[i] = 0;
d564 1
a564 1
                }
d566 1
a566 1
            /* terminate token */
d569 3
a571 3
            }else if( !quote && isspace( (int)argstr[i] ) ){
                argstr[i] = 0;
                start = !start;
d573 1
a573 1
            }
d575 1
a575 1
            /* toggle quote semaphore */
d577 2
a578 2
            if( argstr[i] == '\'' || argstr[i] == '\"' ){
                quote = !quote;
d580 1
a580 1
            }
d582 1
a582 1
        }
d584 1
a584 1
        /* display all tokens */
d586 1
a586 1
        if( debug ){
d588 6
a593 6
            i=0;
            while( i < j && targv[i] != 0 ){
                if( strlen( targv[i] ) ){
                    fprintf( stderr ,"%d -> %s\n" ,i ,targv[i] );
                }
                i++;
d595 2
a596 2
            }
        }
d598 1
a598 1
        /* discard non-parameter tokens */
d600 9
a608 9
        i=0;
        targc=0;
        while( i < j && targv[i] != 0 ){
            if( strchr( targv[i] ,'=' ) ){
                targv[targc] = targv[i];
                targc++;
            }
            i++;
        }
d694 1
a694 1
        int debug=FALSE;
d704 4
a707 4
                        if( debug ){
                                fprintf(stderr,
                                "argtbl[%d]: name=%s asciival=%s\n",
                                nargs,argtbl[nargs].name,argtbl[nargs].asciival);
d709 1
a709 1
                        }
@


1.29
log
@added copyright statement
@
text
@d46 1
a46 1

d75 1
d144 5
d152 2
d254 1
d258 20
d351 23
@


1.28
log
@*** empty log message ***
@
text
@d1 3
@


1.27
log
@John Gravley's changes
@
text
@d1 1
d251 5
@


1.26
log
@cosmetic from Reg Beardsley
@
text
@d6 1
a6 1
	strings (type string or char *) may also be gotten. 
d18 1
a18 1
getparlong		get long integers 
d23 1
a23 1
getparstringarray	get string array (fields delimited by commas) 
d31 3
a33 3
getnparfloat		get n'th occurrence of float 
getnpardouble		get n'th occurrence of double 
getnparstring		get n'th occurrence of string 
d76 1
a76 1
	... if integer n not specified, then default to zero. 
d78 1
a78 1
	
d86 1
a86 1
	
d97 1
a97 1
******************************************************************************	
d103 1
a103 1
*****************************************************************************/	
d132 3
d136 1
d249 4
a252 4
	
	/* 
	 * handle string type as a special case, since a string 
	 * may contain commas. 
d257 1
a257 1
	} 
d340 1
a340 1
	if (i>=0) 
d355 1
a355 1
 * Return the index of the n'th occurrence of a parameter name, 
d383 1
a383 1
	size_t pflen;		/* length of parameter file in bytes	*/ 
d458 2
a459 2
    
    
d461 1
a461 1
    
d465 1
a465 1
    
d467 1
a467 1
    
d469 1
a469 1
    
d471 1
a471 1
    
d473 1
a473 1
    
d475 3
a477 2
    
                if( isgraph( argstr[i] ) ){
d481 1
a481 1
    
d484 1
a484 1
    
d486 1
a486 1
    
d488 3
a490 2
    
            }else if( !quote && isspace( argstr[i] ) ){
d493 1
a493 1
    
d495 1
a495 1
    
d497 1
a497 1
    
d500 1
a500 1
    
d502 1
a502 1
    
d504 1
a504 1
    
d506 1
a506 1
    
d508 1
a508 1
    
d515 1
a515 1
        
d518 1
a518 1
    
d520 1
a520 1
    
d546 1
a546 1
	
d561 1
a561 1
		}	
d568 4
a571 1
/* 
d608 1
d626 3
a628 3
                                fprintf(stderr, 
                                "argtbl[%d]: name=%s asciival=%s\n", 
                                nargs,argtbl[nargs].name,argtbl[nargs].asciival); 
d670 1
a670 1
	if (getparint("i", &i))	
d698 1
a698 1
	if (getparfloat("f", &f))	
d726 1
a726 1
	if (getparstring("s", &s))	
d728 1
a728 1
	
@


1.25
log
@Reg Beardsley fix
@
text
@d31 4
a34 4
getnparfloat		get n'th occurrence of float integer
getnpardouble		get n'th occurrence of double integer
getnparstring		get n'th occurrence of string integer
getnparstringarray	get n'th occurrence of string integer array
@


1.24
log
@19 Aug 2003
@
text
@d438 1
a438 1
	targv = (char **) ealloc1(argstrlen+1, 1);
@


1.23
log
@(off_t) added
@
text
@d504 1
a504 1
            while( targv[i] != 0 ){
d517 1
a517 1
        while( targv[i] != 0 ){
@


1.22
log
@small bug fix
@
text
@d382 1
a382 1
	int argstrlen;
d417 3
a420 2
		efseek(pffd, 0, SEEK_END);
		pflen = eftell(pffd);
@


1.21
log
@revision 20
@
text
@d106 5
a133 1
static void strchop(char *s, char *t);
d374 1
d384 1
a384 1
	size_t nread;		/* bytes fread				*/
d386 3
d393 1
d395 1
d400 1
d406 1
a406 1
	/* parfile = (pfname = getpfname()) ? TRUE : FALSE; */
d417 1
d426 12
a437 4
	/* Allocate space for command line and parameter file
		plus nulls at the ends to help with parsing. */
	/* argstr = (char *) calloc((size_t) (1+argstrlen+1), 1); */
	argstr = (char *) ealloc1(1+argstrlen+1, 1);
d441 2
a442 1
		nread = efread(argstr + 1, 1, pflen, pffd);
a448 2
		/* Zap whites in parfile to help in parsing */
		pfargc = white2null(argstr, pflen);
d453 70
d524 1
a524 2
	/* Total arg count */
	targc = pfargc + xargc - 1;
d526 1
a526 16
	/* Allocate space for total arg pointers */
	targv = (char **) ealloc1(targc, sizeof(char*));

	if (parfile) {
		/* Parse the parfile.  Skip over multiple NULLs */
		for (j = 1, i = 0; j < pflen; j++) {
			if (argstr[j] && !argstr[j-1]) {
			       targv[i++] = argstr + j;
			}
		}
	} else {
		i = 0;
	}

	/* Copy command line arguments */
	for (j = 1, pargstr = argstr + pflen + 2; j < xargc; j++) {
d528 1
a528 1
		targv[i++] = pargstr;
d533 1
d537 1
a541 1

d604 1
d614 4
a617 3
/* 			fprintf(stderr, */
/* 			"argtbl[%d]: name=%s asciival=%s\n", */
/* 			nargs,argtbl[nargs].name,argtbl[nargs].asciival); */
d619 1
a634 18
static void strchop(char *s, char *t)
/***********************************************************************
strchop - chop off the tail end of a string "s" after a "," returning
          the front part of "s" as "t".
************************************************************************
Notes:
Based on strcpy in Kernighan and Ritchie's C [ANSI C] book, p. 106.
************************************************************************
Author: CWP: John Stockwell and Jack K. Cohen, July 1995
***********************************************************************/
{

	while ( (*s != ',') && (*s != '\0') ) {
		 *t++ = *s++;
	}
	*t='\0';
}

a720 1

@


1.20
log
@bug fix reported by Alexander Koek of Delft.
@
text
@d118 1
a118 1
static int targc;		/* total number of args		*/
d125 1
a125 1
static void tabulate (int argc, char **argv);
d127 1
a127 1
static int white2null (char *str, int len);
d374 2
a375 2
	int pflen;		/* length of parameter file in bytes	*/ 
	static int pfargc;	/* arg count from parameter file	*/
d379 1
a379 1
	int nread;		/* bytes fread				*/
d473 1
a473 1
	int pfnamelen;
d492 1
a492 1
static int white2null (char *str, int len)
d495 1
a495 1
	int count;
d499 1
a499 1
	for (i = 1, count = 0; i < len; i++) {
d526 1
a526 1
static void tabulate (int argc, char **argv)
@


1.19
log
@fixed -Wall complaints
@
text
@d288 1
a288 1
				   tmpstr = ealloc1(strlen(aval),1);
@


1.18
log
@Fix in white2null by Dave Hale:
Note the change with my name on it below. Although I have not verified that
the indicated change is necessary, I think that omitting it yields an
unitialized memory read in the best case, and a bad parameter read in the
worst case.
@
text
@a0 3
/* Copyright (c) Colorado School of Mines, 1995.*/
/* All rights reserved.                       */

d373 1
a373 1
	FILE *pffd;		/* file id of parameter file		*/
d396 1
a396 1
	if (pfname = getpfname()) {
@


1.17
log
@added getparstringarray stuff
@
text
@d501 1
@


1.16
log
@added dummy selfdocs
@
text
@d1 3
d10 2
a11 1
	(Arrays of strings may not be gotten.)  The functions are:
d13 2
d25 2
a26 1
getparstring		get string
d37 1
d58 1
d68 1
d132 1
d184 4
d230 4
d247 1
a247 1
	 * may contain commas.  Therefore, no arrays of strings.
d252 1
a252 1
	}
d289 9
d560 11
d572 7
d664 1
@


1.15
log
@Mostly cosmetic.  Wrote in credit for JEA.  Removed internal
function declarations in getparinit that were hanging around
from pre ANSI C.
@
text
@d1 1
d3 5
a7 4
Functions to get parameters from the command line.  Numeric parameters may
be single values or arrays of int, uint, short, ushort, long, ulong, float, 
or double.  Single character strings (type string or char *) may also be
gotten.  (Arrays of strings may not be gotten.)  The functions are:
d9 28
a36 3
void initargs(int argc, char **argv)
	Makes command line args available to subroutines (re-entrant).
	Every par program starts with this call!
d38 22
a59 12
int getpar<type> (char *name, <type> *ptr);
	Gets values for the last occurrence of a parameter, where <type>
	denotes one of the parameter types listed above.  Returns the
	number of parameters gotten, zero if parameter not specified.

int getnpar<type> (int n, char *name, <type> *ptr);
	Gets values for the n'th occurrence of a parameter, where <type>
	denotes one of the parameter types listed above.  Returns the
	number of parameters gotten, zero if n'th occurrence not found.
	The value n = 0 is used as a special flag to indicate getting the
	LAST occurrence of a parameter.

a60 2
	Returns the number of occurrences of a parameter name.

d62 2
a63 1
	Returns the number of values in the last occurrence of a parameter.
d65 4
a68 4
int countnparval (int n, char *name);
	Returns the number of values in the n'th occurrence of a parameter.
******************************************************************************	
Example:
d85 1
a85 2
******************************************************************************	
Notes:
d89 1
d97 1
@


1.14
log
@Per suggestions by John E. Anderson:
1. incorporate initargs and make it re-entrant
2. add hook for ProMAX compatibility (getPar).
3. also some minor fixes in prototypes.
@
text
@d7 4
d46 1
d59 1
a318 5
	char *getpfname();	/* return name of parameter file	*/
	int white2null();	/* deliminate arg strings from parameter
				   file with (possibly multiple) NULLs
				   and return a count of the strings	*/
	void tabulate();	/* install symbol table			*/
d407 1
d426 3
a428 2
 * Replace the whites by nulls.  If we see a non-white and the previous
 * char is a null, this signals the start of a string and we bump the count.
d462 1
a462 1
/* Tabulate parameters */
@


1.13
log
@Fixed spelling of occurrence in 24 places.  Added comment about
getnpar's n=0 hook.
@
text
@d68 3
d74 2
a75 2
static int getparinit(void);
static int tabulate (int argc, char **argv);
d80 13
d237 6
d302 1
a302 1
static int getparinit (void)
a303 2
	static int targc;	/* total number of args			*/
	static char **targv;	/* pointer to arg strings		*/
d310 1
a310 2
	char *argstr, *pargstr;	/* storage for command line and
						parameter file args	*/
d317 1
a317 1
	int tabulate();		/* install symbol table			*/
d401 2
d460 1
a460 1
static int tabulate (int argc, char **argv)
d480 1
@


1.12
log
@removed copyright statement, stray occurences of 'ushort'
@
text
@d8 1
a8 1
	Gets values for the last occurence of a parameter, where <type>
d13 1
a13 1
	Gets values for the n'th occurence of a parameter, where <type>
d15 3
a17 1
	number of parameters gotten, zero if n'th occurence not found.
d20 1
a20 1
	Returns the number of occurences of a parameter name.
d23 1
a23 1
	Returns the number of values in the last occurence of a parameter.
d26 1
a26 1
	Returns the number of values in the n'th occurence of a parameter.
d77 1
a77 1
/* functions to get values for the last occurence of a parameter name */
d119 1
a119 1
/* functions to get values for the n'th occurence of a parameter name */
d222 1
a222 1
/* return number of occurences of parameter name */
d234 1
a234 1
/* return number of values in n'th occurence of parameter name */
d248 1
a248 1
/* return number of values in last occurence of parameter name */
d257 3
a259 3
 * Return the index of the n'th occurence of a parameter name, 
 * except if n==0, return the index of the last occurence.
 * Return -1 if the specified occurence does not exist.
d492 1
a492 1
		printf("occurence %d of i=%d\n",ipar,i);
d495 1
a495 1
		printf("last occurence of i=%d\n",i);
d500 1
a500 1
		printf("occurence %d has %d values\n",ipar,nval);
d508 1
a508 1
		printf("last occurence has %d values\n",nval);
d520 1
a520 1
		printf("occurence %d of f=%g\n",ipar,f);
d523 1
a523 1
		printf("last occurence of f=%g\n",f);
d528 1
a528 1
		printf("occurence %d has %d values\n",ipar,nval);
d536 1
a536 1
		printf("last occurence has %d values\n",nval);
d548 1
a548 1
		printf("occurence %d of s=%s\n",ipar,s);
d551 1
a551 1
		printf("last occurence of s=%s\n",s);
@


1.11
log
@changed #include to "par.h"
@
text
@a0 13
/*----------------------------------------------------------------------
 * Copyright (c) Colorado School of Mines, 1989.
 * All rights reserved.
 *
 * This code is part of SU.  SU stands for Seismic Unix, a processing line
 * developed at the Colorado School of Mines, partially based on Stanford
 * Exploration Project (SEP) software.  Inquiries should be addressed to:
 *
 *  Jack K. Cohen, Center for Wave Phenomena, Colorado School of Mines,
 *  Golden, CO 80401  (jkc@@dix.mines.colorado.edu)
 *----------------------------------------------------------------------
 */
 
@


1.10
log
@Tweak to documentation of countnparval.
@
text
@d67 1
a67 1
#include "../include/par.h"
@


1.9
log
@Junked obsolete fgetpar, etal.  bool -> int (with true -> TRUE, etc.)
@
text
@d36 1
a36 1
int countnparval (char *name);
@


1.8
log
@Fixed pointer arithmetic in getnpars() to comply with ANSI C
@
text
@d78 1
a78 1
static bool tabled = false;	/* true when parameters tabled 	*/
a264 37
/* obsolute functions - provided here for compatibility */
int igetpar (char *name, int *ptr)
{
	return getnpar(0,name,"i",ptr);
}
int pgetpar (char *name, unsigned int *ptr)
{
	return getnpar(0,name,"p",ptr);
}
int hgetpar (char *name, short *ptr)
{
	return getnpar(0,name,"h",ptr);
}
int ugetpar (char *name, unsigned short *ptr)
{
	return getnpar(0,name,"u",ptr);
}
int lgetpar (char *name, long *ptr)
{
	return getnpar(0,name,"l",ptr);
}
int vgetpar (char *name, unsigned long *ptr)
{
	return getnpar(0,name,"v",ptr);
}
int fgetpar (char *name, float *ptr)
{
	return getnpar(0,name,"f",ptr);
}
int dgetpar (char *name, double *ptr)
{
	return getnpar(0,name,"d",ptr);
}
int sgetpar (char *name, char **ptr)
{
	return getnpar(0,name,"s",ptr);
}
a266 1

d299 1
a299 1
	bool parfile;		/* parfile existence flag		*/
d312 1
a312 1
	tabled = true;		/* remember table is built		*/
d324 1
a324 1
	/* parfile = (pfname = getpfname()) ? true : false; */
d326 1
a326 1
		parfile = true;
d328 1
a328 1
		parfile = false;
d421 1
a421 1
	bool inquote = false;
d424 1
a424 1
		if (str[i]=='"') inquote=(inquote==true)?false:true;
d433 2
a434 2
	for (i = 1, inquote=false; i < len; i++) {
		if (str[i]=='"') inquote=(inquote==true)?false:true;
d441 1
a441 1
				inquote = false;
@


1.7
log
@Fixed bug in countnparval() - was not returning the count.
@
text
@d191 2
a192 1
				*((int*)ptr)++ = eatoi(aval);
d195 2
a196 1
				*((unsigned int*)ptr)++ = eatop(aval);
d199 2
a200 1
				*((short*)ptr)++ = eatoh(aval);
d203 2
a204 1
				*((unsigned short*)ptr)++ = eatou(aval);
d207 2
a208 1
				*((long*)ptr)++ = eatol(aval);
d211 2
a212 1
				*((unsigned long*)ptr)++ = eatov(aval);
d215 2
a216 1
				*((float*)ptr)++ = eatof(aval);
d219 2
a220 1
				*((double*)ptr)++ = eatod(aval);
@


1.6
log
@Extensive revisions:
changed igetpar to getparint, etc.
added getnpar<type> functions to get n'th occurence of a parameter
added countparname(), countparval(), and countnparval() functions
@
text
@d246 1
a246 1
		ccount(',',argtbl[i].asciival) + 1;
@


1.5
log
@Using cwp alloc routines and zgetpar -> dgetpar
@
text
@d13 6
d20 47
d69 1
a69 72
/* hgetpar, ugetpar, lgetpar, vgetpar, igetpar, pgetpar, fgetpar,
 * dgetpar, sgetpar - get a parameter or vector of parameters of
 * a given data type
 *
 * maxgetpar - return the size of the longest parameter vector
 *
 * Returns:
 *	int: number of values read, zero if the parameter was not
 *	     specified.
 *
 * Synopsis:
 *	int hgetpar(name, ptr)	(Get a short parameter)
 *	string name;		(External name of parameter)
 *	short *ptr;		(Pointer to parameter value)
 *
 *	int ugetpar(name, ptr)	(Get an unsigned short parameter)
 *	string name;		(External name of parameter)
 *	unsigned short *ptr;	(Pointer to parameter value)
 *
 *	int lgetpar(name, ptr)	(Get a long parameter)
 *	string name;		(External name of parameter)
 *	long *ptr;		(Pointer to parameter value)
 *
 *	int vgetpar(name, ptr)	(Get an unsigned long parameter)
 *	string name;		(External name of parameter)
 *	unsigned long *ptr;	(Pointer to parameter value)
 *
 *	int igetpar(name, ptr)	(Get an int parameter)
 *	string name;		(External name of parameter)
 *	int *ptr;		(Pointer to parameter value)
 *
 *	int pgetpar(name, ptr)	(Get an unsigned int parameter)
 *	string name;		(External name of parameter)
 *	unsigned int *ptr;	(Pointer to parameter value)
 *
 *	int fgetpar(name, ptr)	(Get a float parameter)
 *	string name;		(External name of parameter)
 *	float *ptr;		(Pointer to parameter value)
 *
 *	int dgetpar(name, ptr)	(Get a double parameter)
 *	string name;		(External name of parameter)
 *	double *ptr;		(Pointer to parameter value)
 *
 *	int sgetpar(name, ptr)	(Get a string parameter)
 *	string name;		(External name of parameter)
 *	char **ptr;		(Pointer to parameter value)
 *
 *	unsigned maxgetpar()
 *
 * Examples:
 *      ...Here 0.0 is the default value, if getpar doesn't find x.
 *	x = 0.0; fgetpar("x", &x);
 *
 *	nv = igetpar("vi", &vi);
 *	for (i = 0, i < nv; i++) {
 *		...
 *
 * Notes:
 *	The functions: eatoh, eatou, eatol, eatov, eatoi, eatop used
 *	below are versions of atoi that check for overflow.  The source
 *	file for these functions is atopkge.c.
 *
 *	Usage is illustrated in the DTEST code at the end of this file.
 *
 * Credits:
 *	SEP: Jon Claerbout, Rob Clayton
 *	CWP: Shuki, Jack
 *
 *
 *
 */

d71 2
a72 2
	string name;		/* external name of parameter	*/
	string asciival;	/* ascii value of parameter	*/
d75 2
a76 2

static pointer_table *argtbl;	/* symbol table			*/
d78 1
a78 1
static bool first = true;	/* first entry flag		*/
d80 7
d88 2
a89 3
int hgetpar(name, ptr)
string name;	/* external name of parameter	 */
short *ptr;	/* pointer to parameter value	 */
d91 1
a91 18
	int i;		/* index of name in symbol table	*/
	int n;		/* number of shorts found		*/
	string aval;	/* ascii field of symbol		*/
	int getparindex();	/* PARMS(char *name)		*/

	if (xargc == 1) return 0;
	if (first) getparinit();/* Tabulate command line and parfile */
	i = getparindex(name);	/* Get parameter index */
	if (i < 0) return 0;	/* Not there */

	/* Convert vector ascii (e.g. 1,2,3) to numeric */
	for (n = 0, aval = argtbl[i].asciival; *aval; n++) {
		*ptr++ = eatoh(aval);
		while (*aval++ != ',') {
			if (!*aval) break;
		}
	}
	return n;
d93 1
a93 4

int ugetpar(name, ptr)
string name;	/* external name of parameter	*/
unsigned short *ptr;	/* pointer to parameter value	*/
d95 1
a95 18
	int i;		/* index of name in symbol table	*/
	int n;		/* number of u_shorts found		*/
	string aval;	/* ascii field of symbol		*/
	int getparindex();	/* PARMS(char *name)		*/

	if (xargc == 1) return 0;
	if (first) getparinit();/* Tabulate command line and parfile */
	i = getparindex(name);	/* Get parameter index */
	if (i < 0) return 0;	/* Not there */

	/* Convert vector ascii (e.g. 1,2,3) to numeric */
	for (n = 0, aval = argtbl[i].asciival; *aval; n++) {
		*ptr++ = eatou(aval);
		while (*aval++ != ',') {
			if (!*aval) break;
		}
	}
	return n;
d97 1
a97 4

int lgetpar(name, ptr)
string name;	/* external name of parameter	*/
long *ptr;	/* pointer to parameter value	*/
d99 1
a99 18
	int i;		/* index of name in symbol table	*/
	int n;		/* number of longs found		*/
	string aval;	/* ascii field of symbol		*/
	int getparindex();	/* PARMS(char *name)		*/

	if (xargc == 1) return 0;
	if (first) getparinit();/* Tabulate command line and parfile */
	i = getparindex(name);	/* Get parameter index */
	if (i < 0) return 0;	/* Not there */

	/* Convert vector ascii (e.g. 1,2,3) to numeric */
	for (n = 0, aval = argtbl[i].asciival; *aval; n++) {
		*ptr++ = eatol(aval);
		while (*aval++ != ',') {
			if (!*aval) break;
		}
	}
	return n;
d101 1
a101 4

int vgetpar(name, ptr)
string name;	/* external name of parameter	*/
unsigned long *ptr;	/* pointer to parameter value	*/
d103 1
a103 18
	int i;		/* index of name in symbol table	*/
	int n;		/* number of u_longs found		*/
	string aval;	/* ascii field of symbol		*/
	int getparindex();	/* PARMS(char *name)		*/

	if (xargc == 1) return 0;
	if (first) getparinit();/* Tabulate command line and parfile */
	i = getparindex(name);	/* Get parameter index */
	if (i < 0) return 0;	/* Not there */

	/* Convert vector ascii (e.g. 1,2,3) to numeric */
	for (n = 0, aval = argtbl[i].asciival; *aval; n++) {
		*ptr++ = eatov(aval);
		while (*aval++ != ',') {
			if (!*aval) break;
		}
	}
	return n;
d105 24
d130 2
a131 3
int igetpar(name, ptr)
string name;	/* external name of parameter	*/
int *ptr;	/* pointer to parameter value	*/
d133 39
a171 4
	int i;		/* index of name in symbol table	*/
	int n;		/* number of ints found			*/
	string aval;	/* ascii field of symbol		*/
	int getparindex();	/* PARMS(char *name)		*/
d174 2
a175 2
	if (first) getparinit();/* Tabulate command line and parfile */
	i = getparindex(name);	/* Get parameter index */
d177 9
d187 31
a217 3
	/* Convert vector ascii (e.g. 1,2,3) to numeric */
	for (n = 0, aval = argtbl[i].asciival; *aval; n++) {
		*ptr++ = eatoi(aval);
d222 1
a222 1
	return n;
d225 2
a226 3
int pgetpar(name, ptr)
string name;	/* external name of parameter	*/
unsigned int *ptr;	/* pointer to parameter value	*/
d228 1
a228 4
	int i;		/* index of name in symbol table	*/
	int n;		/* number of u_ints found		*/
	string aval;	/* ascii field of symbol		*/
	int getparindex();	/* PARMS(char *name)		*/
d231 4
a234 12
	if (first) getparinit();/* Tabulate command line and parfile */
	i = getparindex(name);	/* Get parameter index */
	if (i < 0) return 0;	/* Not there */

	/* Convert vector ascii (e.g. 1,2,3) to numeric */
	for (n = 0, aval = argtbl[i].asciival; *aval; n++) {
		*ptr++ = eatop(aval);
		while (*aval++ != ',') {
			if (!*aval) break;
		}
	}
	return n;
d237 2
a238 3
int fgetpar(name, ptr)
string name;	/* external name of parameter	*/
float *ptr;	/* pointer to parameter value	*/
d240 1
a240 4
	int i;		/* index of name in symbol table	*/
	int n;		/* number of floats found		*/
	string aval;	/* ascii field of symbol		*/
	int getparindex();	/* PARMS(char *name)		*/
d243 6
a248 12
	if (first) getparinit();/* Tabulate command line and parfile */
	i = getparindex(name);	/* Get parameter index */
	if (i < 0) return 0;	/* Not there */

	/* Convert vector ascii (e.g. 1,2,3) to float */
	for (n = 0, aval = argtbl[i].asciival; *aval; n++) {
		*ptr++ = (float) eatof(aval);
		while (*aval++ != ',') {
			if (!*aval) break;
		}
	}
	return n;
d251 2
a252 3
int dgetpar(name, ptr)
string name;	/* external name of parameter	*/
double *ptr;	/* pointer to parameter value	*/
d254 1
a254 18
	int i;		/* index of name in symbol table	*/
	int n;		/* number of doubles found		*/
	string aval;	/* ascii field of symbol		*/
	int getparindex();	/* PARMS(char *name)		*/

	if (xargc == 1) return 0;
	if (first) getparinit();/* Tabulate command line and parfile */
	i = getparindex(name);	/* Get parameter index */
	if (i < 0) return 0;	/* Not there */

	/* Convert vector ascii (e.g. 1,2,3) to double */
	for (n = 0, aval = argtbl[i].asciival; *aval; n++) {
		*ptr++ = eatod(aval);
		while (*aval++ != ',') {
			if (!*aval) break;
		}
	}
	return n;
d257 2
a258 3
int sgetpar(name, ptr)
string name;	/* external name of parameter	*/
char **ptr;	/* pointer to parameter value	*/
d260 34
a293 2
	int i;		/* index of name in symbol table	*/
	int getparindex();	/* PARMS(char *name)		*/
a294 4
	if (xargc == 1) return 0;
	if (first) getparinit();/* Tabulate command line and parfile */
	i = getparindex(name);	/* Get parameter index */
	if (i < 0) return 0;	/* Not there */
a295 4
	/* Copy the argument */
	*ptr = argtbl[i].asciival;
	return 1;
}
d298 3
a300 2
 * Find the index of the argument.  We want later references to
 * a given name to replace earlier ones, hence backwards search.
d302 1
a302 2
getparindex(name)
string name;
d305 12
a316 2
	for (i = nargs - 1; i >= 0 ; i--) {
		if (!strcmp(name, argtbl[i].name)) break;
a317 1
	return i;
d320 2
a321 1
getparinit()
d325 1
a325 1
	static string pfname;	/* name of parameter file		*/
d331 1
a331 1
	string argstr, pargstr;	/* storage for command line and
d335 1
a335 1
	string getpfname();	/* return name of parameter file	*/
d342 1
a342 1
	first = false;		/* unset first entry flag		 */
d426 1
a426 1
string getpfname()
d443 5
a447 6
/* Replace the whites by nulls.  If we see a non-white and the previous
   char is a null, this signals the start of a string and we bump the count.
*/
int white2null(str, len)
string str;
int len;
d479 2
a480 4

int tabulate(argc, argv)
int argc;
char **argv;
d483 1
a483 1
	string eqptr;
a484 4
	/* Tabulate arguments (if we need to optimize, try
	   defining argvi = *(argv + i) in the i-loop and insert it
	   in place of the argv[i]'s).
	*/
d502 2
a503 2

unsigned int maxgetpar(void)
a504 22
	static int m = 1;		/* sometimes nargs = 0 */
	static bool localfirst = true;
	int i, mm;

	if (xargc == 1) return 0;

	if (first) (void) igetpar("junkname",&i); /* Just to init argtbl */

	if (localfirst) {
		localfirst = false;
		for (i=0; i<nargs; i++) {
			mm = ccount(',',argtbl[i].asciival) + 1;/* 1,2,3 */
			m = MAX(m, mm);
		}
	}
	return m;
}


int ccount(c, s)
char c, *s;
{
d516 1
a516 1
	string name;
d521 1
a521 1
	int i, vi[N], nh, nu, nl, nv, ni, np, nf, nd;
a526 2
	
	printf("first maxgetpar returned %d\n", maxgetpar());
d528 6
a533 34
	if (sgetpar("name", &name))	printf("name=%s\n", name);
	else				printf("name not specified\n");

	if (hgetpar("h", &h))		printf("h=%d\n", h);
	else				printf("h not specified\n");

	if (ugetpar("u", &u))		printf("u=%u\n", u);
	else				printf("u not specified\n");

	if (lgetpar("l", &l))		printf("l=%ld\n", l);
	else				printf("l not specified\n");

	if (vgetpar("v", &v))		printf("v=%lu\n", v);
	else				printf("v not specified\n");

	if (igetpar("i", &i))		printf("i=%d\n", i);
	else				printf("i not specified\n");

	if (pgetpar("p", &p))		printf("p=%u\n", p);
	else				printf("p not specified\n");

	if (fgetpar("f", &f))		printf("f=%g\n", f);
	else				printf("f not specified\n");

	if (dgetpar("d", &d))		printf("d=%g\n", d);
	else				printf("d not specified\n");


	printf("second maxgetpar returned %d\n", maxgetpar());

	nh = hgetpar("vh", vh);
	if (nh) {
		printf("vh=");
		for (i=0;i<nh;i++) printf("%d%c",vh[i],i==nh-1?'\n':',');
d535 11
a545 6
	else			printf("vh not specified\n");

	nu = ugetpar("vu", vu);
	if (nu) {
		printf("vu=");
		for (i=0;i<nu;i++) printf("%u%c",vu[i],i==nu-1?'\n':',');
d547 4
a550 18
	else			printf("vu not specified\n");

	nl = lgetpar("vl", vl);
	if (nl) {
		printf("vl=");
		for (i=0;i<nl;i++) printf("%ld%c",vl[i],i==nl-1?'\n':',');
	}
	else			printf("vl not specified\n");

	nv = vgetpar("vv", vv);
	if (nv) {
		printf("vv=");
		for (i=0;i<nv;i++) printf("%lu%c",vv[i],i==nv-1?'\n':',');
	}
	else			printf("vv not specified\n");

	ni = igetpar("vi", vi);
	if (ni) {
d552 2
a553 1
		for (i=0;i<ni;i++) printf("%d%c",vi[i],i==ni-1?'\n':',');
a554 1
	else			printf("vi not specified\n");
d556 6
a561 4
	np = pgetpar("vp", vp);
	if (np) {
		printf("vp=");
		for (i=0;i<np;i++) printf("%u%c",vp[i],i==np-1?'\n':',');
d563 8
a570 4
	else			printf("vp not specified\n");

	nf = fgetpar("vf", vf);
	if (nf) {
d572 2
a573 1
		for (i=0;i<nf;i++) printf("%g%c",vf[i],i==nf-1?'\n':',');
d575 8
a582 1
	else			printf("vf not specified\n");
d584 6
a589 4
	nd = dgetpar("vd", vd);
	if (nd) {
		printf("vd=");
		for (i=0;i<nd;i++) printf("%g%c",vd[i],i==nd-1?'\n':',');
d591 3
a593 4
	else			printf("vd not specified\n");

	printf("last maxgetpar returned %d\n",maxgetpar());

@


1.4
log
@Using emalloc, etc.
@
text
@d10 1
a10 1
 *  Golden, CO 80401  (isis!csm9a!jkcohen)
d17 1
a17 1
 * zgetpar, sgetpar - get a parameter or vector of parameters of
d55 1
a55 1
 *	int zgetpar(name, ptr)	(Get a double parameter)
d74 1
a74 1
 *	The functions: atohe, atoue, atole, atove, atoie, atope used
d115 1
a115 1
		*ptr++ = atohe(aval);
d139 1
a139 1
		*ptr++ = atoue(aval);
d163 1
a163 1
		*ptr++ = atole(aval);
d187 1
a187 1
		*ptr++ = atove(aval);
d211 1
a211 1
		*ptr++ = atoie(aval);
d235 1
a235 1
		*ptr++ = atope(aval);
d259 1
a259 1
		*ptr++ = (float) atof(aval);
d267 1
a267 1
int zgetpar(name, ptr)
d283 1
a283 1
		*ptr++ = atof(aval);
d376 2
a377 1
	argstr = (char *) calloc((size_t) (1+argstrlen+1), 1);
d399 1
a399 1
	targv = (char **) emalloc((size_t) (targc*sizeof(char*)));
d420 1
a420 2
	argtbl = (pointer_table*)
		emalloc((size_t) (targc*sizeof(pointer_table)));
d551 1
a551 1
	int i, vi[N], nh, nu, nl, nv, ni, np, nf, nz;
d554 1
a554 1
	double z, vz[N];
d584 2
a585 2
	if (zgetpar("z", &z))		printf("z=%g\n", z);
	else				printf("z not specified\n");
d639 4
a642 4
	nz = zgetpar("vz", vz);
	if (nz) {
		printf("vz=");
		for (i=0;i<nz;i++) printf("%g%c",vz[i],i==nz-1?'\n':',');
d644 1
a644 1
	else			printf("vz not specified\n");
@


1.3
log
@Installing efopen broke getpars probably because Shuki used failure
to open the first argument as proof that it wasn't a file.  I removed
the "feature" of having arg1 used as a parfile without the par= string.
@
text
@d376 1
a376 2
	if (NULL==(argstr=(char *)calloc((size_t) (1+argstrlen+1),1)))
		syserr("%s: can't calloc space for %s", __FILE__, pfname);
d398 1
a398 1
	targv = (char **) malloc((size_t) (targc*sizeof(char*)));
d420 1
a420 1
		malloc((size_t) (targc*sizeof(pointer_table)));
@


1.2
log
@Used new fatal forms of atopkge routines.
Various tweaks to ANSI C format.
@
text
@d355 1
a359 15
		/* Allow argv[1] to be the par file -- ugh (Jack) */
		pffd = efopen(xargv[1], "r");
		efseek(pffd, 0, SEEK_END);
		if (eftell(pffd) < LONG_MAX) {
			rewind(pffd);
			parfile = true;
			while (EOF != (i = getc(pffd))) {
				if (iscntrl(i) || !isascii(i)) {
					parfile = false;
					break;
				}
				efclose(pffd);
				if (parfile) pfname = xargv[1];
			}
		}
@


1.1
log
@Initial revision
@
text
@a87 2
#define MAXPFSZ USHRT_MAX

a114 1
		errno = 0;
a115 1
		if (errno) syserr("%s: atohe failed", __FILE__);
a138 1
		errno = 0;
a139 1
		if (errno) syserr("%s: atoue failed", __FILE__);
a162 1
		errno = 0;
a163 1
		if (errno) syserr("%s: atole failed", __FILE__);
a186 1
		errno = 0;
a187 1
		if (errno) syserr("%s: atove failed", __FILE__);
a210 1
		errno = 0;
a211 1
		if (errno) syserr("%s: atoie failed", __FILE__);
a234 1
		errno = 0;
a235 1
		if (errno) syserr("%s: atope failed", __FILE__);
d359 4
a362 4
		/* Allow argv[1] to be the par file */
		if ((NULL != (pffd = fopen(xargv[1],"r"))) &&
		     (fseek(pffd, 0, 2) == 0) &&
		     (ftell(pffd) < MAXPFSZ) ) {
d370 1
a370 1
				fclose(pffd);
d377 2
a378 2
	 	if (NULL == (pffd = fopen(pfname, "r")))
			syserr("%s: can't fopen %s", __FILE__, pfname);
d380 2
a381 5
		if (-1 == fseek(pffd, 0L, SEEK_END)) {
			syserr("%s: fseek to end of %s failed",
							__FILE__, pfname);
		}
		pflen = ftell(pffd);
d390 1
a390 1
	if (NULL==(argstr=(char *)calloc((unsigned int) (1+argstrlen+1),1)))
d393 1
a393 1
	if(parfile) {
d395 4
a398 4
		nread = fread(argstr + 1, 1, pflen, pffd);
		if (nread != pflen) {
	 	    syserr("%s: fread only %d bytes out of %d from %s",
					__FILE__,  nread, pflen, pfname);
d400 1
a400 3
		if (EOF == fclose(pffd)) {
 		       syserr("%s: fclose failed on %s", __FILE__, pfname);
		}
d413 1
a413 1
	targv = (char **) malloc((unsigned int) (targc*sizeof(char*)));
d415 1
a415 1
	if(parfile) {
d435 1
a435 1
		malloc((unsigned int) (targc*sizeof(pointer_table)));
@
