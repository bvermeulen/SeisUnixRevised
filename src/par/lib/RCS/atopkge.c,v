head	1.10;
access;
symbols;
locks; strict;
comment	@ * @;


1.10
date	2011.10.20.21.08.05;	author john;	state Exp;
branches;
next	1.9;

1.9
date	95.08.17.10.30.13;	author john;	state Exp;
branches;
next	1.8;

1.8
date	94.03.14.12.38.54;	author john;	state Exp;
branches;
next	1.7;

1.7
date	94.02.01.10.56.33;	author jkc;	state Exp;
branches;
next	1.6;

1.6
date	94.01.28.14.41.38;	author jkc;	state Exp;
branches;
next	1.5;

1.5
date	94.01.28.10.11.11;	author jkc;	state Exp;
branches;
next	1.4;

1.4
date	90.04.24.15.05.44;	author jkc;	state Exp;
branches;
next	1.3;

1.3
date	90.04.10.19.16.30;	author jkc;	state Exp;
branches;
next	1.2;

1.2
date	90.04.10.18.59.31;	author jkc;	state Exp;
branches;
next	1.1;

1.1
date	90.04.10.18.34.07;	author jkc;	state Exp;
branches;
next	;


desc
@ascii to various int types with error checking
@


1.10
log
@added copyright statement
@
text
@/* Copyright (c) Colorado School of Mines, 2011.*/
/* All rights reserved.                       */

/*********************** self documentation **********************/
/***************************************************************************
ATOPKGE - convert ascii to arithmetic and with error checking

 
eatoh		ascii to short
eatou		ascii to unsigned short
eatoi		ascii to int
eatop		ascii to unsigned
eatol		ascii to long
eatov		ascii to unsigned long
eatof		ascii to float
eatod		ascii to double

****************************************************************************
Function Prototypes:
short eatoh(char *s);
unsigned short eatou(char *s);
int eatoi(char *s);
unsigned int eatop(char *s);
long eatol(char *s);
unsigned long eatov(char *s);
float eatof(char *s);
double eatod(char *s);

****************************************************************************
Input:
s		string 

Returned:	type indicated
 
****************************************************************************
Notes:
Each of these routines acts like atoi, but has error checking:

This is a major revision of the tedious code required before
vendors implemented the ANSI C strtol, strtoul and strtod.

In addition to the size checks for each integer type, a
specific test on errno is required.  For example, INT_MAX
may (and probably does) equal LONG_MAX.  In this case,
if fed a number exceeding INT_MAX (and LONG_MAX), strtol
will make a quiet return with the wrong answer and it is up
to the user to check if errno == ERANGE.

Size limits are machine dependent and are read from the
ANSI C include files limits.h and float.h.

Bug Report: With NeXT c and Gnucc, when x > DBL_MAX (x <-DBL_MAX),
the return value from strtod was +Infinity (-Infinity), not HUGE_VAL
and more important, errno was not set to ERANGE.  To cope with this,
I put explicit size checks in eatod (which would not be needed if
errno were set as it should be in ANSI C.    jkc 01/29/94

On IBM RS6000, the return value from strtod was +-Inf on
overflow, but errno was set correctly.

****************************************************************************
References:
For old code:
Plum: Reliable Data Structures in C, p. 2-17.
Kernighan and Ritchie: The C Programming Language, p. 58.

CWP: Jack K. Cohen, Brian Sumner
 
For new code:
ANSI C routines with a little help from Jack

****************************************************************************
Author: Jack Cohen, Center for Wave Phenomena, 1994.
***************************************************************************/
/**************** end self doc ********************************/

#include "par.h"

#ifndef SUN_A
#include <errno.h>

/* eatoh - convert string s to short integer {SHRT_MIN:SHRT_MAX} */
short eatoh(char *s)
{
	long n = strtol(s, NULL, 10);
	
	if ( (n > SHRT_MAX) || (n < SHRT_MIN) || (errno == ERANGE) )
		err("%s: eatoh: overflow", __FILE__);

	return (short) n;
}


/* eatou - convert string s to unsigned short integer {0:USHRT_MAX} */
unsigned short eatou(char *s)
{
	unsigned long n = strtoul(s, NULL, 10);

	if ( (n > USHRT_MAX) || (errno == ERANGE) )
		err("%s: eatou: overflow", __FILE__);

	return (unsigned short) n;
}


/* eatoi - convert string s to integer {INT_MIN:INT_MAX} */
int eatoi(char *s)
{
	long n = strtol(s, NULL, 10);

	if ( (n > INT_MAX) || (n < INT_MIN) || (errno == ERANGE) )
		err("%s: eatoi: overflow", __FILE__);

	return (int) n;
}


/* eatop - convert string s to unsigned integer {0:UINT_MAX} */
unsigned int eatop(char *s)
{
	unsigned long n = strtoul(s, NULL, 10);

	if ( (n > UINT_MAX) || (errno == ERANGE) )
		err("%s: eatop: overflow", __FILE__);

	return (unsigned int) n;
}


/* eatol - convert string s to long integer {LONG_MIN:LONG_MAX} */
long eatol(char *s)
{
	long n = strtol(s, NULL, 10);

	if (errno == ERANGE)
		err("%s: eatol: overflow", __FILE__);

	return n;
}


/* eatov - convert string s to unsigned long {0:ULONG_MAX} */
unsigned long eatov(char *s)
{
	unsigned long n = strtoul(s, NULL, 10);

	if (errno == ERANGE)
		err("%s: eatov: overflow", __FILE__);

	return n;
}


/* eatof - convert string s to float {-FLT_MAX:FLT_MAX} */
float eatof(char *s)
{
	float x = strtod(s, NULL);

	if ( (x > FLT_MAX) || (x < -FLT_MAX) || (errno == ERANGE) )
		err("%s: eatof: overflow", __FILE__);

	return (float) x;
}


/* eatod - convert string s to double {-DBL_MAX:DBL_MAX} */
double eatod(char *s)
{
	double x = strtod(s, NULL);

	/* errno == ERANGE suffices if compiler sets errno on overflow */
	if ( (errno == ERANGE) || (x > DBL_MAX) || (x < -DBL_MAX) )
		err("%s: eatod: overflow", __FILE__);

	return x;
}

#else   /* if SUN_A is defined */
/* old one resurrected because SUN 2 didn't have strtoul */

/* atopkge - convert ascii to arithmetic and with error checking
 *
 * eatoh	- ascii to short
 * eatou	- ascii to unsigned short
 * eatoi	- ascii to int
 * eatop	- ascii to unsigned
 * eatol	- ascii to long
 * eatov	- ascii to unsigned long
 * eatof	- ascii to float (dummy sub)
 * eatod	- ascii to double (dummy sub)
 *
 * Returns:
 *	eatoh: short int
 *	eatou: unsigned short int
 *	eatoi: int
 *	eatop: unsigned int
 *	eatol: long int
 *	eatov: unsigned long int
 *	eatof: float
 *	eatod: double
 *
 * Synopsis:
 *	short eatoh(s)
 *	char s[];
 *
 *	unsigned short eatou(s)
 *	char s[];
 *
 *	int eatoi(s)
 *	char s[];
 *
 *	unsigned eatop(s)
 *	char s[];
 *
 *	long eatol(s)
 *	char s[];
 *
 *	unsigned long eatov(s)
 *	char s[];
 *
 *	float eatof(s)
 *	char s[];
 *
 *	double eatod(s)
 *	char s[];
 *
 * Notes:
 *	I haven't a clue as to how to write eatof and eatod, but when
 *	vendors come up to snuff on the ANSI C prescribed error returns
 *	for strtod, it'll be a piece of cake.  And when strtol, strtoul
 *	are likewise properly implemented, the remaining routines in this
 *	package will simplify materially.  For now, eatof and eatod are
 *	just place holders that don't really check for errors.
 *
 *	The overflow error check on a type that fills an unsigned long
 *	is different and a bit slower than the others.  Still, it might
 *      be better to use it in eatou and eatop as well and avoid the
 *	(possible) additional function call.
 *
 *	The code relies on the fact that converting unsigned to signed
 *	has no surprises for numbers in the lower half of the range.
 *
 *	Size limits on the integer data types are machine dependent and
 *      are read from the file limits.h.
 *
 * Credits:
 *	Plum: Reliable Data Structures in C, p. 2-17.
 *	Kernighan and Ritchie: The C Programming Language, p. 58.
 *	CWP: Jack, Brian
 *
 *
 */

/* eatoh - convert string s to short integer {SHRT_MIN:SHRT_MAX}    *
 * We store the absolute value of the converted string in an        *
 * unsigned long so we can test it for overflow.                    */
short eatoh(char *s)
{
	unsigned long n;
	int i;
	short sign = 1;
	long eatol();

	for (i = 0; isspace(s[i]); ++i) ;	/* skip white space */

	if (s[i] == '+' || s[i] == '-') {
		sign = (s[i++] == '+') ? 1 : -1;
	}

	for (n = 0; isdigit(s[i]) && n <= SHRT_MAX/10; ++i) {
		n = 10 * n + (s[i] - '0');
	}

	if ((sign ==  1) && (n > SHRT_MAX) ||
	    (sign == -1) && (n > SHRT_MIN) || isdigit(s[i]))
		err("%s: eatoh: overflow", __FILE__);

	return  sign * (short) n;
}


/* eatou - convert string s to unsigned short integer {0:USHRT_MAX} *
 * If USHRT_MAX < ULONG_MAX, we can temporarily fit the converted   *
 * number in an unsigned long with room to check for overflow       *
 * condition.  If not, we forward the string to the unsigned long   *
 * routine.                                                         */
unsigned short eatou(char *s)
{
	unsigned long n;
	int i;
	unsigned long eatov();

	if (USHRT_MAX == ULONG_MAX)  return (unsigned short) eatov(s);

	for (i = 0; isspace(s[i]); ++i) ;  /* skip white space */

	if (s[i] == '-')
		err("%s: eatou: saw negative number", __FILE__);

	for (n = 0; isdigit(s[i]) && n <= USHRT_MAX/10; ++i) {
		n = 10 * n + (s[i] - '0');
	}
	if (n > USHRT_MAX || isdigit(s[i]))
		err("%s: eatou: overflow", __FILE__);

	return (unsigned short) n;
}


/* eatoi - convert string s to short integer {INT_MIN:INT_MAX}    *
 * The logic is the same as for eatou with INT_MAX replacing      *
 * SHRT_MAX and INT_MIN replacing SHRT_MIN.                       */
int eatoi(char *s)
{
	unsigned long n;
	int i;
	int sign = 1;
	long eatol();

	if (INT_MAX == LONG_MAX) return (int) eatol(s);

	for (i = 0; isspace(s[i]); ++i) ;	/* skip white space */

	if (s[i] == '+' || s[i] == '-') {
		sign = (s[i++] == '+') ? 1 : -1;
	}

	for (n = 0; isdigit(s[i]) && n <= INT_MAX/10; ++i) {
		n = 10 * n + (s[i] - '0');
	}

	if ((sign ==  1) && (n > INT_MAX) ||
	    (sign == -1) && (n > INT_MIN) || isdigit(s[i]))
		err("%s: eatoi: overflow", __FILE__);

	return  sign * (int) n;
}


/* eatop - convert string s to unsigned integer {0:UINT_MAX}        *
 * The logic is the same as for eatou with UINT_MAX replacing       *
 * USHRT_MAX.                                                       */
unsigned int eatop(char *s)
{
	unsigned long n;
	int i;
	unsigned long eatov();

	if (UINT_MAX == ULONG_MAX) return((unsigned int) eatov(s));

	for (i = 0; isspace(s[i]); ++i) ;  /* skip white space */

	if (s[i] == '-')
		err("%s: eatop: saw negative number", __FILE__);

	for (n = 0; isdigit(s[i]) && n <= UINT_MAX/10; ++i) {
		n = 10 * n + (s[i] - '0');
	}
	if (n > UINT_MAX || isdigit(s[i]))
		err("%s: eatop: overflow", __FILE__);

	return (unsigned int) n;
}


/* eatol - convert string s to long integer {LONG_MIN:LONG_MAX}     *
 * We store the absolute value of the converted string in an        *
 * unsigned long so we can test it for overflow.                    */
long eatol(char *s)
{
	unsigned long n;
	int i;
	int sign = 1L;

	for (i = 0; isspace(s[i]); ++i) ;	/* skip white space */

	if (s[i] == '+' || s[i] == '-') {
		sign = (s[i++] == '+') ? 1L : -1L;
	}

	for (n = 0L; isdigit(s[i]) && n <= LONG_MAX/10L; ++i) {
		n = 10L * n + (s[i] - '0');
	}

	if ((sign ==  1L) && (n > LONG_MAX)   ||
	    (sign == -1L) && (n > LONG_MIN) || isdigit(s[i]))
		err("%s: eatol: overflow", __FILE__);

	return  sign * (long) n;
}


/* eatov - convert string s to unsigned long {0:ULONG_MAX}          *
 * Here, we check for overflow by seeing whether n decreases.       */
unsigned long eatov(char *s)
{
	unsigned long n;
	unsigned long n_old;
	int i;

	for (i = 0; isspace(s[i]); ++i) ;  /* skip white space */

	if (s[i] == '-')
		err("%s: eatov: saw negative number", __FILE__);

	for (n_old = 0L, n = 0L; isdigit(s[i]); ++i) {
		n = 10L * n + (s[i] - '0');
		if (n < n_old)
			err("%s: eatov: overflow", __FILE__);
		n_old = n;
	}

	return n;
}

/* Dummy atof, atod routines until the ANSI police get here */
float eatof(char *s)
{
	return (float) atof(s);
}


double eatod(char *s)
{
	return atof(s);
}

#endif /* SUN_A */

#ifdef TEST
main(int argc, char **argv)
{
	char s[BUFSIZ];
	short nh;
	unsigned short nu;
	int ni;
	unsigned int np;
	long nl;
	unsigned long nv;

	initargs(argc, argv);


	/* Test code for eatoh */
	if (SHRT_MAX == LONG_MAX) {
	    warn("Warning: eatoh not used on this machine.\n");
	} else {
	    warn("\n");
	}
	strcpy(s, "0");
	nh = eatoh(s);
	warn("eatoh(%s) = %hd\n", s, nh);

	strcpy(s, "32767");
	nh = eatoh(s);
	warn("eatoh(%s) = %hd\n", s, nh);

	strcpy(s, "-32768");
	nh = eatoh(s);
	warn("eatoh(%s) = %hd\n", s, nh);


	/* Test code for eatou */
	if (USHRT_MAX == ULONG_MAX) {
	    warn("Warning: eatou not used on this machine.\n");
	} else {
	    warn("\n");
	}
	strcpy(s, "0");
	nu = eatou(s);
	warn("eatou(%s) = %hu\n", s, nu);

	strcpy(s, "65535");
	nu = eatou(s);
	warn("eatou(%s) = %hu\n", s, nu);


	/* Test code for eatoi */
	if (INT_MAX == LONG_MAX) {
	    warn("Warning: eatoi not used on this machine.\n");
	} else {
	    warn("\n");
	}
	strcpy(s, "0");
	ni = eatoi(s);
	warn("eatoi(%s) = %d\n", s, ni);

	strcpy(s, "2147483647");
	ni = eatoi(s);
	warn("eatoi(%s) = %d\n", s, ni);


	strcpy(s, "-2147483648");
	ni = eatoi(s);
	warn("eatoi(%s) = %d\n", s, ni);


	/* Test code for eatop */
	if (INT_MAX == LONG_MAX) {
	    warn("Warning: eatop not used on this machine.\n");
	} else {
	    warn("\n");
	}
	strcpy(s, "0");
	np = eatop(s);
	warn("eatop(%s) = %lu\n", s, np);

	strcpy(s, "4294967295");
	np = eatop(s);
	warn("eatop(%s) = %lu\n", s, np);


	/* Test code for eatol */
	warn("\n");
	strcpy(s, "0");
	nl = eatol(s);
	warn("eatol(%s) = %ld\n", s, nl);

	strcpy(s, "2147483647");
	nl = eatol(s);
	warn("eatol(%s) = %ld\n", s, nl);

	strcpy(s, "-2147483648");
	nl = eatol(s);
	warn("eatol(%s) = %ld\n", s, nl);


	/* Test code for eatov */
	strcpy(s, "0");
	nv = eatov(s);
	warn("eatov(%s) = %lu\n", s, nv);

	strcpy(s, "4294967295");
	nv = eatov(s);
	warn("eatov(%s) = %lu\n", s, nv);

	warn("Now we feed in 4294967296, expecting fatal error exit\n");
	strcpy(s, "4294967296");
	nv = eatov(s);
	warn("eatov(%s) = %lu\n", s, nv);

	return EXIT_SUCCESS;
}
#endif
@


1.9
log
@added SUN_A ifdefs to handle cases where people are installing with
GCC on SUN but are using the native C libraries, rather than the
GLIBC libraries.
@
text
@d1 3
@


1.8
log
@added dummy selfdocs
@
text
@d75 2
d175 2
d178 249
a436 2
	float xf;
	double xd;
d442 5
a446 4
	warn("\nMachine constants for eatoh:");
	sprintf(s, "%hd", SHRT_MAX); warn("SHRT_MAX = %hd", SHRT_MAX);
	sprintf(s, "%hd", SHRT_MIN); warn("SHRT_MIN = %hd", SHRT_MIN);
	
a447 1
	warn("testing s = %s", s);
d449 1
a449 1
	warn("eatoh(%s) = %hd", s, nh);
d451 1
a451 2
	sprintf(s, "%hd", SHRT_MAX);
	warn("testing s = %s", s);
d453 1
a453 1
	warn("eatoh(%s) = %hd", s, nh);
d455 1
a455 2
	sprintf(s, "%hd", SHRT_MIN);
	warn("testing s = %s", s);
d457 1
a457 1
	warn("eatoh(%s) = %hd", s, nh);
a458 11
/* Fatal Error Checks; obviously can only run one at a time! */
/*
	warn("ALERT: testing 32768, probably an overflow");
	strcpy(s, "32768");
	nh = eatoh(s);
*/
/*
	warn("ALERT: testing -32769, probably an overflow");
	strcpy(s, "-32769");
	nh = eatoh(s);
*/
d461 5
a465 3
	warn("\nMachine constant for eatou:");
	sprintf(s, "%hu", USHRT_MAX); warn("USHRT_MAX = %hu", USHRT_MAX);
	
a466 1
	warn("testing s = %s", s);
d468 1
a468 1
	warn("eatou(%s) = %hu", s, nu);
d470 1
a470 2
	sprintf(s, "%hu", USHRT_MAX);
	warn("testing s = %s", s);
d472 1
a472 8
	warn("eatou(%s) = %hu", s, nu);
	
/* Fatal Error Checks; obviously can only run one at a time! */
/*
	warn("ALERT: testing 65536, probably an overflow");
	strcpy(s, "65536");
	nh = eatou(s);
*/
d476 5
a480 4
	warn("\nMachine constants for eatoi:");
	sprintf(s, "%d", INT_MAX); warn("INT_MAX = %d", INT_MAX);
	sprintf(s, "%d", INT_MIN); warn("INT_MIN = %d", INT_MIN);
	
a481 1
	warn("testing s = %s", s);
d483 1
a483 1
	warn("eatoi(%s) = %d", s, ni);
d485 1
a485 2
	sprintf(s, "%d", INT_MAX);
	warn("testing s = %s", s);
d487 1
a487 1
	warn("eatoi(%s) = %d", s, ni);
a488 4
	sprintf(s, "%d", INT_MIN);
	warn("testing s = %s", s);
	ni = eatoi(s);
	warn("eatoi(%s) = %d", s, ni);
d490 1
a490 4
/* Fatal Error Checks; obviously can only run one at a time! */
/*
	warn("ALERT: testing 2147483648, probably an overflow");
	strcpy(s, "2147483648");
d492 1
a492 6
*/
/*
	warn("ALERT: testing -2147483649, probably an overflow");
	strcpy(s, "-2147483649");
	ni = eatoi(s);
*/
d496 5
a500 3
	warn("\nMachine constant for eatop:");
	sprintf(s, "%u", UINT_MAX); warn("UINT_MAX = %u", UINT_MAX);

a501 1
	warn("testing s = %s", s);
d503 1
a503 1
	warn("eatop(%s) = %u", s, np);
d505 1
a505 2
	sprintf(s, "%u", UINT_MAX);
	warn("testing s = %s", s);
d507 1
a507 1
	warn("eatop(%s) = %u", s, np);
a508 6
/* Fatal Error Checks; obviously can only run one at a time! */
/*
	warn("ALERT: testing 4294967296, probably an overflow");
	strcpy(s, "4294967296");
	np = eatop(s);
*/
a509 1

d511 1
a511 4
	warn("\nMachine constants:");
	sprintf(s, "%ld", LONG_MAX); warn("LONG_MAX = %ld", LONG_MAX);
	sprintf(s, "%ld", LONG_MIN); warn("LONG_MIN = %ld", LONG_MIN);
	
a512 1
	warn("testing s = %s", s);
d514 1
a514 1
	warn("eatol(%s) = %ld", s, nl);
d516 1
a516 2
	sprintf(s, "%ld", LONG_MAX);
	warn("testing s = %s", s);
d518 1
a518 1
	warn("eatol(%s) = %ld", s, nl);
d520 1
a520 2
	sprintf(s, "%ld", LONG_MIN);
	warn("testing s = %s", s);
d522 1
a522 1
	warn("eatol(%s) = %ld", s, nl);
a523 11
/* Fatal Error Checks; obviously can only run one at a time! */
/*
	warn("ALERT: testing 2147483648, probably an overflow");
	strcpy(s, "2147483648");
	nl = eatol(s);
*/
/*
	warn("ALERT: testing -2147483649, probably an overflow");
	strcpy(s, "-2147483649");
	nl = eatol(s);
*/
a524 1

a525 3
	warn("\nMachine constant for eatov:");
	sprintf(s, "%lu", ULONG_MAX); warn("ULONG_MAX = %lu", ULONG_MAX);

a526 1
	warn("testing s = %s", s);
d528 1
a528 1
	warn("eatov(%s) = %lu", s, nv);
d530 1
a530 2
	sprintf(s, "%lu", ULONG_MAX);
	warn("testing s = %s", s);
d532 1
a532 1
	warn("eatov(%s) = %lu", s, nv);
d534 1
a534 3
/* Fatal Error Checks; obviously can only run one at a time! */
/*
	warn("ALERT: testing 4294967296, probably an overflow");
d537 1
a537 1
*/
a538 64

	/* Test code for eatof */
	warn("\nMachine constant for eatof:");
	sprintf(s, "%g", FLT_MAX); warn("FLT_MAX = %g", FLT_MAX);

	strcpy(s, "0");
	warn("testing s = %s", s);
	xf = eatof(s);
	warn("eatof(%s) = %g", s, xf);

	sprintf(s, "%g", FLT_MAX);
	warn("testing s = %s", s);
	xf = eatof(s);
	warn("eatof(%s) = %g", s, xf);

	sprintf(s, "%g", -FLT_MAX);
	warn("testing s = %s", s);
	xf = eatof(s);
	warn("eatof(%s) = %g", s, xf);

/* Fatal Error Checks; obviously can only run one at a time! */
/*
	warn("ALERT: testing 3.5e+38f, probably an overflow");
	strcpy(s, "3.5e+38f");
	xf = eatof(s);
*/
/*
	warn("ALERT: testing -3.5e+38f, probably an overflow");
	strcpy(s, "-3.5e+38f");
	xf = eatof(s);
*/


	/* Test code for eatod */
	warn("\nMachine constant for eatod:");
	sprintf(s, "%g", DBL_MAX); warn("DBL_MAX = %g", DBL_MAX);

	strcpy(s, "0");
	warn("testing s = %s", s);
	xd = eatod(s);
	warn("eatod(%s) = %g", s, xd);

	sprintf(s, "%g", DBL_MAX);
	warn("testing s = %s", s);
	xd = eatod(s);
	warn("eatod(%s) = %g", s, xd);

	sprintf(s, "%g", -DBL_MAX);
	warn("testing s = %s", s);
	xd = eatod(s);
	warn("eatod(%s) = %g", s, xd);

/* Fatal Error Checks; obviously can only run one at a time! */
/*
	warn("ALERT: testing 1.8e+308, probably an overflow");
	strcpy(s, "1.8e+308");
	xd = eatod(s);
*/

	warn("ALERT: testing -1.8e+308, probably an overflow");
	strcpy(s, "-1.8e+308");
	xd = eatod(s);

		
@


1.7
log
@Major revision: uses ANSI C strtol, strtoul, strtod to do the
heavy lifting.  Provision made for gnu cc failure to set errno
on overflow.  For first time, floats and doubles are also checked
for overflow.  Much tedious code eliminated.
@
text
@d1 73
a75 47

/* atopkge - convert ascii to arithmetic and with error checking
 *
 * Each of these routines acts like atoi, but has error checking:
 * eatoh	- ascii to short
 * eatou	- ascii to unsigned short
 * eatoi	- ascii to int
 * eatop	- ascii to unsigned
 * eatol	- ascii to long
 * eatov	- ascii to unsigned long
 * eatof	- ascii to float
 * eatod	- ascii to double
 *
 * Notes:
 *	This is a major revision of the tedious code required before
 *	vendors implemented the ANSI C strtol, strtoul and strtod.
 *
 *	In addition to the size checks for each integer type, a
 *	specific test on errno is required.  For example, INT_MAX
 *	may (and probably does) equal LONG_MAX.  In this case,
 *	if fed a number exceeding INT_MAX (and LONG_MAX), strtol
 *	will make a quiet return with the wrong answer and it is up
 * 	to the user to check if errno == ERANGE.
 *
 *	Size limits are machine dependent and are read from the
 *      ANSI C include files limits.h and float.h.
 *
 * 	Bug Report: With NeXT c and Gnucc, when x > DBL_MAX (x <-DBL_MAX),
 *	the return value from strtod was +Infinity (-Infinity), not HUGE_VAL
 *	and more important, errno was not set to ERANGE.  To cope with this,
 *	I put explicit size checks in eatod (which would not be needed if
 *	errno were set as it should be in ANSI C.    jkc 01/29/94
 *
 *	On IBM RS6000, the return value from strtod was +-Inf on
 *	overflow, but errno was set correctly.
 *
 * Credits:
 *	For old code:
 *	Plum: Reliable Data Structures in C, p. 2-17.
 *	Kernighan and Ritchie: The C Programming Language, p. 58.
 *	CWP: Jack, Brian
 *
 *	For new code:
 *	ANSI C routines with a little help from Jack
 *
 *
 */
@


1.6
log
@removed copyright statement, stray occurences of 'ushort'
@
text
@d2 1
d6 1
d13 2
a14 2
 * eatof	- ascii to float (dummy sub)
 * eatod	- ascii to double (dummy sub)
d16 3
a18 9
 * Returns:
 *	eatoh: short int
 *	eatou: unsigned short int
 *	eatoi: int
 *	eatop: unsigned int
 *	eatol: long int
 *	eatov: unsigned long int
 *	eatof: float
 *	eatod: double
d20 6
a25 3
 * Synopsis:
 *	short eatoh(s)
 *	char s[];
d27 2
a28 2
 *	unsigned short eatou(s)
 *	char s[];
d30 5
a34 2
 *	int eatoi(s)
 *	char s[];
d36 2
a37 2
 *	unsigned eatop(s)
 *	char s[];
a38 31
 *	long eatol(s)
 *	char s[];
 *
 *	unsigned long eatov(s)
 *	char s[];
 *
 *	float eatof(s)
 *	char s[];
 *
 *	double eatod(s)
 *	char s[];
 *
 * Notes:
 *	I haven't a clue as to how to write eatof and eatod, but when
 *	vendors come up to snuff on the ANSI C prescribed error returns
 *	for strtod, it'll be a piece of cake.  And when strtol, strtoul
 *	are likewise properly implemented, the remaining routines in this
 *	package will simplify materially.  For now, eatof and eatod are
 *	just place holders that don't really check for errors.
 *
 *	The overflow error check on a type that fills an unsigned long
 *	is different and a bit slower than the others.  Still, it might
 *      be better to use it in eatou and eatop as well and avoid the
 *	(possible) additional function call.
 *
 *	The code relies on the fact that converting unsigned to signed
 *	has no surprises for numbers in the lower half of the range.
 *
 *	Size limits on the integer data types are machine dependent and
 *      are read from the file limits.h.
 *
d40 1
d45 2
d48 1
d51 1
a51 3
/* eatoh - convert string s to short integer {SHRT_MIN:SHRT_MAX}    *
 * We store the absolute value of the converted string in an        *
 * unsigned long so we can test it for overflow.                    */
d54 3
a56 17
	unsigned long n;
	int i;
	short sign = 1;
	long eatol();

	for (i = 0; isspace(s[i]); ++i) ;	/* skip white space */

	if (s[i] == '+' || s[i] == '-') {
		sign = (s[i++] == '+') ? 1 : -1;
	}

	for (n = 0; isdigit(s[i]) && n <= SHRT_MAX/10; ++i) {
		n = 10 * n + (s[i] - '0');
	}

	if ((sign ==  1) && (n > SHRT_MAX) ||
	    (sign == -1) && (n > SHRT_MIN) || isdigit(s[i]))
d59 1
a59 1
	return  sign * (short) n;
d63 1
a63 5
/* eatou - convert string s to unsigned short integer {0:USHRT_MAX} *
 * If USHRT_MAX < ULONG_MAX, we can temporarily fit the converted   *
 * number in an unsigned long with room to check for overflow       *
 * condition.  If not, we forward the string to the unsigned long   *
 * routine.                                                         */
d66 1
a66 3
	unsigned long n;
	int i;
	unsigned long eatov();
d68 1
a68 11
	if (USHRT_MAX == ULONG_MAX)  return (unsigned short) eatov(s);

	for (i = 0; isspace(s[i]); ++i) ;  /* skip white space */

	if (s[i] == '-')
		err("%s: eatou: saw negative number", __FILE__);

	for (n = 0; isdigit(s[i]) && n <= USHRT_MAX/10; ++i) {
		n = 10 * n + (s[i] - '0');
	}
	if (n > USHRT_MAX || isdigit(s[i]))
d75 1
a75 3
/* eatoi - convert string s to short integer {INT_MIN:INT_MAX}    *
 * The logic is the same as for eatou with INT_MAX replacing      *
 * SHRT_MAX and INT_MIN replacing SHRT_MIN.                       */
d78 1
a78 4
	unsigned long n;
	int i;
	int sign = 1;
	long eatol();
d80 1
a80 14
	if (INT_MAX == LONG_MAX) return (int) eatol(s);

	for (i = 0; isspace(s[i]); ++i) ;	/* skip white space */

	if (s[i] == '+' || s[i] == '-') {
		sign = (s[i++] == '+') ? 1 : -1;
	}

	for (n = 0; isdigit(s[i]) && n <= INT_MAX/10; ++i) {
		n = 10 * n + (s[i] - '0');
	}

	if ((sign ==  1) && (n > INT_MAX) ||
	    (sign == -1) && (n > INT_MIN) || isdigit(s[i]))
d83 1
a83 1
	return  sign * (int) n;
d87 1
a87 3
/* eatop - convert string s to unsigned integer {0:UINT_MAX}        *
 * The logic is the same as for eatou with UINT_MAX replacing       *
 * USHRT_MAX.                                                       */
d90 1
a90 3
	unsigned long n;
	int i;
	unsigned long eatov();
d92 1
a92 11
	if (UINT_MAX == ULONG_MAX) return((unsigned int) eatov(s));

	for (i = 0; isspace(s[i]); ++i) ;  /* skip white space */

	if (s[i] == '-')
		err("%s: eatop: saw negative number", __FILE__);

	for (n = 0; isdigit(s[i]) && n <= UINT_MAX/10; ++i) {
		n = 10 * n + (s[i] - '0');
	}
	if (n > UINT_MAX || isdigit(s[i]))
d99 1
a99 3
/* eatol - convert string s to long integer {LONG_MIN:LONG_MAX}     *
 * We store the absolute value of the converted string in an        *
 * unsigned long so we can test it for overflow.                    */
d102 1
a102 3
	unsigned long n;
	int i;
	int sign = 1L;
d104 1
a104 12
	for (i = 0; isspace(s[i]); ++i) ;	/* skip white space */

	if (s[i] == '+' || s[i] == '-') {
		sign = (s[i++] == '+') ? 1L : -1L;
	}

	for (n = 0L; isdigit(s[i]) && n <= LONG_MAX/10L; ++i) {
		n = 10L * n + (s[i] - '0');
	}

	if ((sign ==  1L) && (n > LONG_MAX)   ||
	    (sign == -1L) && (n > LONG_MIN) || isdigit(s[i]))
d107 1
a107 1
	return  sign * (long) n;
d111 1
a111 2
/* eatov - convert string s to unsigned long {0:ULONG_MAX}          *
 * Here, we check for overflow by seeing whether n decreases.       */
d114 1
a114 3
	unsigned long n;
	unsigned long n_old;
	int i;
d116 2
a117 1
	for (i = 0; isspace(s[i]); ++i) ;  /* skip white space */
a118 10
	if (s[i] == '-')
		err("%s: eatov: saw negative number", __FILE__);

	for (n_old = 0L, n = 0L; isdigit(s[i]); ++i) {
		n = 10L * n + (s[i] - '0');
		if (n < n_old)
			err("%s: eatov: overflow", __FILE__);
		n_old = n;
	}

d122 2
a123 1
/* Dummy atof, atod routines until the ANSI police get here */
d126 6
a131 1
	return (float) atof(s);
d135 1
d138 7
a144 1
	return atof(s);
d158 2
d165 4
a168 5
	if (SHRT_MAX == LONG_MAX) {
	    warn("Warning: eatoh not used on this machine.\n");
	} else {
	    warn("\n");
	}
d170 1
d172 1
a172 1
	warn("eatoh(%s) = %hd\n", s, nh);
d174 2
a175 1
	strcpy(s, "32767");
d177 1
a177 1
	warn("eatoh(%s) = %hd\n", s, nh);
d179 2
a180 1
	strcpy(s, "-32768");
d182 1
a182 1
	warn("eatoh(%s) = %hd\n", s, nh);
d184 11
d197 3
a199 5
	if (USHRT_MAX == ULONG_MAX) {
	    warn("Warning: eatou not used on this machine.\n");
	} else {
	    warn("\n");
	}
d201 1
d203 1
a203 1
	warn("eatou(%s) = %hu\n", s, nu);
d205 2
a206 1
	strcpy(s, "65535");
d208 8
a215 1
	warn("eatou(%s) = %hu\n", s, nu);
d219 4
a222 5
	if (INT_MAX == LONG_MAX) {
	    warn("Warning: eatoi not used on this machine.\n");
	} else {
	    warn("\n");
	}
d224 1
d226 1
a226 1
	warn("eatoi(%s) = %d\n", s, ni);
d228 2
a229 1
	strcpy(s, "2147483647");
d231 1
a231 1
	warn("eatoi(%s) = %d\n", s, ni);
d233 4
d238 4
a241 1
	strcpy(s, "-2147483648");
d243 6
a248 1
	warn("eatoi(%s) = %d\n", s, ni);
d252 3
a254 5
	if (INT_MAX == LONG_MAX) {
	    warn("Warning: eatop not used on this machine.\n");
	} else {
	    warn("\n");
	}
d256 1
d258 1
a258 1
	warn("eatop(%s) = %lu\n", s, np);
d260 2
a261 1
	strcpy(s, "4294967295");
d263 1
a263 1
	warn("eatop(%s) = %lu\n", s, np);
d265 6
d272 1
d274 4
a277 1
	warn("\n");
d279 1
d281 1
a281 1
	warn("eatol(%s) = %ld\n", s, nl);
d283 2
a284 1
	strcpy(s, "2147483647");
d286 1
a286 1
	warn("eatol(%s) = %ld\n", s, nl);
d288 2
a289 1
	strcpy(s, "-2147483648");
d291 1
a291 1
	warn("eatol(%s) = %ld\n", s, nl);
d293 11
d305 1
d307 3
d311 1
d313 1
a313 1
	warn("eatov(%s) = %lu\n", s, nv);
d315 2
a316 1
	strcpy(s, "4294967295");
d318 1
a318 1
	warn("eatov(%s) = %lu\n", s, nv);
d320 3
a322 1
	warn("Now we feed in 4294967296, expecting fatal error exit\n");
d325 1
a325 1
	warn("eatov(%s) = %lu\n", s, nv);
d327 64
@


1.5
log
@Put warning before fatal exit in test driver.
Removed the copyright heading that suggested mail to isis!csm9a.
@
text
@d109 1
a109 1
ushort eatou(char *s)
d115 1
a115 1
	if (USHRT_MAX == ULONG_MAX)  return (ushort) eatov(s);
d128 1
a128 1
	return (ushort) n;
d256 1
a256 1
	ushort nu;
@


1.4
log
@atoie -> eatoi and so forth.  eatof and eatod are dummysubs.
@
text
@a0 13
/*----------------------------------------------------------------------
 * Copyright (c) Colorado School of Mines, 1989.
 * All rights reserved.
 *
 * This code is part of SU.  SU stands for Seismic Unix, a processing line
 * developed at the Colorado School of Mines, partially based on Stanford
 * Exploration Project (SEP) software.  Inquiries should be addressed to:
 *
 *  Jack K. Cohen, Center for Wave Phenomena, Colorado School of Mines,
 *  Golden, CO 80401  (isis!csm9a!jkcohen)
 *----------------------------------------------------------------------
 */

d358 1
@


1.3
log
@Fixed driver by taking out all but the last bad number.
@
text
@d18 8
a25 6
 * atohe	- ascii to short
 * atoue	- ascii to unsigned short
 * atoie	- ascii to int
 * atope	- ascii to unsigned
 * atole	- ascii to long
 * atove	- ascii to unsigned long
d28 8
a35 6
 *	atohe: short int
 *	atoue: unsigned short int
 *	atoie: int
 *	atope: unsigned int
 *	atole: long int
 *	atove: unsigned long int
d38 1
a38 1
 *	short atohe(s)
d41 1
a41 1
 *	unsigned short atoue(s)
d44 1
a44 1
 *	int atoie(s)
d47 1
a47 1
 *	unsigned atope(s)
d50 1
a50 1
 *	long atole(s)
d53 1
a53 1
 *	unsigned long atove(s)
d56 6
d63 7
d72 1
a72 1
 *      be better to use it in atoue and atope as well and avoid the
d89 1
a89 1
/* atohe - convert string s to short integer {SHRT_MIN:SHRT_MAX}    *
d92 1
a92 1
short atohe(char *s)
d97 1
a97 1
	long atole();
d111 1
a111 1
		err("%s: atohe: overflow", __FILE__);
d117 1
a117 1
/* atoue - convert string s to unsigned short integer {0:USHRT_MAX} *
d122 1
a122 1
ushort atoue(char *s)
d126 1
a126 1
	unsigned long atove();
d128 1
a128 1
	if (USHRT_MAX == ULONG_MAX)  return (ushort) atove(s);
d133 1
a133 1
		err("%s: atoue: saw negative number", __FILE__);
d139 1
a139 1
		err("%s: atoue: overflow", __FILE__);
d145 2
a146 2
/* atoie - convert string s to short integer {INT_MIN:INT_MAX}    *
 * The logic is the same as for atoue with INT_MAX replacing      *
d148 1
a148 1
int atoie(char *s)
d153 1
a153 1
	long atole();
d155 1
a155 1
	if (INT_MAX == LONG_MAX) return (int) atole(s);
d169 1
a169 1
		err("%s: atoie: overflow", __FILE__);
d175 2
a176 2
/* atope - convert string s to unsigned integer {0:UINT_MAX}        *
 * The logic is the same as for atoue with UINT_MAX replacing       *
d178 1
a178 1
unsigned int atope(char *s)
d182 1
a182 1
	unsigned long atove();
d184 1
a184 1
	if (UINT_MAX == ULONG_MAX) return((unsigned int) atove(s));
d189 1
a189 1
		err("%s: atope: saw negative number", __FILE__);
d195 1
a195 1
		err("%s: atope: overflow", __FILE__);
d201 1
a201 1
/* atole - convert string s to long integer {LONG_MIN:LONG_MAX}     *
d204 1
a204 1
long atole(char *s)
d222 1
a222 1
		err("%s: atole: overflow", __FILE__);
d228 1
a228 1
/* atove - convert string s to unsigned long {0:ULONG_MAX}          *
d230 1
a230 1
unsigned long atove(char *s)
d239 1
a239 1
		err("%s: atove: saw negative number", __FILE__);
d244 1
a244 1
			err("%s: atove: overflow", __FILE__);
d251 5
d257 7
d278 1
a278 1
	/* Test code for atohe */
d280 1
a280 1
	    warn("Warning: atohe not used on this machine.\n");
d285 2
a286 2
	nh = atohe(s);
	warn("atohe(%s) = %hd\n", s, nh);
d289 2
a290 2
	nh = atohe(s);
	warn("atohe(%s) = %hd\n", s, nh);
d293 2
a294 2
	nh = atohe(s);
	warn("atohe(%s) = %hd\n", s, nh);
d297 1
a297 1
	/* Test code for atoue */
d299 1
a299 1
	    warn("Warning: atoue not used on this machine.\n");
d304 2
a305 2
	nu = atoue(s);
	warn("atoue(%s) = %hu\n", s, nu);
d308 2
a309 2
	nu = atoue(s);
	warn("atoue(%s) = %hu\n", s, nu);
d312 1
a312 1
	/* Test code for atoie */
d314 1
a314 1
	    warn("Warning: atoie not used on this machine.\n");
d319 2
a320 2
	ni = atoie(s);
	warn("atoie(%s) = %d\n", s, ni);
d323 2
a324 2
	ni = atoie(s);
	warn("atoie(%s) = %d\n", s, ni);
d328 2
a329 2
	ni = atoie(s);
	warn("atoie(%s) = %d\n", s, ni);
d332 1
a332 1
	/* Test code for atope */
d334 1
a334 1
	    warn("Warning: atope not used on this machine.\n");
d339 2
a340 2
	np = atope(s);
	warn("atope(%s) = %lu\n", s, np);
d343 2
a344 2
	np = atope(s);
	warn("atope(%s) = %lu\n", s, np);
d347 1
a347 1
	/* Test code for atole */
d350 2
a351 2
	nl = atole(s);
	warn("atole(%s) = %ld\n", s, nl);
d354 2
a355 2
	nl = atole(s);
	warn("atole(%s) = %ld\n", s, nl);
d358 2
a359 2
	nl = atole(s);
	warn("atole(%s) = %ld\n", s, nl);
d362 1
a362 1
	/* Test code for atove */
d364 2
a365 2
	nv = atove(s);
	warn("atove(%s) = %lu\n", s, nv);
d368 2
a369 2
	nv = atove(s);
	warn("atove(%s) = %lu\n", s, nv);
d372 2
a373 2
	nv = atove(s);
	warn("atove(%s) = %lu\n", s, nv);
@


1.2
log
@Made errors fatal instead of returning EDOM.
@
text
@d93 1
a93 1
	    (sign == -1) && (n < SHRT_MIN) || isdigit(s[i]))
d251 1
a251 1
	    fprintf(stderr, "Warning: atohe not used on this machine.\n");
d253 1
a253 1
	    fprintf(stderr, "\n");
a255 1
	errno = 0;
d257 1
a257 6
	if (errno) {
		syswarn("atohe(%s)", s);
		fprintf(stderr, "bad value: atohe(%s) = %hd\n\n", s, nh);
	} else {
		fprintf(stderr, "atohe(%s) = %hd\n", s, nh);
	}
a259 1
	errno = 0;
d261 1
a261 6
	if (errno) {
		syswarn("atohe(%s)", s);
		fprintf(stderr, "bad value: atohe(%s) = %hd\n\n", s, nh);
	} else {
		fprintf(stderr, "atohe(%s) = %hd\n", s, nh);
	}
a262 10
	strcpy(s, "32768");
	errno = 0;
	nh = atohe(s);
	if (errno) {
		syswarn("atohe(%s)", s);
		fprintf(stderr, "bad value: atohe(%s) = %hd\n\n", s, nh);
	} else {
		fprintf(stderr, "atohe(%s) = %hd\n", s, nh);
	}

a263 1
	errno = 0;
d265 1
a265 6
	if (errno) {
		syswarn("atohe(%s)", s);
		fprintf(stderr, "bad value: atohe(%s) = %hd\n\n", s, nh);
	} else {
		fprintf(stderr, "atohe(%s) = %hd\n", s, nh);
	}
a266 9
	strcpy(s, "-32769");
	errno = 0;
	nh = atohe(s);
	if (errno) {
		syswarn("atohe(%s)", s);
		fprintf(stderr, "bad value: atohe(%s) = %hd\n\n", s, nh);
	} else {
		fprintf(stderr, "atohe(%s) = %hd\n", s, nh);
	}
d270 1
a270 1
	    fprintf(stderr, "Warning: atoue not used on this machine.\n");
d272 1
a272 1
	    fprintf(stderr, "\n");
a274 1
	errno = 0;
d276 1
a276 6
	if (errno) {
		syswarn("atoue(%s)", s);
		fprintf(stderr, "bad value: atoue(%s) = %hu\n\n", s, nu);
	} else {
		fprintf(stderr, "atoue(%s) = %hu\n", s, nu);
	}
a278 1
	errno = 0;
d280 1
a280 6
	if (errno) {
		syswarn("atoue(%s)", s);
		fprintf(stderr, "bad value: atoue(%s) = %hu\n\n", s, nu);
	} else {
		fprintf(stderr, "atoue(%s) = %hu\n", s, nu);
	}
a281 9
	strcpy(s, "65536");
	errno = 0;
	nu = atoue(s);
	if (errno) {
		syswarn("atoue(%s)", s);
		fprintf(stderr, "bad value: atoue(%s) = %hu\n\n", s, nu);
	} else {
		fprintf(stderr, "atoue(%s) = %hu\n", s, nu);
	}
a282 11
	strcpy(s, "-6");
	errno = 0;
	nu = atoue(s);
	if (errno) {
		syswarn("atoue(%s)", s);
		fprintf(stderr, "bad value: atoue(%s) = %hu\n\n", s, nu);
	} else {
		fprintf(stderr, "atoue(%s) = %hu\n", s, nu);
	}


d285 1
a285 1
	    fprintf(stderr, "Warning: atoie not used on this machine.\n");
d287 1
a287 1
	    fprintf(stderr, "\n");
a289 1
	errno = 0;
d291 1
a291 6
	if (errno) {
		syswarn("atoie(%s)", s);
		fprintf(stderr, "bad value: atoie(%s) = %d\n\n", s, ni);
	} else {
		fprintf(stderr, "atoie(%s) = %d\n", s, ni);
	}
a293 1
	errno = 0;
d295 1
a295 6
	if (errno) {
		syswarn("atoie(%s)", s);
		fprintf(stderr, "bad value: atoie(%s) = %d\n\n", s, ni);
	} else {
		fprintf(stderr, "atoie(%s) = %d\n", s, ni);
	}
a296 9
	strcpy(s, "2147483648");
	errno = 0;
	ni = atoie(s);
	if (errno) {
		syswarn("atoie(%s)", s);
		fprintf(stderr, "bad value: atoie(%s) = %d\n\n", s, ni);
	} else {
		fprintf(stderr, "atoie(%s) = %d\n", s, ni);
	}
a298 1
	errno = 0;
d300 1
a300 6
	if (errno) {
		syswarn("atoie(%s)", s);
		fprintf(stderr, "bad value: atoie(%s) = %d\n\n", s, ni);
	} else {
		fprintf(stderr, "atoie(%s) = %d\n", s, ni);
	}
a301 9
	strcpy(s, "-2147483649");
	errno = 0;
	ni = atoie(s);
	if (errno) {
		syswarn("atoie(%s)", s);
		fprintf(stderr, "bad value: atoie(%s) = %d\n\n", s, ni);
	} else {
		fprintf(stderr, "atoie(%s) = %d\n", s, ni);
	}
d305 1
a305 1
	    fprintf(stderr, "Warning: atope not used on this machine.\n");
d307 1
a307 1
	    fprintf(stderr, "\n");
a309 1
	errno = 0;
d311 1
a311 6
	if (errno) {
		syswarn("atope(%s)", s);
		fprintf(stderr, "bad value: atope(%s) = %lu\n\n", s, np);
	} else {
		fprintf(stderr, "atope(%s) = %lu\n", s, np);
	}
a313 1
	errno = 0;
d315 1
a315 6
	if (errno) {
		syswarn("atope(%s)", s);
		fprintf(stderr, "bad value: atope(%s) = %lu\n\n", s, np);
	} else {
		fprintf(stderr, "atope(%s) = %lu\n", s, np);
	}
a316 9
	strcpy(s, "4294967296");
	errno = 0;
	np = atope(s);
	if (errno) {
		syswarn("atope(%s)", s);
		fprintf(stderr, "bad value: atope(%s) = %lu\n\n", s, np);
	} else {
		fprintf(stderr, "atope(%s) = %lu\n", s, np);
	}
a317 10
	strcpy(s, "-6");
	errno = 0;
	np = atope(s);
	if (errno) {
		syswarn("atope(%s)", s);
		fprintf(stderr, "bad value: atope(%s) = %lu\n\n", s, np);
	} else {
		fprintf(stderr, "atope(%s) = %lu\n", s, np);
	}

d319 1
a319 1
	fprintf(stderr, "\n");
a320 1
	errno = 0;
d322 1
a322 6
	if (errno) {
		syswarn("atole(%s)", s);
		fprintf(stderr, "bad value: atole(%s) = %ld\n\n", s, nl);
	} else {
		fprintf(stderr, "atole(%s) = %ld\n", s, nl);
	}
a324 1
	errno = 0;
d326 1
a326 6
	if (errno) {
		syswarn("atole(%s)", s);
		fprintf(stderr, "bad value: atole(%s) = %ld\n\n", s, nl);
	} else {
		fprintf(stderr, "atole(%s) = %ld\n", s, nl);
	}
a327 10
	strcpy(s, "2147483648");
	errno = 0;
	nl = atole(s);
	if (errno) {
		syswarn("atole(%s)", s);
		fprintf(stderr, "bad value: atole(%s) = %ld\n\n", s, nl);
	} else {
		fprintf(stderr, "atole(%s) = %ld\n", s, nl);
	}

a328 1
	errno = 0;
d330 1
a330 6
	if (errno) {
		syswarn("atole(%s)", s);
		fprintf(stderr, "bad value: atole(%s) = %ld\n\n", s, nl);
	} else {
		fprintf(stderr, "atole(%s) = %ld\n", s, nl);
	}
a331 9
	strcpy(s, "-2147483649");
	errno = 0;
	nl = atole(s);
	if (errno) {
		syswarn("atole(%s)", s);
		fprintf(stderr, "bad value: atole(%s) = %ld\n\n", s, nl);
	} else {
		fprintf(stderr, "atole(%s) = %ld\n", s, nl);
	}
a334 1
	errno = 0;
d336 1
a336 6
	if (errno) {
		syswarn("atove(%s)", s);
		fprintf(stderr, "bad value: atove(%s) = %lu\n\n", s, nv);
	} else {
		fprintf(stderr, "atove(%s) = %lu\n", s, nv);
	}
a338 1
	errno = 0;
d340 1
a340 6
	if (errno) {
		syswarn("atove(%s)", s);
		fprintf(stderr, "bad value: atove(%s) = %lu\n\n", s, nv);
	} else {
		fprintf(stderr, "atove(%s) = %lu\n", s, nv);
	}
a342 1
	errno = 0;
d344 1
a344 16
	if (errno) {
		syswarn("atove(%s)", s);
		fprintf(stderr, "bad value: atove(%s) = %lu\n\n", s, nv);
	} else {
		fprintf(stderr, "atove(%s) = %lu\n", s, nv);
	}

	strcpy(s, "-6");
	errno = 0;
	nv = atove(s);
	if (errno) {
		syswarn("atove(%s)", s);
		fprintf(stderr, "bad value: atove(%s) = %lu\n\n", s, nv);
	} else {
		fprintf(stderr, "atove(%s) = %lu\n", s, nv);
	}
@


1.1
log
@Initial revision
@
text
@d16 1
a16 1
/* atopkge - convert ascii to arithmetic and set errno to EDOM on error
a52 6
 *	It is left to the application code to trap the EDOM error
 *	return from these routines.  Here is a typical paragraph:
 *		errno = 0;
 *		vxt[j].cmp = atoie(s2);
 *		if (errno) err("atoie failed on %s", vxt[j].cmp);
 *
d62 1
a62 1
 *      are read from the file ../include/limits.h.
d82 1
a82 1
	for (i = 0; isspace(s[i]); i++) ;	/* skip white space */
d88 1
a88 1
	for (n = 0; isdigit(s[i]) && n <= SHRT_MAX/10; i++) {
d93 4
a96 6
	    (sign == -1) && (n > SHRT_MIN) || isdigit(s[i])) {
		errno = EDOM;
		return((short) 0);
	} else {
		return(sign * (short) n);
	}
d111 1
a111 1
	if (USHRT_MAX == ULONG_MAX) return((ushort) atove(s));
d113 1
a113 1
	for (i = 0; isspace(s[i]); i++) ;  /* skip white space */
d115 2
a116 4
	if (s[i] == '-') {
		errno = EDOM;
		return((ushort) 0);
	}
d118 1
a118 1
	for (n = 0; isdigit(s[i]) && n <= USHRT_MAX/10; i++) {
d121 4
a124 6
	if (n > USHRT_MAX || isdigit(s[i])) {
		errno = EDOM;
		return((ushort) 0);
	} else {
		return((ushort) n);
	}
d138 1
a138 1
	if (INT_MAX == LONG_MAX) return((int) atole(s));
d140 1
a140 1
	for (i = 0; isspace(s[i]); i++) ;	/* skip white space */
d146 1
a146 1
	for (n = 0; isdigit(s[i]) && n <= INT_MAX/10; i++) {
d151 4
a154 6
	    (sign == -1) && (n > INT_MIN) || isdigit(s[i])) {
		errno = EDOM;
		return((int) 0);
	} else {
		return(sign * (int) n);
	}
d169 1
a169 1
	for (i = 0; isspace(s[i]); i++) ;  /* skip white space */
d171 2
a172 4
	if (s[i] == '-') {
		errno = EDOM;
		return((unsigned int) 0);
	}
d174 1
a174 1
	for (n = 0; isdigit(s[i]) && n <= UINT_MAX/10; i++) {
d177 4
a180 6
	if (n > UINT_MAX || isdigit(s[i])) {
		errno = EDOM;
		return((unsigned int) 0);
	} else {
		return((unsigned int) n);
	}
d193 1
a193 1
	for (i = 0; isspace(s[i]); i++) ;	/* skip white space */
d199 1
a199 1
	for (n = 0L; isdigit(s[i]) && n <= LONG_MAX/10L; i++) {
d204 4
a207 6
	    (sign == -1L) && (n > LONG_MIN) || isdigit(s[i])) {
		errno = EDOM;
		return(0L);
	} else {
		return(sign * (long) n);
	}
d219 1
a219 1
	for (i = 0; isspace(s[i]); i++) ;  /* skip white space */
d221 2
a222 4
	if (s[i] == '-') {
		errno = EDOM;
		return(0L);
	}
d224 1
a224 1
	for (n_old = 0L, n = 0L; isdigit(s[i]); i++) {
d226 2
a227 4
		if (n < n_old) {
			errno = EDOM;
			return(0L);
		}
d230 2
a231 1
	return(n);
@
