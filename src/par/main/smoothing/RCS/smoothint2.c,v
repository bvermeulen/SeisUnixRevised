head	1.11;
access;
symbols;
locks; strict;
comment	@ * @;


1.11
date	2012.04.19.21.09.31;	author john;	state Exp;
branches;
next	1.10;

1.10
date	2011.11.16.16.42.16;	author john;	state Exp;
branches;
next	1.9;

1.9
date	2011.10.20.21.08.50;	author john;	state Exp;
branches;
next	1.8;

1.8
date	2003.08.19.21.24.44;	author john;	state Exp;
branches;
next	1.7;

1.7
date	96.04.28.20.19.53;	author jkc;	state Exp;
branches;
next	1.6;

1.6
date	95.09.27.20.38.59;	author john;	state Exp;
branches;
next	1.5;

1.5
date	95.04.25.15.15.21;	author john;	state Exp;
branches;
next	1.4;

1.4
date	95.01.19.11.46.08;	author john;	state Exp;
branches;
next	1.3;

1.3
date	94.02.09.14.17.43;	author john;	state Exp;
branches;
next	1.2;

1.2
date	94.02.09.14.08.26;	author john;	state Exp;
branches;
next	1.1;

1.1
date	94.02.09.12.43.12;	author john;	state Exp;
branches;
next	;


desc
@smoothint2 --- smooth interfaces in 2d models
@


1.11
log
@moved smooth_1 subroutine into libpar.a
@
text
@/* Copyright (c) Colorado School of Mines, 2011.*/
/* All rights reserved.                       */

/* SMO0THINT2: $Revision: 1.10 $ ; $Date: 2011/11/16 16:42:16 $	*/

#include "par.h"

/*********************** self documentation ******************************/
char *sdoc[] = {
" 									",
" SMOOTHINT2 --- SMOOTH non-uniformly sampled INTerfaces, via the damped",
"  		least-squares technique					",
" 									",
"  smoothint2 <input ninf= >output [optional parameters]		",
" 									",
" Required Parameters:							",
" <input                 file containing original interfaces		",
" >output                file containing smoothed interfaces	 	",
" 									",
" Optional Parameters:							",
" ninf=5                number of interfaces  				",
" r=100			smoothing parameter 				",
" npmax=101		maximum number of points in interfaces		",
" 									",
" Notes:								",
" The input file is an ASCII file. Each interface is represented by pairs",
" (non-uniform sampling) of x and z values, with one pair of values on	",
" each line, separated by spaces or tabs. Each interface is separated with",
" an entry with a large negative z value for example: 1.0     -9999.	",
" There is no entry for the surface. The surface is assumed to be flat  ",
" with z=0.								",
" This is similar to a CSHOT model file without a surface entry and	",
" without comments.							",
" 									",
" The smoothing method is analogous to a moving window averaging process",
" (but not the same) with the parameter \"r\" being analogous to the \"width\"",
" of the window. Thus, the size of \"r\" must be chosen to by compatible",
" with the scale (wavelengths) of the variations of the interfaces in the",
" model being smoothed.							",
" 									",
" Example using the test data set generated by unif2: 			",
" unif2 tfile=tfilename							",
" Compare the unsmoothed interface model:				",
" unif2 < tfilename method=interpolation_method |			",
"	 			psimage n1=100 n2=100 d1=10 d2=10 | ...	",
" To the smoothed interface model:					",
" smoothint2 r=100 < tfilename | unif2 method=interpolation_method |	", 
"	psimage n1=100 n2=100 d1=10 d2=10 | ...				",
"   									",
NULL};

/*
 * Credits:
 *  CWP: Zhenyue Liu, Jan 1994
 * Reference:
 *    Liu, Zhenyue, 1994, Velocity smoothing: theory and implementation, 
 *    Project Review, 1994, Consortium Project on Seismic Inverse Methods
 *    for Complex Stuctures (in review)
 */

/**************** end self doc *******************************************/


int
main(int argc, char **argv)
{
	int i,j,ninf,npmax,npt;
	float r;
	float *xint,*zint;
	
	/* hook up getpar */
	initargs(argc, argv);
	requestdoc(0);
	
	/* get parameters */
	if (!getparint("ninf",&ninf))	ninf=5;
	if (!getparint("npmax",&npmax)) npmax=101;
	if (!getparfloat("r",&r)) r=0;
	
        checkpars();

	xint =  alloc1float(npmax);
	zint =  alloc1float(npmax);
	
	/* Input x z pairs specifying interfaces and velocity values. */
	for(i=0; i<ninf; ++i) {
		j= -1;
		do {
			j +=1;
			if(j>=npmax) 
		err("The point number on the %ith interface exceeds %i!",
				i+1,npmax);
			scanf("%f%f\n", &xint[j], &zint[j]);
		} while(zint[j]>-9999);
			npt = j;

		smooth_1(xint,zint,r,npt);
		for(j=0; j<npt; ++j)
 			printf("\t%g\t%g\n",xint[j],zint[j]);
 		printf("\t%g\t%g\n",1.,-99999.);
	}

	return(CWP_Exit());
}	       
@


1.10
log
@checkpar() added
@
text
@d4 1
a4 1
/* SMO0THINT2: $Revision: 1.8 $ ; $Date: 2003/08/19 21:24:44 $	*/
a62 1
void smooth_1(float *x, float *z, float r, int n);
a104 54

void smooth_1(float *x, float *z, float r, int n)
/**************************************************************************
smooth_1  --- damped least squares smoothing of nonuniformly sampled 1d array
**************************************************************************
Input:
	x     array of horizontal coordinates
	z     array of vertical coordinate
	r     smoothing operator length
	n     number of points input 
Output:
	z     array of smoothed vertical coordinates
**************************************************************************
Reference:
    Liu, Zhenyue, 1994, Velocity smoothing: theory and implementation, 
    Project Review, 1994, Consortium Project on Seismic Inverse Methods
    for Complex Stuctures (in review).
**************************************************************************
Author: CWP: Zhenyue Liu, 1994
**************************************************************************/
{
	int  ir, i;		
	float *d, *e, *o;

	o = alloc1float(n+1);
	d = alloc1float(n);
	e = alloc1float(n);

	for(i=0; i<n-1; ++i){
		if(x[i+1]==x[i])
 			err("x-spacing of data values must not be zero!\n");
		o[i] = 1.0/(x[i+1]-x[i]);
		o[i] = o[i]*o[i];
	}
	o[n-1] = 0.;
		
	/* scale smoothing parameter */
	r = 0.5*r*r;
	r /= 5.19*5.19;

	for(ir=0; ir<2; ++ir) {
		for(i=1; i<n; ++i){
			d[i] = 1.0+r*(o[i]+o[i-1]);
			e[i-1] = -r*o[i-1];
		}
		d[0] = 1.0+r*o[0];
         	tripd(d,e,z,n);
	}

	free1float(d);
	free1float(e);
	free1float(o);
}

@


1.9
log
@added copyright statement
@
text
@d81 2
@


1.8
log
@19 Aug 2003
@
text
@d1 4
a4 1
/* SMO0THINT2: $Revision: 1.7 $ ; $Date: 1996/04/28 20:19:53 $	*/
@


1.7
log
@./main/smoothint2.c
"smoothint2.c", line 85: warning: ambiguous assignment for non-ansi compilers
@
text
@d1 1
a1 1
/* SMO0THINT2: $Revision: 1.6 $ ; $Date: 1995/09/27 20:38:59 $	*/
d99 1
a99 1
	return EXIT_SUCCESS;
@


1.6
log
@added   return EXIT_SUCCESS;
@
text
@d1 1
a1 1
/* SMO0THINT2: $Revision: 1.5 $ ; $Date: 1995/04/25 15:15:21 $	*/
d62 1
d83 1
a83 1
		j=-1;
@


1.5
log
@fixed RCS label
@
text
@d1 1
a1 1
/* SMOTHINT2: $Revision: 1.4 $ ; $Date: 95/01/19 11:46:08 $	*/
d98 1
@


1.4
log
@cosmetic
@
text
@d1 1
a1 1
/* SMOTHINT2: $Revision: 1.3 $ ; $Date: 94/02/09 14:17:43 $	*/
@


1.3
log
@selfdoc
@
text
@d1 1
a1 1
/* SMOTHINT2: $Revision: 1.2 $ ; $Date: 94/02/09 14:08:26 $	*/
a59 1
void tripd(float *d, float *e, float *b, int n);
a152 29
void tripd(float *d, float *e, float *b, int n)
/*****************************************************************************
Given a n-by-n symmetric, tridiagonal, positive definite matrix A and a
 n-vector b, the following algorithm overwrites b with the solution to Ax = b.

  d() the diagonal of A 
  e() the superdiagonal of A
*****************************************************************************/
{
	int k; 
	float temp;
	
	/* decomposition */
	for(k=1; k<n; ++k) {
          	temp = e[k-1];
           	e[k-1] = temp/d[k-1];
           d[k] -= temp*e[k-1];
	}

	/* substitution	*/
        for(k=1; k<n; ++k) 
 		b[k] -= e[k-1]*b[k-1];
	
        b[n-1] /=d[n-1];

        for(k=n-1; k>0; --k) 
		b[k-1] = b[k-1]/d[k-1]-e[k-1]*b[k]; 
	
}
@


1.2
log
@selfdoc update
@
text
@d1 1
a1 1
/* SMOTHINT2: $Revision: 1.1 $ ; $Date: 94/02/09 12:43:12 $	*/
d41 2
a42 1
" unif2 < tfilename method=spline | psimage n1=100 n2=100 d1=10 d2=10 | ...",
d44 2
a45 2
" smoothint2 r=100 < tfilename | unif2 method=spline |			", 
"				psimage n1=100 n2=100 d1=10 d2=10 | ...	",
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/* SMOINT: $Revision: 1.2 $ ; $Date: 94/01/20 15:18:39 $	*/
d38 1
a38 1
" Test example using the test data set generated by unif2: 		",
d40 6
a45 2
" smoothint2 < tfilename | unif2 | psimage n1=100 n2=100 d1=10 d2=10 | ...",
"  									",
@
