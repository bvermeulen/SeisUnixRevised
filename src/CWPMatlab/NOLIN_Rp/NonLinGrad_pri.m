% AUTHOR: Petr Jilek, Colorado School of Mines, Center for Wave
% Phenomena, January 2002.  

function NonLinGrad_pri

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% NonLinGrad_pri.m is the primary subphase of PHASE2, the nonlinear
% least-square gradient-type inversion (for detailed description of the
% inversion algorythm, see the "lsqnonlin" function on:
% http://www.mathworks.com/access/helpdesk/help/toolbox/optim/optim.shtml).
% It takes the set of M_best initial models from PSM generated by MisfitSort
% and performs "refinement" (i.e., "a descent to a valley") by solving
% optimization problem using nonlinear least-squares method (that finds the
% "best-fit solution in L2 norm"). Setting up a sufficient "high resolution"
% stopping criterion (see below), the refinement can be completed in this
% primary subphase. However, it is usually faster to set up a "low
% resolution" stopping criterion and complete the descent in the secondary
% subphase using NonLinGrad_sec.m. Efficiency of using NonLinGrad_sec.m
% increases with increasing number of model parameters to be inverted.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%   You should be familiar with the meanings of basic variables, 
%   as described in README.MAIN file.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% INPUT:
% I) Data file ("Data.in" as default) containing the input ERROR-CONTAMINATED
%    data (usually generated by MisfitSort) in the matrix form whose
%    lines are in the following format:  
%    [inc_angle azimuth Rpp Rps1 Rps2].
% II) InitModel file ("InitModels.in" as default) containing the set of
%     initial conditions starting with the best-fitting, as generated by
%     MisfitSort program. Note that you are free to add any other
%     initial conditions manually to this file, keeping the appropriate
%     format. 
% III) Numerous initial settings controlling the behavior of the program
%      as described below. The settings also eneble to incorporate an a
%      priori information that may be available.
%
% OUTPUT:
% I) INFO.out ... information about the inversion completed. The file
%    consists of paragraphs (one paragraph per each model inverted) with
%    the following information:
%    initial conditions (the starting model), inversion ON number,
%    final value of Fobj, type of convergence (-1... no convergence,
%    0..."slow" convergence, 1...succesful convergence), the number of total
%    iterations (n_Iter), the number of total objective function
%    evaluations (n_FunEval), and the number of CG (conjugate-gradient-type)
%    iterations (n_CGiter).
% I) RESULT.out ... results of the inversion. Each
%    row of the file corresponds to one vector of the 
%    format [ON [model]], where [model] is the model vector as:
%    if ISO: 
%    [Drho  Dv33  Dv55  v55_v33];
%    if HTI: 
%    [Drho  Dv33  Dv55  v55_v33  ev_1  dv_1  g_1 ev_2 dv_2 g_2]
%    if HTIxHTI: 
%    [Drho  Dv33  Dv55  v55_v33  ev_1  dv_1  g_1  ev_2 dv_2 g_2 kappa]
%    if ORT:   
%    [Drho  Dv33  Dv55  v55_v33  e1_1  e2_1 d1_1
%     d2_1 g1_1 g2_1 d3_1 e1_2 e2_1 d1_2 d2_2 g1_2 g2_2 d3_2]
%    if ORTxORT:  
%    [Drho  Dv33  Dv55  v55_v33  e1_1  e2_1 d1_1
%     d2_1 g1_1 g2_1 d3_1 e1_2 e2_1 d1_2 d2_2 g1_2 g2_2 d3_2 kappa]
%    FIRS TWO rows of RESULT.out file (both with ON=0)
%    are reproductions of the lower and upper boundaries of the
%    individual medium parameters prescribed below. They are used in the
%    secondary subphase of PHASE2 in NonLinGrad_sec.
% III) EVOLUTION.out ... information about evolution of all medium
%      parameters with proceeding iterations, i.e., during the descent from
%      the starting model to the minimum. Each row of the file corresponds
%      to one iteration step and has the following format: [ODmodel Niter
%      F_obj [model]], where ODmodel is the ordinary number of the model
%      being inverted, Niter is the iteration step for the model Nmodel,
%      F_obj is the value of the objective function at Niter and [model] is
%      the set of corresponding model parameters as above. For lucidity, the
%      vector [-100 -100 ... -100] follows the last iteration step of each
%      model, separating thus the iteration sequence of one model from
%      another.
% IV) Problems.out ... problem-information text file. The file is generated only
%     if the model recovered in a particular iteration step results in some
%     pathological response (for exampel, complex reflection coefficients are
%     generated, the medium is not physical, or S-wave singularities exist
%     in certain directions). Despite the occurance of those problems,
%     the inversion is designed to correct the pathological model (using
%     certain "penalty" functions) and continue in the
%     inversion. Problems.out file is useful if some unexpected failures
%     occur. Many times, it may be quite large and should be deleted
%     continuously. It is possible to deactivate the generation of this file
%     by commenting appropriate lines in subroutines FormCij, Azim_ChristEq,
%     ChristEq and InterMatrix.
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

clear all;

%-------
% Unmark this if the routine is to be run under Matlab,
% mark this if the routine is to be compiled into an executable.
% If used, adjust the path of the libraries accordingly.
%
%close all;
%path(path,'/Net/dobrin/home1/pjilek/src/Matlab/NOLIN_Rp/LIB');      %Obj_Rcf library M routines
% this library should be installed - Matlab Optimization Toolbox
%path(path,'.../Optim');                                             %Optim library M routines
%---------

global Pdata
global Sdata
global S1data
global S2data
global RECORD

% ==========================
% START OF INITIAL SETTINGS:
% ==========================

% 1) Some basic settings:
% -----------------------

model_ID=4;        % (0=ISO)  (3=HTI aligned) (4=HTIxHTI) (5=ORT aligned) (6=ORTxORT)
M_best=[1 25];     % This range of M first best starting models from PSM will be
                   % processed by NonLinGrat_pri.m routine [from min(M_best)
                   % to max(M_best)] .
FtolParam = 1e-2;  % Resolution stopping criterion. Tolerance of the misfit
                   % function; the inversion terminates if the misfit
                   % function changes by less than FtolParam. For this
                   % particular inversion problem, "low resolution" can be
                   % considered with FtolParam > 1e-2, and "high resolution"
                   % with FtolParam < 1e-3. If FtolParam is too small, you
                   % will be fitting noise and the inversion will take
                   % extremally long time to finish; if FtolParam too large,
                   % you may not fit the data very well but the inversion
                   % will be significantly faster. The default value for the
                   % primary subphase seems to be optimal as +-10% data
                   % error. (For instance, if the st. deviation of measured
                   % data is estimated as +-0.1, then the default value 0.01
                   % seems to be optimal). Other possible stopping
                   % criteria can be set up on the lines immediately
                   % following the title "B) Model optimization:".


% B) Ranges of parameters to be estimated: the ranges that follow represent
%    HARD constraints, i.e., the final model estimates will be strictly
%    inside those ranges; by modifying corresponding ranges, it is easy to
%    implement an ultimate a priori information (including its uncertainity)
%    on individual model parameters; WARNING: if a priori information
%    is incorrect, the final parameter estimates will be biased - if you do
%    not know a priori information well, broad ranges should be set up.
% ------------------------------------------------------------------------

r_r=[-1.2 1.5];        % Drho range
a_r=[-1.5 1.5];       % Dv33 velocity range
b_r=[-1.5 1.5];        % Dv55 velocity range
b_a_r=[0.2 0.8];     % v55_v33 ratio range
 %DEFAULT
 %r_r=[-1.2 1.2];
 %a_r=[-1.5 1.5];
 %b_r=[-1.5 1.5];
 %b_a_r=[0.2 0.8];

% HTI||HTI or HTIxHTI:

if model_ID==3 | model_ID==4
  ev_1_r=[-0.5 1.0];  % ev_1 range
  dv_1_r=[-1.0 1.0];  % dv_1 range
  g_1_r=[-1.0 1.0];   % g_1 range
  ev_2_r=[-0.5 1.0];  % ev_2 range
  dv_2_r=[-1.0 1.0];  % dv_2 range
  g_2_r=[-1.0 1.0];   % g_2 range
  kap_r=[0. 90.];     % kappa range
  % DEFAULT:
  %ev_1_r=[-0.5 1.0];
  %dv_1_r=[-1.0 1.0];
  %gv_1_r=[-1.0 1.0];
  %ev_2_r=[-0.5 1.0];
  %dv_2_r=[-1.0 1.0];
  %gv_2_r=[-1.0 1.0];
  %kap_r=[0. 90.];
end;

% ORT||ORT or ORTxORT:

if model_ID==5 | model_ID==6
  e1_1_r=[-0.19 -0.11];        % e1_1 range
  e2_1_r=[0.11 0.19];          % e2_1 range
  d1_1_r=[-0.21 -0.19];        % d1_1 range
  d2_1_r=[0.09 0.11];          % d2_1 range
  g1_1_r=[0.14 0.16];          % g1_1 range
  g2_1_r=[0.03 0.07];          % g2_1 range
  d3_1_r=[0.0 0.25];           % d3_1 range
  e1_2_r=[-0.5 1.0];           % e1_2 range
  e2_2_r=[-0.5 1.0];           % e2_2 range
  d1_2_r=[-1.0 1.0];           % d1_2 range
  d2_2_r=[-1.0 1.0];           % d2_2 range
  g1_2_r=[-1.0 1.0];           % g1_2 range
  g2_2_r=[-1.0 1.0];           % g2_2 range
  d3_2_r=[-1.0 1.0];           % d3_2 range
  kap_r=[0. 90.];              % kappa range
  % DEFAULT:
  %e1_1_r=[-0.5 1.0];
  %e2_1_r=[-0.5 1.0];
  %d1_1_r=[-1.0 1.0];
  %d2_1_r=[-1.0 1.0];
  %g1_1_r=[-1.0 1.0];
  %g2_1_r=[-1.0 1.0];
  %d3_1_r=[-1.0 1.0];
  %e1_2_r=[-0.5 1.0];
  %e2_2_r=[-0.5 1.0];
  %d1_2_r=[-1.0 1.0];
  %d2_2_r=[-1.0 1.0];
  %g1_2_r=[-1.0 1.0];
  %g2_2_r=[-1.0 1.0];
  %d3_2_r=[-1.0 1.0];
  %kap_r=[0. 90.];
end;

% =======================
% END OF INITIAL SETTINGS
% =======================

% -------------------
% DATA PREPROCESSING:
% -------------------

fid=fopen('Data.in');
D=fscanf(fid,'%f',[5 Inf]);
fclose(fid);
model=D';

fid=fopen('InitModels.in');
if model_ID==0
  D=fscanf(fid,'%f',[6 Inf]);
end;
if model_ID==3
  D=fscanf(fid,'%f',[12 Inf]);
end;
if model_ID==4
  D=fscanf(fid,'%f',[13 Inf]);
end;
if model_ID==5
  D=fscanf(fid,'%f',[20 Inf]);
end;
if model_ID==6
  D=fscanf(fid,'%f',[21 Inf]);
end;
fclose(fid);
I_model=D';

[x y]=size(I_model);

if min(M_best) > x
  fprintf('\nWRONG choice of M_best=[%f %f]; \M_best is out of range \n',min(M_best),max(M_best));
  fprintf('\n*** Program terminated ***\n');
  break;
elseif max(M_best) > x
  M_best=[min(M_best) x];
end;

fprintf('Running slotnick1 ...');

I_model=I_model(min(M_best):max(M_best),:);
[x y]=size(I_model);

inc_deg=model(:,1);
azim_deg=model(:,2);
Pdata=model(:,3);
S1data=model(:,4);
S2data=model(:,5);
inc=inc_deg*pi/180;
azim=azim_deg*pi/180;

% -------------------------------
% OPTIMIZATION FOR M_best MODELS:
% -------------------------------

for I=1:x  % loop over initial models

  RECORD=1;
  fprintf('\n *** inversion running: model # %i out of %i ***\n',I,x);
  
  % 
  % A) model initialization:
  % ------------------------
  
  Drho0=I_model(I,3);
  Dv330=I_model(I,4);
  Dv550=I_model(I,5);
  b_a0=I_model(I,6);
  
  % ISO:
  if model_ID == 0   
    Sdata=sqrt(S1data.^2+S2data.^2);  % for ISO models, this operation
                                      % unifies the S1 and S2 waves
                                      % formally computed by the exact code.
    INIT0=[Drho0 Dv330 Dv550 b_a0];
    LB=[min(r_r) min(a_r) min(b_r) min(b_a_r)];
    UB=[max(r_r) max(a_r) max(b_r) max(b_a_r)];
    INITIAL=INIT_check(INIT0,LB,UB);

  
  % HTI||HTI:
  elseif model_ID == 3   
    
    ev0_1=I_model(I,7); ev0_2=I_model(I,10);
    dv0_1=I_model(I,8); dv0_2=I_model(I,11);
    g0_1=I_model(I,9); g0_2=I_model(I,12);

    INIT0=[Drho0 Dv330 Dv550 b_a0 ev0_1 dv0_1 g0_1 ...
	     ev0_2 dv0_2 g0_2];
    LB=[min(r_r) min(a_r) min(b_r) min(b_a_r) min(ev_1_r) ...
	min(dv_1_r) min(g_1_r) min(ev_2_r) ...
	min(dv_2_r) min(g_2_r)];
    UB=[max(r_r) max(a_r) max(b_r) max(b_a_r) max(ev_1_r) ...
	max(dv_1_r) max(g_1_r) max(ev_2_r) ...
	max(dv_2_r) max(g_2_r)];
    INITIAL=INIT_check(INIT0,LB,UB);

  % HTIxHTI:
  elseif model_ID == 4   
    
    ev0_1=I_model(I,7); ev0_2=I_model(I,10);
    dv0_1=I_model(I,8); dv0_2=I_model(I,11);
    g0_1=I_model(I,9); g0_2=I_model(I,12);
    kappa0=I_model(I,13);

    INIT0=[Drho0 Dv330 Dv550 b_a0 ev0_1 dv0_1 g0_1 ...
	     ev0_2 dv0_2 g0_2 kappa0];
    LB=[min(r_r) min(a_r) min(b_r) min(b_a_r) min(ev_1_r) ...
	min(dv_1_r) min(g_1_r) min(ev_2_r) ...
	min(dv_2_r) min(g_2_r) min(kap_r)];
    UB=[max(r_r) max(a_r) max(b_r) max(b_a_r) max(ev_1_r) ...
	max(dv_1_r) max(g_1_r) max(ev_2_r) ...
	max(dv_2_r) max(g_2_r) max(kap_r)];
    INITIAL=INIT_check(INIT0,LB,UB);

  % ORT||ORT:
  elseif model_ID == 5   
    e10_1=I_model(I,7); e20_1=I_model(I,8); e10_2=I_model(I,14); e20_2=I_model(I,15);
    d10_1=I_model(I,9); d20_1=I_model(I,10); d10_2=I_model(I,16); d20_2=I_model(I,17);
    g10_1=I_model(I,11); g20_1=I_model(I,12); g10_2=I_model(I,18); g20_2=I_model(I,19);
    d30_1=I_model(I,13); d30_2=I_model(I,20);
    
    INIT0=[Drho0 Dv330 Dv550 b_a0 e10_1 e20_1 d10_1 d20_1 g10_1 ...
	     g20_1 d30_1 e10_2 e20_2 d10_2 d20_2 g10_2 g20_2 d30_2];
    LB=[min(r_r) min(a_r) min(b_r) min(b_a_r) min(e1_1_r) min(e2_1_r) ...
	min(d1_1_r) min(d2_1_r) min(g1_1_r) min(g2_1_r) min(d3_1_r) min(e1_2_r) ...
	min(e2_2_r) min(d1_2_r) min(d2_2_r) min(g1_2_r) min(g2_2_r) min(d3_2_r)];
    UB=[max(r_r) max(a_r) max(b_r) max(b_a_r) max(e1_1_r) max(e2_1_r) ...
	max(d1_1_r) max(d2_1_r) max(g1_1_r) max(g2_1_r) max(d3_1_r) max(e1_2_r) ...
	max(e2_2_r) max(d1_2_r) max(d2_2_r) max(g1_2_r) max(g2_2_r) max(d3_2_r)];
    INITIAL=INIT_check(INIT0,LB,UB);

  % ORTxORT:
  elseif model_ID == 6   
    e10_1=I_model(I,7); e20_1=I_model(I,8); e10_2=I_model(I,14); e20_2=I_model(I,15);
    d10_1=I_model(I,9); d20_1=I_model(I,10); d10_2=I_model(I,16); d20_2=I_model(I,17);
    g10_1=I_model(I,11); g20_1=I_model(I,12); g10_2=I_model(I,18); g20_2=I_model(I,19);
    d30_1=I_model(I,13); d30_2=I_model(I,20);
    kappa0=I_model(I,21);
    
    INIT0=[Drho0 Dv330 Dv550 b_a0 e10_1 e20_1 d10_1 d20_1 g10_1 ...
	     g20_1 d30_1 e10_2 e20_2 d10_2 d20_2 g10_2 g20_2 d30_2 kappa0];
    LB=[min(r_r) min(a_r) min(b_r) min(b_a_r) min(e1_1_r) min(e2_1_r) ...
	min(d1_1_r) min(d2_1_r) min(g1_1_r) min(g2_1_r) min(d3_1_r) min(e1_2_r) ...
	min(e2_2_r) min(d1_2_r) min(d2_2_r) min(g1_2_r) min(g2_2_r) min(d3_2_r) min(kap_r)];
    UB=[max(r_r) max(a_r) max(b_r) max(b_a_r) max(e1_1_r) max(e2_1_r) ...
	max(d1_1_r) max(d2_1_r) max(g1_1_r) max(g2_1_r) max(d3_1_r) max(e1_2_r) ...
	max(e2_2_r) max(d1_2_r) max(d2_2_r) max(g1_2_r) max(g2_2_r) max(d3_2_r) max(kap_r)];
    INITIAL=INIT_check(INIT0,LB,UB);
  else
    fprintf('\nWRONG choice of model_ID=%5.1f; \nthis model configuration is not supported by this version. \n',model_ID);
    fprintf('\n*** Program terminated *** \n');
    break;
  end;

  %
  % B) Model optimization:
  % ---------------------
    
  XtolParam = 1e-7;
  f_eval_ISO = 600;
  f_eval_HTI = 1000;
  f_eval_ORT = 1700;

  if model_ID==0  % ISO:
    OPTIONS = optimset('DerivativeCheck','off','Diagnostics','off',  'LargeScale', 'on', 'Display', 'on', ...
		       'LevenbergMarquardt','off','Jacobian', 'off','MaxFunEvals',f_eval_ISO,'MaxIter', 100, ...
		       'TolX', XtolParam,   'TolFun', FtolParam);
    [medium,L2norm,residual,flag,out_struc,lambda,jac] = ...
	lsqnonlin('ISO_objective',INITIAL,LB,UB,OPTIONS,inc,azim,I,1);
    result=medium;
    info=[flag out_struc.iterations out_struc.funcCount out_struc.cgiterations];
    FF=ISO_objective(result,inc,azim,I,1);
    F_obj_final=sum(FF.^2);
  
  elseif model_ID==3  % HTI aligned:
    OPTIONS = optimset('DerivativeCheck','off','Diagnostics','off',  'LargeScale', 'on', 'Display', 'on', ...
		       'LevenbergMarquardt','off','Jacobian', 'off','MaxFunEvals',f_eval_HTI,'MaxIter', 100, ...
		       'TolX', XtolParam,   'TolFun', FtolParam);
    [medium,L2norm,residual,flag,out_struc,lambda,jac] = ...
	lsqnonlin('HTI_align_objective',INITIAL,LB,UB,OPTIONS,inc,azim,I,1);
    result=medium;
    info=[flag out_struc.iterations out_struc.funcCount out_struc.cgiterations];
    FF=HTI_align_objective(result,inc,azim,I,1);
    F_obj_final=sum(FF.^2);

  elseif model_ID==4  % HTIxHTI:
    OPTIONS = optimset('DerivativeCheck','off','Diagnostics','off',  'LargeScale', 'on', 'Display', 'on', ...
		       'LevenbergMarquardt','off','Jacobian', 'off','MaxFunEvals',f_eval_HTI,'MaxIter', 100, ...
		       'TolX', XtolParam,   'TolFun', FtolParam);
    [medium,L2norm,residual,flag,out_struc,lambda,jac] = ...
	lsqnonlin('HTI_objective',INITIAL,LB,UB,OPTIONS,inc,azim,I,1);
    result=medium;
    info=[flag out_struc.iterations out_struc.funcCount out_struc.cgiterations];
    FF=HTI_objective(result,inc,azim,I,1);
    F_obj_final=sum(FF.^2);

  elseif model_ID==5  % ORT aligned:
    OPTIONS = optimset('DerivativeCheck','off','Diagnostics','off',  'LargeScale', 'on', 'Display', 'on', ...
		       'LevenbergMarquardt','off','Jacobian', 'off','MaxFunEvals',f_eval_ORT,'MaxIter', 150, ...
		       'TolX', XtolParam,   'TolFun', FtolParam);
    [medium,L2norm,residual,flag,out_struc,lambda,jac] = ...
	lsqnonlin('ORT_align_objective',INITIAL,LB,UB,OPTIONS,inc,azim,I,1);
    result=medium;
    info=[flag out_struc.iterations out_struc.funcCount out_struc.cgiterations];
    FF=ORT_align_objective(result,inc,azim,I,1);
    F_obj_final=sum(FF.^2);
  
  elseif model_ID==6  % ORTxORT:
    OPTIONS = optimset('DerivativeCheck','off','Diagnostics','off',  'LargeScale', 'on', 'Display', 'on', ...
		       'LevenbergMarquardt','off','Jacobian', 'off','MaxFunEvals',f_eval_ORT,'MaxIter', 150, ...
		       'TolX', XtolParam,   'TolFun', FtolParam);
    [medium,L2norm,residual,flag,out_struc,lambda,jac] = ...
	lsqnonlin('ORT_objective',INITIAL,LB,UB,OPTIONS,inc,azim,I,1);
    result=medium;
    info=[flag out_struc.iterations out_struc.funcCount out_struc.cgiterations];
    FF=ORT_objective(result,inc,azim,I,1);
    F_obj_final=sum(FF.^2);
  
  end;
  
  % 
  % C) Output the final results:
  % ----------------------------

  fid0=fopen('EVOLUTION.out','a');
  if I == 1
    fid1=fopen('RESULT.out','w');         % estimated models
    fid2=fopen('INFO.out','w');           % info about the inversion
                                          % result (convergence, e.t.c.)
  else
    fid1=fopen('RESULT.out','a');
    fid2=fopen('INFO.out','a');   
  end;

  if model_ID==0
    fprintf(fid0,'%i %i %i %i %i %i %i\n',[-100 -100 -100 -100 -100 -100 -100]);
    if I==1
      fprintf(fid1,'%i \t %f \t %f \t %f \t %f \n',0, LB);
      fprintf(fid1,'%i \t %f \t %f \t %f \t %f \n',0, UB);
    end;      
    fprintf(fid1,'%i \t %f \t %f \t %f \t %f \n',I, result);
    fprintf(fid2,'\n initial conditions: Drho=%f Dv33=%f Dv55=%f b_a=%f \n',INITIAL);
  elseif model_ID==3
    % this marks the end of the model #I in EVOLUTION file:
    fprintf(fid0,'%i %i %i %i %i %i %i %i %i %i %i %i %i\n',[-100 -100 -100 -100 -100 -100 -100 -100 -100 -100 -100 -100 -100]);
    if I==1
      fprintf(fid1,'%i \t %f \t %f \t %f \t %f \t %f \t %f \t %f \t %f \t %f \t %f \n',0,LB);
      fprintf(fid1,'%i \t %f \t %f \t %f \t %f \t %f \t %f \t %f \t %f \t %f \t %f \n',0,UB);
    end;      
    fprintf(fid1,'%i \t %f \t %f \t %f \t %f \t %f \t %f \t %f \t %f \t %f \t %f \n',I,result);
    fprintf(fid2,'\n initial conditions: Drho=%f Dv33=%f Dv55=%f b_a=%f \nev1=%f dv1=%f g1=%f ev2=%f dv2=%f g2=%f \n',INITIAL);
  elseif model_ID==4
    % this marks the end of the model #I in EVOLUTION file:
    fprintf(fid0,'%i %i %i %i %i %i %i %i %i %i %i %i %i %i\n',[-100 -100 -100 -100 -100 -100 -100 -100 -100 -100 -100 -100 -100 -100]);
    if I==1
      fprintf(fid1,'%i \t %f \t %f \t %f \t %f \t %f \t %f \t %f \t %f \t %f \t %f \t %f \n',0,LB);
      fprintf(fid1,'%i \t %f \t %f \t %f \t %f \t %f \t %f \t %f \t %f \t %f \t %f \t %f \n',0,UB);
    end;      
    fprintf(fid1,'%i \t %f \t %f \t %f \t %f \t %f \t %f \t %f \t %f \t %f \t %f \t %f \n',I,result);
    fprintf(fid2,'\n initial conditions: Drho=%f Dv33=%f Dv55=%f b_a=%f \nev1=%f dv1=%f g1=%f ev2=%f dv2=%f g2=%f kappa=%f\n',INITIAL);
  elseif model_ID==5
    % this marks the end of the model #I in EVOLUTION file:
    fprintf(fid0,'%i %i %i %i %i %i %i %i %i %i %i %i %i %i %i %i %i %i %i %i %i\n',[-100 -100 -100 -100 -100 -100 -100 -100 -100 -100 -100 -100 -100 -100 -100 -100 -100 -100 -100 -100 -100]);
    if I==1
      fprintf(fid1,'%i \t %f \t %f \t %f \t %f \t %f \t %f \t %f \t %f \t %f \t %f \t %f \t %f \t %f \t %f \t %f \t %f \t %f \t %f \t \n',0,LB);
      fprintf(fid1,'%i \t %f \t %f \t %f \t %f \t %f \t %f \t %f \t %f \t %f \t %f \t %f \t %f \t %f \t %f \t %f \t %f \t %f \t %f \t \n',0,UB);
    end;      
    fprintf(fid1,'%i \t %f \t %f \t %f \t %f \t %f \t %f \t %f \t %f \t %f \t %f \t %f \t %f \t %f \t %f \t %f \t %f \t %f \t %f \t \n',I,result);
    fprintf(fid2,'\n initial conditions: Drho=%f Dv33=%f Dv55=%f b_a=%f \ne1_1=%f e2_1=%f d1_1=%f d2_1=%f g1_1=%f g2_1=%f d3_1=%f \ne1_2=%f e2_2=%f d1_2=%f d2_2=%f g1_2=%f g2_2=%f d3_2=%f \n',INITIAL);
  elseif model_ID==6
    % this marks the end of the model #I in EVOLUTION file:
    fprintf(fid0,'%i %i %i %i %i %i %i %i %i %i %i %i %i %i %i %i %i %i %i %i %i %i\n',[-100 -100 -100 -100 -100 -100 -100 -100 -100 -100 -100 -100 -100 -100 -100 -100 -100 -100 -100 -100 -100 -100]);
    if I==1
      fprintf(fid1,'%i \t %f \t %f \t %f \t %f \t %f \t %f \t %f \t %f \t %f \t %f \t %f \t %f \t %f \t %f \t %f \t %f \t %f \t %f \t %f \n',0,LB);
      fprintf(fid1,'%i \t %f \t %f \t %f \t %f \t %f \t %f \t %f \t %f \t %f \t %f \t %f \t %f \t %f \t %f \t %f \t %f \t %f \t %f \t %f \n',0,UB);
    end;
    fprintf(fid1,'%i \t %f \t %f \t %f \t %f \t %f \t %f \t %f \t %f \t %f \t %f \t %f \t %f \t %f \t %f \t %f \t %f \t %f \t %f \t %f \n',I,result);
    fprintf(fid2,'\ninitial conditions: Drho=%f Dv33=%f Dv55=%f b_a=%f \ne1_1=%f e2_1=%f d1_1=%f d2_1=%f g1_1=%f g2_1=%f d3_1=%f \ne1_2=%f e2_2=%f d1_2=%f d2_2=%f g1_2=%f g2_2=%f d3_2=%f kappa=%f\n',INITIAL);
  end;
  fprintf(fid2,'ON=%i \t F_obj=%f \t convergence=%i \t n_Iter=%i \t n_FunEval=%i \t n_CGiter=%i \n',I,F_obj_final,info);
  fclose(fid1);
  fclose(fid2);
  fclose(fid0);
  
  fprintf('*** inversion of model # %i (out of %i) finished \n',I,x);
 
end;   % end of loop over initial models

%%%%%%%% END OF FILE %%%%%%%%%%%%%%%%%%%%%%%%%%%
